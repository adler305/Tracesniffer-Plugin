
FreeRTOS-TraceSniffer.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800100  00001700  00001794  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001700  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000060f  0080011c  0080011c  000017b0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000017b0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000017e0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003d0  00000000  00000000  00001820  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006125  00000000  00000000  00001bf0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017c2  00000000  00000000  00007d15  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000270b  00000000  00000000  000094d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bf4  00000000  00000000  0000bbe4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f3f  00000000  00000000  0000c7d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004269  00000000  00000000  0000e717  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000468  00000000  00000000  00012980  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 1a 03 	jmp	0x634	; 0x634 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_18>
      4c:	0c 94 a2 00 	jmp	0x144	; 0x144 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 e0       	ldi	r30, 0x00	; 0
      7c:	f7 e1       	ldi	r31, 0x17	; 23
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ac 31       	cpi	r26, 0x1C	; 28
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	ac e1       	ldi	r26, 0x1C	; 28
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ab 32       	cpi	r26, 0x2B	; 43
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 0e 01 	call	0x21c	; 0x21c <main>
      9e:	0c 94 7e 0b 	jmp	0x16fc	; 0x16fc <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_18>:
    UART_RxTail = tmptail; 
    
    UART_LastRxError = 0;
    return (lastRxError << 8) + data;

}/* uart_getc */
      a6:	1f 92       	push	r1
      a8:	0f 92       	push	r0
      aa:	0f b6       	in	r0, 0x3f	; 63
      ac:	0f 92       	push	r0
      ae:	11 24       	eor	r1, r1
      b0:	1f 93       	push	r17
      b2:	2f 93       	push	r18
      b4:	3f 93       	push	r19
      b6:	4f 93       	push	r20
      b8:	5f 93       	push	r21
      ba:	6f 93       	push	r22
      bc:	7f 93       	push	r23
      be:	8f 93       	push	r24
      c0:	9f 93       	push	r25
      c2:	af 93       	push	r26
      c4:	bf 93       	push	r27
      c6:	ef 93       	push	r30
      c8:	ff 93       	push	r31
      ca:	cf 93       	push	r28
      cc:	df 93       	push	r29
      ce:	1f 92       	push	r1
      d0:	cd b7       	in	r28, 0x3d	; 61
      d2:	de b7       	in	r29, 0x3e	; 62
      d4:	10 91 c0 00 	lds	r17, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
      d8:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
      dc:	89 83       	std	Y+1, r24	; 0x01
      de:	42 e0       	ldi	r20, 0x02	; 2
      e0:	61 e0       	ldi	r22, 0x01	; 1
      e2:	ce 01       	movw	r24, r28
      e4:	01 96       	adiw	r24, 0x01	; 1
      e6:	0e 94 30 07 	call	0xe60	; 0xe60 <writeFIFO>
      ea:	81 2f       	mov	r24, r17
      ec:	8c 71       	andi	r24, 0x1C	; 28
      ee:	e0 91 1e 01 	lds	r30, 0x011E	; 0x80011e <UART_RxHead>
      f2:	ef 5f       	subi	r30, 0xFF	; 255
      f4:	ef 70       	andi	r30, 0x0F	; 15
      f6:	90 91 1d 01 	lds	r25, 0x011D	; 0x80011d <UART_RxTail>
      fa:	e9 17       	cp	r30, r25
      fc:	41 f0       	breq	.+16     	; 0x10e <__vector_18+0x68>
      fe:	e0 93 1e 01 	sts	0x011E, r30	; 0x80011e <UART_RxHead>
     102:	f0 e0       	ldi	r31, 0x00	; 0
     104:	99 81       	ldd	r25, Y+1	; 0x01
     106:	ef 5d       	subi	r30, 0xDF	; 223
     108:	fe 4f       	sbci	r31, 0xFE	; 254
     10a:	90 83       	st	Z, r25
     10c:	01 c0       	rjmp	.+2      	; 0x110 <__vector_18+0x6a>
     10e:	82 e0       	ldi	r24, 0x02	; 2
     110:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <__data_end>
     114:	89 2b       	or	r24, r25
     116:	80 93 1c 01 	sts	0x011C, r24	; 0x80011c <__data_end>
     11a:	0f 90       	pop	r0
     11c:	df 91       	pop	r29
     11e:	cf 91       	pop	r28
     120:	ff 91       	pop	r31
     122:	ef 91       	pop	r30
     124:	bf 91       	pop	r27
     126:	af 91       	pop	r26
     128:	9f 91       	pop	r25
     12a:	8f 91       	pop	r24
     12c:	7f 91       	pop	r23
     12e:	6f 91       	pop	r22
     130:	5f 91       	pop	r21
     132:	4f 91       	pop	r20
     134:	3f 91       	pop	r19
     136:	2f 91       	pop	r18
     138:	1f 91       	pop	r17
     13a:	0f 90       	pop	r0
     13c:	0f be       	out	0x3f, r0	; 63
     13e:	0f 90       	pop	r0
     140:	1f 90       	pop	r1
     142:	18 95       	reti

00000144 <__vector_19>:
     144:	1f 92       	push	r1
     146:	0f 92       	push	r0
     148:	0f b6       	in	r0, 0x3f	; 63
     14a:	0f 92       	push	r0
     14c:	11 24       	eor	r1, r1
     14e:	8f 93       	push	r24
     150:	9f 93       	push	r25
     152:	ef 93       	push	r30
     154:	ff 93       	push	r31
     156:	f8 94       	cli
     158:	90 91 20 01 	lds	r25, 0x0120	; 0x800120 <UART_TxHead>
     15c:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <UART_TxTail>
     160:	98 17       	cp	r25, r24
     162:	61 f0       	breq	.+24     	; 0x17c <__vector_19+0x38>
     164:	e0 91 1f 01 	lds	r30, 0x011F	; 0x80011f <UART_TxTail>
     168:	ef 5f       	subi	r30, 0xFF	; 255
     16a:	e0 93 1f 01 	sts	0x011F, r30	; 0x80011f <UART_TxTail>
     16e:	f0 e0       	ldi	r31, 0x00	; 0
     170:	ef 5c       	subi	r30, 0xCF	; 207
     172:	fe 4f       	sbci	r31, 0xFE	; 254
     174:	80 81       	ld	r24, Z
     176:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     17a:	05 c0       	rjmp	.+10     	; 0x186 <__vector_19+0x42>
     17c:	e1 ec       	ldi	r30, 0xC1	; 193
     17e:	f0 e0       	ldi	r31, 0x00	; 0
     180:	80 81       	ld	r24, Z
     182:	8f 7d       	andi	r24, 0xDF	; 223
     184:	80 83       	st	Z, r24
     186:	78 94       	sei
     188:	ff 91       	pop	r31
     18a:	ef 91       	pop	r30
     18c:	9f 91       	pop	r25
     18e:	8f 91       	pop	r24
     190:	0f 90       	pop	r0
     192:	0f be       	out	0x3f, r0	; 63
     194:	0f 90       	pop	r0
     196:	1f 90       	pop	r1
     198:	18 95       	reti

0000019a <uart_init>:
     19a:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <UART_TxHead>
     19e:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <UART_TxTail>
     1a2:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <UART_RxHead>
     1a6:	10 92 1d 01 	sts	0x011D, r1	; 0x80011d <UART_RxTail>
     1aa:	99 23       	and	r25, r25
     1ac:	1c f4       	brge	.+6      	; 0x1b4 <uart_init+0x1a>
     1ae:	22 e0       	ldi	r18, 0x02	; 2
     1b0:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     1b4:	90 78       	andi	r25, 0x80	; 128
     1b6:	90 93 c5 00 	sts	0x00C5, r25	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     1ba:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     1be:	88 e9       	ldi	r24, 0x98	; 152
     1c0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
     1c4:	86 e0       	ldi	r24, 0x06	; 6
     1c6:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
     1ca:	08 95       	ret

000001cc <uart_putc>:
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
     1cc:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <UART_TxHead>
     1d0:	2f 5f       	subi	r18, 0xFF	; 255
    
    while ( tmphead == UART_TxTail ){
     1d2:	90 91 1f 01 	lds	r25, 0x011F	; 0x80011f <UART_TxTail>
     1d6:	29 17       	cp	r18, r25
     1d8:	e1 f3       	breq	.-8      	; 0x1d2 <uart_putc+0x6>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
     1da:	e2 2f       	mov	r30, r18
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	ef 5c       	subi	r30, 0xCF	; 207
     1e0:	fe 4f       	sbci	r31, 0xFE	; 254
     1e2:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
     1e4:	20 93 20 01 	sts	0x0120, r18	; 0x800120 <UART_TxHead>

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
     1e8:	e1 ec       	ldi	r30, 0xC1	; 193
     1ea:	f0 e0       	ldi	r31, 0x00	; 0
     1ec:	80 81       	ld	r24, Z
     1ee:	80 62       	ori	r24, 0x20	; 32
     1f0:	80 83       	st	Z, r24
     1f2:	08 95       	ret

000001f4 <blink_task>:

TaskHandle_t lcd_task_handle;


void blink_task() {
	DDRB =0xff;	
     1f4:	8f ef       	ldi	r24, 0xFF	; 255
     1f6:	84 b9       	out	0x04, r24	; 4
	while (1) {
		
		PORTB ^=0xff;//(1<<PORTB1);
     1f8:	85 b1       	in	r24, 0x05	; 5
     1fa:	80 95       	com	r24
     1fc:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(100);
     1fe:	84 e6       	ldi	r24, 0x64	; 100
     200:	90 e0       	ldi	r25, 0x00	; 0
     202:	0e 94 9c 06 	call	0xd38	; 0xd38 <vTaskDelay>
	}
     206:	f8 cf       	rjmp	.-16     	; 0x1f8 <blink_task+0x4>

00000208 <blink2_task>:
}

void blink2_task() {
	DDRC =0xff;
     208:	8f ef       	ldi	r24, 0xFF	; 255
     20a:	87 b9       	out	0x07, r24	; 7
	
	while (1) {
		
		PORTC ^=0xff;//(1<<PORTB1);
     20c:	88 b1       	in	r24, 0x08	; 8
     20e:	80 95       	com	r24
     210:	88 b9       	out	0x08, r24	; 8
		vTaskDelay(1000);
     212:	88 ee       	ldi	r24, 0xE8	; 232
     214:	93 e0       	ldi	r25, 0x03	; 3
     216:	0e 94 9c 06 	call	0xd38	; 0xd38 <vTaskDelay>
	}
     21a:	f8 cf       	rjmp	.-16     	; 0x20c <blink2_task+0x4>

0000021c <main>:
}

int main( void )
{	

	sei();
     21c:	78 94       	sei
	uart_init(UBRR_VALUE_NORMAL_SPEED);
     21e:	80 e0       	ldi	r24, 0x00	; 0
     220:	90 e0       	ldi	r25, 0x00	; 0
     222:	0e 94 cd 00 	call	0x19a	; 0x19a <uart_init>
	initialiseTraceSniffer();
     226:	0e 94 23 08 	call	0x1046	; 0x1046 <initialiseTraceSniffer>

	xTaskCreate((pdTASK_CODE)blink_task, "blink", configMINIMAL_STACK_SIZE, 0,
     22a:	0f 2e       	mov	r0, r31
     22c:	f9 ee       	ldi	r31, 0xE9	; 233
     22e:	ef 2e       	mov	r14, r31
     230:	f6 e0       	ldi	r31, 0x06	; 6
     232:	ff 2e       	mov	r15, r31
     234:	f0 2d       	mov	r31, r0
     236:	02 e0       	ldi	r16, 0x02	; 2
     238:	20 e0       	ldi	r18, 0x00	; 0
     23a:	30 e0       	ldi	r19, 0x00	; 0
     23c:	45 e5       	ldi	r20, 0x55	; 85
     23e:	50 e0       	ldi	r21, 0x00	; 0
     240:	60 e0       	ldi	r22, 0x00	; 0
     242:	71 e0       	ldi	r23, 0x01	; 1
     244:	8a ef       	ldi	r24, 0xFA	; 250
     246:	90 e0       	ldi	r25, 0x00	; 0
     248:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <xTaskCreate>
	basicPriority, &lcd_task_handle);
	
	xTaskCreate((pdTASK_CODE)blink2_task, "blink2", configMINIMAL_STACK_SIZE, 0,
     24c:	20 e0       	ldi	r18, 0x00	; 0
     24e:	30 e0       	ldi	r19, 0x00	; 0
     250:	45 e5       	ldi	r20, 0x55	; 85
     252:	50 e0       	ldi	r21, 0x00	; 0
     254:	66 e0       	ldi	r22, 0x06	; 6
     256:	71 e0       	ldi	r23, 0x01	; 1
     258:	84 e0       	ldi	r24, 0x04	; 4
     25a:	91 e0       	ldi	r25, 0x01	; 1
     25c:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <xTaskCreate>
	basicPriority, &lcd_task_handle);
 
	vTaskStartScheduler();
     260:	0e 94 15 05 	call	0xa2a	; 0xa2a <vTaskStartScheduler>
	while(1);
     264:	ff cf       	rjmp	.-2      	; 0x264 <main+0x48>

00000266 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     266:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     268:	03 96       	adiw	r24, 0x03	; 3
     26a:	92 83       	std	Z+2, r25	; 0x02
     26c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     26e:	2f ef       	ldi	r18, 0xFF	; 255
     270:	3f ef       	ldi	r19, 0xFF	; 255
     272:	34 83       	std	Z+4, r19	; 0x04
     274:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     276:	96 83       	std	Z+6, r25	; 0x06
     278:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     27a:	90 87       	std	Z+8, r25	; 0x08
     27c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     27e:	10 82       	st	Z, r1
     280:	08 95       	ret

00000282 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     282:	fc 01       	movw	r30, r24
     284:	11 86       	std	Z+9, r1	; 0x09
     286:	10 86       	std	Z+8, r1	; 0x08
     288:	08 95       	ret

0000028a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     28a:	cf 93       	push	r28
     28c:	df 93       	push	r29
     28e:	9c 01       	movw	r18, r24
     290:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     292:	dc 01       	movw	r26, r24
     294:	11 96       	adiw	r26, 0x01	; 1
     296:	cd 91       	ld	r28, X+
     298:	dc 91       	ld	r29, X
     29a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     29c:	d3 83       	std	Z+3, r29	; 0x03
     29e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     2a0:	8c 81       	ldd	r24, Y+4	; 0x04
     2a2:	9d 81       	ldd	r25, Y+5	; 0x05
     2a4:	95 83       	std	Z+5, r25	; 0x05
     2a6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     2a8:	8c 81       	ldd	r24, Y+4	; 0x04
     2aa:	9d 81       	ldd	r25, Y+5	; 0x05
     2ac:	dc 01       	movw	r26, r24
     2ae:	13 96       	adiw	r26, 0x03	; 3
     2b0:	7c 93       	st	X, r23
     2b2:	6e 93       	st	-X, r22
     2b4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     2b6:	7d 83       	std	Y+5, r23	; 0x05
     2b8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2ba:	31 87       	std	Z+9, r19	; 0x09
     2bc:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     2be:	f9 01       	movw	r30, r18
     2c0:	80 81       	ld	r24, Z
     2c2:	8f 5f       	subi	r24, 0xFF	; 255
     2c4:	80 83       	st	Z, r24
}
     2c6:	df 91       	pop	r29
     2c8:	cf 91       	pop	r28
     2ca:	08 95       	ret

000002cc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2cc:	cf 93       	push	r28
     2ce:	df 93       	push	r29
     2d0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     2d2:	48 81       	ld	r20, Y
     2d4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2d6:	4f 3f       	cpi	r20, 0xFF	; 255
     2d8:	2f ef       	ldi	r18, 0xFF	; 255
     2da:	52 07       	cpc	r21, r18
     2dc:	21 f4       	brne	.+8      	; 0x2e6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2de:	fc 01       	movw	r30, r24
     2e0:	a7 81       	ldd	r26, Z+7	; 0x07
     2e2:	b0 85       	ldd	r27, Z+8	; 0x08
     2e4:	0d c0       	rjmp	.+26     	; 0x300 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2e6:	dc 01       	movw	r26, r24
     2e8:	13 96       	adiw	r26, 0x03	; 3
     2ea:	01 c0       	rjmp	.+2      	; 0x2ee <vListInsert+0x22>
     2ec:	df 01       	movw	r26, r30
     2ee:	12 96       	adiw	r26, 0x02	; 2
     2f0:	ed 91       	ld	r30, X+
     2f2:	fc 91       	ld	r31, X
     2f4:	13 97       	sbiw	r26, 0x03	; 3
     2f6:	20 81       	ld	r18, Z
     2f8:	31 81       	ldd	r19, Z+1	; 0x01
     2fa:	42 17       	cp	r20, r18
     2fc:	53 07       	cpc	r21, r19
     2fe:	b0 f7       	brcc	.-20     	; 0x2ec <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     300:	12 96       	adiw	r26, 0x02	; 2
     302:	ed 91       	ld	r30, X+
     304:	fc 91       	ld	r31, X
     306:	13 97       	sbiw	r26, 0x03	; 3
     308:	fb 83       	std	Y+3, r31	; 0x03
     30a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     30c:	d5 83       	std	Z+5, r29	; 0x05
     30e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     310:	bd 83       	std	Y+5, r27	; 0x05
     312:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     314:	13 96       	adiw	r26, 0x03	; 3
     316:	dc 93       	st	X, r29
     318:	ce 93       	st	-X, r28
     31a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     31c:	99 87       	std	Y+9, r25	; 0x09
     31e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     320:	fc 01       	movw	r30, r24
     322:	20 81       	ld	r18, Z
     324:	2f 5f       	subi	r18, 0xFF	; 255
     326:	20 83       	st	Z, r18
}
     328:	df 91       	pop	r29
     32a:	cf 91       	pop	r28
     32c:	08 95       	ret

0000032e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     32e:	cf 93       	push	r28
     330:	df 93       	push	r29
     332:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     334:	a0 85       	ldd	r26, Z+8	; 0x08
     336:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     338:	c2 81       	ldd	r28, Z+2	; 0x02
     33a:	d3 81       	ldd	r29, Z+3	; 0x03
     33c:	84 81       	ldd	r24, Z+4	; 0x04
     33e:	95 81       	ldd	r25, Z+5	; 0x05
     340:	9d 83       	std	Y+5, r25	; 0x05
     342:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     344:	c4 81       	ldd	r28, Z+4	; 0x04
     346:	d5 81       	ldd	r29, Z+5	; 0x05
     348:	82 81       	ldd	r24, Z+2	; 0x02
     34a:	93 81       	ldd	r25, Z+3	; 0x03
     34c:	9b 83       	std	Y+3, r25	; 0x03
     34e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     350:	11 96       	adiw	r26, 0x01	; 1
     352:	cd 91       	ld	r28, X+
     354:	dc 91       	ld	r29, X
     356:	12 97       	sbiw	r26, 0x02	; 2
     358:	ce 17       	cp	r28, r30
     35a:	df 07       	cpc	r29, r31
     35c:	31 f4       	brne	.+12     	; 0x36a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     35e:	8c 81       	ldd	r24, Y+4	; 0x04
     360:	9d 81       	ldd	r25, Y+5	; 0x05
     362:	12 96       	adiw	r26, 0x02	; 2
     364:	9c 93       	st	X, r25
     366:	8e 93       	st	-X, r24
     368:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     36a:	11 86       	std	Z+9, r1	; 0x09
     36c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     36e:	8c 91       	ld	r24, X
     370:	81 50       	subi	r24, 0x01	; 1
     372:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     374:	8c 91       	ld	r24, X
}
     376:	df 91       	pop	r29
     378:	cf 91       	pop	r28
     37a:	08 95       	ret

0000037c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     37c:	31 e1       	ldi	r19, 0x11	; 17
     37e:	fc 01       	movw	r30, r24
     380:	30 83       	st	Z, r19
     382:	31 97       	sbiw	r30, 0x01	; 1
     384:	22 e2       	ldi	r18, 0x22	; 34
     386:	20 83       	st	Z, r18
     388:	31 97       	sbiw	r30, 0x01	; 1
     38a:	a3 e3       	ldi	r26, 0x33	; 51
     38c:	a0 83       	st	Z, r26
     38e:	31 97       	sbiw	r30, 0x01	; 1
     390:	60 83       	st	Z, r22
     392:	31 97       	sbiw	r30, 0x01	; 1
     394:	70 83       	st	Z, r23
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	10 82       	st	Z, r1
     39a:	31 97       	sbiw	r30, 0x01	; 1
     39c:	60 e8       	ldi	r22, 0x80	; 128
     39e:	60 83       	st	Z, r22
     3a0:	31 97       	sbiw	r30, 0x01	; 1
     3a2:	10 82       	st	Z, r1
     3a4:	31 97       	sbiw	r30, 0x01	; 1
     3a6:	62 e0       	ldi	r22, 0x02	; 2
     3a8:	60 83       	st	Z, r22
     3aa:	31 97       	sbiw	r30, 0x01	; 1
     3ac:	63 e0       	ldi	r22, 0x03	; 3
     3ae:	60 83       	st	Z, r22
     3b0:	31 97       	sbiw	r30, 0x01	; 1
     3b2:	64 e0       	ldi	r22, 0x04	; 4
     3b4:	60 83       	st	Z, r22
     3b6:	31 97       	sbiw	r30, 0x01	; 1
     3b8:	65 e0       	ldi	r22, 0x05	; 5
     3ba:	60 83       	st	Z, r22
     3bc:	31 97       	sbiw	r30, 0x01	; 1
     3be:	66 e0       	ldi	r22, 0x06	; 6
     3c0:	60 83       	st	Z, r22
     3c2:	31 97       	sbiw	r30, 0x01	; 1
     3c4:	67 e0       	ldi	r22, 0x07	; 7
     3c6:	60 83       	st	Z, r22
     3c8:	31 97       	sbiw	r30, 0x01	; 1
     3ca:	68 e0       	ldi	r22, 0x08	; 8
     3cc:	60 83       	st	Z, r22
     3ce:	31 97       	sbiw	r30, 0x01	; 1
     3d0:	69 e0       	ldi	r22, 0x09	; 9
     3d2:	60 83       	st	Z, r22
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	60 e1       	ldi	r22, 0x10	; 16
     3d8:	60 83       	st	Z, r22
     3da:	31 97       	sbiw	r30, 0x01	; 1
     3dc:	30 83       	st	Z, r19
     3de:	31 97       	sbiw	r30, 0x01	; 1
     3e0:	32 e1       	ldi	r19, 0x12	; 18
     3e2:	30 83       	st	Z, r19
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	33 e1       	ldi	r19, 0x13	; 19
     3e8:	30 83       	st	Z, r19
     3ea:	31 97       	sbiw	r30, 0x01	; 1
     3ec:	34 e1       	ldi	r19, 0x14	; 20
     3ee:	30 83       	st	Z, r19
     3f0:	31 97       	sbiw	r30, 0x01	; 1
     3f2:	35 e1       	ldi	r19, 0x15	; 21
     3f4:	30 83       	st	Z, r19
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	36 e1       	ldi	r19, 0x16	; 22
     3fa:	30 83       	st	Z, r19
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	37 e1       	ldi	r19, 0x17	; 23
     400:	30 83       	st	Z, r19
     402:	31 97       	sbiw	r30, 0x01	; 1
     404:	38 e1       	ldi	r19, 0x18	; 24
     406:	30 83       	st	Z, r19
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	39 e1       	ldi	r19, 0x19	; 25
     40c:	30 83       	st	Z, r19
     40e:	31 97       	sbiw	r30, 0x01	; 1
     410:	30 e2       	ldi	r19, 0x20	; 32
     412:	30 83       	st	Z, r19
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	31 e2       	ldi	r19, 0x21	; 33
     418:	30 83       	st	Z, r19
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	20 83       	st	Z, r18
     41e:	31 97       	sbiw	r30, 0x01	; 1
     420:	23 e2       	ldi	r18, 0x23	; 35
     422:	20 83       	st	Z, r18
     424:	31 97       	sbiw	r30, 0x01	; 1
     426:	40 83       	st	Z, r20
     428:	31 97       	sbiw	r30, 0x01	; 1
     42a:	50 83       	st	Z, r21
     42c:	31 97       	sbiw	r30, 0x01	; 1
     42e:	26 e2       	ldi	r18, 0x26	; 38
     430:	20 83       	st	Z, r18
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	27 e2       	ldi	r18, 0x27	; 39
     436:	20 83       	st	Z, r18
     438:	31 97       	sbiw	r30, 0x01	; 1
     43a:	28 e2       	ldi	r18, 0x28	; 40
     43c:	20 83       	st	Z, r18
     43e:	31 97       	sbiw	r30, 0x01	; 1
     440:	29 e2       	ldi	r18, 0x29	; 41
     442:	20 83       	st	Z, r18
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	20 e3       	ldi	r18, 0x30	; 48
     448:	20 83       	st	Z, r18
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	21 e3       	ldi	r18, 0x31	; 49
     44e:	20 83       	st	Z, r18
     450:	86 97       	sbiw	r24, 0x26	; 38
     452:	08 95       	ret

00000454 <xPortStartScheduler>:
     454:	8e e3       	ldi	r24, 0x3E	; 62
     456:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     45a:	8f e7       	ldi	r24, 0x7F	; 127
     45c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     460:	89 e0       	ldi	r24, 0x09	; 9
     462:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     466:	ef e6       	ldi	r30, 0x6F	; 111
     468:	f0 e0       	ldi	r31, 0x00	; 0
     46a:	80 81       	ld	r24, Z
     46c:	82 60       	ori	r24, 0x02	; 2
     46e:	80 83       	st	Z, r24
     470:	a0 91 94 05 	lds	r26, 0x0594	; 0x800594 <pxCurrentTCB>
     474:	b0 91 95 05 	lds	r27, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     478:	cd 91       	ld	r28, X+
     47a:	cd bf       	out	0x3d, r28	; 61
     47c:	dd 91       	ld	r29, X+
     47e:	de bf       	out	0x3e, r29	; 62
     480:	ff 91       	pop	r31
     482:	ef 91       	pop	r30
     484:	df 91       	pop	r29
     486:	cf 91       	pop	r28
     488:	bf 91       	pop	r27
     48a:	af 91       	pop	r26
     48c:	9f 91       	pop	r25
     48e:	8f 91       	pop	r24
     490:	7f 91       	pop	r23
     492:	6f 91       	pop	r22
     494:	5f 91       	pop	r21
     496:	4f 91       	pop	r20
     498:	3f 91       	pop	r19
     49a:	2f 91       	pop	r18
     49c:	1f 91       	pop	r17
     49e:	0f 91       	pop	r16
     4a0:	ff 90       	pop	r15
     4a2:	ef 90       	pop	r14
     4a4:	df 90       	pop	r13
     4a6:	cf 90       	pop	r12
     4a8:	bf 90       	pop	r11
     4aa:	af 90       	pop	r10
     4ac:	9f 90       	pop	r9
     4ae:	8f 90       	pop	r8
     4b0:	7f 90       	pop	r7
     4b2:	6f 90       	pop	r6
     4b4:	5f 90       	pop	r5
     4b6:	4f 90       	pop	r4
     4b8:	3f 90       	pop	r3
     4ba:	2f 90       	pop	r2
     4bc:	1f 90       	pop	r1
     4be:	0f 90       	pop	r0
     4c0:	0f be       	out	0x3f, r0	; 63
     4c2:	0f 90       	pop	r0
     4c4:	08 95       	ret
     4c6:	81 e0       	ldi	r24, 0x01	; 1
     4c8:	08 95       	ret

000004ca <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     4ca:	0f 92       	push	r0
     4cc:	0f b6       	in	r0, 0x3f	; 63
     4ce:	f8 94       	cli
     4d0:	0f 92       	push	r0
     4d2:	1f 92       	push	r1
     4d4:	11 24       	eor	r1, r1
     4d6:	2f 92       	push	r2
     4d8:	3f 92       	push	r3
     4da:	4f 92       	push	r4
     4dc:	5f 92       	push	r5
     4de:	6f 92       	push	r6
     4e0:	7f 92       	push	r7
     4e2:	8f 92       	push	r8
     4e4:	9f 92       	push	r9
     4e6:	af 92       	push	r10
     4e8:	bf 92       	push	r11
     4ea:	cf 92       	push	r12
     4ec:	df 92       	push	r13
     4ee:	ef 92       	push	r14
     4f0:	ff 92       	push	r15
     4f2:	0f 93       	push	r16
     4f4:	1f 93       	push	r17
     4f6:	2f 93       	push	r18
     4f8:	3f 93       	push	r19
     4fa:	4f 93       	push	r20
     4fc:	5f 93       	push	r21
     4fe:	6f 93       	push	r22
     500:	7f 93       	push	r23
     502:	8f 93       	push	r24
     504:	9f 93       	push	r25
     506:	af 93       	push	r26
     508:	bf 93       	push	r27
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	ef 93       	push	r30
     510:	ff 93       	push	r31
     512:	a0 91 94 05 	lds	r26, 0x0594	; 0x800594 <pxCurrentTCB>
     516:	b0 91 95 05 	lds	r27, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     51a:	0d b6       	in	r0, 0x3d	; 61
     51c:	0d 92       	st	X+, r0
     51e:	0e b6       	in	r0, 0x3e	; 62
     520:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     522:	0e 94 ba 06 	call	0xd74	; 0xd74 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     526:	a0 91 94 05 	lds	r26, 0x0594	; 0x800594 <pxCurrentTCB>
     52a:	b0 91 95 05 	lds	r27, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     52e:	cd 91       	ld	r28, X+
     530:	cd bf       	out	0x3d, r28	; 61
     532:	dd 91       	ld	r29, X+
     534:	de bf       	out	0x3e, r29	; 62
     536:	ff 91       	pop	r31
     538:	ef 91       	pop	r30
     53a:	df 91       	pop	r29
     53c:	cf 91       	pop	r28
     53e:	bf 91       	pop	r27
     540:	af 91       	pop	r26
     542:	9f 91       	pop	r25
     544:	8f 91       	pop	r24
     546:	7f 91       	pop	r23
     548:	6f 91       	pop	r22
     54a:	5f 91       	pop	r21
     54c:	4f 91       	pop	r20
     54e:	3f 91       	pop	r19
     550:	2f 91       	pop	r18
     552:	1f 91       	pop	r17
     554:	0f 91       	pop	r16
     556:	ff 90       	pop	r15
     558:	ef 90       	pop	r14
     55a:	df 90       	pop	r13
     55c:	cf 90       	pop	r12
     55e:	bf 90       	pop	r11
     560:	af 90       	pop	r10
     562:	9f 90       	pop	r9
     564:	8f 90       	pop	r8
     566:	7f 90       	pop	r7
     568:	6f 90       	pop	r6
     56a:	5f 90       	pop	r5
     56c:	4f 90       	pop	r4
     56e:	3f 90       	pop	r3
     570:	2f 90       	pop	r2
     572:	1f 90       	pop	r1
     574:	0f 90       	pop	r0
     576:	0f be       	out	0x3f, r0	; 63
     578:	0f 90       	pop	r0

	asm volatile ( "ret" );
     57a:	08 95       	ret

0000057c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     57c:	0f 92       	push	r0
     57e:	0f b6       	in	r0, 0x3f	; 63
     580:	f8 94       	cli
     582:	0f 92       	push	r0
     584:	1f 92       	push	r1
     586:	11 24       	eor	r1, r1
     588:	2f 92       	push	r2
     58a:	3f 92       	push	r3
     58c:	4f 92       	push	r4
     58e:	5f 92       	push	r5
     590:	6f 92       	push	r6
     592:	7f 92       	push	r7
     594:	8f 92       	push	r8
     596:	9f 92       	push	r9
     598:	af 92       	push	r10
     59a:	bf 92       	push	r11
     59c:	cf 92       	push	r12
     59e:	df 92       	push	r13
     5a0:	ef 92       	push	r14
     5a2:	ff 92       	push	r15
     5a4:	0f 93       	push	r16
     5a6:	1f 93       	push	r17
     5a8:	2f 93       	push	r18
     5aa:	3f 93       	push	r19
     5ac:	4f 93       	push	r20
     5ae:	5f 93       	push	r21
     5b0:	6f 93       	push	r22
     5b2:	7f 93       	push	r23
     5b4:	8f 93       	push	r24
     5b6:	9f 93       	push	r25
     5b8:	af 93       	push	r26
     5ba:	bf 93       	push	r27
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
     5c0:	ef 93       	push	r30
     5c2:	ff 93       	push	r31
     5c4:	a0 91 94 05 	lds	r26, 0x0594	; 0x800594 <pxCurrentTCB>
     5c8:	b0 91 95 05 	lds	r27, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     5cc:	0d b6       	in	r0, 0x3d	; 61
     5ce:	0d 92       	st	X+, r0
     5d0:	0e b6       	in	r0, 0x3e	; 62
     5d2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5d4:	0e 94 4f 05 	call	0xa9e	; 0xa9e <xTaskIncrementTick>
     5d8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     5da:	0e 94 ba 06 	call	0xd74	; 0xd74 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     5de:	a0 91 94 05 	lds	r26, 0x0594	; 0x800594 <pxCurrentTCB>
     5e2:	b0 91 95 05 	lds	r27, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     5e6:	cd 91       	ld	r28, X+
     5e8:	cd bf       	out	0x3d, r28	; 61
     5ea:	dd 91       	ld	r29, X+
     5ec:	de bf       	out	0x3e, r29	; 62
     5ee:	ff 91       	pop	r31
     5f0:	ef 91       	pop	r30
     5f2:	df 91       	pop	r29
     5f4:	cf 91       	pop	r28
     5f6:	bf 91       	pop	r27
     5f8:	af 91       	pop	r26
     5fa:	9f 91       	pop	r25
     5fc:	8f 91       	pop	r24
     5fe:	7f 91       	pop	r23
     600:	6f 91       	pop	r22
     602:	5f 91       	pop	r21
     604:	4f 91       	pop	r20
     606:	3f 91       	pop	r19
     608:	2f 91       	pop	r18
     60a:	1f 91       	pop	r17
     60c:	0f 91       	pop	r16
     60e:	ff 90       	pop	r15
     610:	ef 90       	pop	r14
     612:	df 90       	pop	r13
     614:	cf 90       	pop	r12
     616:	bf 90       	pop	r11
     618:	af 90       	pop	r10
     61a:	9f 90       	pop	r9
     61c:	8f 90       	pop	r8
     61e:	7f 90       	pop	r7
     620:	6f 90       	pop	r6
     622:	5f 90       	pop	r5
     624:	4f 90       	pop	r4
     626:	3f 90       	pop	r3
     628:	2f 90       	pop	r2
     62a:	1f 90       	pop	r1
     62c:	0f 90       	pop	r0
     62e:	0f be       	out	0x3f, r0	; 63
     630:	0f 90       	pop	r0

	asm volatile ( "ret" );
     632:	08 95       	ret

00000634 <__vector_11>:
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
	}*/
	ISR(TIMER1_COMPA_vect){
     634:	1f 92       	push	r1
     636:	0f 92       	push	r0
     638:	0f b6       	in	r0, 0x3f	; 63
     63a:	0f 92       	push	r0
     63c:	11 24       	eor	r1, r1
     63e:	2f 93       	push	r18
     640:	3f 93       	push	r19
     642:	4f 93       	push	r20
     644:	5f 93       	push	r21
     646:	6f 93       	push	r22
     648:	7f 93       	push	r23
     64a:	8f 93       	push	r24
     64c:	9f 93       	push	r25
     64e:	af 93       	push	r26
     650:	bf 93       	push	r27
     652:	ef 93       	push	r30
     654:	ff 93       	push	r31
		vPortYieldFromTick();
     656:	0e 94 be 02 	call	0x57c	; 0x57c <vPortYieldFromTick>
	}
     65a:	ff 91       	pop	r31
     65c:	ef 91       	pop	r30
     65e:	bf 91       	pop	r27
     660:	af 91       	pop	r26
     662:	9f 91       	pop	r25
     664:	8f 91       	pop	r24
     666:	7f 91       	pop	r23
     668:	6f 91       	pop	r22
     66a:	5f 91       	pop	r21
     66c:	4f 91       	pop	r20
     66e:	3f 91       	pop	r19
     670:	2f 91       	pop	r18
     672:	0f 90       	pop	r0
     674:	0f be       	out	0x3f, r0	; 63
     676:	0f 90       	pop	r0
     678:	1f 90       	pop	r1
     67a:	18 95       	reti

0000067c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     67c:	0f 93       	push	r16
     67e:	1f 93       	push	r17
     680:	cf 93       	push	r28
     682:	df 93       	push	r29
     684:	8c 01       	movw	r16, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     686:	0e 94 3f 05 	call	0xa7e	; 0xa7e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     68a:	80 91 31 02 	lds	r24, 0x0231	; 0x800231 <pucAlignedHeap.2214>
     68e:	90 91 32 02 	lds	r25, 0x0232	; 0x800232 <pucAlignedHeap.2214+0x1>
     692:	89 2b       	or	r24, r25
     694:	31 f4       	brne	.+12     	; 0x6a2 <pvPortMalloc+0x26>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     696:	86 e3       	ldi	r24, 0x36	; 54
     698:	92 e0       	ldi	r25, 0x02	; 2
     69a:	90 93 32 02 	sts	0x0232, r25	; 0x800232 <pucAlignedHeap.2214+0x1>
     69e:	80 93 31 02 	sts	0x0231, r24	; 0x800231 <pucAlignedHeap.2214>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     6a2:	20 91 33 02 	lds	r18, 0x0233	; 0x800233 <xNextFreeByte>
     6a6:	30 91 34 02 	lds	r19, 0x0234	; 0x800234 <xNextFreeByte+0x1>
     6aa:	c8 01       	movw	r24, r16
     6ac:	82 0f       	add	r24, r18
     6ae:	93 1f       	adc	r25, r19
     6b0:	8f 31       	cpi	r24, 0x1F	; 31
     6b2:	43 e0       	ldi	r20, 0x03	; 3
     6b4:	94 07       	cpc	r25, r20
     6b6:	70 f4       	brcc	.+28     	; 0x6d4 <pvPortMalloc+0x58>
     6b8:	28 17       	cp	r18, r24
     6ba:	39 07       	cpc	r19, r25
     6bc:	70 f4       	brcc	.+28     	; 0x6da <pvPortMalloc+0x5e>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     6be:	c0 91 31 02 	lds	r28, 0x0231	; 0x800231 <pucAlignedHeap.2214>
     6c2:	d0 91 32 02 	lds	r29, 0x0232	; 0x800232 <pucAlignedHeap.2214+0x1>
     6c6:	c2 0f       	add	r28, r18
     6c8:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     6ca:	90 93 34 02 	sts	0x0234, r25	; 0x800234 <xNextFreeByte+0x1>
     6ce:	80 93 33 02 	sts	0x0233, r24	; 0x800233 <xNextFreeByte>
     6d2:	05 c0       	rjmp	.+10     	; 0x6de <pvPortMalloc+0x62>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     6d4:	c0 e0       	ldi	r28, 0x00	; 0
     6d6:	d0 e0       	ldi	r29, 0x00	; 0
     6d8:	02 c0       	rjmp	.+4      	; 0x6de <pvPortMalloc+0x62>
     6da:	c0 e0       	ldi	r28, 0x00	; 0
     6dc:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
     6de:	40 2f       	mov	r20, r16
     6e0:	61 2f       	mov	r22, r17
     6e2:	82 e3       	ldi	r24, 0x32	; 50
     6e4:	0e 94 fa 09 	call	0x13f4	; 0x13f4 <packPayload2>
	}
	( void ) xTaskResumeAll();
     6e8:	0e 94 15 06 	call	0xc2a	; 0xc2a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     6ec:	ce 01       	movw	r24, r28
     6ee:	df 91       	pop	r29
     6f0:	cf 91       	pop	r28
     6f2:	1f 91       	pop	r17
     6f4:	0f 91       	pop	r16
     6f6:	08 95       	ret

000006f8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6f8:	08 95       	ret

000006fa <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     6fa:	e0 91 77 05 	lds	r30, 0x0577	; 0x800577 <pxDelayedTaskList>
     6fe:	f0 91 78 05 	lds	r31, 0x0578	; 0x800578 <pxDelayedTaskList+0x1>
     702:	80 81       	ld	r24, Z
     704:	81 11       	cpse	r24, r1
     706:	07 c0       	rjmp	.+14     	; 0x716 <prvResetNextTaskUnblockTime+0x1c>
     708:	8f ef       	ldi	r24, 0xFF	; 255
     70a:	9f ef       	ldi	r25, 0xFF	; 255
     70c:	90 93 59 05 	sts	0x0559, r25	; 0x800559 <xNextTaskUnblockTime+0x1>
     710:	80 93 58 05 	sts	0x0558, r24	; 0x800558 <xNextTaskUnblockTime>
     714:	08 95       	ret
     716:	e0 91 77 05 	lds	r30, 0x0577	; 0x800577 <pxDelayedTaskList>
     71a:	f0 91 78 05 	lds	r31, 0x0578	; 0x800578 <pxDelayedTaskList+0x1>
     71e:	05 80       	ldd	r0, Z+5	; 0x05
     720:	f6 81       	ldd	r31, Z+6	; 0x06
     722:	e0 2d       	mov	r30, r0
     724:	06 80       	ldd	r0, Z+6	; 0x06
     726:	f7 81       	ldd	r31, Z+7	; 0x07
     728:	e0 2d       	mov	r30, r0
     72a:	82 81       	ldd	r24, Z+2	; 0x02
     72c:	93 81       	ldd	r25, Z+3	; 0x03
     72e:	90 93 59 05 	sts	0x0559, r25	; 0x800559 <xNextTaskUnblockTime+0x1>
     732:	80 93 58 05 	sts	0x0558, r24	; 0x800558 <xNextTaskUnblockTime>
     736:	08 95       	ret

00000738 <prvIdleTask>:
     738:	cb e8       	ldi	r28, 0x8B	; 139
     73a:	d5 e0       	ldi	r29, 0x05	; 5
     73c:	88 81       	ld	r24, Y
     73e:	82 30       	cpi	r24, 0x02	; 2
     740:	e8 f3       	brcs	.-6      	; 0x73c <prvIdleTask+0x4>
     742:	0e 94 65 02 	call	0x4ca	; 0x4ca <vPortYield>
     746:	fa cf       	rjmp	.-12     	; 0x73c <prvIdleTask+0x4>

00000748 <prvAddCurrentTaskToDelayedList>:
     748:	ff 92       	push	r15
     74a:	0f 93       	push	r16
     74c:	1f 93       	push	r17
     74e:	cf 93       	push	r28
     750:	df 93       	push	r29
     752:	ec 01       	movw	r28, r24
     754:	f6 2e       	mov	r15, r22
     756:	00 91 60 05 	lds	r16, 0x0560	; 0x800560 <xTickCount>
     75a:	10 91 61 05 	lds	r17, 0x0561	; 0x800561 <xTickCount+0x1>
     75e:	80 91 94 05 	lds	r24, 0x0594	; 0x800594 <pxCurrentTCB>
     762:	90 91 95 05 	lds	r25, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     766:	02 96       	adiw	r24, 0x02	; 2
     768:	0e 94 97 01 	call	0x32e	; 0x32e <uxListRemove>
     76c:	cf 3f       	cpi	r28, 0xFF	; 255
     76e:	8f ef       	ldi	r24, 0xFF	; 255
     770:	d8 07       	cpc	r29, r24
     772:	69 f4       	brne	.+26     	; 0x78e <prvAddCurrentTaskToDelayedList+0x46>
     774:	ff 20       	and	r15, r15
     776:	59 f0       	breq	.+22     	; 0x78e <prvAddCurrentTaskToDelayedList+0x46>
     778:	60 91 94 05 	lds	r22, 0x0594	; 0x800594 <pxCurrentTCB>
     77c:	70 91 95 05 	lds	r23, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     780:	6e 5f       	subi	r22, 0xFE	; 254
     782:	7f 4f       	sbci	r23, 0xFF	; 255
     784:	83 e6       	ldi	r24, 0x63	; 99
     786:	95 e0       	ldi	r25, 0x05	; 5
     788:	0e 94 45 01 	call	0x28a	; 0x28a <vListInsertEnd>
     78c:	2f c0       	rjmp	.+94     	; 0x7ec <prvAddCurrentTaskToDelayedList+0xa4>
     78e:	c0 0f       	add	r28, r16
     790:	d1 1f       	adc	r29, r17
     792:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     796:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     79a:	d3 83       	std	Z+3, r29	; 0x03
     79c:	c2 83       	std	Z+2, r28	; 0x02
     79e:	c0 17       	cp	r28, r16
     7a0:	d1 07       	cpc	r29, r17
     7a2:	68 f4       	brcc	.+26     	; 0x7be <prvAddCurrentTaskToDelayedList+0x76>
     7a4:	60 91 94 05 	lds	r22, 0x0594	; 0x800594 <pxCurrentTCB>
     7a8:	70 91 95 05 	lds	r23, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     7ac:	80 91 75 05 	lds	r24, 0x0575	; 0x800575 <pxOverflowDelayedTaskList>
     7b0:	90 91 76 05 	lds	r25, 0x0576	; 0x800576 <pxOverflowDelayedTaskList+0x1>
     7b4:	6e 5f       	subi	r22, 0xFE	; 254
     7b6:	7f 4f       	sbci	r23, 0xFF	; 255
     7b8:	0e 94 66 01 	call	0x2cc	; 0x2cc <vListInsert>
     7bc:	17 c0       	rjmp	.+46     	; 0x7ec <prvAddCurrentTaskToDelayedList+0xa4>
     7be:	60 91 94 05 	lds	r22, 0x0594	; 0x800594 <pxCurrentTCB>
     7c2:	70 91 95 05 	lds	r23, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     7c6:	80 91 77 05 	lds	r24, 0x0577	; 0x800577 <pxDelayedTaskList>
     7ca:	90 91 78 05 	lds	r25, 0x0578	; 0x800578 <pxDelayedTaskList+0x1>
     7ce:	6e 5f       	subi	r22, 0xFE	; 254
     7d0:	7f 4f       	sbci	r23, 0xFF	; 255
     7d2:	0e 94 66 01 	call	0x2cc	; 0x2cc <vListInsert>
     7d6:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <xNextTaskUnblockTime>
     7da:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <xNextTaskUnblockTime+0x1>
     7de:	c8 17       	cp	r28, r24
     7e0:	d9 07       	cpc	r29, r25
     7e2:	20 f4       	brcc	.+8      	; 0x7ec <prvAddCurrentTaskToDelayedList+0xa4>
     7e4:	d0 93 59 05 	sts	0x0559, r29	; 0x800559 <xNextTaskUnblockTime+0x1>
     7e8:	c0 93 58 05 	sts	0x0558, r28	; 0x800558 <xNextTaskUnblockTime>
     7ec:	df 91       	pop	r29
     7ee:	cf 91       	pop	r28
     7f0:	1f 91       	pop	r17
     7f2:	0f 91       	pop	r16
     7f4:	ff 90       	pop	r15
     7f6:	08 95       	ret

000007f8 <xTaskCreate>:
     7f8:	6f 92       	push	r6
     7fa:	7f 92       	push	r7
     7fc:	8f 92       	push	r8
     7fe:	9f 92       	push	r9
     800:	af 92       	push	r10
     802:	bf 92       	push	r11
     804:	cf 92       	push	r12
     806:	df 92       	push	r13
     808:	ef 92       	push	r14
     80a:	ff 92       	push	r15
     80c:	0f 93       	push	r16
     80e:	1f 93       	push	r17
     810:	cf 93       	push	r28
     812:	df 93       	push	r29
     814:	5c 01       	movw	r10, r24
     816:	eb 01       	movw	r28, r22
     818:	8a 01       	movw	r16, r20
     81a:	39 01       	movw	r6, r18
     81c:	ca 01       	movw	r24, r20
     81e:	0e 94 3e 03 	call	0x67c	; 0x67c <pvPortMalloc>
     822:	6c 01       	movw	r12, r24
     824:	89 2b       	or	r24, r25
     826:	09 f4       	brne	.+2      	; 0x82a <xTaskCreate+0x32>
     828:	ce c0       	rjmp	.+412    	; 0x9c6 <__stack+0xc7>
     82a:	82 e3       	ldi	r24, 0x32	; 50
     82c:	90 e0       	ldi	r25, 0x00	; 0
     82e:	0e 94 3e 03 	call	0x67c	; 0x67c <pvPortMalloc>
     832:	4c 01       	movw	r8, r24
     834:	00 97       	sbiw	r24, 0x00	; 0
     836:	b1 f0       	breq	.+44     	; 0x864 <xTaskCreate+0x6c>
     838:	fc 01       	movw	r30, r24
     83a:	d0 8e       	std	Z+24, r13	; 0x18
     83c:	c7 8a       	std	Z+23, r12	; 0x17
     83e:	a8 01       	movw	r20, r16
     840:	65 ea       	ldi	r22, 0xA5	; 165
     842:	70 e0       	ldi	r23, 0x00	; 0
     844:	c6 01       	movw	r24, r12
     846:	0e 94 77 0b 	call	0x16ee	; 0x16ee <memset>
     84a:	01 50       	subi	r16, 0x01	; 1
     84c:	11 09       	sbc	r17, r1
     84e:	f4 01       	movw	r30, r8
     850:	87 89       	ldd	r24, Z+23	; 0x17
     852:	90 8d       	ldd	r25, Z+24	; 0x18
     854:	08 0f       	add	r16, r24
     856:	19 1f       	adc	r17, r25
     858:	88 81       	ld	r24, Y
     85a:	81 8f       	std	Z+25, r24	; 0x19
     85c:	88 81       	ld	r24, Y
     85e:	81 11       	cpse	r24, r1
     860:	05 c0       	rjmp	.+10     	; 0x86c <xTaskCreate+0x74>
     862:	14 c0       	rjmp	.+40     	; 0x88c <xTaskCreate+0x94>
     864:	c6 01       	movw	r24, r12
     866:	0e 94 7c 03 	call	0x6f8	; 0x6f8 <vPortFree>
     86a:	ad c0       	rjmp	.+346    	; 0x9c6 <__stack+0xc7>
     86c:	d4 01       	movw	r26, r8
     86e:	5a 96       	adiw	r26, 0x1a	; 26
     870:	fe 01       	movw	r30, r28
     872:	31 96       	adiw	r30, 0x01	; 1
     874:	9e 01       	movw	r18, r28
     876:	20 5f       	subi	r18, 0xF0	; 240
     878:	3f 4f       	sbci	r19, 0xFF	; 255
     87a:	ef 01       	movw	r28, r30
     87c:	81 91       	ld	r24, Z+
     87e:	8d 93       	st	X+, r24
     880:	88 81       	ld	r24, Y
     882:	88 23       	and	r24, r24
     884:	19 f0       	breq	.+6      	; 0x88c <xTaskCreate+0x94>
     886:	e2 17       	cp	r30, r18
     888:	f3 07       	cpc	r31, r19
     88a:	b9 f7       	brne	.-18     	; 0x87a <xTaskCreate+0x82>
     88c:	f4 01       	movw	r30, r8
     88e:	10 a6       	std	Z+40, r1	; 0x28
     890:	16 8a       	std	Z+22, r1	; 0x16
     892:	13 a6       	std	Z+43, r1	; 0x2b
     894:	14 a6       	std	Z+44, r1	; 0x2c
     896:	e4 01       	movw	r28, r8
     898:	22 96       	adiw	r28, 0x02	; 2
     89a:	ce 01       	movw	r24, r28
     89c:	0e 94 41 01 	call	0x282	; 0x282 <vListInitialiseItem>
     8a0:	c4 01       	movw	r24, r8
     8a2:	0c 96       	adiw	r24, 0x0c	; 12
     8a4:	0e 94 41 01 	call	0x282	; 0x282 <vListInitialiseItem>
     8a8:	f4 01       	movw	r30, r8
     8aa:	91 86       	std	Z+9, r9	; 0x09
     8ac:	80 86       	std	Z+8, r8	; 0x08
     8ae:	81 e0       	ldi	r24, 0x01	; 1
     8b0:	90 e0       	ldi	r25, 0x00	; 0
     8b2:	95 87       	std	Z+13, r25	; 0x0d
     8b4:	84 87       	std	Z+12, r24	; 0x0c
     8b6:	93 8a       	std	Z+19, r9	; 0x13
     8b8:	82 8a       	std	Z+18, r8	; 0x12
     8ba:	15 a6       	std	Z+45, r1	; 0x2d
     8bc:	16 a6       	std	Z+46, r1	; 0x2e
     8be:	17 a6       	std	Z+47, r1	; 0x2f
     8c0:	10 aa       	std	Z+48, r1	; 0x30
     8c2:	11 aa       	std	Z+49, r1	; 0x31
     8c4:	a3 01       	movw	r20, r6
     8c6:	b5 01       	movw	r22, r10
     8c8:	c8 01       	movw	r24, r16
     8ca:	0e 94 be 01 	call	0x37c	; 0x37c <pxPortInitialiseStack>
     8ce:	f4 01       	movw	r30, r8
     8d0:	91 83       	std	Z+1, r25	; 0x01
     8d2:	80 83       	st	Z, r24
     8d4:	e1 14       	cp	r14, r1
     8d6:	f1 04       	cpc	r15, r1
     8d8:	19 f0       	breq	.+6      	; 0x8e0 <xTaskCreate+0xe8>
     8da:	f7 01       	movw	r30, r14
     8dc:	91 82       	std	Z+1, r9	; 0x01
     8de:	80 82       	st	Z, r8
     8e0:	0f b6       	in	r0, 0x3f	; 63
     8e2:	f8 94       	cli
     8e4:	0f 92       	push	r0
     8e6:	80 91 62 05 	lds	r24, 0x0562	; 0x800562 <uxCurrentNumberOfTasks>
     8ea:	8f 5f       	subi	r24, 0xFF	; 255
     8ec:	80 93 62 05 	sts	0x0562, r24	; 0x800562 <uxCurrentNumberOfTasks>
     8f0:	80 91 94 05 	lds	r24, 0x0594	; 0x800594 <pxCurrentTCB>
     8f4:	90 91 95 05 	lds	r25, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     8f8:	89 2b       	or	r24, r25
     8fa:	49 f4       	brne	.+18     	; 0x90e <__stack+0xf>
     8fc:	90 92 95 05 	sts	0x0595, r9	; 0x800595 <pxCurrentTCB+0x1>
     900:	80 92 94 05 	sts	0x0594, r8	; 0x800594 <pxCurrentTCB>
     904:	80 91 62 05 	lds	r24, 0x0562	; 0x800562 <uxCurrentNumberOfTasks>
     908:	81 30       	cpi	r24, 0x01	; 1
     90a:	91 f4       	brne	.+36     	; 0x930 <__stack+0x31>
     90c:	5e c0       	rjmp	.+188    	; 0x9ca <__stack+0xcb>
     90e:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <xSchedulerRunning>
     912:	81 11       	cpse	r24, r1
     914:	0d c0       	rjmp	.+26     	; 0x930 <__stack+0x31>
     916:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     91a:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     91e:	96 89       	ldd	r25, Z+22	; 0x16
     920:	f4 01       	movw	r30, r8
     922:	86 89       	ldd	r24, Z+22	; 0x16
     924:	89 17       	cp	r24, r25
     926:	20 f0       	brcs	.+8      	; 0x930 <__stack+0x31>
     928:	90 92 95 05 	sts	0x0595, r9	; 0x800595 <pxCurrentTCB+0x1>
     92c:	80 92 94 05 	sts	0x0594, r8	; 0x800594 <pxCurrentTCB>
     930:	80 91 5a 05 	lds	r24, 0x055A	; 0x80055a <uxTaskNumber>
     934:	8f 5f       	subi	r24, 0xFF	; 255
     936:	80 93 5a 05 	sts	0x055A, r24	; 0x80055a <uxTaskNumber>
     93a:	f4 01       	movw	r30, r8
     93c:	81 a7       	std	Z+41, r24	; 0x29
     93e:	b4 01       	movw	r22, r8
     940:	67 5e       	subi	r22, 0xE7	; 231
     942:	7f 4f       	sbci	r23, 0xFF	; 255
     944:	85 e0       	ldi	r24, 0x05	; 5
     946:	0e 94 62 08 	call	0x10c4	; 0x10c4 <updateObjectList>
     94a:	f4 01       	movw	r30, r8
     94c:	82 a7       	std	Z+42, r24	; 0x2a
     94e:	68 2f       	mov	r22, r24
     950:	83 e2       	ldi	r24, 0x23	; 35
     952:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
     956:	f4 01       	movw	r30, r8
     958:	62 a5       	ldd	r22, Z+42	; 0x2a
     95a:	8b e0       	ldi	r24, 0x0B	; 11
     95c:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
     960:	f4 01       	movw	r30, r8
     962:	86 89       	ldd	r24, Z+22	; 0x16
     964:	90 91 5f 05 	lds	r25, 0x055F	; 0x80055f <uxTopReadyPriority>
     968:	98 17       	cp	r25, r24
     96a:	10 f4       	brcc	.+4      	; 0x970 <__stack+0x71>
     96c:	80 93 5f 05 	sts	0x055F, r24	; 0x80055f <uxTopReadyPriority>
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	9c 01       	movw	r18, r24
     974:	22 0f       	add	r18, r18
     976:	33 1f       	adc	r19, r19
     978:	22 0f       	add	r18, r18
     97a:	33 1f       	adc	r19, r19
     97c:	22 0f       	add	r18, r18
     97e:	33 1f       	adc	r19, r19
     980:	82 0f       	add	r24, r18
     982:	93 1f       	adc	r25, r19
     984:	be 01       	movw	r22, r28
     986:	85 57       	subi	r24, 0x75	; 117
     988:	9a 4f       	sbci	r25, 0xFA	; 250
     98a:	0e 94 45 01 	call	0x28a	; 0x28a <vListInsertEnd>
     98e:	f4 01       	movw	r30, r8
     990:	62 a5       	ldd	r22, Z+42	; 0x2a
     992:	8c e0       	ldi	r24, 0x0C	; 12
     994:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
     998:	0f 90       	pop	r0
     99a:	0f be       	out	0x3f, r0	; 63
     99c:	80 91 5e 05 	lds	r24, 0x055E	; 0x80055e <xSchedulerRunning>
     9a0:	88 23       	and	r24, r24
     9a2:	69 f0       	breq	.+26     	; 0x9be <__stack+0xbf>
     9a4:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     9a8:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     9ac:	96 89       	ldd	r25, Z+22	; 0x16
     9ae:	f4 01       	movw	r30, r8
     9b0:	86 89       	ldd	r24, Z+22	; 0x16
     9b2:	98 17       	cp	r25, r24
     9b4:	30 f4       	brcc	.+12     	; 0x9c2 <__stack+0xc3>
     9b6:	0e 94 65 02 	call	0x4ca	; 0x4ca <vPortYield>
     9ba:	81 e0       	ldi	r24, 0x01	; 1
     9bc:	27 c0       	rjmp	.+78     	; 0xa0c <__stack+0x10d>
     9be:	81 e0       	ldi	r24, 0x01	; 1
     9c0:	25 c0       	rjmp	.+74     	; 0xa0c <__stack+0x10d>
     9c2:	81 e0       	ldi	r24, 0x01	; 1
     9c4:	23 c0       	rjmp	.+70     	; 0xa0c <__stack+0x10d>
     9c6:	8f ef       	ldi	r24, 0xFF	; 255
     9c8:	21 c0       	rjmp	.+66     	; 0xa0c <__stack+0x10d>
     9ca:	8b e8       	ldi	r24, 0x8B	; 139
     9cc:	95 e0       	ldi	r25, 0x05	; 5
     9ce:	0e 94 33 01 	call	0x266	; 0x266 <vListInitialise>
     9d2:	82 e8       	ldi	r24, 0x82	; 130
     9d4:	95 e0       	ldi	r25, 0x05	; 5
     9d6:	0e 94 33 01 	call	0x266	; 0x266 <vListInitialise>
     9da:	89 e7       	ldi	r24, 0x79	; 121
     9dc:	95 e0       	ldi	r25, 0x05	; 5
     9de:	0e 94 33 01 	call	0x266	; 0x266 <vListInitialise>
     9e2:	8c e6       	ldi	r24, 0x6C	; 108
     9e4:	95 e0       	ldi	r25, 0x05	; 5
     9e6:	0e 94 33 01 	call	0x266	; 0x266 <vListInitialise>
     9ea:	83 e6       	ldi	r24, 0x63	; 99
     9ec:	95 e0       	ldi	r25, 0x05	; 5
     9ee:	0e 94 33 01 	call	0x266	; 0x266 <vListInitialise>
     9f2:	82 e8       	ldi	r24, 0x82	; 130
     9f4:	95 e0       	ldi	r25, 0x05	; 5
     9f6:	90 93 78 05 	sts	0x0578, r25	; 0x800578 <pxDelayedTaskList+0x1>
     9fa:	80 93 77 05 	sts	0x0577, r24	; 0x800577 <pxDelayedTaskList>
     9fe:	89 e7       	ldi	r24, 0x79	; 121
     a00:	95 e0       	ldi	r25, 0x05	; 5
     a02:	90 93 76 05 	sts	0x0576, r25	; 0x800576 <pxOverflowDelayedTaskList+0x1>
     a06:	80 93 75 05 	sts	0x0575, r24	; 0x800575 <pxOverflowDelayedTaskList>
     a0a:	92 cf       	rjmp	.-220    	; 0x930 <__stack+0x31>
     a0c:	df 91       	pop	r29
     a0e:	cf 91       	pop	r28
     a10:	1f 91       	pop	r17
     a12:	0f 91       	pop	r16
     a14:	ff 90       	pop	r15
     a16:	ef 90       	pop	r14
     a18:	df 90       	pop	r13
     a1a:	cf 90       	pop	r12
     a1c:	bf 90       	pop	r11
     a1e:	af 90       	pop	r10
     a20:	9f 90       	pop	r9
     a22:	8f 90       	pop	r8
     a24:	7f 90       	pop	r7
     a26:	6f 90       	pop	r6
     a28:	08 95       	ret

00000a2a <vTaskStartScheduler>:
     a2a:	ef 92       	push	r14
     a2c:	ff 92       	push	r15
     a2e:	0f 93       	push	r16
     a30:	0f 2e       	mov	r0, r31
     a32:	f6 e5       	ldi	r31, 0x56	; 86
     a34:	ef 2e       	mov	r14, r31
     a36:	f5 e0       	ldi	r31, 0x05	; 5
     a38:	ff 2e       	mov	r15, r31
     a3a:	f0 2d       	mov	r31, r0
     a3c:	00 e0       	ldi	r16, 0x00	; 0
     a3e:	20 e0       	ldi	r18, 0x00	; 0
     a40:	30 e0       	ldi	r19, 0x00	; 0
     a42:	45 e5       	ldi	r20, 0x55	; 85
     a44:	50 e0       	ldi	r21, 0x00	; 0
     a46:	6d e0       	ldi	r22, 0x0D	; 13
     a48:	71 e0       	ldi	r23, 0x01	; 1
     a4a:	8c e9       	ldi	r24, 0x9C	; 156
     a4c:	93 e0       	ldi	r25, 0x03	; 3
     a4e:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <xTaskCreate>
     a52:	81 30       	cpi	r24, 0x01	; 1
     a54:	81 f4       	brne	.+32     	; 0xa76 <vTaskStartScheduler+0x4c>
     a56:	f8 94       	cli
     a58:	8f ef       	ldi	r24, 0xFF	; 255
     a5a:	9f ef       	ldi	r25, 0xFF	; 255
     a5c:	90 93 59 05 	sts	0x0559, r25	; 0x800559 <xNextTaskUnblockTime+0x1>
     a60:	80 93 58 05 	sts	0x0558, r24	; 0x800558 <xNextTaskUnblockTime>
     a64:	81 e0       	ldi	r24, 0x01	; 1
     a66:	80 93 5e 05 	sts	0x055E, r24	; 0x80055e <xSchedulerRunning>
     a6a:	10 92 61 05 	sts	0x0561, r1	; 0x800561 <xTickCount+0x1>
     a6e:	10 92 60 05 	sts	0x0560, r1	; 0x800560 <xTickCount>
     a72:	0e 94 2a 02 	call	0x454	; 0x454 <xPortStartScheduler>
     a76:	0f 91       	pop	r16
     a78:	ff 90       	pop	r15
     a7a:	ef 90       	pop	r14
     a7c:	08 95       	ret

00000a7e <vTaskSuspendAll>:
     a7e:	80 91 55 05 	lds	r24, 0x0555	; 0x800555 <uxSchedulerSuspended>
     a82:	8f 5f       	subi	r24, 0xFF	; 255
     a84:	80 93 55 05 	sts	0x0555, r24	; 0x800555 <uxSchedulerSuspended>
     a88:	08 95       	ret

00000a8a <xTaskGetTickCount>:
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	0f 92       	push	r0
     a90:	80 91 60 05 	lds	r24, 0x0560	; 0x800560 <xTickCount>
     a94:	90 91 61 05 	lds	r25, 0x0561	; 0x800561 <xTickCount+0x1>
     a98:	0f 90       	pop	r0
     a9a:	0f be       	out	0x3f, r0	; 63
     a9c:	08 95       	ret

00000a9e <xTaskIncrementTick>:
     a9e:	cf 92       	push	r12
     aa0:	df 92       	push	r13
     aa2:	ef 92       	push	r14
     aa4:	ff 92       	push	r15
     aa6:	0f 93       	push	r16
     aa8:	1f 93       	push	r17
     aaa:	cf 93       	push	r28
     aac:	df 93       	push	r29
     aae:	8c e2       	ldi	r24, 0x2C	; 44
     ab0:	0e 94 85 09 	call	0x130a	; 0x130a <packPayload0>
     ab4:	80 91 55 05 	lds	r24, 0x0555	; 0x800555 <uxSchedulerSuspended>
     ab8:	81 11       	cpse	r24, r1
     aba:	a1 c0       	rjmp	.+322    	; 0xbfe <xTaskIncrementTick+0x160>
     abc:	e0 90 60 05 	lds	r14, 0x0560	; 0x800560 <xTickCount>
     ac0:	f0 90 61 05 	lds	r15, 0x0561	; 0x800561 <xTickCount+0x1>
     ac4:	8f ef       	ldi	r24, 0xFF	; 255
     ac6:	e8 1a       	sub	r14, r24
     ac8:	f8 0a       	sbc	r15, r24
     aca:	f0 92 61 05 	sts	0x0561, r15	; 0x800561 <xTickCount+0x1>
     ace:	e0 92 60 05 	sts	0x0560, r14	; 0x800560 <xTickCount>
     ad2:	e1 14       	cp	r14, r1
     ad4:	f1 04       	cpc	r15, r1
     ad6:	b9 f4       	brne	.+46     	; 0xb06 <xTaskIncrementTick+0x68>
     ad8:	80 91 77 05 	lds	r24, 0x0577	; 0x800577 <pxDelayedTaskList>
     adc:	90 91 78 05 	lds	r25, 0x0578	; 0x800578 <pxDelayedTaskList+0x1>
     ae0:	20 91 75 05 	lds	r18, 0x0575	; 0x800575 <pxOverflowDelayedTaskList>
     ae4:	30 91 76 05 	lds	r19, 0x0576	; 0x800576 <pxOverflowDelayedTaskList+0x1>
     ae8:	30 93 78 05 	sts	0x0578, r19	; 0x800578 <pxDelayedTaskList+0x1>
     aec:	20 93 77 05 	sts	0x0577, r18	; 0x800577 <pxDelayedTaskList>
     af0:	90 93 76 05 	sts	0x0576, r25	; 0x800576 <pxOverflowDelayedTaskList+0x1>
     af4:	80 93 75 05 	sts	0x0575, r24	; 0x800575 <pxOverflowDelayedTaskList>
     af8:	80 91 5b 05 	lds	r24, 0x055B	; 0x80055b <xNumOfOverflows>
     afc:	8f 5f       	subi	r24, 0xFF	; 255
     afe:	80 93 5b 05 	sts	0x055B, r24	; 0x80055b <xNumOfOverflows>
     b02:	0e 94 7d 03 	call	0x6fa	; 0x6fa <prvResetNextTaskUnblockTime>
     b06:	80 91 58 05 	lds	r24, 0x0558	; 0x800558 <xNextTaskUnblockTime>
     b0a:	90 91 59 05 	lds	r25, 0x0559	; 0x800559 <xNextTaskUnblockTime+0x1>
     b0e:	e8 16       	cp	r14, r24
     b10:	f9 06       	cpc	r15, r25
     b12:	10 f4       	brcc	.+4      	; 0xb18 <xTaskIncrementTick+0x7a>
     b14:	d1 2c       	mov	r13, r1
     b16:	5b c0       	rjmp	.+182    	; 0xbce <xTaskIncrementTick+0x130>
     b18:	d1 2c       	mov	r13, r1
     b1a:	cc 24       	eor	r12, r12
     b1c:	c3 94       	inc	r12
     b1e:	e0 91 77 05 	lds	r30, 0x0577	; 0x800577 <pxDelayedTaskList>
     b22:	f0 91 78 05 	lds	r31, 0x0578	; 0x800578 <pxDelayedTaskList+0x1>
     b26:	90 81       	ld	r25, Z
     b28:	91 11       	cpse	r25, r1
     b2a:	07 c0       	rjmp	.+14     	; 0xb3a <xTaskIncrementTick+0x9c>
     b2c:	8f ef       	ldi	r24, 0xFF	; 255
     b2e:	9f ef       	ldi	r25, 0xFF	; 255
     b30:	90 93 59 05 	sts	0x0559, r25	; 0x800559 <xNextTaskUnblockTime+0x1>
     b34:	80 93 58 05 	sts	0x0558, r24	; 0x800558 <xNextTaskUnblockTime>
     b38:	4a c0       	rjmp	.+148    	; 0xbce <xTaskIncrementTick+0x130>
     b3a:	e0 91 77 05 	lds	r30, 0x0577	; 0x800577 <pxDelayedTaskList>
     b3e:	f0 91 78 05 	lds	r31, 0x0578	; 0x800578 <pxDelayedTaskList+0x1>
     b42:	05 80       	ldd	r0, Z+5	; 0x05
     b44:	f6 81       	ldd	r31, Z+6	; 0x06
     b46:	e0 2d       	mov	r30, r0
     b48:	c6 81       	ldd	r28, Z+6	; 0x06
     b4a:	d7 81       	ldd	r29, Z+7	; 0x07
     b4c:	2a 81       	ldd	r18, Y+2	; 0x02
     b4e:	3b 81       	ldd	r19, Y+3	; 0x03
     b50:	e2 16       	cp	r14, r18
     b52:	f3 06       	cpc	r15, r19
     b54:	28 f4       	brcc	.+10     	; 0xb60 <xTaskIncrementTick+0xc2>
     b56:	30 93 59 05 	sts	0x0559, r19	; 0x800559 <xNextTaskUnblockTime+0x1>
     b5a:	20 93 58 05 	sts	0x0558, r18	; 0x800558 <xNextTaskUnblockTime>
     b5e:	37 c0       	rjmp	.+110    	; 0xbce <xTaskIncrementTick+0x130>
     b60:	8e 01       	movw	r16, r28
     b62:	0e 5f       	subi	r16, 0xFE	; 254
     b64:	1f 4f       	sbci	r17, 0xFF	; 255
     b66:	c8 01       	movw	r24, r16
     b68:	0e 94 97 01 	call	0x32e	; 0x32e <uxListRemove>
     b6c:	8c 89       	ldd	r24, Y+20	; 0x14
     b6e:	9d 89       	ldd	r25, Y+21	; 0x15
     b70:	89 2b       	or	r24, r25
     b72:	21 f0       	breq	.+8      	; 0xb7c <xTaskIncrementTick+0xde>
     b74:	ce 01       	movw	r24, r28
     b76:	0c 96       	adiw	r24, 0x0c	; 12
     b78:	0e 94 97 01 	call	0x32e	; 0x32e <uxListRemove>
     b7c:	6a a5       	ldd	r22, Y+42	; 0x2a
     b7e:	8b e0       	ldi	r24, 0x0B	; 11
     b80:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
     b84:	2e 89       	ldd	r18, Y+22	; 0x16
     b86:	80 91 5f 05 	lds	r24, 0x055F	; 0x80055f <uxTopReadyPriority>
     b8a:	82 17       	cp	r24, r18
     b8c:	10 f4       	brcc	.+4      	; 0xb92 <xTaskIncrementTick+0xf4>
     b8e:	20 93 5f 05 	sts	0x055F, r18	; 0x80055f <uxTopReadyPriority>
     b92:	30 e0       	ldi	r19, 0x00	; 0
     b94:	c9 01       	movw	r24, r18
     b96:	88 0f       	add	r24, r24
     b98:	99 1f       	adc	r25, r25
     b9a:	88 0f       	add	r24, r24
     b9c:	99 1f       	adc	r25, r25
     b9e:	88 0f       	add	r24, r24
     ba0:	99 1f       	adc	r25, r25
     ba2:	82 0f       	add	r24, r18
     ba4:	93 1f       	adc	r25, r19
     ba6:	b8 01       	movw	r22, r16
     ba8:	85 57       	subi	r24, 0x75	; 117
     baa:	9a 4f       	sbci	r25, 0xFA	; 250
     bac:	0e 94 45 01 	call	0x28a	; 0x28a <vListInsertEnd>
     bb0:	6a a5       	ldd	r22, Y+42	; 0x2a
     bb2:	8c e0       	ldi	r24, 0x0C	; 12
     bb4:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
     bb8:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     bbc:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     bc0:	9e 89       	ldd	r25, Y+22	; 0x16
     bc2:	86 89       	ldd	r24, Z+22	; 0x16
     bc4:	98 17       	cp	r25, r24
     bc6:	08 f4       	brcc	.+2      	; 0xbca <xTaskIncrementTick+0x12c>
     bc8:	aa cf       	rjmp	.-172    	; 0xb1e <xTaskIncrementTick+0x80>
     bca:	dc 2c       	mov	r13, r12
     bcc:	a8 cf       	rjmp	.-176    	; 0xb1e <xTaskIncrementTick+0x80>
     bce:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     bd2:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     bd6:	86 89       	ldd	r24, Z+22	; 0x16
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	fc 01       	movw	r30, r24
     bdc:	ee 0f       	add	r30, r30
     bde:	ff 1f       	adc	r31, r31
     be0:	ee 0f       	add	r30, r30
     be2:	ff 1f       	adc	r31, r31
     be4:	ee 0f       	add	r30, r30
     be6:	ff 1f       	adc	r31, r31
     be8:	8e 0f       	add	r24, r30
     bea:	9f 1f       	adc	r25, r31
     bec:	fc 01       	movw	r30, r24
     bee:	e5 57       	subi	r30, 0x75	; 117
     bf0:	fa 4f       	sbci	r31, 0xFA	; 250
     bf2:	80 81       	ld	r24, Z
     bf4:	82 30       	cpi	r24, 0x02	; 2
     bf6:	48 f0       	brcs	.+18     	; 0xc0a <xTaskIncrementTick+0x16c>
     bf8:	dd 24       	eor	r13, r13
     bfa:	d3 94       	inc	r13
     bfc:	06 c0       	rjmp	.+12     	; 0xc0a <xTaskIncrementTick+0x16c>
     bfe:	80 91 5d 05 	lds	r24, 0x055D	; 0x80055d <uxPendedTicks>
     c02:	8f 5f       	subi	r24, 0xFF	; 255
     c04:	80 93 5d 05 	sts	0x055D, r24	; 0x80055d <uxPendedTicks>
     c08:	d1 2c       	mov	r13, r1
     c0a:	80 91 5c 05 	lds	r24, 0x055C	; 0x80055c <xYieldPending>
     c0e:	88 23       	and	r24, r24
     c10:	11 f0       	breq	.+4      	; 0xc16 <xTaskIncrementTick+0x178>
     c12:	dd 24       	eor	r13, r13
     c14:	d3 94       	inc	r13
     c16:	8d 2d       	mov	r24, r13
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	1f 91       	pop	r17
     c1e:	0f 91       	pop	r16
     c20:	ff 90       	pop	r15
     c22:	ef 90       	pop	r14
     c24:	df 90       	pop	r13
     c26:	cf 90       	pop	r12
     c28:	08 95       	ret

00000c2a <xTaskResumeAll>:
     c2a:	df 92       	push	r13
     c2c:	ef 92       	push	r14
     c2e:	ff 92       	push	r15
     c30:	0f 93       	push	r16
     c32:	1f 93       	push	r17
     c34:	cf 93       	push	r28
     c36:	df 93       	push	r29
     c38:	0f b6       	in	r0, 0x3f	; 63
     c3a:	f8 94       	cli
     c3c:	0f 92       	push	r0
     c3e:	80 91 55 05 	lds	r24, 0x0555	; 0x800555 <uxSchedulerSuspended>
     c42:	81 50       	subi	r24, 0x01	; 1
     c44:	80 93 55 05 	sts	0x0555, r24	; 0x800555 <uxSchedulerSuspended>
     c48:	80 91 55 05 	lds	r24, 0x0555	; 0x800555 <uxSchedulerSuspended>
     c4c:	81 11       	cpse	r24, r1
     c4e:	67 c0       	rjmp	.+206    	; 0xd1e <xTaskResumeAll+0xf4>
     c50:	80 91 62 05 	lds	r24, 0x0562	; 0x800562 <uxCurrentNumberOfTasks>
     c54:	81 11       	cpse	r24, r1
     c56:	3b c0       	rjmp	.+118    	; 0xcce <xTaskResumeAll+0xa4>
     c58:	65 c0       	rjmp	.+202    	; 0xd24 <xTaskResumeAll+0xfa>
     c5a:	d7 01       	movw	r26, r14
     c5c:	15 96       	adiw	r26, 0x05	; 5
     c5e:	ed 91       	ld	r30, X+
     c60:	fc 91       	ld	r31, X
     c62:	16 97       	sbiw	r26, 0x06	; 6
     c64:	c6 81       	ldd	r28, Z+6	; 0x06
     c66:	d7 81       	ldd	r29, Z+7	; 0x07
     c68:	ce 01       	movw	r24, r28
     c6a:	0c 96       	adiw	r24, 0x0c	; 12
     c6c:	0e 94 97 01 	call	0x32e	; 0x32e <uxListRemove>
     c70:	8e 01       	movw	r16, r28
     c72:	0e 5f       	subi	r16, 0xFE	; 254
     c74:	1f 4f       	sbci	r17, 0xFF	; 255
     c76:	c8 01       	movw	r24, r16
     c78:	0e 94 97 01 	call	0x32e	; 0x32e <uxListRemove>
     c7c:	6a a5       	ldd	r22, Y+42	; 0x2a
     c7e:	8b e0       	ldi	r24, 0x0B	; 11
     c80:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
     c84:	2e 89       	ldd	r18, Y+22	; 0x16
     c86:	80 91 5f 05 	lds	r24, 0x055F	; 0x80055f <uxTopReadyPriority>
     c8a:	82 17       	cp	r24, r18
     c8c:	10 f4       	brcc	.+4      	; 0xc92 <xTaskResumeAll+0x68>
     c8e:	20 93 5f 05 	sts	0x055F, r18	; 0x80055f <uxTopReadyPriority>
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	c9 01       	movw	r24, r18
     c96:	88 0f       	add	r24, r24
     c98:	99 1f       	adc	r25, r25
     c9a:	88 0f       	add	r24, r24
     c9c:	99 1f       	adc	r25, r25
     c9e:	88 0f       	add	r24, r24
     ca0:	99 1f       	adc	r25, r25
     ca2:	82 0f       	add	r24, r18
     ca4:	93 1f       	adc	r25, r19
     ca6:	b8 01       	movw	r22, r16
     ca8:	85 57       	subi	r24, 0x75	; 117
     caa:	9a 4f       	sbci	r25, 0xFA	; 250
     cac:	0e 94 45 01 	call	0x28a	; 0x28a <vListInsertEnd>
     cb0:	6a a5       	ldd	r22, Y+42	; 0x2a
     cb2:	8c e0       	ldi	r24, 0x0C	; 12
     cb4:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
     cb8:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     cbc:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     cc0:	9e 89       	ldd	r25, Y+22	; 0x16
     cc2:	86 89       	ldd	r24, Z+22	; 0x16
     cc4:	98 17       	cp	r25, r24
     cc6:	68 f0       	brcs	.+26     	; 0xce2 <xTaskResumeAll+0xb8>
     cc8:	d0 92 5c 05 	sts	0x055C, r13	; 0x80055c <xYieldPending>
     ccc:	0a c0       	rjmp	.+20     	; 0xce2 <xTaskResumeAll+0xb8>
     cce:	c0 e0       	ldi	r28, 0x00	; 0
     cd0:	d0 e0       	ldi	r29, 0x00	; 0
     cd2:	0f 2e       	mov	r0, r31
     cd4:	fc e6       	ldi	r31, 0x6C	; 108
     cd6:	ef 2e       	mov	r14, r31
     cd8:	f5 e0       	ldi	r31, 0x05	; 5
     cda:	ff 2e       	mov	r15, r31
     cdc:	f0 2d       	mov	r31, r0
     cde:	dd 24       	eor	r13, r13
     ce0:	d3 94       	inc	r13
     ce2:	f7 01       	movw	r30, r14
     ce4:	80 81       	ld	r24, Z
     ce6:	81 11       	cpse	r24, r1
     ce8:	b8 cf       	rjmp	.-144    	; 0xc5a <xTaskResumeAll+0x30>
     cea:	cd 2b       	or	r28, r29
     cec:	11 f0       	breq	.+4      	; 0xcf2 <xTaskResumeAll+0xc8>
     cee:	0e 94 7d 03 	call	0x6fa	; 0x6fa <prvResetNextTaskUnblockTime>
     cf2:	c0 91 5d 05 	lds	r28, 0x055D	; 0x80055d <uxPendedTicks>
     cf6:	cc 23       	and	r28, r28
     cf8:	51 f0       	breq	.+20     	; 0xd0e <xTaskResumeAll+0xe4>
     cfa:	d1 e0       	ldi	r29, 0x01	; 1
     cfc:	0e 94 4f 05 	call	0xa9e	; 0xa9e <xTaskIncrementTick>
     d00:	81 11       	cpse	r24, r1
     d02:	d0 93 5c 05 	sts	0x055C, r29	; 0x80055c <xYieldPending>
     d06:	c1 50       	subi	r28, 0x01	; 1
     d08:	c9 f7       	brne	.-14     	; 0xcfc <xTaskResumeAll+0xd2>
     d0a:	10 92 5d 05 	sts	0x055D, r1	; 0x80055d <uxPendedTicks>
     d0e:	80 91 5c 05 	lds	r24, 0x055C	; 0x80055c <xYieldPending>
     d12:	88 23       	and	r24, r24
     d14:	31 f0       	breq	.+12     	; 0xd22 <xTaskResumeAll+0xf8>
     d16:	0e 94 65 02 	call	0x4ca	; 0x4ca <vPortYield>
     d1a:	81 e0       	ldi	r24, 0x01	; 1
     d1c:	03 c0       	rjmp	.+6      	; 0xd24 <xTaskResumeAll+0xfa>
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	01 c0       	rjmp	.+2      	; 0xd24 <xTaskResumeAll+0xfa>
     d22:	80 e0       	ldi	r24, 0x00	; 0
     d24:	0f 90       	pop	r0
     d26:	0f be       	out	0x3f, r0	; 63
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	1f 91       	pop	r17
     d2e:	0f 91       	pop	r16
     d30:	ff 90       	pop	r15
     d32:	ef 90       	pop	r14
     d34:	df 90       	pop	r13
     d36:	08 95       	ret

00000d38 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     d38:	cf 93       	push	r28
     d3a:	df 93       	push	r29
     d3c:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     d3e:	89 2b       	or	r24, r25
     d40:	a1 f0       	breq	.+40     	; 0xd6a <vTaskDelay+0x32>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     d42:	0e 94 3f 05 	call	0xa7e	; 0xa7e <vTaskSuspendAll>
			{
				traceTASK_DELAY();
     d46:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     d4a:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     d4e:	2c 2f       	mov	r18, r28
     d50:	4d 2f       	mov	r20, r29
     d52:	62 a5       	ldd	r22, Z+42	; 0x2a
     d54:	87 e2       	ldi	r24, 0x27	; 39
     d56:	0e 94 3f 0a 	call	0x147e	; 0x147e <packPayload3>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     d5a:	60 e0       	ldi	r22, 0x00	; 0
     d5c:	ce 01       	movw	r24, r28
     d5e:	0e 94 a4 03 	call	0x748	; 0x748 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     d62:	0e 94 15 06 	call	0xc2a	; 0xc2a <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d66:	81 11       	cpse	r24, r1
     d68:	02 c0       	rjmp	.+4      	; 0xd6e <vTaskDelay+0x36>
		{
			portYIELD_WITHIN_API();
     d6a:	0e 94 65 02 	call	0x4ca	; 0x4ca <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d6e:	df 91       	pop	r29
     d70:	cf 91       	pop	r28
     d72:	08 95       	ret

00000d74 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     d74:	80 91 55 05 	lds	r24, 0x0555	; 0x800555 <uxSchedulerSuspended>
     d78:	88 23       	and	r24, r24
     d7a:	21 f0       	breq	.+8      	; 0xd84 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     d7c:	81 e0       	ldi	r24, 0x01	; 1
     d7e:	80 93 5c 05 	sts	0x055C, r24	; 0x80055c <xYieldPending>
     d82:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     d84:	10 92 5c 05 	sts	0x055C, r1	; 0x80055c <xYieldPending>
		traceTASK_SWITCHED_OUT();
     d88:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     d8c:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     d90:	62 a5       	ldd	r22, Z+42	; 0x2a
     d92:	86 e0       	ldi	r24, 0x06	; 6
     d94:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     d98:	20 91 5f 05 	lds	r18, 0x055F	; 0x80055f <uxTopReadyPriority>
     d9c:	82 2f       	mov	r24, r18
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	fc 01       	movw	r30, r24
     da2:	ee 0f       	add	r30, r30
     da4:	ff 1f       	adc	r31, r31
     da6:	ee 0f       	add	r30, r30
     da8:	ff 1f       	adc	r31, r31
     daa:	ee 0f       	add	r30, r30
     dac:	ff 1f       	adc	r31, r31
     dae:	e8 0f       	add	r30, r24
     db0:	f9 1f       	adc	r31, r25
     db2:	e5 57       	subi	r30, 0x75	; 117
     db4:	fa 4f       	sbci	r31, 0xFA	; 250
     db6:	30 81       	ld	r19, Z
     db8:	31 11       	cpse	r19, r1
     dba:	11 c0       	rjmp	.+34     	; 0xdde <vTaskSwitchContext+0x6a>
     dbc:	21 50       	subi	r18, 0x01	; 1
     dbe:	82 2f       	mov	r24, r18
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	fc 01       	movw	r30, r24
     dc4:	ee 0f       	add	r30, r30
     dc6:	ff 1f       	adc	r31, r31
     dc8:	ee 0f       	add	r30, r30
     dca:	ff 1f       	adc	r31, r31
     dcc:	ee 0f       	add	r30, r30
     dce:	ff 1f       	adc	r31, r31
     dd0:	e8 0f       	add	r30, r24
     dd2:	f9 1f       	adc	r31, r25
     dd4:	e5 57       	subi	r30, 0x75	; 117
     dd6:	fa 4f       	sbci	r31, 0xFA	; 250
     dd8:	30 81       	ld	r19, Z
     dda:	33 23       	and	r19, r19
     ddc:	79 f3       	breq	.-34     	; 0xdbc <vTaskSwitchContext+0x48>
     dde:	ac 01       	movw	r20, r24
     de0:	44 0f       	add	r20, r20
     de2:	55 1f       	adc	r21, r21
     de4:	44 0f       	add	r20, r20
     de6:	55 1f       	adc	r21, r21
     de8:	44 0f       	add	r20, r20
     dea:	55 1f       	adc	r21, r21
     dec:	48 0f       	add	r20, r24
     dee:	59 1f       	adc	r21, r25
     df0:	da 01       	movw	r26, r20
     df2:	a5 57       	subi	r26, 0x75	; 117
     df4:	ba 4f       	sbci	r27, 0xFA	; 250
     df6:	11 96       	adiw	r26, 0x01	; 1
     df8:	ed 91       	ld	r30, X+
     dfa:	fc 91       	ld	r31, X
     dfc:	12 97       	sbiw	r26, 0x02	; 2
     dfe:	02 80       	ldd	r0, Z+2	; 0x02
     e00:	f3 81       	ldd	r31, Z+3	; 0x03
     e02:	e0 2d       	mov	r30, r0
     e04:	12 96       	adiw	r26, 0x02	; 2
     e06:	fc 93       	st	X, r31
     e08:	ee 93       	st	-X, r30
     e0a:	11 97       	sbiw	r26, 0x01	; 1
     e0c:	42 57       	subi	r20, 0x72	; 114
     e0e:	5a 4f       	sbci	r21, 0xFA	; 250
     e10:	e4 17       	cp	r30, r20
     e12:	f5 07       	cpc	r31, r21
     e14:	29 f4       	brne	.+10     	; 0xe20 <vTaskSwitchContext+0xac>
     e16:	42 81       	ldd	r20, Z+2	; 0x02
     e18:	53 81       	ldd	r21, Z+3	; 0x03
     e1a:	fd 01       	movw	r30, r26
     e1c:	52 83       	std	Z+2, r21	; 0x02
     e1e:	41 83       	std	Z+1, r20	; 0x01
     e20:	fc 01       	movw	r30, r24
     e22:	ee 0f       	add	r30, r30
     e24:	ff 1f       	adc	r31, r31
     e26:	ee 0f       	add	r30, r30
     e28:	ff 1f       	adc	r31, r31
     e2a:	ee 0f       	add	r30, r30
     e2c:	ff 1f       	adc	r31, r31
     e2e:	8e 0f       	add	r24, r30
     e30:	9f 1f       	adc	r25, r31
     e32:	fc 01       	movw	r30, r24
     e34:	e5 57       	subi	r30, 0x75	; 117
     e36:	fa 4f       	sbci	r31, 0xFA	; 250
     e38:	01 80       	ldd	r0, Z+1	; 0x01
     e3a:	f2 81       	ldd	r31, Z+2	; 0x02
     e3c:	e0 2d       	mov	r30, r0
     e3e:	86 81       	ldd	r24, Z+6	; 0x06
     e40:	97 81       	ldd	r25, Z+7	; 0x07
     e42:	90 93 95 05 	sts	0x0595, r25	; 0x800595 <pxCurrentTCB+0x1>
     e46:	80 93 94 05 	sts	0x0594, r24	; 0x800594 <pxCurrentTCB>
     e4a:	20 93 5f 05 	sts	0x055F, r18	; 0x80055f <uxTopReadyPriority>
		traceTASK_SWITCHED_IN();
     e4e:	e0 91 94 05 	lds	r30, 0x0594	; 0x800594 <pxCurrentTCB>
     e52:	f0 91 95 05 	lds	r31, 0x0595	; 0x800595 <pxCurrentTCB+0x1>
     e56:	62 a5       	ldd	r22, Z+42	; 0x2a
     e58:	82 e0       	ldi	r24, 0x02	; 2
     e5a:	0e 94 bc 09 	call	0x1378	; 0x1378 <packPayload1>
     e5e:	08 95       	ret

00000e60 <writeFIFO>:
            return 0;
        }

    //EMPTY
	return 1;
}
     e60:	df 92       	push	r13
     e62:	ef 92       	push	r14
     e64:	ff 92       	push	r15
     e66:	0f 93       	push	r16
     e68:	1f 93       	push	r17
     e6a:	cf 93       	push	r28
     e6c:	df 93       	push	r29
     e6e:	7c 01       	movw	r14, r24
     e70:	d6 2e       	mov	r13, r22
     e72:	44 23       	and	r20, r20
     e74:	61 f1       	breq	.+88     	; 0xece <writeFIFO+0x6e>
     e76:	42 30       	cpi	r20, 0x02	; 2
     e78:	09 f0       	breq	.+2      	; 0xe7c <writeFIFO+0x1c>
     e7a:	5a c0       	rjmp	.+180    	; 0xf30 <writeFIFO+0xd0>
     e7c:	cb ee       	ldi	r28, 0xEB	; 235
     e7e:	d6 e0       	ldi	r29, 0x06	; 6
     e80:	e8 81       	ld	r30, Y
     e82:	f9 81       	ldd	r31, Y+1	; 0x01
     e84:	cf 01       	movw	r24, r30
     e86:	01 96       	adiw	r24, 0x01	; 1
     e88:	6c 81       	ldd	r22, Y+4	; 0x04
     e8a:	7d 81       	ldd	r23, Y+5	; 0x05
     e8c:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <__udivmodhi4>
     e90:	8c 01       	movw	r16, r24
     e92:	8a 81       	ldd	r24, Y+2	; 0x02
     e94:	9b 81       	ldd	r25, Y+3	; 0x03
     e96:	08 17       	cp	r16, r24
     e98:	19 07       	cpc	r17, r25
     e9a:	09 f4       	brne	.+2      	; 0xe9e <writeFIFO+0x3e>
     e9c:	4b c0       	rjmp	.+150    	; 0xf34 <writeFIFO+0xd4>
     e9e:	cd 2d       	mov	r28, r13
     ea0:	d0 e0       	ldi	r29, 0x00	; 0
     ea2:	ae 01       	movw	r20, r28
     ea4:	b7 01       	movw	r22, r14
     ea6:	cf 01       	movw	r24, r30
     ea8:	8f 50       	subi	r24, 0x0F	; 15
     eaa:	99 4f       	sbci	r25, 0xF9	; 249
     eac:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <memcpy>
     eb0:	ab ee       	ldi	r26, 0xEB	; 235
     eb2:	b6 e0       	ldi	r27, 0x06	; 6
     eb4:	ed 91       	ld	r30, X+
     eb6:	fc 91       	ld	r31, X
     eb8:	11 97       	sbiw	r26, 0x01	; 1
     eba:	ee 0f       	add	r30, r30
     ebc:	ff 1f       	adc	r31, r31
     ebe:	e5 51       	subi	r30, 0x15	; 21
     ec0:	f9 4f       	sbci	r31, 0xF9	; 249
     ec2:	d6 8b       	std	Z+22, r29	; 0x16
     ec4:	c5 8b       	std	Z+21, r28	; 0x15
     ec6:	0d 93       	st	X+, r16
     ec8:	1c 93       	st	X, r17
     eca:	80 e0       	ldi	r24, 0x00	; 0
     ecc:	36 c0       	rjmp	.+108    	; 0xf3a <writeFIFO+0xda>
     ece:	ee e1       	ldi	r30, 0x1E	; 30
     ed0:	f7 e0       	ldi	r31, 0x07	; 7
     ed2:	20 81       	ld	r18, Z
     ed4:	31 81       	ldd	r19, Z+1	; 0x01
     ed6:	c9 01       	movw	r24, r18
     ed8:	01 96       	adiw	r24, 0x01	; 1
     eda:	64 81       	ldd	r22, Z+4	; 0x04
     edc:	75 81       	ldd	r23, Z+5	; 0x05
     ede:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <__udivmodhi4>
     ee2:	8c 01       	movw	r16, r24
     ee4:	82 81       	ldd	r24, Z+2	; 0x02
     ee6:	93 81       	ldd	r25, Z+3	; 0x03
     ee8:	08 17       	cp	r16, r24
     eea:	19 07       	cpc	r17, r25
     eec:	29 f1       	breq	.+74     	; 0xf38 <writeFIFO+0xd8>
     eee:	cd 2d       	mov	r28, r13
     ef0:	d0 e0       	ldi	r29, 0x00	; 0
     ef2:	2f 5f       	subi	r18, 0xFF	; 255
     ef4:	3f 4f       	sbci	r19, 0xFF	; 255
     ef6:	c9 01       	movw	r24, r18
     ef8:	88 0f       	add	r24, r24
     efa:	99 1f       	adc	r25, r25
     efc:	28 0f       	add	r18, r24
     efe:	39 1f       	adc	r19, r25
     f00:	c9 01       	movw	r24, r18
     f02:	88 0f       	add	r24, r24
     f04:	99 1f       	adc	r25, r25
     f06:	ae 01       	movw	r20, r28
     f08:	b7 01       	movw	r22, r14
     f0a:	82 5e       	subi	r24, 0xE2	; 226
     f0c:	98 4f       	sbci	r25, 0xF8	; 248
     f0e:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <memcpy>
     f12:	ae e1       	ldi	r26, 0x1E	; 30
     f14:	b7 e0       	ldi	r27, 0x07	; 7
     f16:	ed 91       	ld	r30, X+
     f18:	fc 91       	ld	r31, X
     f1a:	11 97       	sbiw	r26, 0x01	; 1
     f1c:	ee 0f       	add	r30, r30
     f1e:	ff 1f       	adc	r31, r31
     f20:	ec 5d       	subi	r30, 0xDC	; 220
     f22:	f8 4f       	sbci	r31, 0xF8	; 248
     f24:	d1 83       	std	Z+1, r29	; 0x01
     f26:	c0 83       	st	Z, r28
     f28:	0d 93       	st	X+, r16
     f2a:	1c 93       	st	X, r17
     f2c:	80 e0       	ldi	r24, 0x00	; 0
     f2e:	05 c0       	rjmp	.+10     	; 0xf3a <writeFIFO+0xda>
     f30:	81 e0       	ldi	r24, 0x01	; 1
     f32:	03 c0       	rjmp	.+6      	; 0xf3a <writeFIFO+0xda>
     f34:	81 e0       	ldi	r24, 0x01	; 1
     f36:	01 c0       	rjmp	.+2      	; 0xf3a <writeFIFO+0xda>
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	df 91       	pop	r29
     f3c:	cf 91       	pop	r28
     f3e:	1f 91       	pop	r17
     f40:	0f 91       	pop	r16
     f42:	ff 90       	pop	r15
     f44:	ef 90       	pop	r14
     f46:	df 90       	pop	r13
     f48:	08 95       	ret

00000f4a <readFIFO>:

inline uint8_t readFIFO(void* pData, payloadType* pType,Priority* prio){
     f4a:	0f 93       	push	r16
     f4c:	1f 93       	push	r17
     f4e:	cf 93       	push	r28
     f50:	df 93       	push	r29
     f52:	8a 01       	movw	r16, r20
}
#endif

inline uint8_t readReceiveFIFO(void* pData, payloadType* pType){

        if (receiveFIFO.wptr!=receiveFIFO.rptr){
     f54:	eb ee       	ldi	r30, 0xEB	; 235
     f56:	f6 e0       	ldi	r31, 0x06	; 6
     f58:	22 81       	ldd	r18, Z+2	; 0x02
     f5a:	33 81       	ldd	r19, Z+3	; 0x03
     f5c:	40 81       	ld	r20, Z
     f5e:	51 81       	ldd	r21, Z+1	; 0x01
     f60:	42 17       	cp	r20, r18
     f62:	53 07       	cpc	r21, r19
     f64:	09 f4       	brne	.+2      	; 0xf68 <readFIFO+0x1e>
     f66:	47 c0       	rjmp	.+142    	; 0xff6 <readFIFO+0xac>
            *pType= receiveFIFO.DataType[receiveFIFO.rptr];
     f68:	ef 01       	movw	r28, r30
     f6a:	22 0f       	add	r18, r18
     f6c:	33 1f       	adc	r19, r19
     f6e:	f9 01       	movw	r30, r18
     f70:	e5 51       	subi	r30, 0x15	; 21
     f72:	f9 4f       	sbci	r31, 0xF9	; 249
     f74:	45 89       	ldd	r20, Z+21	; 0x15
     f76:	56 89       	ldd	r21, Z+22	; 0x16
     f78:	fb 01       	movw	r30, r22
     f7a:	40 83       	st	Z, r20

			memcpy(pData,&(receiveFIFO.Buffer[receiveFIFO.rptr]),*pType);
     f7c:	55 27       	eor	r21, r21
     f7e:	6a 81       	ldd	r22, Y+2	; 0x02
     f80:	7b 81       	ldd	r23, Y+3	; 0x03
     f82:	6f 50       	subi	r22, 0x0F	; 15
     f84:	79 4f       	sbci	r23, 0xF9	; 249
     f86:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <memcpy>

           // free(fifo[prio].Buffer[fifo[prio].rptr]);
            //fifo[prio].Buffer[fifo[prio].rptr]=0;
			receiveFIFO.rptr=(receiveFIFO.rptr+1)%receiveFIFO.size;
     f8a:	8a 81       	ldd	r24, Y+2	; 0x02
     f8c:	9b 81       	ldd	r25, Y+3	; 0x03
     f8e:	01 96       	adiw	r24, 0x01	; 1
     f90:	6c 81       	ldd	r22, Y+4	; 0x04
     f92:	7d 81       	ldd	r23, Y+5	; 0x05
     f94:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <__udivmodhi4>
     f98:	9b 83       	std	Y+3, r25	; 0x03
     f9a:	8a 83       	std	Y+2, r24	; 0x02
	return 1;
}

inline uint8_t readFIFO(void* pData, payloadType* pType,Priority* prio){
	if(readReceiveFIFO(pData,pType)==0){
		*prio = prioRECEIVE;
     f9c:	82 e0       	ldi	r24, 0x02	; 2
     f9e:	f8 01       	movw	r30, r16
     fa0:	80 83       	st	Z, r24
		return 0;
     fa2:	80 e0       	ldi	r24, 0x00	; 0
     fa4:	32 c0       	rjmp	.+100    	; 0x100a <readFIFO+0xc0>
}

inline uint8_t readErrorFIFO(void* pData, payloadType* pType){

        if (errorFIFO.wptr!=errorFIFO.rptr){
            *pType= errorFIFO.DataType[errorFIFO.rptr];
     fa6:	ce e1       	ldi	r28, 0x1E	; 30
     fa8:	d7 e0       	ldi	r29, 0x07	; 7
     faa:	22 0f       	add	r18, r18
     fac:	33 1f       	adc	r19, r19
     fae:	f9 01       	movw	r30, r18
     fb0:	ec 5d       	subi	r30, 0xDC	; 220
     fb2:	f8 4f       	sbci	r31, 0xF8	; 248
     fb4:	40 81       	ld	r20, Z
     fb6:	51 81       	ldd	r21, Z+1	; 0x01
     fb8:	fb 01       	movw	r30, r22
     fba:	40 83       	st	Z, r20

			memcpy(pData,&(errorFIFO.Buffer[errorFIFO.rptr]),*pType);
     fbc:	55 27       	eor	r21, r21
     fbe:	2a 81       	ldd	r18, Y+2	; 0x02
     fc0:	3b 81       	ldd	r19, Y+3	; 0x03
     fc2:	2f 5f       	subi	r18, 0xFF	; 255
     fc4:	3f 4f       	sbci	r19, 0xFF	; 255
     fc6:	b9 01       	movw	r22, r18
     fc8:	66 0f       	add	r22, r22
     fca:	77 1f       	adc	r23, r23
     fcc:	62 0f       	add	r22, r18
     fce:	73 1f       	adc	r23, r19
     fd0:	66 0f       	add	r22, r22
     fd2:	77 1f       	adc	r23, r23
     fd4:	62 5e       	subi	r22, 0xE2	; 226
     fd6:	78 4f       	sbci	r23, 0xF8	; 248
     fd8:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <memcpy>

           // free(fifo[prio].Buffer[fifo[prio].rptr]);
            //fifo[prio].Buffer[fifo[prio].rptr]=0;
			errorFIFO.rptr=(errorFIFO.rptr+1)%errorFIFO.size;
     fdc:	8a 81       	ldd	r24, Y+2	; 0x02
     fde:	9b 81       	ldd	r25, Y+3	; 0x03
     fe0:	01 96       	adiw	r24, 0x01	; 1
     fe2:	6c 81       	ldd	r22, Y+4	; 0x04
     fe4:	7d 81       	ldd	r23, Y+5	; 0x05
     fe6:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <__udivmodhi4>
     fea:	9b 83       	std	Y+3, r25	; 0x03
     fec:	8a 83       	std	Y+2, r24	; 0x02
		*prio = prioSTREAM;
		return 0;
	}
#endif
	else if(readErrorFIFO(pData,pType)==0){
		*prio = prioERROR;
     fee:	f8 01       	movw	r30, r16
     ff0:	10 82       	st	Z, r1
		return 0;
     ff2:	80 e0       	ldi	r24, 0x00	; 0
     ff4:	0a c0       	rjmp	.+20     	; 0x100a <readFIFO+0xc0>
	return 1;
}

inline uint8_t readErrorFIFO(void* pData, payloadType* pType){

        if (errorFIFO.wptr!=errorFIFO.rptr){
     ff6:	ee e1       	ldi	r30, 0x1E	; 30
     ff8:	f7 e0       	ldi	r31, 0x07	; 7
     ffa:	22 81       	ldd	r18, Z+2	; 0x02
     ffc:	33 81       	ldd	r19, Z+3	; 0x03
     ffe:	40 81       	ld	r20, Z
    1000:	51 81       	ldd	r21, Z+1	; 0x01
    1002:	42 17       	cp	r20, r18
    1004:	53 07       	cpc	r21, r19
    1006:	79 f6       	brne	.-98     	; 0xfa6 <readFIFO+0x5c>
#endif
	else if(readErrorFIFO(pData,pType)==0){
		*prio = prioERROR;
		return 0;
	}
	return 1;
    1008:	81 e0       	ldi	r24, 0x01	; 1
}
    100a:	df 91       	pop	r29
    100c:	cf 91       	pop	r28
    100e:	1f 91       	pop	r17
    1010:	0f 91       	pop	r16
    1012:	08 95       	ret

00001014 <initialiseReceiveFIFO>:
	streamFIFO.size=SIZE_OF_STREAM_FIFO;
}
#endif

void initialiseReceiveFIFO(){
	receiveFIFO.wptr=0;
    1014:	eb ee       	ldi	r30, 0xEB	; 235
    1016:	f6 e0       	ldi	r31, 0x06	; 6
    1018:	11 82       	std	Z+1, r1	; 0x01
    101a:	10 82       	st	Z, r1
	receiveFIFO.rptr=0;
    101c:	13 82       	std	Z+3, r1	; 0x03
    101e:	12 82       	std	Z+2, r1	; 0x02
	receiveFIFO.size=SIZE_OF_RECEIVE_FIFO;
    1020:	8f e0       	ldi	r24, 0x0F	; 15
    1022:	90 e0       	ldi	r25, 0x00	; 0
    1024:	95 83       	std	Z+5, r25	; 0x05
    1026:	84 83       	std	Z+4, r24	; 0x04
    1028:	08 95       	ret

0000102a <initialiseErrorFIFO>:
}

void initialiseErrorFIFO(){
	errorFIFO.wptr=0;
    102a:	ee e1       	ldi	r30, 0x1E	; 30
    102c:	f7 e0       	ldi	r31, 0x07	; 7
    102e:	11 82       	std	Z+1, r1	; 0x01
    1030:	10 82       	st	Z, r1
	errorFIFO.rptr=0;
    1032:	13 82       	std	Z+3, r1	; 0x03
    1034:	12 82       	std	Z+2, r1	; 0x02
	errorFIFO.size=SIZE_OF_ERROR_FIFO;
    1036:	15 82       	std	Z+5, r1	; 0x05
    1038:	14 82       	std	Z+4, r1	; 0x04
    103a:	08 95       	ret

0000103c <initialiseFIFO>:

void initialiseFIFO(){
#if SEND_WITHOUT_SNIFF_TASK == 0
initialiseStreamFIFO();
#endif
initialiseReceiveFIFO();
    103c:	0e 94 0a 08 	call	0x1014	; 0x1014 <initialiseReceiveFIFO>
initialiseErrorFIFO();
    1040:	0e 94 15 08 	call	0x102a	; 0x102a <initialiseErrorFIFO>
    1044:	08 95       	ret

00001046 <initialiseTraceSniffer>:
typedef void* TaskHandle_t;
static TaskHandle_t sniffTaskHandle = NULL;
extern long xTaskCreate();
extern void vTaskSuspend(TaskHandle_t xTaskToSuspend);

uint8_t initialiseTraceSniffer() {
    1046:	ef 92       	push	r14
    1048:	ff 92       	push	r15
    104a:	0f 93       	push	r16
    104c:	1f 93       	push	r17
	initialiseFIFO();
    104e:	0e 94 1e 08 	call	0x103c	; 0x103c <initialiseFIFO>
	initialiseObjectList();
    1052:	0e 94 4b 08 	call	0x1096	; 0x1096 <initialiseObjectList>
	enableReceiveInterrupt();
	memset(sniffIDFilter, 0xff, sizeof(uint8_t) * SIZE_OF_FILTER);
    1056:	4d e0       	ldi	r20, 0x0D	; 13
    1058:	50 e0       	ldi	r21, 0x00	; 0
    105a:	6f ef       	ldi	r22, 0xFF	; 255
    105c:	70 e0       	ldi	r23, 0x00	; 0
    105e:	88 e9       	ldi	r24, 0x98	; 152
    1060:	95 e0       	ldi	r25, 0x05	; 5
    1062:	0e 94 77 0b 	call	0x16ee	; 0x16ee <memset>
#if WAIT_FOR_SNIFFER_START
	uint8_t* data;
	payloadType* type;
	while(readReceiveFIFO(data,type)!=0);
#endif
	xTaskCreate(sniffTask, "sniffTask", STACK_SIZE_OF_SNIFF_TASK, NULL,
    1066:	0f 2e       	mov	r0, r31
    1068:	f6 e9       	ldi	r31, 0x96	; 150
    106a:	ef 2e       	mov	r14, r31
    106c:	f5 e0       	ldi	r31, 0x05	; 5
    106e:	ff 2e       	mov	r15, r31
    1070:	f0 2d       	mov	r31, r0
    1072:	01 e0       	ldi	r16, 0x01	; 1
    1074:	10 e0       	ldi	r17, 0x00	; 0
    1076:	20 e0       	ldi	r18, 0x00	; 0
    1078:	30 e0       	ldi	r19, 0x00	; 0
    107a:	45 e5       	ldi	r20, 0x55	; 85
    107c:	50 e0       	ldi	r21, 0x00	; 0
    107e:	62 e1       	ldi	r22, 0x12	; 18
    1080:	71 e0       	ldi	r23, 0x01	; 1
    1082:	8b e8       	ldi	r24, 0x8B	; 139
    1084:	9a e0       	ldi	r25, 0x0A	; 10
    1086:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <xTaskCreate>
	PRIORITY_OF_SNIFF_TASK, &sniffTaskHandle);
	//Create Task
	return 0;
}
    108a:	80 e0       	ldi	r24, 0x00	; 0
    108c:	1f 91       	pop	r17
    108e:	0f 91       	pop	r16
    1090:	ff 90       	pop	r15
    1092:	ef 90       	pop	r14
    1094:	08 95       	ret

00001096 <initialiseObjectList>:
	if (0xff == objectCounter[objectType]) {
		//TODO: error -> Counter voll
		return 0x0;
	}
	return objectCounter[objectType]++;
}
    1096:	cf 93       	push	r28
    1098:	df 93       	push	r29
    109a:	a4 e2       	ldi	r26, 0x24	; 36
    109c:	b7 e0       	ldi	r27, 0x07	; 7
    109e:	e8 ea       	ldi	r30, 0xA8	; 168
    10a0:	f5 e0       	ldi	r31, 0x05	; 5
    10a2:	80 e0       	ldi	r24, 0x00	; 0
    10a4:	21 e0       	ldi	r18, 0x01	; 1
    10a6:	97 e9       	ldi	r25, 0x97	; 151
    10a8:	2d 93       	st	X+, r18
    10aa:	ef 01       	movw	r28, r30
    10ac:	21 97       	sbiw	r28, 0x01	; 1
    10ae:	88 83       	st	Y, r24
    10b0:	21 97       	sbiw	r28, 0x01	; 1
    10b2:	98 83       	st	Y, r25
    10b4:	10 82       	st	Z, r1
    10b6:	8f 5f       	subi	r24, 0xFF	; 255
    10b8:	f6 96       	adiw	r30, 0x36	; 54
    10ba:	86 30       	cpi	r24, 0x06	; 6
    10bc:	a9 f7       	brne	.-22     	; 0x10a8 <initialiseObjectList+0x12>
    10be:	df 91       	pop	r29
    10c0:	cf 91       	pop	r28
    10c2:	08 95       	ret

000010c4 <updateObjectList>:

inline unsigned int updateObjectList(ObjectType objectType,
		char* objectNameExtern) { // count is 1 based while the array place is 0 based -> count-1, the 0 in count is used to determine a deleted object
    10c4:	cf 92       	push	r12
    10c6:	df 92       	push	r13
    10c8:	ef 92       	push	r14
    10ca:	ff 92       	push	r15
    10cc:	0f 93       	push	r16
    10ce:	1f 93       	push	r17
    10d0:	cf 93       	push	r28
    10d2:	df 93       	push	r29
	size_t len;
	size_t lengthObjectName = strlen(objectNameExtern);
    10d4:	fb 01       	movw	r30, r22
    10d6:	01 90       	ld	r0, Z+
    10d8:	00 20       	and	r0, r0
    10da:	e9 f7       	brne	.-6      	; 0x10d6 <updateObjectList+0x12>
    10dc:	31 97       	sbiw	r30, 0x01	; 1
    10de:	7f 01       	movw	r14, r30
    10e0:	e6 1a       	sub	r14, r22
    10e2:	f7 0a       	sbc	r15, r23
	}
}

inline unsigned int increaseObjectCounter(ObjectType objectType) {

	if (0xff == objectCounter[objectType]) {
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	fc 01       	movw	r30, r24
    10e8:	ec 5d       	subi	r30, 0xDC	; 220
    10ea:	f8 4f       	sbci	r31, 0xF8	; 248
    10ec:	40 81       	ld	r20, Z
    10ee:	4f 3f       	cpi	r20, 0xFF	; 255
    10f0:	41 f0       	breq	.+16     	; 0x1102 <updateObjectList+0x3e>
		//TODO: error -> Counter voll
		return 0x0;
	}
	return objectCounter[objectType]++;
    10f2:	fc 01       	movw	r30, r24
    10f4:	ec 5d       	subi	r30, 0xDC	; 220
    10f6:	f8 4f       	sbci	r31, 0xF8	; 248
    10f8:	21 e0       	ldi	r18, 0x01	; 1
    10fa:	24 0f       	add	r18, r20
    10fc:	20 83       	st	Z, r18
    10fe:	50 e0       	ldi	r21, 0x00	; 0
    1100:	02 c0       	rjmp	.+4      	; 0x1106 <updateObjectList+0x42>

inline unsigned int increaseObjectCounter(ObjectType objectType) {

	if (0xff == objectCounter[objectType]) {
		//TODO: error -> Counter voll
		return 0x0;
    1102:	40 e0       	ldi	r20, 0x00	; 0
    1104:	50 e0       	ldi	r21, 0x00	; 0
    1106:	8a 01       	movw	r16, r20
    1108:	11 27       	eor	r17, r17
		char* objectNameExtern) { // count is 1 based while the array place is 0 based -> count-1, the 0 in count is used to determine a deleted object
	size_t len;
	size_t lengthObjectName = strlen(objectNameExtern);
	uint8_t count = increaseObjectCounter(objectType);

	objectList[objectType].objectArray[count - 1].objectNumber = count;
    110a:	98 01       	movw	r18, r16
    110c:	21 50       	subi	r18, 0x01	; 1
    110e:	31 09       	sbc	r19, r1
    1110:	d9 01       	movw	r26, r18
    1112:	aa 0f       	add	r26, r26
    1114:	bb 1f       	adc	r27, r27
    1116:	f9 01       	movw	r30, r18
    1118:	ee 0f       	add	r30, r30
    111a:	ff 1f       	adc	r31, r31
    111c:	ee 0f       	add	r30, r30
    111e:	ff 1f       	adc	r31, r31
    1120:	ee 0f       	add	r30, r30
    1122:	ff 1f       	adc	r31, r31
    1124:	ea 0f       	add	r30, r26
    1126:	fb 1f       	adc	r31, r27
    1128:	56 e3       	ldi	r21, 0x36	; 54
    112a:	58 9f       	mul	r21, r24
    112c:	d0 01       	movw	r26, r0
    112e:	59 9f       	mul	r21, r25
    1130:	b0 0d       	add	r27, r0
    1132:	11 24       	eor	r1, r1
    1134:	ea 0f       	add	r30, r26
    1136:	fb 1f       	adc	r31, r27
    1138:	eb 55       	subi	r30, 0x5B	; 91
    113a:	fa 4f       	sbci	r31, 0xFA	; 250

inline unsigned int updateObjectList(ObjectType objectType,
		char* objectNameExtern) { // count is 1 based while the array place is 0 based -> count-1, the 0 in count is used to determine a deleted object
	size_t len;
	size_t lengthObjectName = strlen(objectNameExtern);
	uint8_t count = increaseObjectCounter(objectType);
    113c:	44 83       	std	Z+4, r20	; 0x04

	objectList[objectType].objectArray[count - 1].objectNumber = count;

	if ((MAX_LENGTH_OF_OBJECTNAME - 1) < lengthObjectName) {
    113e:	48 e0       	ldi	r20, 0x08	; 8
    1140:	e4 16       	cp	r14, r20
    1142:	f1 04       	cpc	r15, r1
    1144:	20 f0       	brcs	.+8      	; 0x114e <updateObjectList+0x8a>
		len = MAX_LENGTH_OF_OBJECTNAME;
    1146:	68 94       	set
    1148:	ee 24       	eor	r14, r14
    114a:	e3 f8       	bld	r14, 3
    114c:	f1 2c       	mov	r15, r1
	} else {
		len = lengthObjectName;
	}

	memcpy(objectList[objectType].objectArray[count - 1].objectName,
    114e:	e9 01       	movw	r28, r18
    1150:	cc 0f       	add	r28, r28
    1152:	dd 1f       	adc	r29, r29
    1154:	22 0f       	add	r18, r18
    1156:	33 1f       	adc	r19, r19
    1158:	22 0f       	add	r18, r18
    115a:	33 1f       	adc	r19, r19
    115c:	22 0f       	add	r18, r18
    115e:	33 1f       	adc	r19, r19
    1160:	c2 0f       	add	r28, r18
    1162:	d3 1f       	adc	r29, r19
    1164:	26 e3       	ldi	r18, 0x36	; 54
    1166:	28 9f       	mul	r18, r24
    1168:	60 01       	movw	r12, r0
    116a:	29 9f       	mul	r18, r25
    116c:	d0 0c       	add	r13, r0
    116e:	11 24       	eor	r1, r1
    1170:	cc 0d       	add	r28, r12
    1172:	dd 1d       	adc	r29, r13
    1174:	a7 01       	movw	r20, r14
    1176:	ce 01       	movw	r24, r28
    1178:	85 55       	subi	r24, 0x55	; 85
    117a:	9a 4f       	sbci	r25, 0xFA	; 250
    117c:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <memcpy>
			objectNameExtern, len);
	objectList[objectType].objectArray[count - 1].objectName[len] = '\0';
    1180:	cb 55       	subi	r28, 0x5B	; 91
    1182:	da 4f       	sbci	r29, 0xFA	; 250
    1184:	fe 01       	movw	r30, r28
    1186:	ee 0d       	add	r30, r14
    1188:	ff 1d       	adc	r31, r15
    118a:	16 82       	std	Z+6, r1	; 0x06
	objectList[objectType].objectArray[count - 1].lenObjectName = len;
    118c:	ed 82       	std	Y+5, r14	; 0x05

	objectList[objectType].objectHeader.length++;
    118e:	f6 01       	movw	r30, r12
    1190:	eb 55       	subi	r30, 0x5B	; 91
    1192:	fa 4f       	sbci	r31, 0xFA	; 250
    1194:	83 81       	ldd	r24, Z+3	; 0x03
    1196:	8f 5f       	subi	r24, 0xFF	; 255
    1198:	83 83       	std	Z+3, r24	; 0x03

	return count;
}
    119a:	c8 01       	movw	r24, r16
    119c:	df 91       	pop	r29
    119e:	cf 91       	pop	r28
    11a0:	1f 91       	pop	r17
    11a2:	0f 91       	pop	r16
    11a4:	ff 90       	pop	r15
    11a6:	ef 90       	pop	r14
    11a8:	df 90       	pop	r13
    11aa:	cf 90       	pop	r12
    11ac:	08 95       	ret

000011ae <sendObjectList>:

void sendObjectList(uint8_t *packetCounter) {
    11ae:	2f 92       	push	r2
    11b0:	3f 92       	push	r3
    11b2:	4f 92       	push	r4
    11b4:	5f 92       	push	r5
    11b6:	6f 92       	push	r6
    11b8:	7f 92       	push	r7
    11ba:	8f 92       	push	r8
    11bc:	9f 92       	push	r9
    11be:	af 92       	push	r10
    11c0:	bf 92       	push	r11
    11c2:	cf 92       	push	r12
    11c4:	df 92       	push	r13
    11c6:	ef 92       	push	r14
    11c8:	ff 92       	push	r15
    11ca:	0f 93       	push	r16
    11cc:	1f 93       	push	r17
    11ce:	cf 93       	push	r28
    11d0:	df 93       	push	r29
    11d2:	3c 01       	movw	r6, r24
    11d4:	0f 2e       	mov	r0, r31
    11d6:	fb ea       	ldi	r31, 0xAB	; 171
    11d8:	af 2e       	mov	r10, r31
    11da:	f5 e0       	ldi	r31, 0x05	; 5
    11dc:	bf 2e       	mov	r11, r31
    11de:	f0 2d       	mov	r31, r0
    11e0:	0f 2e       	mov	r0, r31
    11e2:	ff ee       	ldi	r31, 0xEF	; 239
    11e4:	4f 2e       	mov	r4, r31
    11e6:	f6 e0       	ldi	r31, 0x06	; 6
    11e8:	5f 2e       	mov	r5, r31
    11ea:	f0 2d       	mov	r31, r0
		sendByteOverInterface(objectList[i].objectHeader.informationID);
		sendByteOverInterface(objectList[i].objectHeader.objectType);
		lengthList = objectList[i].objectHeader.length;
		sendByteOverInterface(lengthList);

		for (int j = 0; j < lengthList; ++j) {
    11ec:	31 2c       	mov	r3, r1
	uint8_t lengthObjectName;
	char* currObjectName;

	for (int i = 0; i < NUMBER_OF_OBJECTTYPES; ++i) {

		SEND_PREAMBLE
    11ee:	8d ef       	ldi	r24, 0xFD	; 253
    11f0:	90 e0       	ldi	r25, 0x00	; 0
    11f2:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    11f6:	8e ef       	ldi	r24, 0xFE	; 254
    11f8:	90 e0       	ldi	r25, 0x00	; 0
    11fa:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    11fe:	8f ef       	ldi	r24, 0xFF	; 255
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		;
		objectList[i].objectHeader.packetID = (*packetCounter)++;
    1206:	f3 01       	movw	r30, r6
    1208:	80 81       	ld	r24, Z
    120a:	91 e0       	ldi	r25, 0x01	; 1
    120c:	98 0f       	add	r25, r24
    120e:	90 83       	st	Z, r25
    1210:	f5 01       	movw	r30, r10
    1212:	36 97       	sbiw	r30, 0x06	; 6
    1214:	80 83       	st	Z, r24
		sendByteOverInterface(objectList[i].objectHeader.packetID);
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    121c:	f5 01       	movw	r30, r10
    121e:	35 97       	sbiw	r30, 0x05	; 5
		sendByteOverInterface(objectList[i].objectHeader.informationID);
    1220:	80 81       	ld	r24, Z
    1222:	90 e0       	ldi	r25, 0x00	; 0
    1224:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    1228:	f5 01       	movw	r30, r10
    122a:	34 97       	sbiw	r30, 0x04	; 4
		sendByteOverInterface(objectList[i].objectHeader.objectType);
    122c:	80 81       	ld	r24, Z
    122e:	90 e0       	ldi	r25, 0x00	; 0
    1230:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    1234:	f5 01       	movw	r30, r10
    1236:	33 97       	sbiw	r30, 0x03	; 3
		lengthList = objectList[i].objectHeader.length;
		sendByteOverInterface(lengthList);
    1238:	80 80       	ld	r8, Z
    123a:	91 2c       	mov	r9, r1
    123c:	c4 01       	movw	r24, r8
    123e:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>

		for (int j = 0; j < lengthList; ++j) {
    1242:	18 14       	cp	r1, r8
    1244:	19 04       	cpc	r1, r9
    1246:	44 f5       	brge	.+80     	; 0x1298 <sendObjectList+0xea>
    1248:	75 01       	movw	r14, r10
    124a:	c3 2c       	mov	r12, r3
    124c:	d1 2c       	mov	r13, r1
    124e:	e7 01       	movw	r28, r14
    1250:	f7 01       	movw	r30, r14
    1252:	32 97       	sbiw	r30, 0x02	; 2
			sendByteOverInterface(objectList[i].objectArray[j].objectNumber);
    1254:	80 81       	ld	r24, Z
    1256:	90 e0       	ldi	r25, 0x00	; 0
    1258:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    125c:	f7 01       	movw	r30, r14
    125e:	31 97       	sbiw	r30, 0x01	; 1
			lengthObjectName = objectList[i].objectArray[j].lenObjectName;
    1260:	20 80       	ld	r2, Z
			sendByteOverInterface(lengthObjectName);
    1262:	02 2d       	mov	r16, r2
    1264:	10 e0       	ldi	r17, 0x00	; 0
    1266:	c8 01       	movw	r24, r16
    1268:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
			currObjectName = objectList[i].objectArray[j].objectName;
			for (int i = 0; i < lengthObjectName; ++i) {
    126c:	10 16       	cp	r1, r16
    126e:	11 06       	cpc	r1, r17
    1270:	54 f4       	brge	.+20     	; 0x1286 <sendObjectList+0xd8>
    1272:	87 01       	movw	r16, r14
    1274:	02 0d       	add	r16, r2
    1276:	11 1d       	adc	r17, r1
				sendByteOverInterface(*currObjectName);
    1278:	89 91       	ld	r24, Y+
    127a:	90 e0       	ldi	r25, 0x00	; 0
    127c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		for (int j = 0; j < lengthList; ++j) {
			sendByteOverInterface(objectList[i].objectArray[j].objectNumber);
			lengthObjectName = objectList[i].objectArray[j].lenObjectName;
			sendByteOverInterface(lengthObjectName);
			currObjectName = objectList[i].objectArray[j].objectName;
			for (int i = 0; i < lengthObjectName; ++i) {
    1280:	c0 17       	cp	r28, r16
    1282:	d1 07       	cpc	r29, r17
    1284:	c9 f7       	brne	.-14     	; 0x1278 <sendObjectList+0xca>
		sendByteOverInterface(objectList[i].objectHeader.informationID);
		sendByteOverInterface(objectList[i].objectHeader.objectType);
		lengthList = objectList[i].objectHeader.length;
		sendByteOverInterface(lengthList);

		for (int j = 0; j < lengthList; ++j) {
    1286:	ff ef       	ldi	r31, 0xFF	; 255
    1288:	cf 1a       	sub	r12, r31
    128a:	df 0a       	sbc	r13, r31
    128c:	8a e0       	ldi	r24, 0x0A	; 10
    128e:	e8 0e       	add	r14, r24
    1290:	f1 1c       	adc	r15, r1
    1292:	8c 14       	cp	r8, r12
    1294:	9d 04       	cpc	r9, r13
    1296:	d9 f6       	brne	.-74     	; 0x124e <sendObjectList+0xa0>
				sendByteOverInterface(*currObjectName);
				currObjectName++;
			}

		}
		SEND_PREAMBLE
    1298:	8d ef       	ldi	r24, 0xFD	; 253
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    12a0:	8e ef       	ldi	r24, 0xFE	; 254
    12a2:	90 e0       	ldi	r25, 0x00	; 0
    12a4:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    12a8:	8f ef       	ldi	r24, 0xFF	; 255
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    12b0:	e6 e3       	ldi	r30, 0x36	; 54
    12b2:	ae 0e       	add	r10, r30
    12b4:	b1 1c       	adc	r11, r1
void sendObjectList(uint8_t *packetCounter) {
	uint8_t lengthList = 0;
	uint8_t lengthObjectName;
	char* currObjectName;

	for (int i = 0; i < NUMBER_OF_OBJECTTYPES; ++i) {
    12b6:	a4 14       	cp	r10, r4
    12b8:	b5 04       	cpc	r11, r5
    12ba:	09 f0       	breq	.+2      	; 0x12be <sendObjectList+0x110>
    12bc:	98 cf       	rjmp	.-208    	; 0x11ee <sendObjectList+0x40>

		}
		SEND_PREAMBLE
		;
	}
}
    12be:	df 91       	pop	r29
    12c0:	cf 91       	pop	r28
    12c2:	1f 91       	pop	r17
    12c4:	0f 91       	pop	r16
    12c6:	ff 90       	pop	r15
    12c8:	ef 90       	pop	r14
    12ca:	df 90       	pop	r13
    12cc:	cf 90       	pop	r12
    12ce:	bf 90       	pop	r11
    12d0:	af 90       	pop	r10
    12d2:	9f 90       	pop	r9
    12d4:	8f 90       	pop	r8
    12d6:	7f 90       	pop	r7
    12d8:	6f 90       	pop	r6
    12da:	5f 90       	pop	r5
    12dc:	4f 90       	pop	r4
    12de:	3f 90       	pop	r3
    12e0:	2f 90       	pop	r2
    12e2:	08 95       	ret

000012e4 <applyInformationIDFilter>:

//Modulo Alternative      i & (m-1)

uint8_t applyInformationIDFilter(uint8_t informationID) {
	uint8_t arrayPlace;
	arrayPlace = informationID >> 3;
    12e4:	e8 2f       	mov	r30, r24
    12e6:	e6 95       	lsr	r30
    12e8:	e6 95       	lsr	r30
    12ea:	e6 95       	lsr	r30
	if (sniffIDFilter[arrayPlace] & (1 << (informationID & (7)))) {
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	e8 56       	subi	r30, 0x68	; 104
    12f0:	fa 4f       	sbci	r31, 0xFA	; 250
    12f2:	20 81       	ld	r18, Z
    12f4:	30 e0       	ldi	r19, 0x00	; 0
    12f6:	87 70       	andi	r24, 0x07	; 7
    12f8:	a9 01       	movw	r20, r18
    12fa:	02 c0       	rjmp	.+4      	; 0x1300 <applyInformationIDFilter+0x1c>
    12fc:	55 95       	asr	r21
    12fe:	47 95       	ror	r20
    1300:	8a 95       	dec	r24
    1302:	e2 f7       	brpl	.-8      	; 0x12fc <applyInformationIDFilter+0x18>
    1304:	ca 01       	movw	r24, r20
		return 1;
	}
	return 0;
}
    1306:	81 70       	andi	r24, 0x01	; 1
    1308:	08 95       	ret

0000130a <packPayload0>:
#endif
//Functions

//Modulo Alternative      i & (m-1)

inline void packPayload0(InformationID informationID) {
    130a:	cf 93       	push	r28
    130c:	c8 2f       	mov	r28, r24
#if SEND_WITHOUT_SNIFF_TASK
	if (applyInformationIDFilter(informationID)) {
    130e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <applyInformationIDFilter>
    1312:	88 23       	and	r24, r24
    1314:	79 f1       	breq	.+94     	; 0x1374 <packPayload0+0x6a>
		SEND_PREAMBLE
    1316:	8d ef       	ldi	r24, 0xFD	; 253
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    131e:	8e ef       	ldi	r24, 0xFE	; 254
    1320:	90 e0       	ldi	r25, 0x00	; 0
    1322:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    1326:	8f ef       	ldi	r24, 0xFF	; 255
    1328:	90 e0       	ldi	r25, 0x00	; 0
    132a:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		;
		sendByteOverInterface(packetCounter++);
    132e:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <packetCounter>
    1332:	91 e0       	ldi	r25, 0x01	; 1
    1334:	98 0f       	add	r25, r24
    1336:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <packetCounter>
    133a:	90 e0       	ldi	r25, 0x00	; 0
    133c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(informationID);
    1340:	8c 2f       	mov	r24, r28
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(xTaskGetTickCount() >> 8);
    1348:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
    134c:	67 2f       	mov	r22, r23
    134e:	78 2f       	mov	r23, r24
    1350:	89 2f       	mov	r24, r25
    1352:	99 27       	eor	r25, r25
    1354:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(xTaskGetTickCount());
    1358:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
    135c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(readOutSysTimerHigh());
    1360:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    1364:	90 e0       	ldi	r25, 0x00	; 0
    1366:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(readOutSysTimerLow());
    136a:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
	payload.payloadHead.timerByteLow = readOutSysTimerLow();
	if(writeFIFO(&payload,PAYLOAD_0,prioSTREAM)!=0) {
		packPayloadError(ID_ERROR_STREAM_FIFO_FULL);
	}
#endif
}
    1374:	cf 91       	pop	r28
    1376:	08 95       	ret

00001378 <packPayload1>:

inline void packPayload1(InformationID informationID, uint8_t data1) {
    1378:	cf 93       	push	r28
    137a:	df 93       	push	r29
    137c:	c8 2f       	mov	r28, r24
    137e:	d6 2f       	mov	r29, r22
#if SEND_WITHOUT_SNIFF_TASK

	if (applyInformationIDFilter(informationID)) {
    1380:	0e 94 72 09 	call	0x12e4	; 0x12e4 <applyInformationIDFilter>
    1384:	88 23       	and	r24, r24
    1386:	99 f1       	breq	.+102    	; 0x13ee <packPayload1+0x76>
		SEND_PREAMBLE
    1388:	8d ef       	ldi	r24, 0xFD	; 253
    138a:	90 e0       	ldi	r25, 0x00	; 0
    138c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    1390:	8e ef       	ldi	r24, 0xFE	; 254
    1392:	90 e0       	ldi	r25, 0x00	; 0
    1394:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    1398:	8f ef       	ldi	r24, 0xFF	; 255
    139a:	90 e0       	ldi	r25, 0x00	; 0
    139c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(packetCounter++);
    13a0:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <packetCounter>
    13a4:	91 e0       	ldi	r25, 0x01	; 1
    13a6:	98 0f       	add	r25, r24
    13a8:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <packetCounter>
    13ac:	90 e0       	ldi	r25, 0x00	; 0
    13ae:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(informationID);
    13b2:	8c 2f       	mov	r24, r28
    13b4:	90 e0       	ldi	r25, 0x00	; 0
    13b6:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(xTaskGetTickCount() >> 8);
    13ba:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
    13be:	67 2f       	mov	r22, r23
    13c0:	78 2f       	mov	r23, r24
    13c2:	89 2f       	mov	r24, r25
    13c4:	99 27       	eor	r25, r25
    13c6:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(xTaskGetTickCount());
    13ca:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
    13ce:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(readOutSysTimerHigh());
    13d2:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(readOutSysTimerLow());
    13dc:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(data1);
    13e6:	8d 2f       	mov	r24, r29
    13e8:	90 e0       	ldi	r25, 0x00	; 0
    13ea:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
	payload.data1 = data1;
	if(writeFIFO(&payload,PAYLOAD_1,prioSTREAM)!=0) {
		packPayloadError(ID_ERROR_STREAM_FIFO_FULL);
	}
#endif
}
    13ee:	df 91       	pop	r29
    13f0:	cf 91       	pop	r28
    13f2:	08 95       	ret

000013f4 <packPayload2>:

inline void packPayload2(InformationID informationID, uint8_t data1,
		uint8_t data2) {
    13f4:	1f 93       	push	r17
    13f6:	cf 93       	push	r28
    13f8:	df 93       	push	r29
    13fa:	c8 2f       	mov	r28, r24
    13fc:	16 2f       	mov	r17, r22
    13fe:	d4 2f       	mov	r29, r20
#if SEND_WITHOUT_SNIFF_TASK //TODO: Structs werden nicht gebraucht
	if (applyInformationIDFilter(informationID)) {
    1400:	0e 94 72 09 	call	0x12e4	; 0x12e4 <applyInformationIDFilter>
    1404:	88 23       	and	r24, r24
    1406:	b9 f1       	breq	.+110    	; 0x1476 <packPayload2+0x82>
		SEND_PREAMBLE
    1408:	8d ef       	ldi	r24, 0xFD	; 253
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    1410:	8e ef       	ldi	r24, 0xFE	; 254
    1412:	90 e0       	ldi	r25, 0x00	; 0
    1414:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    1418:	8f ef       	ldi	r24, 0xFF	; 255
    141a:	90 e0       	ldi	r25, 0x00	; 0
    141c:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(packetCounter++);
    1420:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <packetCounter>
    1424:	91 e0       	ldi	r25, 0x01	; 1
    1426:	98 0f       	add	r25, r24
    1428:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <packetCounter>
    142c:	90 e0       	ldi	r25, 0x00	; 0
    142e:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(informationID);
    1432:	8c 2f       	mov	r24, r28
    1434:	90 e0       	ldi	r25, 0x00	; 0
    1436:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(xTaskGetTickCount() >> 8);
    143a:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
    143e:	67 2f       	mov	r22, r23
    1440:	78 2f       	mov	r23, r24
    1442:	89 2f       	mov	r24, r25
    1444:	99 27       	eor	r25, r25
    1446:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(xTaskGetTickCount());
    144a:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
    144e:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(readOutSysTimerHigh());
    1452:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    1456:	90 e0       	ldi	r25, 0x00	; 0
    1458:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(readOutSysTimerLow());
    145c:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
    1460:	90 e0       	ldi	r25, 0x00	; 0
    1462:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(data1);
    1466:	81 2f       	mov	r24, r17
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(data2);
    146e:	8d 2f       	mov	r24, r29
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
	payload.data2 = data2;
	if(writeFIFO(&payload,PAYLOAD_2,prioSTREAM)!=0) {
		packPayloadError(ID_ERROR_STREAM_FIFO_FULL);
	}
#endif
}
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	1f 91       	pop	r17
    147c:	08 95       	ret

0000147e <packPayload3>:

inline void packPayload3(InformationID informationID, uint8_t data1,
		uint8_t data2, uint8_t data3) {
    147e:	0f 93       	push	r16
    1480:	1f 93       	push	r17
    1482:	cf 93       	push	r28
    1484:	df 93       	push	r29
    1486:	c8 2f       	mov	r28, r24
    1488:	06 2f       	mov	r16, r22
    148a:	14 2f       	mov	r17, r20
    148c:	d2 2f       	mov	r29, r18
#if SEND_WITHOUT_SNIFF_TASK
	if (applyInformationIDFilter(informationID)) {
    148e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <applyInformationIDFilter>
    1492:	88 23       	and	r24, r24
    1494:	d9 f1       	breq	.+118    	; 0x150c <packPayload3+0x8e>
		SEND_PREAMBLE
    1496:	8d ef       	ldi	r24, 0xFD	; 253
    1498:	90 e0       	ldi	r25, 0x00	; 0
    149a:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    149e:	8e ef       	ldi	r24, 0xFE	; 254
    14a0:	90 e0       	ldi	r25, 0x00	; 0
    14a2:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    14a6:	8f ef       	ldi	r24, 0xFF	; 255
    14a8:	90 e0       	ldi	r25, 0x00	; 0
    14aa:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(packetCounter++);
    14ae:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <packetCounter>
    14b2:	91 e0       	ldi	r25, 0x01	; 1
    14b4:	98 0f       	add	r25, r24
    14b6:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <packetCounter>
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(informationID);
    14c0:	8c 2f       	mov	r24, r28
    14c2:	90 e0       	ldi	r25, 0x00	; 0
    14c4:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(xTaskGetTickCount() >> 8);
    14c8:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
    14cc:	67 2f       	mov	r22, r23
    14ce:	78 2f       	mov	r23, r24
    14d0:	89 2f       	mov	r24, r25
    14d2:	99 27       	eor	r25, r25
    14d4:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(xTaskGetTickCount());
    14d8:	0e 94 45 05 	call	0xa8a	; 0xa8a <xTaskGetTickCount>
    14dc:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(readOutSysTimerHigh());
    14e0:	80 91 85 00 	lds	r24, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(readOutSysTimerLow());
    14ea:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
    14ee:	90 e0       	ldi	r25, 0x00	; 0
    14f0:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(data1);
    14f4:	80 2f       	mov	r24, r16
    14f6:	90 e0       	ldi	r25, 0x00	; 0
    14f8:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(data2);
    14fc:	81 2f       	mov	r24, r17
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
		sendByteOverInterface(data3);
    1504:	8d 2f       	mov	r24, r29
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>

	if(writeFIFO(&payload,PAYLOAD_3,prioSTREAM)!=0) {
		packPayloadError(ID_ERROR_STREAM_FIFO_FULL);
	}
#endif
}
    150c:	df 91       	pop	r29
    150e:	cf 91       	pop	r28
    1510:	1f 91       	pop	r17
    1512:	0f 91       	pop	r16
    1514:	08 95       	ret

00001516 <sniffTask>:
#include <sniffFIFO.h>
#include <sniffPort.h>

extern void vTaskDelay();

void sniffTask() {
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
    151a:	cd b7       	in	r28, 0x3d	; 61
    151c:	de b7       	in	r29, 0x3e	; 62
    151e:	6d 97       	sbiw	r28, 0x1d	; 29
    1520:	0f b6       	in	r0, 0x3f	; 63
    1522:	f8 94       	cli
    1524:	de bf       	out	0x3e, r29	; 62
    1526:	0f be       	out	0x3f, r0	; 63
    1528:	cd bf       	out	0x3d, r28	; 61
	PayloadError *currPayloadError;
	uint8_t* currPayloadReceived;

	payloadType currPayloadType;
	Priority currReadPrio;
	uint8_t packetCounter = 0;
    152a:	1c 86       	std	Y+12, r1	; 0x0c
	ReceiverState receiverState = NORMAL;

	//Miscellanous Variables
	unsigned char const* ptr; // ptr for iterating over payload struct
	unsigned char currSniffFilterByte = 0;
    152c:	81 2c       	mov	r8, r1
	uint8_t* currPayloadReceived;

	payloadType currPayloadType;
	Priority currReadPrio;
	uint8_t packetCounter = 0;
	ReceiverState receiverState = NORMAL;
    152e:	91 2c       	mov	r9, r1
					currPayload->payloadHead.packetID = packetCounter++;

					SEND_PREAMBLE
					;
					ptr = (unsigned char*) currPayload;
					for (size_t pos = 0; pos < currPayloadType; pos++) {
    1530:	71 2c       	mov	r7, r1
    1532:	61 2c       	mov	r6, r1
    1534:	ce 01       	movw	r24, r28
    1536:	0d 96       	adiw	r24, 0x0d	; 13
    1538:	9b 8f       	std	Y+27, r25	; 0x1b
    153a:	8a 8f       	std	Y+26, r24	; 0x1a
    153c:	0f 2e       	mov	r0, r31
    153e:	f8 e9       	ldi	r31, 0x98	; 152
    1540:	2f 2e       	mov	r2, r31
    1542:	f5 e0       	ldi	r31, 0x05	; 5
    1544:	3f 2e       	mov	r3, r31
    1546:	f0 2d       	mov	r31, r0
    1548:	0f 2e       	mov	r0, r31
    154a:	f5 ea       	ldi	r31, 0xA5	; 165
    154c:	af 2e       	mov	r10, r31
    154e:	f5 e0       	ldi	r31, 0x05	; 5
    1550:	bf 2e       	mov	r11, r31
    1552:	f0 2d       	mov	r31, r0
				uint8_t copySniffIDFilter[SIZE_OF_FILTER];
				#endif

				switch (receiverState) {
				case NORMAL: {
					switch (*currPayloadReceived) {
    1554:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1556:	9c 8f       	std	Y+28, r25	; 0x1c
    1558:	eb 8d       	ldd	r30, Y+27	; 0x1b
    155a:	ed 8f       	std	Y+29, r30	; 0x1d
    155c:	6e 01       	movw	r12, r28
    155e:	fa e1       	ldi	r31, 0x1A	; 26
    1560:	cf 0e       	add	r12, r31
    1562:	d1 1c       	adc	r13, r1
	unsigned char currSniffFilterByte = 0;
	uint8_t* pSniffIDFilter;

	while (1) {

		if (0 == readFIFO((void*) &payload, &currPayloadType, &currReadPrio)) {
    1564:	ae 01       	movw	r20, r28
    1566:	45 5f       	subi	r20, 0xF5	; 245
    1568:	5f 4f       	sbci	r21, 0xFF	; 255
    156a:	be 01       	movw	r22, r28
    156c:	66 5f       	subi	r22, 0xF6	; 246
    156e:	7f 4f       	sbci	r23, 0xFF	; 255
    1570:	ce 01       	movw	r24, r28
    1572:	01 96       	adiw	r24, 0x01	; 1
    1574:	0e 94 a5 07 	call	0xf4a	; 0xf4a <readFIFO>
    1578:	81 11       	cpse	r24, r1
    157a:	97 c0       	rjmp	.+302    	; 0x16aa <sniffTask+0x194>
			switch (currReadPrio) {
    157c:	8b 85       	ldd	r24, Y+11	; 0x0b
    157e:	81 30       	cpi	r24, 0x01	; 1
    1580:	29 f0       	breq	.+10     	; 0x158c <sniffTask+0x76>
    1582:	80 f1       	brcs	.+96     	; 0x15e4 <sniffTask+0xce>
    1584:	82 30       	cpi	r24, 0x02	; 2
    1586:	09 f4       	brne	.+2      	; 0x158a <sniffTask+0x74>
    1588:	55 c0       	rjmp	.+170    	; 0x1634 <sniffTask+0x11e>
    158a:	ec cf       	rjmp	.-40     	; 0x1564 <sniffTask+0x4e>
			case prioSTREAM: {
				currPayload = (Payload3*) &payload;
				if (applyInformationIDFilter(
    158c:	8a 81       	ldd	r24, Y+2	; 0x02
    158e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <applyInformationIDFilter>
    1592:	88 23       	and	r24, r24
    1594:	39 f3       	breq	.-50     	; 0x1564 <sniffTask+0x4e>
						currPayload->payloadHead.informationID)) {
					currPayload->payloadHead.packetID = packetCounter++;
    1596:	8c 85       	ldd	r24, Y+12	; 0x0c
    1598:	91 e0       	ldi	r25, 0x01	; 1
    159a:	98 0f       	add	r25, r24
    159c:	9c 87       	std	Y+12, r25	; 0x0c
    159e:	89 83       	std	Y+1, r24	; 0x01

					SEND_PREAMBLE
    15a0:	8d ef       	ldi	r24, 0xFD	; 253
    15a2:	90 e0       	ldi	r25, 0x00	; 0
    15a4:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    15a8:	8e ef       	ldi	r24, 0xFE	; 254
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    15b0:	8f ef       	ldi	r24, 0xFF	; 255
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
					;
					ptr = (unsigned char*) currPayload;
					for (size_t pos = 0; pos < currPayloadType; pos++) {
    15b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    15ba:	88 23       	and	r24, r24
    15bc:	99 f2       	breq	.-90     	; 0x1564 <sniffTask+0x4e>
    15be:	07 2d       	mov	r16, r7
    15c0:	16 2d       	mov	r17, r6
    15c2:	ce 01       	movw	r24, r28
    15c4:	01 96       	adiw	r24, 0x01	; 1
    15c6:	7c 01       	movw	r14, r24
						sendByteOverInterface(*ptr);
    15c8:	f7 01       	movw	r30, r14
    15ca:	81 91       	ld	r24, Z+
    15cc:	7f 01       	movw	r14, r30
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
					currPayload->payloadHead.packetID = packetCounter++;

					SEND_PREAMBLE
					;
					ptr = (unsigned char*) currPayload;
					for (size_t pos = 0; pos < currPayloadType; pos++) {
    15d4:	0f 5f       	subi	r16, 0xFF	; 255
    15d6:	1f 4f       	sbci	r17, 0xFF	; 255
    15d8:	8a 85       	ldd	r24, Y+10	; 0x0a
    15da:	90 e0       	ldi	r25, 0x00	; 0
    15dc:	08 17       	cp	r16, r24
    15de:	19 07       	cpc	r17, r25
    15e0:	98 f3       	brcs	.-26     	; 0x15c8 <sniffTask+0xb2>
    15e2:	c0 cf       	rjmp	.-128    	; 0x1564 <sniffTask+0x4e>
				}
			}
				break;
			case prioERROR: {
				currPayloadError = (PayloadError*) &payload;
				currPayloadError->payloadHead.packetID = packetCounter++;
    15e4:	8c 85       	ldd	r24, Y+12	; 0x0c
    15e6:	91 e0       	ldi	r25, 0x01	; 1
    15e8:	98 0f       	add	r25, r24
    15ea:	9c 87       	std	Y+12, r25	; 0x0c
    15ec:	89 83       	std	Y+1, r24	; 0x01
				SEND_PREAMBLE
    15ee:	8d ef       	ldi	r24, 0xFD	; 253
    15f0:	90 e0       	ldi	r25, 0x00	; 0
    15f2:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    15f6:	8e ef       	ldi	r24, 0xFE	; 254
    15f8:	90 e0       	ldi	r25, 0x00	; 0
    15fa:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
    15fe:	8f ef       	ldi	r24, 0xFF	; 255
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
				;
				ptr = (unsigned char*) currPayloadError;
				for (size_t pos = 0; pos < currPayloadType; pos++) {
    1606:	8a 85       	ldd	r24, Y+10	; 0x0a
    1608:	88 23       	and	r24, r24
    160a:	09 f4       	brne	.+2      	; 0x160e <sniffTask+0xf8>
    160c:	ab cf       	rjmp	.-170    	; 0x1564 <sniffTask+0x4e>
    160e:	07 2d       	mov	r16, r7
    1610:	16 2d       	mov	r17, r6
    1612:	ce 01       	movw	r24, r28
    1614:	01 96       	adiw	r24, 0x01	; 1
    1616:	7c 01       	movw	r14, r24
					sendByteOverInterface(*ptr);
    1618:	f7 01       	movw	r30, r14
    161a:	81 91       	ld	r24, Z+
    161c:	7f 01       	movw	r14, r30
    161e:	90 e0       	ldi	r25, 0x00	; 0
    1620:	0e 94 e6 00 	call	0x1cc	; 0x1cc <uart_putc>
				currPayloadError = (PayloadError*) &payload;
				currPayloadError->payloadHead.packetID = packetCounter++;
				SEND_PREAMBLE
				;
				ptr = (unsigned char*) currPayloadError;
				for (size_t pos = 0; pos < currPayloadType; pos++) {
    1624:	0f 5f       	subi	r16, 0xFF	; 255
    1626:	1f 4f       	sbci	r17, 0xFF	; 255
    1628:	8a 85       	ldd	r24, Y+10	; 0x0a
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	08 17       	cp	r16, r24
    162e:	19 07       	cpc	r17, r25
    1630:	98 f3       	brcs	.-26     	; 0x1618 <sniffTask+0x102>
    1632:	98 cf       	rjmp	.-208    	; 0x1564 <sniffTask+0x4e>
				currPayloadReceived = (uint8_t*) &payload;
				#if SEND_WITHOUT_SNIFF_TASK
				uint8_t copySniffIDFilter[SIZE_OF_FILTER];
				#endif

				switch (receiverState) {
    1634:	99 20       	and	r9, r9
    1636:	21 f0       	breq	.+8      	; 0x1640 <sniffTask+0x12a>
    1638:	f1 e0       	ldi	r31, 0x01	; 1
    163a:	9f 16       	cp	r9, r31
    163c:	31 f1       	breq	.+76     	; 0x168a <sniffTask+0x174>
    163e:	92 cf       	rjmp	.-220    	; 0x1564 <sniffTask+0x4e>
				case NORMAL: {
					switch (*currPayloadReceived) {
    1640:	89 81       	ldd	r24, Y+1	; 0x01
    1642:	87 39       	cpi	r24, 0x97	; 151
    1644:	39 f0       	breq	.+14     	; 0x1654 <sniffTask+0x13e>
    1646:	88 39       	cpi	r24, 0x98	; 152
    1648:	09 f0       	breq	.+2      	; 0x164c <sniffTask+0x136>
    164a:	8c cf       	rjmp	.-232    	; 0x1564 <sniffTask+0x4e>
						}
					#endif
						break;
					case ID_SNIFF_FILTER: {
						receiverState = RECEIVE_FILTER;
						pSniffIDFilter = (uint8_t*) sniffIDFilter;
    164c:	21 01       	movw	r4, r2
							sniffIDFilter[i] = copySniffIDFilter[i];
						}
					#endif
						break;
					case ID_SNIFF_FILTER: {
						receiverState = RECEIVE_FILTER;
    164e:	99 24       	eor	r9, r9
    1650:	93 94       	inc	r9
    1652:	88 cf       	rjmp	.-240    	; 0x1564 <sniffTask+0x4e>
    1654:	8e 01       	movw	r16, r28
    1656:	03 5f       	subi	r16, 0xF3	; 243
    1658:	1f 4f       	sbci	r17, 0xFF	; 255
    165a:	71 01       	movw	r14, r2
				uint8_t copySniffIDFilter[SIZE_OF_FILTER];
				#endif

				switch (receiverState) {
				case NORMAL: {
					switch (*currPayloadReceived) {
    165c:	f1 01       	movw	r30, r2
    165e:	ac 8d       	ldd	r26, Y+28	; 0x1c
    1660:	bd 8d       	ldd	r27, Y+29	; 0x1d
					case ID_OBJECT_LIST:
					#if SEND_WITHOUT_SNIFF_TASK // So the Object Send wont get interrupted (Only by errors)
						for (int i = 0; i < SIZE_OF_FILTER; ++i) {
							copySniffIDFilter[i] = sniffIDFilter[i];
    1662:	80 81       	ld	r24, Z
    1664:	8d 93       	st	X+, r24
							sniffIDFilter[i] = 0;
    1666:	11 92       	st	Z+, r1
				switch (receiverState) {
				case NORMAL: {
					switch (*currPayloadReceived) {
					case ID_OBJECT_LIST:
					#if SEND_WITHOUT_SNIFF_TASK // So the Object Send wont get interrupted (Only by errors)
						for (int i = 0; i < SIZE_OF_FILTER; ++i) {
    1668:	ea 15       	cp	r30, r10
    166a:	fb 05       	cpc	r31, r11
    166c:	d1 f7       	brne	.-12     	; 0x1662 <sniffTask+0x14c>
							copySniffIDFilter[i] = sniffIDFilter[i];
							sniffIDFilter[i] = 0;
						}
					#endif
						sendObjectList(&packetCounter);
    166e:	ce 01       	movw	r24, r28
    1670:	0c 96       	adiw	r24, 0x0c	; 12
    1672:	0e 94 d7 08 	call	0x11ae	; 0x11ae <sendObjectList>
					#if SEND_WITHOUT_SNIFF_TASK
						for (int i = 0; i < SIZE_OF_FILTER; ++i) {
							sniffIDFilter[i] = copySniffIDFilter[i];
    1676:	f8 01       	movw	r30, r16
    1678:	81 91       	ld	r24, Z+
    167a:	8f 01       	movw	r16, r30
    167c:	f7 01       	movw	r30, r14
    167e:	81 93       	st	Z+, r24
    1680:	7f 01       	movw	r14, r30
							sniffIDFilter[i] = 0;
						}
					#endif
						sendObjectList(&packetCounter);
					#if SEND_WITHOUT_SNIFF_TASK
						for (int i = 0; i < SIZE_OF_FILTER; ++i) {
    1682:	0c 15       	cp	r16, r12
    1684:	1d 05       	cpc	r17, r13
    1686:	b9 f7       	brne	.-18     	; 0x1676 <sniffTask+0x160>
    1688:	6d cf       	rjmp	.-294    	; 0x1564 <sniffTask+0x4e>
					}
				}
					break;
				case RECEIVE_FILTER: {

					if (currSniffFilterByte < SIZE_OF_FILTER) {
    168a:	fc e0       	ldi	r31, 0x0C	; 12
    168c:	f8 15       	cp	r31, r8
    168e:	08 f4       	brcc	.+2      	; 0x1692 <sniffTask+0x17c>
    1690:	69 cf       	rjmp	.-302    	; 0x1564 <sniffTask+0x4e>
						*pSniffIDFilter = *currPayloadReceived;
    1692:	89 81       	ldd	r24, Y+1	; 0x01
    1694:	f2 01       	movw	r30, r4
    1696:	81 93       	st	Z+, r24
    1698:	2f 01       	movw	r4, r30
						pSniffIDFilter++;
						currSniffFilterByte++;
    169a:	83 94       	inc	r8
						if (currSniffFilterByte >= 13) {
    169c:	fc e0       	ldi	r31, 0x0C	; 12
    169e:	f8 15       	cp	r31, r8
    16a0:	08 f0       	brcs	.+2      	; 0x16a4 <sniffTask+0x18e>
    16a2:	60 cf       	rjmp	.-320    	; 0x1564 <sniffTask+0x4e>
							currSniffFilterByte = 0;
    16a4:	81 2c       	mov	r8, r1
							receiverState = NORMAL;
    16a6:	91 2c       	mov	r9, r1
				default:
					break;
				}

			}
				break;
    16a8:	5d cf       	rjmp	.-326    	; 0x1564 <sniffTask+0x4e>

				break;
			}

		} else {
			vTaskDelay(10);
    16aa:	8a e0       	ldi	r24, 0x0A	; 10
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	0e 94 9c 06 	call	0xd38	; 0xd38 <vTaskDelay>
    16b2:	58 cf       	rjmp	.-336    	; 0x1564 <sniffTask+0x4e>

000016b4 <__udivmodhi4>:
    16b4:	aa 1b       	sub	r26, r26
    16b6:	bb 1b       	sub	r27, r27
    16b8:	51 e1       	ldi	r21, 0x11	; 17
    16ba:	07 c0       	rjmp	.+14     	; 0x16ca <__udivmodhi4_ep>

000016bc <__udivmodhi4_loop>:
    16bc:	aa 1f       	adc	r26, r26
    16be:	bb 1f       	adc	r27, r27
    16c0:	a6 17       	cp	r26, r22
    16c2:	b7 07       	cpc	r27, r23
    16c4:	10 f0       	brcs	.+4      	; 0x16ca <__udivmodhi4_ep>
    16c6:	a6 1b       	sub	r26, r22
    16c8:	b7 0b       	sbc	r27, r23

000016ca <__udivmodhi4_ep>:
    16ca:	88 1f       	adc	r24, r24
    16cc:	99 1f       	adc	r25, r25
    16ce:	5a 95       	dec	r21
    16d0:	a9 f7       	brne	.-22     	; 0x16bc <__udivmodhi4_loop>
    16d2:	80 95       	com	r24
    16d4:	90 95       	com	r25
    16d6:	bc 01       	movw	r22, r24
    16d8:	cd 01       	movw	r24, r26
    16da:	08 95       	ret

000016dc <memcpy>:
    16dc:	fb 01       	movw	r30, r22
    16de:	dc 01       	movw	r26, r24
    16e0:	02 c0       	rjmp	.+4      	; 0x16e6 <memcpy+0xa>
    16e2:	01 90       	ld	r0, Z+
    16e4:	0d 92       	st	X+, r0
    16e6:	41 50       	subi	r20, 0x01	; 1
    16e8:	50 40       	sbci	r21, 0x00	; 0
    16ea:	d8 f7       	brcc	.-10     	; 0x16e2 <memcpy+0x6>
    16ec:	08 95       	ret

000016ee <memset>:
    16ee:	dc 01       	movw	r26, r24
    16f0:	01 c0       	rjmp	.+2      	; 0x16f4 <memset+0x6>
    16f2:	6d 93       	st	X+, r22
    16f4:	41 50       	subi	r20, 0x01	; 1
    16f6:	50 40       	sbci	r21, 0x00	; 0
    16f8:	e0 f7       	brcc	.-8      	; 0x16f2 <memset+0x4>
    16fa:	08 95       	ret

000016fc <_exit>:
    16fc:	f8 94       	cli

000016fe <__stop_program>:
    16fe:	ff cf       	rjmp	.-2      	; 0x16fe <__stop_program>
