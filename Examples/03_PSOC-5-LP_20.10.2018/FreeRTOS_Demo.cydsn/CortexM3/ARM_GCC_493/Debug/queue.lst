ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"queue.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.comm	xQueueRegistry,80,4
  19              		.section	.text.xQueueGenericReset,"ax",%progbits
  20              		.align	2
  21              		.global	xQueueGenericReset
  22              		.thumb
  23              		.thumb_func
  24              		.type	xQueueGenericReset, %function
  25              	xQueueGenericReset:
  26              	.LFB68:
  27              		.file 1 "..\\Source\\queue.c"
   1:..\Source/queue.c **** /*
   2:..\Source/queue.c ****     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:..\Source/queue.c ****     All rights reserved
   4:..\Source/queue.c **** 
   5:..\Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:..\Source/queue.c **** 
   7:..\Source/queue.c ****     This file is part of the FreeRTOS distribution.
   8:..\Source/queue.c **** 
   9:..\Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:..\Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:..\Source/queue.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:..\Source/queue.c **** 
  13:..\Source/queue.c ****     ***************************************************************************
  14:..\Source/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:..\Source/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:..\Source/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:..\Source/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:..\Source/queue.c ****     ***************************************************************************
  19:..\Source/queue.c **** 
  20:..\Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:..\Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:..\Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:..\Source/queue.c ****     link: http://www.freertos.org/a00114.html
  24:..\Source/queue.c **** 
  25:..\Source/queue.c ****     ***************************************************************************
  26:..\Source/queue.c ****      *                                                                       *
  27:..\Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:..\Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:..\Source/queue.c ****      *    platform software that is more than just the market leader, it     *
  30:..\Source/queue.c ****      *    is the industry's de facto standard.                               *
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 2


  31:..\Source/queue.c ****      *                                                                       *
  32:..\Source/queue.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:..\Source/queue.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:..\Source/queue.c ****      *    tutorial book, reference manual, or both:                          *
  35:..\Source/queue.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:..\Source/queue.c ****      *                                                                       *
  37:..\Source/queue.c ****     ***************************************************************************
  38:..\Source/queue.c **** 
  39:..\Source/queue.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:..\Source/queue.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:..\Source/queue.c ****     defined configASSERT()?
  42:..\Source/queue.c **** 
  43:..\Source/queue.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:..\Source/queue.c ****     embedded software for free we request you assist our global community by
  45:..\Source/queue.c ****     participating in the support forum.
  46:..\Source/queue.c **** 
  47:..\Source/queue.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:..\Source/queue.c ****     be as productive as possible as early as possible.  Now you can receive
  49:..\Source/queue.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:..\Source/queue.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:..\Source/queue.c **** 
  52:..\Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:..\Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:..\Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:..\Source/queue.c **** 
  56:..\Source/queue.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:..\Source/queue.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:..\Source/queue.c **** 
  59:..\Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:..\Source/queue.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:..\Source/queue.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:..\Source/queue.c **** 
  63:..\Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:..\Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  65:..\Source/queue.c ****     mission critical applications that require provable dependability.
  66:..\Source/queue.c **** 
  67:..\Source/queue.c ****     1 tab == 4 spaces!
  68:..\Source/queue.c **** */
  69:..\Source/queue.c **** 
  70:..\Source/queue.c **** #include <stdlib.h>
  71:..\Source/queue.c **** #include <string.h>
  72:..\Source/queue.c **** 
  73:..\Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  74:..\Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  75:..\Source/queue.c **** task.h is included from an application file. */
  76:..\Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  77:..\Source/queue.c **** 
  78:..\Source/queue.c **** #include "FreeRTOS.h"
  79:..\Source/queue.c **** #include "task.h"
  80:..\Source/queue.c **** #include "queue.h"
  81:..\Source/queue.c **** 
  82:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  83:..\Source/queue.c **** 	#include "croutine.h"
  84:..\Source/queue.c **** #endif
  85:..\Source/queue.c **** 
  86:..\Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  87:..\Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 3


  88:..\Source/queue.c **** header files above, but not in this file, in order to generate the correct
  89:..\Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  90:..\Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  91:..\Source/queue.c **** 
  92:..\Source/queue.c **** 
  93:..\Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  94:..\Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  95:..\Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  96:..\Source/queue.c **** 
  97:..\Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  98:..\Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  99:..\Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
 100:..\Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
 101:..\Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
 102:..\Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
 103:..\Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 104:..\Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 105:..\Source/queue.c **** against the coding standard (although an exception to the standard has been
 106:..\Source/queue.c **** permitted where the dual use also significantly changes the type of the
 107:..\Source/queue.c **** structure member). */
 108:..\Source/queue.c **** #define pxMutexHolder					pcTail
 109:..\Source/queue.c **** #define uxQueueType						pcHead
 110:..\Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 111:..\Source/queue.c **** 
 112:..\Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 113:..\Source/queue.c **** zero. */
 114:..\Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 115:..\Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 116:..\Source/queue.c **** 
 117:..\Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
 118:..\Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 119:..\Source/queue.c **** 	performed just because a higher priority task has been woken. */
 120:..\Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 121:..\Source/queue.c **** #else
 122:..\Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 123:..\Source/queue.c **** #endif
 124:..\Source/queue.c **** 
 125:..\Source/queue.c **** /*
 126:..\Source/queue.c ****  * Definition of the queue used by the scheduler.
 127:..\Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
 128:..\Source/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
 129:..\Source/queue.c ****  */
 130:..\Source/queue.c **** typedef struct QueueDefinition
 131:..\Source/queue.c **** {
 132:..\Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 133:..\Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 134:..\Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 135:..\Source/queue.c **** 
 136:..\Source/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 137:..\Source/queue.c **** 	{
 138:..\Source/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 139:..\Source/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 140:..\Source/queue.c **** 	} u;
 141:..\Source/queue.c **** 
 142:..\Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 143:..\Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 144:..\Source/queue.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 4


 145:..\Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 146:..\Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 147:..\Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 148:..\Source/queue.c **** 
 149:..\Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 150:..\Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 151:..\Source/queue.c **** 
 152:..\Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 153:..\Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 154:..\Source/queue.c **** 	#endif
 155:..\Source/queue.c **** 
 156:..\Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 157:..\Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 158:..\Source/queue.c **** 	#endif
 159:..\Source/queue.c **** 
 160:..\Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 161:..\Source/queue.c **** 		UBaseType_t uxQueueNumber;
 162:..\Source/queue.c **** 		uint8_t ucQueueType;
 163:..\Source/queue.c **** 	#endif
 164:..\Source/queue.c **** 
 165:..\Source/queue.c **** } xQUEUE;
 166:..\Source/queue.c **** 
 167:..\Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 168:..\Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 169:..\Source/queue.c **** typedef xQUEUE Queue_t;
 170:..\Source/queue.c **** 
 171:..\Source/queue.c **** /*-----------------------------------------------------------*/
 172:..\Source/queue.c **** 
 173:..\Source/queue.c **** /*
 174:..\Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 175:..\Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 176:..\Source/queue.c ****  */
 177:..\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 178:..\Source/queue.c **** 
 179:..\Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 180:..\Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 181:..\Source/queue.c **** 	more user friendly. */
 182:..\Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 183:..\Source/queue.c **** 	{
 184:..\Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 185:..\Source/queue.c **** 		QueueHandle_t xHandle;
 186:..\Source/queue.c **** 	} xQueueRegistryItem;
 187:..\Source/queue.c **** 
 188:..\Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 189:..\Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 190:..\Source/queue.c **** 	debuggers. */
 191:..\Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 192:..\Source/queue.c **** 
 193:..\Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 194:..\Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:..\Source/queue.c **** 	array position being vacant. */
 196:..\Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:..\Source/queue.c **** 
 198:..\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 199:..\Source/queue.c **** 
 200:..\Source/queue.c **** /*
 201:..\Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 5


 202:..\Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 203:..\Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 204:..\Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 205:..\Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 206:..\Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 207:..\Source/queue.c ****  */
 208:..\Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 209:..\Source/queue.c **** 
 210:..\Source/queue.c **** /*
 211:..\Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 212:..\Source/queue.c ****  *
 213:..\Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 214:..\Source/queue.c ****  */
 215:..\Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 216:..\Source/queue.c **** 
 217:..\Source/queue.c **** /*
 218:..\Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 219:..\Source/queue.c ****  *
 220:..\Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 221:..\Source/queue.c ****  */
 222:..\Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 223:..\Source/queue.c **** 
 224:..\Source/queue.c **** /*
 225:..\Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 226:..\Source/queue.c ****  * back of the queue.
 227:..\Source/queue.c ****  */
 228:..\Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 229:..\Source/queue.c **** 
 230:..\Source/queue.c **** /*
 231:..\Source/queue.c ****  * Copies an item out of a queue.
 232:..\Source/queue.c ****  */
 233:..\Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 234:..\Source/queue.c **** 
 235:..\Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 236:..\Source/queue.c **** 	/*
 237:..\Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 238:..\Source/queue.c **** 	 * the queue set that the queue contains data.
 239:..\Source/queue.c **** 	 */
 240:..\Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 241:..\Source/queue.c **** #endif
 242:..\Source/queue.c **** 
 243:..\Source/queue.c **** /*
 244:..\Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 245:..\Source/queue.c ****  * dynamically to fill in the structure's members.
 246:..\Source/queue.c ****  */
 247:..\Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 248:..\Source/queue.c **** 
 249:..\Source/queue.c **** /*
 250:..\Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 251:..\Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 252:..\Source/queue.c ****  * as a mutex.
 253:..\Source/queue.c ****  */
 254:..\Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 255:..\Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 256:..\Source/queue.c **** #endif
 257:..\Source/queue.c **** 
 258:..\Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 6


 259:..\Source/queue.c **** 
 260:..\Source/queue.c **** /*
 261:..\Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 262:..\Source/queue.c ****  * accessing the queue event lists.
 263:..\Source/queue.c ****  */
 264:..\Source/queue.c **** #define prvLockQueue( pxQueue )								\
 265:..\Source/queue.c **** 	taskENTER_CRITICAL();									\
 266:..\Source/queue.c **** 	{														\
 267:..\Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 268:..\Source/queue.c **** 		{													\
 269:..\Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 270:..\Source/queue.c **** 		}													\
 271:..\Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 272:..\Source/queue.c **** 		{													\
 273:..\Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 274:..\Source/queue.c **** 		}													\
 275:..\Source/queue.c **** 	}														\
 276:..\Source/queue.c **** 	taskEXIT_CRITICAL()
 277:..\Source/queue.c **** /*-----------------------------------------------------------*/
 278:..\Source/queue.c **** 
 279:..\Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 280:..\Source/queue.c **** {
  28              		.loc 1 280 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 16
  31              		@ frame_needed = 1, uses_anonymous_args = 0
  32 0000 80B5     		push	{r7, lr}
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 84B0     		sub	sp, sp, #16
  37              		.cfi_def_cfa_offset 24
  38 0004 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  40 0006 7860     		str	r0, [r7, #4]
  41 0008 3960     		str	r1, [r7]
 281:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  42              		.loc 1 281 0
  43 000a 7B68     		ldr	r3, [r7, #4]
  44 000c FB60     		str	r3, [r7, #12]
 282:..\Source/queue.c **** 
 283:..\Source/queue.c **** 	configASSERT( pxQueue );
 284:..\Source/queue.c **** 
 285:..\Source/queue.c **** 	taskENTER_CRITICAL();
  45              		.loc 1 285 0
  46 000e FFF7FEFF 		bl	vPortEnterCritical
 286:..\Source/queue.c **** 	{
 287:..\Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  47              		.loc 1 287 0
  48 0012 FB68     		ldr	r3, [r7, #12]
  49 0014 1A68     		ldr	r2, [r3]
  50 0016 FB68     		ldr	r3, [r7, #12]
  51 0018 DB6B     		ldr	r3, [r3, #60]
  52 001a F968     		ldr	r1, [r7, #12]
  53 001c 096C     		ldr	r1, [r1, #64]
  54 001e 01FB03F3 		mul	r3, r1, r3
  55 0022 1A44     		add	r2, r2, r3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 7


  56 0024 FB68     		ldr	r3, [r7, #12]
  57 0026 5A60     		str	r2, [r3, #4]
 288:..\Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  58              		.loc 1 288 0
  59 0028 FB68     		ldr	r3, [r7, #12]
  60 002a 0022     		movs	r2, #0
  61 002c 9A63     		str	r2, [r3, #56]
 289:..\Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  62              		.loc 1 289 0
  63 002e FB68     		ldr	r3, [r7, #12]
  64 0030 1A68     		ldr	r2, [r3]
  65 0032 FB68     		ldr	r3, [r7, #12]
  66 0034 9A60     		str	r2, [r3, #8]
 290:..\Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
  67              		.loc 1 290 0
  68 0036 FB68     		ldr	r3, [r7, #12]
  69 0038 1A68     		ldr	r2, [r3]
  70 003a FB68     		ldr	r3, [r7, #12]
  71 003c DB6B     		ldr	r3, [r3, #60]
  72 003e 013B     		subs	r3, r3, #1
  73 0040 F968     		ldr	r1, [r7, #12]
  74 0042 096C     		ldr	r1, [r1, #64]
  75 0044 01FB03F3 		mul	r3, r1, r3
  76 0048 1A44     		add	r2, r2, r3
  77 004a FB68     		ldr	r3, [r7, #12]
  78 004c DA60     		str	r2, [r3, #12]
 291:..\Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
  79              		.loc 1 291 0
  80 004e FB68     		ldr	r3, [r7, #12]
  81 0050 FF22     		movs	r2, #255
  82 0052 83F84420 		strb	r2, [r3, #68]
 292:..\Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
  83              		.loc 1 292 0
  84 0056 FB68     		ldr	r3, [r7, #12]
  85 0058 FF22     		movs	r2, #255
  86 005a 83F84520 		strb	r2, [r3, #69]
 293:..\Source/queue.c **** 
 294:..\Source/queue.c **** 		if( xNewQueue == pdFALSE )
  87              		.loc 1 294 0
  88 005e 3B68     		ldr	r3, [r7]
  89 0060 002B     		cmp	r3, #0
  90 0062 14D1     		bne	.L2
 295:..\Source/queue.c **** 		{
 296:..\Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 297:..\Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 298:..\Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 299:..\Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 300:..\Source/queue.c **** 			it will be possible to write to it. */
 301:..\Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  91              		.loc 1 301 0
  92 0064 FB68     		ldr	r3, [r7, #12]
  93 0066 1B69     		ldr	r3, [r3, #16]
  94 0068 002B     		cmp	r3, #0
  95 006a 1AD0     		beq	.L3
 302:..\Source/queue.c **** 			{
 303:..\Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  96              		.loc 1 303 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 8


  97 006c FB68     		ldr	r3, [r7, #12]
  98 006e 1033     		adds	r3, r3, #16
  99 0070 1846     		mov	r0, r3
 100 0072 FFF7FEFF 		bl	xTaskRemoveFromEventList
 101 0076 0346     		mov	r3, r0
 102 0078 002B     		cmp	r3, #0
 103 007a 12D0     		beq	.L3
 304:..\Source/queue.c **** 				{
 305:..\Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 104              		.loc 1 305 0
 105 007c 0C4B     		ldr	r3, .L5
 106 007e 4FF08052 		mov	r2, #268435456
 107 0082 1A60     		str	r2, [r3]
 108              	@ 305 "..\Source\queue.c" 1
 109 0084 BFF34F8F 		dsb
 110              	@ 0 "" 2
 111              	@ 305 "..\Source\queue.c" 1
 112 0088 BFF36F8F 		isb
 113              	@ 0 "" 2
 114              		.thumb
 115 008c 09E0     		b	.L3
 116              	.L2:
 306:..\Source/queue.c **** 				}
 307:..\Source/queue.c **** 				else
 308:..\Source/queue.c **** 				{
 309:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 310:..\Source/queue.c **** 				}
 311:..\Source/queue.c **** 			}
 312:..\Source/queue.c **** 			else
 313:..\Source/queue.c **** 			{
 314:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 315:..\Source/queue.c **** 			}
 316:..\Source/queue.c **** 		}
 317:..\Source/queue.c **** 		else
 318:..\Source/queue.c **** 		{
 319:..\Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 320:..\Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 117              		.loc 1 320 0
 118 008e FB68     		ldr	r3, [r7, #12]
 119 0090 1033     		adds	r3, r3, #16
 120 0092 1846     		mov	r0, r3
 121 0094 FFF7FEFF 		bl	vListInitialise
 321:..\Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 122              		.loc 1 321 0
 123 0098 FB68     		ldr	r3, [r7, #12]
 124 009a 2433     		adds	r3, r3, #36
 125 009c 1846     		mov	r0, r3
 126 009e FFF7FEFF 		bl	vListInitialise
 127              	.L3:
 322:..\Source/queue.c **** 		}
 323:..\Source/queue.c **** 	}
 324:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 128              		.loc 1 324 0
 129 00a2 FFF7FEFF 		bl	vPortExitCritical
 325:..\Source/queue.c **** 
 326:..\Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 327:..\Source/queue.c **** 	versions. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 9


 328:..\Source/queue.c **** 	return pdPASS;
 130              		.loc 1 328 0
 131 00a6 0123     		movs	r3, #1
 329:..\Source/queue.c **** }
 132              		.loc 1 329 0
 133 00a8 1846     		mov	r0, r3
 134 00aa 1037     		adds	r7, r7, #16
 135              		.cfi_def_cfa_offset 8
 136 00ac BD46     		mov	sp, r7
 137              		.cfi_def_cfa_register 13
 138              		@ sp needed
 139 00ae 80BD     		pop	{r7, pc}
 140              	.L6:
 141              		.align	2
 142              	.L5:
 143 00b0 04ED00E0 		.word	-536810236
 144              		.cfi_endproc
 145              	.LFE68:
 146              		.size	xQueueGenericReset, .-xQueueGenericReset
 147              		.section	.text.xQueueGenericCreate,"ax",%progbits
 148              		.align	2
 149              		.global	xQueueGenericCreate
 150              		.thumb
 151              		.thumb_func
 152              		.type	xQueueGenericCreate, %function
 153              	xQueueGenericCreate:
 154              	.LFB69:
 330:..\Source/queue.c **** /*-----------------------------------------------------------*/
 331:..\Source/queue.c **** 
 332:..\Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 333:..\Source/queue.c **** 
 334:..\Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 335:..\Source/queue.c **** 	{
 336:..\Source/queue.c **** 	Queue_t *pxNewQueue;
 337:..\Source/queue.c **** 
 338:..\Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 339:..\Source/queue.c **** 
 340:..\Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 341:..\Source/queue.c **** 		supplied. */
 342:..\Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 343:..\Source/queue.c **** 
 344:..\Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 345:..\Source/queue.c **** 		should not be provided if the item size is 0. */
 346:..\Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 347:..\Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 348:..\Source/queue.c **** 
 349:..\Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 350:..\Source/queue.c **** 		{
 351:..\Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 352:..\Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 353:..\Source/queue.c **** 			the real queue and semaphore structures. */
 354:..\Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 355:..\Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 356:..\Source/queue.c **** 		}
 357:..\Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 358:..\Source/queue.c **** 
 359:..\Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 10


 360:..\Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 361:..\Source/queue.c **** 		but is already set. */
 362:..\Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are d
 363:..\Source/queue.c **** 
 364:..\Source/queue.c **** 		if( pxNewQueue != NULL )
 365:..\Source/queue.c **** 		{
 366:..\Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:..\Source/queue.c **** 			{
 368:..\Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 369:..\Source/queue.c **** 				note this queue was allocated statically in case the queue is
 370:..\Source/queue.c **** 				later deleted. */
 371:..\Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 372:..\Source/queue.c **** 			}
 373:..\Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 374:..\Source/queue.c **** 
 375:..\Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 376:..\Source/queue.c **** 		}
 377:..\Source/queue.c **** 
 378:..\Source/queue.c **** 		return pxNewQueue;
 379:..\Source/queue.c **** 	}
 380:..\Source/queue.c **** 
 381:..\Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 382:..\Source/queue.c **** /*-----------------------------------------------------------*/
 383:..\Source/queue.c **** 
 384:..\Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 385:..\Source/queue.c **** 
 386:..\Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 387:..\Source/queue.c **** 	{
 155              		.loc 1 387 0
 156              		.cfi_startproc
 157              		@ args = 0, pretend = 0, frame = 32
 158              		@ frame_needed = 1, uses_anonymous_args = 0
 159 0000 90B5     		push	{r4, r7, lr}
 160              		.cfi_def_cfa_offset 12
 161              		.cfi_offset 4, -12
 162              		.cfi_offset 7, -8
 163              		.cfi_offset 14, -4
 164 0002 8BB0     		sub	sp, sp, #44
 165              		.cfi_def_cfa_offset 56
 166 0004 02AF     		add	r7, sp, #8
 167              		.cfi_def_cfa 7, 48
 168 0006 F860     		str	r0, [r7, #12]
 169 0008 B960     		str	r1, [r7, #8]
 170 000a 1346     		mov	r3, r2
 171 000c FB71     		strb	r3, [r7, #7]
 388:..\Source/queue.c **** 	Queue_t *pxNewQueue;
 389:..\Source/queue.c **** 	size_t xQueueSizeInBytes;
 390:..\Source/queue.c **** 	uint8_t *pucQueueStorage;
 391:..\Source/queue.c **** 
 392:..\Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 393:..\Source/queue.c **** 
 394:..\Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
 172              		.loc 1 394 0
 173 000e BB68     		ldr	r3, [r7, #8]
 174 0010 002B     		cmp	r3, #0
 175 0012 02D1     		bne	.L8
 395:..\Source/queue.c **** 		{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 11


 396:..\Source/queue.c **** 			/* There is not going to be a queue storage area. */
 397:..\Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 176              		.loc 1 397 0
 177 0014 0023     		movs	r3, #0
 178 0016 FB61     		str	r3, [r7, #28]
 179 0018 04E0     		b	.L9
 180              	.L8:
 398:..\Source/queue.c **** 		}
 399:..\Source/queue.c **** 		else
 400:..\Source/queue.c **** 		{
 401:..\Source/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 402:..\Source/queue.c **** 			can be in the queue at any time. */
 403:..\Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 181              		.loc 1 403 0
 182 001a FB68     		ldr	r3, [r7, #12]
 183 001c BA68     		ldr	r2, [r7, #8]
 184 001e 02FB03F3 		mul	r3, r2, r3
 185 0022 FB61     		str	r3, [r7, #28]
 186              	.L9:
 404:..\Source/queue.c **** 		}
 405:..\Source/queue.c **** 
 406:..\Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 187              		.loc 1 406 0
 188 0024 FB69     		ldr	r3, [r7, #28]
 189 0026 4833     		adds	r3, r3, #72
 190 0028 1846     		mov	r0, r3
 191 002a FFF7FEFF 		bl	pvPortMalloc
 192 002e B861     		str	r0, [r7, #24]
 407:..\Source/queue.c **** 
 408:..\Source/queue.c **** 		if( pxNewQueue != NULL )
 193              		.loc 1 408 0
 194 0030 BB69     		ldr	r3, [r7, #24]
 195 0032 002B     		cmp	r3, #0
 196 0034 0BD0     		beq	.L10
 409:..\Source/queue.c **** 		{
 410:..\Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 411:..\Source/queue.c **** 			storage area. */
 412:..\Source/queue.c **** 			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 197              		.loc 1 412 0
 198 0036 BB69     		ldr	r3, [r7, #24]
 199 0038 4833     		adds	r3, r3, #72
 200 003a 7B61     		str	r3, [r7, #20]
 413:..\Source/queue.c **** 
 414:..\Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 415:..\Source/queue.c **** 			{
 416:..\Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 417:..\Source/queue.c **** 				note this task was created dynamically in case it is later
 418:..\Source/queue.c **** 				deleted. */
 419:..\Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 420:..\Source/queue.c **** 			}
 421:..\Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 422:..\Source/queue.c **** 
 423:..\Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 201              		.loc 1 423 0
 202 003c FC79     		ldrb	r4, [r7, #7]	@ zero_extendqisi2
 203 003e BB69     		ldr	r3, [r7, #24]
 204 0040 0093     		str	r3, [sp]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 12


 205 0042 F868     		ldr	r0, [r7, #12]
 206 0044 B968     		ldr	r1, [r7, #8]
 207 0046 7A69     		ldr	r2, [r7, #20]
 208 0048 2346     		mov	r3, r4
 209 004a FFF7FEFF 		bl	prvInitialiseNewQueue
 210              	.L10:
 424:..\Source/queue.c **** 		}
 425:..\Source/queue.c **** 
 426:..\Source/queue.c **** 		return pxNewQueue;
 211              		.loc 1 426 0
 212 004e BB69     		ldr	r3, [r7, #24]
 427:..\Source/queue.c **** 	}
 213              		.loc 1 427 0
 214 0050 1846     		mov	r0, r3
 215 0052 2437     		adds	r7, r7, #36
 216              		.cfi_def_cfa_offset 12
 217 0054 BD46     		mov	sp, r7
 218              		.cfi_def_cfa_register 13
 219              		@ sp needed
 220 0056 90BD     		pop	{r4, r7, pc}
 221              		.cfi_endproc
 222              	.LFE69:
 223              		.size	xQueueGenericCreate, .-xQueueGenericCreate
 224              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 225              		.align	2
 226              		.thumb
 227              		.thumb_func
 228              		.type	prvInitialiseNewQueue, %function
 229              	prvInitialiseNewQueue:
 230              	.LFB70:
 428:..\Source/queue.c **** 
 429:..\Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 430:..\Source/queue.c **** /*-----------------------------------------------------------*/
 431:..\Source/queue.c **** 
 432:..\Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 433:..\Source/queue.c **** {
 231              		.loc 1 433 0
 232              		.cfi_startproc
 233              		@ args = 4, pretend = 0, frame = 16
 234              		@ frame_needed = 1, uses_anonymous_args = 0
 235 0000 80B5     		push	{r7, lr}
 236              		.cfi_def_cfa_offset 8
 237              		.cfi_offset 7, -8
 238              		.cfi_offset 14, -4
 239 0002 84B0     		sub	sp, sp, #16
 240              		.cfi_def_cfa_offset 24
 241 0004 00AF     		add	r7, sp, #0
 242              		.cfi_def_cfa_register 7
 243 0006 F860     		str	r0, [r7, #12]
 244 0008 B960     		str	r1, [r7, #8]
 245 000a 7A60     		str	r2, [r7, #4]
 246 000c FB70     		strb	r3, [r7, #3]
 434:..\Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 435:..\Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 436:..\Source/queue.c **** 	( void ) ucQueueType;
 437:..\Source/queue.c **** 
 438:..\Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 13


 247              		.loc 1 438 0
 248 000e BB68     		ldr	r3, [r7, #8]
 249 0010 002B     		cmp	r3, #0
 250 0012 03D1     		bne	.L13
 439:..\Source/queue.c **** 	{
 440:..\Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 441:..\Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 442:..\Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 443:..\Source/queue.c **** 		value that is known to be within the memory map. */
 444:..\Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 251              		.loc 1 444 0
 252 0014 BB69     		ldr	r3, [r7, #24]
 253 0016 BA69     		ldr	r2, [r7, #24]
 254 0018 1A60     		str	r2, [r3]
 255 001a 02E0     		b	.L14
 256              	.L13:
 445:..\Source/queue.c **** 	}
 446:..\Source/queue.c **** 	else
 447:..\Source/queue.c **** 	{
 448:..\Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 449:..\Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 257              		.loc 1 449 0
 258 001c BB69     		ldr	r3, [r7, #24]
 259 001e 7A68     		ldr	r2, [r7, #4]
 260 0020 1A60     		str	r2, [r3]
 261              	.L14:
 450:..\Source/queue.c **** 	}
 451:..\Source/queue.c **** 
 452:..\Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 453:..\Source/queue.c **** 	defined. */
 454:..\Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 262              		.loc 1 454 0
 263 0022 BB69     		ldr	r3, [r7, #24]
 264 0024 FA68     		ldr	r2, [r7, #12]
 265 0026 DA63     		str	r2, [r3, #60]
 455:..\Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 266              		.loc 1 455 0
 267 0028 BB69     		ldr	r3, [r7, #24]
 268 002a BA68     		ldr	r2, [r7, #8]
 269 002c 1A64     		str	r2, [r3, #64]
 456:..\Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 270              		.loc 1 456 0
 271 002e B869     		ldr	r0, [r7, #24]
 272 0030 0121     		movs	r1, #1
 273 0032 FFF7FEFF 		bl	xQueueGenericReset
 457:..\Source/queue.c **** 
 458:..\Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 459:..\Source/queue.c **** 	{
 460:..\Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 461:..\Source/queue.c **** 	}
 462:..\Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 463:..\Source/queue.c **** 
 464:..\Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 465:..\Source/queue.c **** 	{
 466:..\Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 467:..\Source/queue.c **** 	}
 468:..\Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 14


 469:..\Source/queue.c **** 
 470:..\Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 471:..\Source/queue.c **** }
 274              		.loc 1 471 0
 275 0036 1037     		adds	r7, r7, #16
 276              		.cfi_def_cfa_offset 8
 277 0038 BD46     		mov	sp, r7
 278              		.cfi_def_cfa_register 13
 279              		@ sp needed
 280 003a 80BD     		pop	{r7, pc}
 281              		.cfi_endproc
 282              	.LFE70:
 283              		.size	prvInitialiseNewQueue, .-prvInitialiseNewQueue
 284              		.section	.text.prvInitialiseMutex,"ax",%progbits
 285              		.align	2
 286              		.thumb
 287              		.thumb_func
 288              		.type	prvInitialiseMutex, %function
 289              	prvInitialiseMutex:
 290              	.LFB71:
 472:..\Source/queue.c **** /*-----------------------------------------------------------*/
 473:..\Source/queue.c **** 
 474:..\Source/queue.c **** #if( configUSE_MUTEXES == 1 )
 475:..\Source/queue.c **** 
 476:..\Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 477:..\Source/queue.c **** 	{
 291              		.loc 1 477 0
 292              		.cfi_startproc
 293              		@ args = 0, pretend = 0, frame = 8
 294              		@ frame_needed = 1, uses_anonymous_args = 0
 295 0000 80B5     		push	{r7, lr}
 296              		.cfi_def_cfa_offset 8
 297              		.cfi_offset 7, -8
 298              		.cfi_offset 14, -4
 299 0002 82B0     		sub	sp, sp, #8
 300              		.cfi_def_cfa_offset 16
 301 0004 00AF     		add	r7, sp, #0
 302              		.cfi_def_cfa_register 7
 303 0006 7860     		str	r0, [r7, #4]
 478:..\Source/queue.c **** 		if( pxNewQueue != NULL )
 304              		.loc 1 478 0
 305 0008 7B68     		ldr	r3, [r7, #4]
 306 000a 002B     		cmp	r3, #0
 307 000c 0ED0     		beq	.L15
 479:..\Source/queue.c **** 		{
 480:..\Source/queue.c **** 			/* The queue create function will set all the queue structure members
 481:..\Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 482:..\Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 483:..\Source/queue.c **** 			in particular the information required for priority inheritance. */
 484:..\Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 308              		.loc 1 484 0
 309 000e 7B68     		ldr	r3, [r7, #4]
 310 0010 0022     		movs	r2, #0
 311 0012 5A60     		str	r2, [r3, #4]
 485:..\Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 312              		.loc 1 485 0
 313 0014 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 15


 314 0016 0022     		movs	r2, #0
 315 0018 1A60     		str	r2, [r3]
 486:..\Source/queue.c **** 
 487:..\Source/queue.c **** 			/* In case this is a recursive mutex. */
 488:..\Source/queue.c **** 			pxNewQueue->u.uxRecursiveCallCount = 0;
 316              		.loc 1 488 0
 317 001a 7B68     		ldr	r3, [r7, #4]
 318 001c 0022     		movs	r2, #0
 319 001e DA60     		str	r2, [r3, #12]
 489:..\Source/queue.c **** 
 490:..\Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 491:..\Source/queue.c **** 
 492:..\Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 493:..\Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 320              		.loc 1 493 0
 321 0020 7868     		ldr	r0, [r7, #4]
 322 0022 0021     		movs	r1, #0
 323 0024 0022     		movs	r2, #0
 324 0026 0023     		movs	r3, #0
 325 0028 FFF7FEFF 		bl	xQueueGenericSend
 326              	.L15:
 494:..\Source/queue.c **** 		}
 495:..\Source/queue.c **** 		else
 496:..\Source/queue.c **** 		{
 497:..\Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 498:..\Source/queue.c **** 		}
 499:..\Source/queue.c **** 	}
 327              		.loc 1 499 0
 328 002c 0837     		adds	r7, r7, #8
 329              		.cfi_def_cfa_offset 8
 330 002e BD46     		mov	sp, r7
 331              		.cfi_def_cfa_register 13
 332              		@ sp needed
 333 0030 80BD     		pop	{r7, pc}
 334              		.cfi_endproc
 335              	.LFE71:
 336              		.size	prvInitialiseMutex, .-prvInitialiseMutex
 337 0032 00BF     		.section	.text.xQueueCreateMutex,"ax",%progbits
 338              		.align	2
 339              		.global	xQueueCreateMutex
 340              		.thumb
 341              		.thumb_func
 342              		.type	xQueueCreateMutex, %function
 343              	xQueueCreateMutex:
 344              	.LFB72:
 500:..\Source/queue.c **** 
 501:..\Source/queue.c **** #endif /* configUSE_MUTEXES */
 502:..\Source/queue.c **** /*-----------------------------------------------------------*/
 503:..\Source/queue.c **** 
 504:..\Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 505:..\Source/queue.c **** 
 506:..\Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 507:..\Source/queue.c **** 	{
 345              		.loc 1 507 0
 346              		.cfi_startproc
 347              		@ args = 0, pretend = 0, frame = 24
 348              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 16


 349 0000 80B5     		push	{r7, lr}
 350              		.cfi_def_cfa_offset 8
 351              		.cfi_offset 7, -8
 352              		.cfi_offset 14, -4
 353 0002 86B0     		sub	sp, sp, #24
 354              		.cfi_def_cfa_offset 32
 355 0004 00AF     		add	r7, sp, #0
 356              		.cfi_def_cfa_register 7
 357 0006 0346     		mov	r3, r0
 358 0008 FB71     		strb	r3, [r7, #7]
 508:..\Source/queue.c **** 	Queue_t *pxNewQueue;
 509:..\Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 359              		.loc 1 509 0
 360 000a 0123     		movs	r3, #1
 361 000c 7B61     		str	r3, [r7, #20]
 362 000e 0023     		movs	r3, #0
 363 0010 3B61     		str	r3, [r7, #16]
 510:..\Source/queue.c **** 
 511:..\Source/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 364              		.loc 1 511 0
 365 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 366 0014 7869     		ldr	r0, [r7, #20]
 367 0016 3969     		ldr	r1, [r7, #16]
 368 0018 1A46     		mov	r2, r3
 369 001a FFF7FEFF 		bl	xQueueGenericCreate
 370 001e F860     		str	r0, [r7, #12]
 512:..\Source/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 371              		.loc 1 512 0
 372 0020 F868     		ldr	r0, [r7, #12]
 373 0022 FFF7FEFF 		bl	prvInitialiseMutex
 513:..\Source/queue.c **** 
 514:..\Source/queue.c **** 		return pxNewQueue;
 374              		.loc 1 514 0
 375 0026 FB68     		ldr	r3, [r7, #12]
 515:..\Source/queue.c **** 	}
 376              		.loc 1 515 0
 377 0028 1846     		mov	r0, r3
 378 002a 1837     		adds	r7, r7, #24
 379              		.cfi_def_cfa_offset 8
 380 002c BD46     		mov	sp, r7
 381              		.cfi_def_cfa_register 13
 382              		@ sp needed
 383 002e 80BD     		pop	{r7, pc}
 384              		.cfi_endproc
 385              	.LFE72:
 386              		.size	xQueueCreateMutex, .-xQueueCreateMutex
 387              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 388              		.align	2
 389              		.global	xQueueGiveMutexRecursive
 390              		.thumb
 391              		.thumb_func
 392              		.type	xQueueGiveMutexRecursive, %function
 393              	xQueueGiveMutexRecursive:
 394              	.LFB73:
 516:..\Source/queue.c **** 
 517:..\Source/queue.c **** #endif /* configUSE_MUTEXES */
 518:..\Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 17


 519:..\Source/queue.c **** 
 520:..\Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 521:..\Source/queue.c **** 
 522:..\Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 523:..\Source/queue.c **** 	{
 524:..\Source/queue.c **** 	Queue_t *pxNewQueue;
 525:..\Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 526:..\Source/queue.c **** 
 527:..\Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 528:..\Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 529:..\Source/queue.c **** 		( void ) ucQueueType;
 530:..\Source/queue.c **** 
 531:..\Source/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQ
 532:..\Source/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 533:..\Source/queue.c **** 
 534:..\Source/queue.c **** 		return pxNewQueue;
 535:..\Source/queue.c **** 	}
 536:..\Source/queue.c **** 
 537:..\Source/queue.c **** #endif /* configUSE_MUTEXES */
 538:..\Source/queue.c **** /*-----------------------------------------------------------*/
 539:..\Source/queue.c **** 
 540:..\Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 541:..\Source/queue.c **** 
 542:..\Source/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 543:..\Source/queue.c **** 	{
 544:..\Source/queue.c **** 	void *pxReturn;
 545:..\Source/queue.c **** 
 546:..\Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 547:..\Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 548:..\Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 549:..\Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 550:..\Source/queue.c **** 		following critical section exiting and the function returning. */
 551:..\Source/queue.c **** 		taskENTER_CRITICAL();
 552:..\Source/queue.c **** 		{
 553:..\Source/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 554:..\Source/queue.c **** 			{
 555:..\Source/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 556:..\Source/queue.c **** 			}
 557:..\Source/queue.c **** 			else
 558:..\Source/queue.c **** 			{
 559:..\Source/queue.c **** 				pxReturn = NULL;
 560:..\Source/queue.c **** 			}
 561:..\Source/queue.c **** 		}
 562:..\Source/queue.c **** 		taskEXIT_CRITICAL();
 563:..\Source/queue.c **** 
 564:..\Source/queue.c **** 		return pxReturn;
 565:..\Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 566:..\Source/queue.c **** 
 567:..\Source/queue.c **** #endif
 568:..\Source/queue.c **** /*-----------------------------------------------------------*/
 569:..\Source/queue.c **** 
 570:..\Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 571:..\Source/queue.c **** 
 572:..\Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 573:..\Source/queue.c **** 	{
 395              		.loc 1 573 0
 396              		.cfi_startproc
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 18


 397              		@ args = 0, pretend = 0, frame = 16
 398              		@ frame_needed = 1, uses_anonymous_args = 0
 399 0000 90B5     		push	{r4, r7, lr}
 400              		.cfi_def_cfa_offset 12
 401              		.cfi_offset 4, -12
 402              		.cfi_offset 7, -8
 403              		.cfi_offset 14, -4
 404 0002 85B0     		sub	sp, sp, #20
 405              		.cfi_def_cfa_offset 32
 406 0004 00AF     		add	r7, sp, #0
 407              		.cfi_def_cfa_register 7
 408 0006 7860     		str	r0, [r7, #4]
 574:..\Source/queue.c **** 	BaseType_t xReturn;
 575:..\Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 409              		.loc 1 575 0
 410 0008 7B68     		ldr	r3, [r7, #4]
 411 000a BB60     		str	r3, [r7, #8]
 576:..\Source/queue.c **** 
 577:..\Source/queue.c **** 		configASSERT( pxMutex );
 578:..\Source/queue.c **** 
 579:..\Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 580:..\Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 581:..\Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 582:..\Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 583:..\Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 584:..\Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 585:..\Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 412              		.loc 1 585 0
 413 000c BB68     		ldr	r3, [r7, #8]
 414 000e 5C68     		ldr	r4, [r3, #4]
 415 0010 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 416 0014 0346     		mov	r3, r0
 417 0016 9C42     		cmp	r4, r3
 418 0018 11D1     		bne	.L20
 586:..\Source/queue.c **** 		{
 587:..\Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 588:..\Source/queue.c **** 
 589:..\Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 590:..\Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 591:..\Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 592:..\Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 593:..\Source/queue.c **** 			uxRecursiveCallCount member. */
 594:..\Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 419              		.loc 1 594 0
 420 001a BB68     		ldr	r3, [r7, #8]
 421 001c DB68     		ldr	r3, [r3, #12]
 422 001e 5A1E     		subs	r2, r3, #1
 423 0020 BB68     		ldr	r3, [r7, #8]
 424 0022 DA60     		str	r2, [r3, #12]
 595:..\Source/queue.c **** 
 596:..\Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 597:..\Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 425              		.loc 1 597 0
 426 0024 BB68     		ldr	r3, [r7, #8]
 427 0026 DB68     		ldr	r3, [r3, #12]
 428 0028 002B     		cmp	r3, #0
 429 002a 05D1     		bne	.L21
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 19


 598:..\Source/queue.c **** 			{
 599:..\Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 600:..\Source/queue.c **** 				task that might be waiting to access the mutex. */
 601:..\Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 430              		.loc 1 601 0
 431 002c B868     		ldr	r0, [r7, #8]
 432 002e 0021     		movs	r1, #0
 433 0030 0022     		movs	r2, #0
 434 0032 0023     		movs	r3, #0
 435 0034 FFF7FEFF 		bl	xQueueGenericSend
 436              	.L21:
 602:..\Source/queue.c **** 			}
 603:..\Source/queue.c **** 			else
 604:..\Source/queue.c **** 			{
 605:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 606:..\Source/queue.c **** 			}
 607:..\Source/queue.c **** 
 608:..\Source/queue.c **** 			xReturn = pdPASS;
 437              		.loc 1 608 0
 438 0038 0123     		movs	r3, #1
 439 003a FB60     		str	r3, [r7, #12]
 440 003c 01E0     		b	.L22
 441              	.L20:
 609:..\Source/queue.c **** 		}
 610:..\Source/queue.c **** 		else
 611:..\Source/queue.c **** 		{
 612:..\Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 613:..\Source/queue.c **** 			holder. */
 614:..\Source/queue.c **** 			xReturn = pdFAIL;
 442              		.loc 1 614 0
 443 003e 0023     		movs	r3, #0
 444 0040 FB60     		str	r3, [r7, #12]
 445              	.L22:
 615:..\Source/queue.c **** 
 616:..\Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 617:..\Source/queue.c **** 		}
 618:..\Source/queue.c **** 
 619:..\Source/queue.c **** 		return xReturn;
 446              		.loc 1 619 0
 447 0042 FB68     		ldr	r3, [r7, #12]
 620:..\Source/queue.c **** 	}
 448              		.loc 1 620 0
 449 0044 1846     		mov	r0, r3
 450 0046 1437     		adds	r7, r7, #20
 451              		.cfi_def_cfa_offset 12
 452 0048 BD46     		mov	sp, r7
 453              		.cfi_def_cfa_register 13
 454              		@ sp needed
 455 004a 90BD     		pop	{r4, r7, pc}
 456              		.cfi_endproc
 457              	.LFE73:
 458              		.size	xQueueGiveMutexRecursive, .-xQueueGiveMutexRecursive
 459              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 460              		.align	2
 461              		.global	xQueueTakeMutexRecursive
 462              		.thumb
 463              		.thumb_func
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 20


 464              		.type	xQueueTakeMutexRecursive, %function
 465              	xQueueTakeMutexRecursive:
 466              	.LFB74:
 621:..\Source/queue.c **** 
 622:..\Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 623:..\Source/queue.c **** /*-----------------------------------------------------------*/
 624:..\Source/queue.c **** 
 625:..\Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 626:..\Source/queue.c **** 
 627:..\Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 628:..\Source/queue.c **** 	{
 467              		.loc 1 628 0
 468              		.cfi_startproc
 469              		@ args = 0, pretend = 0, frame = 16
 470              		@ frame_needed = 1, uses_anonymous_args = 0
 471 0000 90B5     		push	{r4, r7, lr}
 472              		.cfi_def_cfa_offset 12
 473              		.cfi_offset 4, -12
 474              		.cfi_offset 7, -8
 475              		.cfi_offset 14, -4
 476 0002 85B0     		sub	sp, sp, #20
 477              		.cfi_def_cfa_offset 32
 478 0004 00AF     		add	r7, sp, #0
 479              		.cfi_def_cfa_register 7
 480 0006 7860     		str	r0, [r7, #4]
 481 0008 3960     		str	r1, [r7]
 629:..\Source/queue.c **** 	BaseType_t xReturn;
 630:..\Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 482              		.loc 1 630 0
 483 000a 7B68     		ldr	r3, [r7, #4]
 484 000c BB60     		str	r3, [r7, #8]
 631:..\Source/queue.c **** 
 632:..\Source/queue.c **** 		configASSERT( pxMutex );
 633:..\Source/queue.c **** 
 634:..\Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 635:..\Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 636:..\Source/queue.c **** 
 637:..\Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 638:..\Source/queue.c **** 
 639:..\Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 485              		.loc 1 639 0
 486 000e BB68     		ldr	r3, [r7, #8]
 487 0010 5C68     		ldr	r4, [r3, #4]
 488 0012 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 489 0016 0346     		mov	r3, r0
 490 0018 9C42     		cmp	r4, r3
 491 001a 07D1     		bne	.L25
 640:..\Source/queue.c **** 		{
 641:..\Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 492              		.loc 1 641 0
 493 001c BB68     		ldr	r3, [r7, #8]
 494 001e DB68     		ldr	r3, [r3, #12]
 495 0020 5A1C     		adds	r2, r3, #1
 496 0022 BB68     		ldr	r3, [r7, #8]
 497 0024 DA60     		str	r2, [r3, #12]
 642:..\Source/queue.c **** 			xReturn = pdPASS;
 498              		.loc 1 642 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 21


 499 0026 0123     		movs	r3, #1
 500 0028 FB60     		str	r3, [r7, #12]
 501 002a 0EE0     		b	.L26
 502              	.L25:
 643:..\Source/queue.c **** 		}
 644:..\Source/queue.c **** 		else
 645:..\Source/queue.c **** 		{
 646:..\Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 503              		.loc 1 646 0
 504 002c B868     		ldr	r0, [r7, #8]
 505 002e 0021     		movs	r1, #0
 506 0030 3A68     		ldr	r2, [r7]
 507 0032 0023     		movs	r3, #0
 508 0034 FFF7FEFF 		bl	xQueueGenericReceive
 509 0038 F860     		str	r0, [r7, #12]
 647:..\Source/queue.c **** 
 648:..\Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 649:..\Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 650:..\Source/queue.c **** 			before reaching here. */
 651:..\Source/queue.c **** 			if( xReturn != pdFAIL )
 510              		.loc 1 651 0
 511 003a FB68     		ldr	r3, [r7, #12]
 512 003c 002B     		cmp	r3, #0
 513 003e 04D0     		beq	.L26
 652:..\Source/queue.c **** 			{
 653:..\Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 514              		.loc 1 653 0
 515 0040 BB68     		ldr	r3, [r7, #8]
 516 0042 DB68     		ldr	r3, [r3, #12]
 517 0044 5A1C     		adds	r2, r3, #1
 518 0046 BB68     		ldr	r3, [r7, #8]
 519 0048 DA60     		str	r2, [r3, #12]
 520              	.L26:
 654:..\Source/queue.c **** 			}
 655:..\Source/queue.c **** 			else
 656:..\Source/queue.c **** 			{
 657:..\Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 658:..\Source/queue.c **** 			}
 659:..\Source/queue.c **** 		}
 660:..\Source/queue.c **** 
 661:..\Source/queue.c **** 		return xReturn;
 521              		.loc 1 661 0
 522 004a FB68     		ldr	r3, [r7, #12]
 662:..\Source/queue.c **** 	}
 523              		.loc 1 662 0
 524 004c 1846     		mov	r0, r3
 525 004e 1437     		adds	r7, r7, #20
 526              		.cfi_def_cfa_offset 12
 527 0050 BD46     		mov	sp, r7
 528              		.cfi_def_cfa_register 13
 529              		@ sp needed
 530 0052 90BD     		pop	{r4, r7, pc}
 531              		.cfi_endproc
 532              	.LFE74:
 533              		.size	xQueueTakeMutexRecursive, .-xQueueTakeMutexRecursive
 534              		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 535              		.align	2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 22


 536              		.global	xQueueCreateCountingSemaphore
 537              		.thumb
 538              		.thumb_func
 539              		.type	xQueueCreateCountingSemaphore, %function
 540              	xQueueCreateCountingSemaphore:
 541              	.LFB75:
 663:..\Source/queue.c **** 
 664:..\Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 665:..\Source/queue.c **** /*-----------------------------------------------------------*/
 666:..\Source/queue.c **** 
 667:..\Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 668:..\Source/queue.c **** 
 669:..\Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 670:..\Source/queue.c **** 	{
 671:..\Source/queue.c **** 	QueueHandle_t xHandle;
 672:..\Source/queue.c **** 
 673:..\Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 674:..\Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 675:..\Source/queue.c **** 
 676:..\Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 677:..\Source/queue.c **** 
 678:..\Source/queue.c **** 		if( xHandle != NULL )
 679:..\Source/queue.c **** 		{
 680:..\Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 681:..\Source/queue.c **** 
 682:..\Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 683:..\Source/queue.c **** 		}
 684:..\Source/queue.c **** 		else
 685:..\Source/queue.c **** 		{
 686:..\Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 687:..\Source/queue.c **** 		}
 688:..\Source/queue.c **** 
 689:..\Source/queue.c **** 		return xHandle;
 690:..\Source/queue.c **** 	}
 691:..\Source/queue.c **** 
 692:..\Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 693:..\Source/queue.c **** /*-----------------------------------------------------------*/
 694:..\Source/queue.c **** 
 695:..\Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 696:..\Source/queue.c **** 
 697:..\Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 698:..\Source/queue.c **** 	{
 542              		.loc 1 698 0
 543              		.cfi_startproc
 544              		@ args = 0, pretend = 0, frame = 16
 545              		@ frame_needed = 1, uses_anonymous_args = 0
 546 0000 80B5     		push	{r7, lr}
 547              		.cfi_def_cfa_offset 8
 548              		.cfi_offset 7, -8
 549              		.cfi_offset 14, -4
 550 0002 84B0     		sub	sp, sp, #16
 551              		.cfi_def_cfa_offset 24
 552 0004 00AF     		add	r7, sp, #0
 553              		.cfi_def_cfa_register 7
 554 0006 7860     		str	r0, [r7, #4]
 555 0008 3960     		str	r1, [r7]
 699:..\Source/queue.c **** 	QueueHandle_t xHandle;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 23


 700:..\Source/queue.c **** 
 701:..\Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 702:..\Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 703:..\Source/queue.c **** 
 704:..\Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 556              		.loc 1 704 0
 557 000a 7868     		ldr	r0, [r7, #4]
 558 000c 0021     		movs	r1, #0
 559 000e 0222     		movs	r2, #2
 560 0010 FFF7FEFF 		bl	xQueueGenericCreate
 561 0014 F860     		str	r0, [r7, #12]
 705:..\Source/queue.c **** 
 706:..\Source/queue.c **** 		if( xHandle != NULL )
 562              		.loc 1 706 0
 563 0016 FB68     		ldr	r3, [r7, #12]
 564 0018 002B     		cmp	r3, #0
 565 001a 02D0     		beq	.L29
 707:..\Source/queue.c **** 		{
 708:..\Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 566              		.loc 1 708 0
 567 001c FB68     		ldr	r3, [r7, #12]
 568 001e 3A68     		ldr	r2, [r7]
 569 0020 9A63     		str	r2, [r3, #56]
 570              	.L29:
 709:..\Source/queue.c **** 
 710:..\Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 711:..\Source/queue.c **** 		}
 712:..\Source/queue.c **** 		else
 713:..\Source/queue.c **** 		{
 714:..\Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 715:..\Source/queue.c **** 		}
 716:..\Source/queue.c **** 
 717:..\Source/queue.c **** 		return xHandle;
 571              		.loc 1 717 0
 572 0022 FB68     		ldr	r3, [r7, #12]
 718:..\Source/queue.c **** 	}
 573              		.loc 1 718 0
 574 0024 1846     		mov	r0, r3
 575 0026 1037     		adds	r7, r7, #16
 576              		.cfi_def_cfa_offset 8
 577 0028 BD46     		mov	sp, r7
 578              		.cfi_def_cfa_register 13
 579              		@ sp needed
 580 002a 80BD     		pop	{r7, pc}
 581              		.cfi_endproc
 582              	.LFE75:
 583              		.size	xQueueCreateCountingSemaphore, .-xQueueCreateCountingSemaphore
 584              		.section	.text.xQueueGenericSend,"ax",%progbits
 585              		.align	2
 586              		.global	xQueueGenericSend
 587              		.thumb
 588              		.thumb_func
 589              		.type	xQueueGenericSend, %function
 590              	xQueueGenericSend:
 591              	.LFB76:
 719:..\Source/queue.c **** 
 720:..\Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 24


 721:..\Source/queue.c **** /*-----------------------------------------------------------*/
 722:..\Source/queue.c **** 
 723:..\Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 724:..\Source/queue.c **** {
 592              		.loc 1 724 0
 593              		.cfi_startproc
 594              		@ args = 0, pretend = 0, frame = 40
 595              		@ frame_needed = 1, uses_anonymous_args = 0
 596 0000 80B5     		push	{r7, lr}
 597              		.cfi_def_cfa_offset 8
 598              		.cfi_offset 7, -8
 599              		.cfi_offset 14, -4
 600 0002 8AB0     		sub	sp, sp, #40
 601              		.cfi_def_cfa_offset 48
 602 0004 00AF     		add	r7, sp, #0
 603              		.cfi_def_cfa_register 7
 604 0006 F860     		str	r0, [r7, #12]
 605 0008 B960     		str	r1, [r7, #8]
 606 000a 7A60     		str	r2, [r7, #4]
 607 000c 3B60     		str	r3, [r7]
 725:..\Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 608              		.loc 1 725 0
 609 000e 0023     		movs	r3, #0
 610 0010 7B62     		str	r3, [r7, #36]
 726:..\Source/queue.c **** TimeOut_t xTimeOut;
 727:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 611              		.loc 1 727 0
 612 0012 FB68     		ldr	r3, [r7, #12]
 613 0014 3B62     		str	r3, [r7, #32]
 614              	.L46:
 728:..\Source/queue.c **** 
 729:..\Source/queue.c **** 	configASSERT( pxQueue );
 730:..\Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 731:..\Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 732:..\Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 733:..\Source/queue.c **** 	{
 734:..\Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 735:..\Source/queue.c **** 	}
 736:..\Source/queue.c **** 	#endif
 737:..\Source/queue.c **** 
 738:..\Source/queue.c **** 
 739:..\Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 740:..\Source/queue.c **** 	statements within the function itself.  This is done in the interest
 741:..\Source/queue.c **** 	of execution time efficiency. */
 742:..\Source/queue.c **** 	for( ;; )
 743:..\Source/queue.c **** 	{
 744:..\Source/queue.c **** 		taskENTER_CRITICAL();
 615              		.loc 1 744 0
 616 0016 FFF7FEFF 		bl	vPortEnterCritical
 745:..\Source/queue.c **** 		{
 746:..\Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 747:..\Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 748:..\Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 749:..\Source/queue.c **** 			queue is full. */
 750:..\Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 617              		.loc 1 750 0
 618 001a 3B6A     		ldr	r3, [r7, #32]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 25


 619 001c 9A6B     		ldr	r2, [r3, #56]
 620 001e 3B6A     		ldr	r3, [r7, #32]
 621 0020 DB6B     		ldr	r3, [r3, #60]
 622 0022 9A42     		cmp	r2, r3
 623 0024 02D3     		bcc	.L32
 624              		.loc 1 750 0 is_stmt 0 discriminator 1
 625 0026 3B68     		ldr	r3, [r7]
 626 0028 022B     		cmp	r3, #2
 627 002a 29D1     		bne	.L33
 628              	.L32:
 751:..\Source/queue.c **** 			{
 752:..\Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 753:..\Source/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 629              		.loc 1 753 0 is_stmt 1
 630 002c 386A     		ldr	r0, [r7, #32]
 631 002e B968     		ldr	r1, [r7, #8]
 632 0030 3A68     		ldr	r2, [r7]
 633 0032 FFF7FEFF 		bl	prvCopyDataToQueue
 634 0036 F861     		str	r0, [r7, #28]
 754:..\Source/queue.c **** 
 755:..\Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 756:..\Source/queue.c **** 				{
 757:..\Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 758:..\Source/queue.c **** 					{
 759:..\Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 760:..\Source/queue.c **** 						{
 761:..\Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 762:..\Source/queue.c **** 							to the queue set caused a higher priority task to
 763:..\Source/queue.c **** 							unblock. A context switch is required. */
 764:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 765:..\Source/queue.c **** 						}
 766:..\Source/queue.c **** 						else
 767:..\Source/queue.c **** 						{
 768:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 769:..\Source/queue.c **** 						}
 770:..\Source/queue.c **** 					}
 771:..\Source/queue.c **** 					else
 772:..\Source/queue.c **** 					{
 773:..\Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 774:..\Source/queue.c **** 						queue then unblock it now. */
 775:..\Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 776:..\Source/queue.c **** 						{
 777:..\Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 778:..\Source/queue.c **** 							{
 779:..\Source/queue.c **** 								/* The unblocked task has a priority higher than
 780:..\Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 781:..\Source/queue.c **** 								do this from within the critical section - the
 782:..\Source/queue.c **** 								kernel takes care of that. */
 783:..\Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 784:..\Source/queue.c **** 							}
 785:..\Source/queue.c **** 							else
 786:..\Source/queue.c **** 							{
 787:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 788:..\Source/queue.c **** 							}
 789:..\Source/queue.c **** 						}
 790:..\Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 791:..\Source/queue.c **** 						{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 26


 792:..\Source/queue.c **** 							/* This path is a special case that will only get
 793:..\Source/queue.c **** 							executed if the task was holding multiple mutexes
 794:..\Source/queue.c **** 							and the mutexes were given back in an order that is
 795:..\Source/queue.c **** 							different to that in which they were taken. */
 796:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 797:..\Source/queue.c **** 						}
 798:..\Source/queue.c **** 						else
 799:..\Source/queue.c **** 						{
 800:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 801:..\Source/queue.c **** 						}
 802:..\Source/queue.c **** 					}
 803:..\Source/queue.c **** 				}
 804:..\Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 805:..\Source/queue.c **** 				{
 806:..\Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 807:..\Source/queue.c **** 					queue then unblock it now. */
 808:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 635              		.loc 1 808 0
 636 0038 3B6A     		ldr	r3, [r7, #32]
 637 003a 5B6A     		ldr	r3, [r3, #36]
 638 003c 002B     		cmp	r3, #0
 639 003e 10D0     		beq	.L34
 809:..\Source/queue.c **** 					{
 810:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 640              		.loc 1 810 0
 641 0040 3B6A     		ldr	r3, [r7, #32]
 642 0042 2433     		adds	r3, r3, #36
 643 0044 1846     		mov	r0, r3
 644 0046 FFF7FEFF 		bl	xTaskRemoveFromEventList
 645 004a 0346     		mov	r3, r0
 646 004c 002B     		cmp	r3, #0
 647 004e 13D0     		beq	.L35
 811:..\Source/queue.c **** 						{
 812:..\Source/queue.c **** 							/* The unblocked task has a priority higher than
 813:..\Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 814:..\Source/queue.c **** 							this from within the critical section - the kernel
 815:..\Source/queue.c **** 							takes care of that. */
 816:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 648              		.loc 1 816 0
 649 0050 414B     		ldr	r3, .L48
 650 0052 4FF08052 		mov	r2, #268435456
 651 0056 1A60     		str	r2, [r3]
 652              	@ 816 "..\Source\queue.c" 1
 653 0058 BFF34F8F 		dsb
 654              	@ 0 "" 2
 655              	@ 816 "..\Source\queue.c" 1
 656 005c BFF36F8F 		isb
 657              	@ 0 "" 2
 658              		.thumb
 659 0060 0AE0     		b	.L35
 660              	.L34:
 817:..\Source/queue.c **** 						}
 818:..\Source/queue.c **** 						else
 819:..\Source/queue.c **** 						{
 820:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 821:..\Source/queue.c **** 						}
 822:..\Source/queue.c **** 					}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 27


 823:..\Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 661              		.loc 1 823 0
 662 0062 FB69     		ldr	r3, [r7, #28]
 663 0064 002B     		cmp	r3, #0
 664 0066 07D0     		beq	.L35
 824:..\Source/queue.c **** 					{
 825:..\Source/queue.c **** 						/* This path is a special case that will only get
 826:..\Source/queue.c **** 						executed if the task was holding multiple mutexes and
 827:..\Source/queue.c **** 						the mutexes were given back in an order that is
 828:..\Source/queue.c **** 						different to that in which they were taken. */
 829:..\Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 665              		.loc 1 829 0
 666 0068 3B4B     		ldr	r3, .L48
 667 006a 4FF08052 		mov	r2, #268435456
 668 006e 1A60     		str	r2, [r3]
 669              	@ 829 "..\Source\queue.c" 1
 670 0070 BFF34F8F 		dsb
 671              	@ 0 "" 2
 672              	@ 829 "..\Source\queue.c" 1
 673 0074 BFF36F8F 		isb
 674              	@ 0 "" 2
 675              		.thumb
 676              	.L35:
 830:..\Source/queue.c **** 					}
 831:..\Source/queue.c **** 					else
 832:..\Source/queue.c **** 					{
 833:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 834:..\Source/queue.c **** 					}
 835:..\Source/queue.c **** 				}
 836:..\Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 837:..\Source/queue.c **** 
 838:..\Source/queue.c **** 				taskEXIT_CRITICAL();
 677              		.loc 1 838 0
 678 0078 FFF7FEFF 		bl	vPortExitCritical
 839:..\Source/queue.c **** 				return pdPASS;
 679              		.loc 1 839 0
 680 007c 0123     		movs	r3, #1
 681 007e 67E0     		b	.L47
 682              	.L33:
 840:..\Source/queue.c **** 			}
 841:..\Source/queue.c **** 			else
 842:..\Source/queue.c **** 			{
 843:..\Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 683              		.loc 1 843 0
 684 0080 7B68     		ldr	r3, [r7, #4]
 685 0082 002B     		cmp	r3, #0
 686 0084 03D1     		bne	.L37
 844:..\Source/queue.c **** 				{
 845:..\Source/queue.c **** 					/* The queue was full and no block time is specified (or
 846:..\Source/queue.c **** 					the block time has expired) so leave now. */
 847:..\Source/queue.c **** 					taskEXIT_CRITICAL();
 687              		.loc 1 847 0
 688 0086 FFF7FEFF 		bl	vPortExitCritical
 848:..\Source/queue.c **** 
 849:..\Source/queue.c **** 					/* Return to the original privilege level before exiting
 850:..\Source/queue.c **** 					the function. */
 851:..\Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 28


 852:..\Source/queue.c **** 					return errQUEUE_FULL;
 689              		.loc 1 852 0
 690 008a 0023     		movs	r3, #0
 691 008c 60E0     		b	.L47
 692              	.L37:
 853:..\Source/queue.c **** 				}
 854:..\Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 693              		.loc 1 854 0
 694 008e 7B6A     		ldr	r3, [r7, #36]
 695 0090 002B     		cmp	r3, #0
 696 0092 06D1     		bne	.L38
 855:..\Source/queue.c **** 				{
 856:..\Source/queue.c **** 					/* The queue was full and a block time was specified so
 857:..\Source/queue.c **** 					configure the timeout structure. */
 858:..\Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 697              		.loc 1 858 0
 698 0094 07F11403 		add	r3, r7, #20
 699 0098 1846     		mov	r0, r3
 700 009a FFF7FEFF 		bl	vTaskSetTimeOutState
 859:..\Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 701              		.loc 1 859 0
 702 009e 0123     		movs	r3, #1
 703 00a0 7B62     		str	r3, [r7, #36]
 704              	.L38:
 860:..\Source/queue.c **** 				}
 861:..\Source/queue.c **** 				else
 862:..\Source/queue.c **** 				{
 863:..\Source/queue.c **** 					/* Entry time was already set. */
 864:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 865:..\Source/queue.c **** 				}
 866:..\Source/queue.c **** 			}
 867:..\Source/queue.c **** 		}
 868:..\Source/queue.c **** 		taskEXIT_CRITICAL();
 705              		.loc 1 868 0
 706 00a2 FFF7FEFF 		bl	vPortExitCritical
 869:..\Source/queue.c **** 
 870:..\Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 871:..\Source/queue.c **** 		now the critical section has been exited. */
 872:..\Source/queue.c **** 
 873:..\Source/queue.c **** 		vTaskSuspendAll();
 707              		.loc 1 873 0
 708 00a6 FFF7FEFF 		bl	vTaskSuspendAll
 874:..\Source/queue.c **** 		prvLockQueue( pxQueue );
 709              		.loc 1 874 0
 710 00aa FFF7FEFF 		bl	vPortEnterCritical
 711 00ae 3B6A     		ldr	r3, [r7, #32]
 712 00b0 93F84430 		ldrb	r3, [r3, #68]
 713 00b4 DBB2     		uxtb	r3, r3
 714 00b6 5BB2     		sxtb	r3, r3
 715 00b8 B3F1FF3F 		cmp	r3, #-1
 716 00bc 03D1     		bne	.L39
 717              		.loc 1 874 0 is_stmt 0 discriminator 1
 718 00be 3B6A     		ldr	r3, [r7, #32]
 719 00c0 0022     		movs	r2, #0
 720 00c2 83F84420 		strb	r2, [r3, #68]
 721              	.L39:
 722              		.loc 1 874 0 discriminator 3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 29


 723 00c6 3B6A     		ldr	r3, [r7, #32]
 724 00c8 93F84530 		ldrb	r3, [r3, #69]
 725 00cc DBB2     		uxtb	r3, r3
 726 00ce 5BB2     		sxtb	r3, r3
 727 00d0 B3F1FF3F 		cmp	r3, #-1
 728 00d4 03D1     		bne	.L40
 729              		.loc 1 874 0 discriminator 4
 730 00d6 3B6A     		ldr	r3, [r7, #32]
 731 00d8 0022     		movs	r2, #0
 732 00da 83F84520 		strb	r2, [r3, #69]
 733              	.L40:
 734              		.loc 1 874 0 discriminator 6
 735 00de FFF7FEFF 		bl	vPortExitCritical
 875:..\Source/queue.c **** 
 876:..\Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 877:..\Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 736              		.loc 1 877 0 is_stmt 1 discriminator 6
 737 00e2 07F11402 		add	r2, r7, #20
 738 00e6 3B1D     		adds	r3, r7, #4
 739 00e8 1046     		mov	r0, r2
 740 00ea 1946     		mov	r1, r3
 741 00ec FFF7FEFF 		bl	xTaskCheckForTimeOut
 742 00f0 0346     		mov	r3, r0
 743 00f2 002B     		cmp	r3, #0
 744 00f4 24D1     		bne	.L41
 878:..\Source/queue.c **** 		{
 879:..\Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 745              		.loc 1 879 0
 746 00f6 386A     		ldr	r0, [r7, #32]
 747 00f8 FFF7FEFF 		bl	prvIsQueueFull
 748 00fc 0346     		mov	r3, r0
 749 00fe 002B     		cmp	r3, #0
 750 0100 18D0     		beq	.L42
 880:..\Source/queue.c **** 			{
 881:..\Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 882:..\Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 751              		.loc 1 882 0
 752 0102 3B6A     		ldr	r3, [r7, #32]
 753 0104 03F11002 		add	r2, r3, #16
 754 0108 7B68     		ldr	r3, [r7, #4]
 755 010a 1046     		mov	r0, r2
 756 010c 1946     		mov	r1, r3
 757 010e FFF7FEFF 		bl	vTaskPlaceOnEventList
 883:..\Source/queue.c **** 
 884:..\Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 885:..\Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 886:..\Source/queue.c **** 				remove this task from the event	list again - but as the
 887:..\Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 888:..\Source/queue.c **** 				ready last instead of the actual ready list. */
 889:..\Source/queue.c **** 				prvUnlockQueue( pxQueue );
 758              		.loc 1 889 0
 759 0112 386A     		ldr	r0, [r7, #32]
 760 0114 FFF7FEFF 		bl	prvUnlockQueue
 890:..\Source/queue.c **** 
 891:..\Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 892:..\Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 893:..\Source/queue.c **** 				task is already in a ready list before it yields - in which
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 30


 894:..\Source/queue.c **** 				case the yield will not cause a context switch unless there
 895:..\Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 896:..\Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 761              		.loc 1 896 0
 762 0118 FFF7FEFF 		bl	xTaskResumeAll
 763 011c 0346     		mov	r3, r0
 764 011e 002B     		cmp	r3, #0
 765 0120 15D1     		bne	.L45
 897:..\Source/queue.c **** 				{
 898:..\Source/queue.c **** 					portYIELD_WITHIN_API();
 766              		.loc 1 898 0
 767 0122 0D4B     		ldr	r3, .L48
 768 0124 4FF08052 		mov	r2, #268435456
 769 0128 1A60     		str	r2, [r3]
 770              	@ 898 "..\Source\queue.c" 1
 771 012a BFF34F8F 		dsb
 772              	@ 0 "" 2
 773              	@ 898 "..\Source\queue.c" 1
 774 012e BFF36F8F 		isb
 775              	@ 0 "" 2
 776              		.thumb
 777 0132 0CE0     		b	.L45
 778              	.L42:
 899:..\Source/queue.c **** 				}
 900:..\Source/queue.c **** 			}
 901:..\Source/queue.c **** 			else
 902:..\Source/queue.c **** 			{
 903:..\Source/queue.c **** 				/* Try again. */
 904:..\Source/queue.c **** 				prvUnlockQueue( pxQueue );
 779              		.loc 1 904 0
 780 0134 386A     		ldr	r0, [r7, #32]
 781 0136 FFF7FEFF 		bl	prvUnlockQueue
 905:..\Source/queue.c **** 				( void ) xTaskResumeAll();
 782              		.loc 1 905 0
 783 013a FFF7FEFF 		bl	xTaskResumeAll
 784 013e 6AE7     		b	.L46
 785              	.L41:
 906:..\Source/queue.c **** 			}
 907:..\Source/queue.c **** 		}
 908:..\Source/queue.c **** 		else
 909:..\Source/queue.c **** 		{
 910:..\Source/queue.c **** 			/* The timeout has expired. */
 911:..\Source/queue.c **** 			prvUnlockQueue( pxQueue );
 786              		.loc 1 911 0
 787 0140 386A     		ldr	r0, [r7, #32]
 788 0142 FFF7FEFF 		bl	prvUnlockQueue
 912:..\Source/queue.c **** 			( void ) xTaskResumeAll();
 789              		.loc 1 912 0
 790 0146 FFF7FEFF 		bl	xTaskResumeAll
 913:..\Source/queue.c **** 
 914:..\Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 915:..\Source/queue.c **** 			return errQUEUE_FULL;
 791              		.loc 1 915 0
 792 014a 0023     		movs	r3, #0
 793 014c 00E0     		b	.L47
 794              	.L45:
 916:..\Source/queue.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 31


 917:..\Source/queue.c **** 	}
 795              		.loc 1 917 0 discriminator 2
 796 014e 62E7     		b	.L46
 797              	.L47:
 918:..\Source/queue.c **** }
 798              		.loc 1 918 0 discriminator 3
 799 0150 1846     		mov	r0, r3
 800 0152 2837     		adds	r7, r7, #40
 801              		.cfi_def_cfa_offset 8
 802 0154 BD46     		mov	sp, r7
 803              		.cfi_def_cfa_register 13
 804              		@ sp needed
 805 0156 80BD     		pop	{r7, pc}
 806              	.L49:
 807              		.align	2
 808              	.L48:
 809 0158 04ED00E0 		.word	-536810236
 810              		.cfi_endproc
 811              	.LFE76:
 812              		.size	xQueueGenericSend, .-xQueueGenericSend
 813              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 814              		.align	2
 815              		.global	xQueueGenericSendFromISR
 816              		.thumb
 817              		.thumb_func
 818              		.type	xQueueGenericSendFromISR, %function
 819              	xQueueGenericSendFromISR:
 820              	.LFB77:
 919:..\Source/queue.c **** /*-----------------------------------------------------------*/
 920:..\Source/queue.c **** 
 921:..\Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 922:..\Source/queue.c **** {
 821              		.loc 1 922 0
 822              		.cfi_startproc
 823              		@ args = 0, pretend = 0, frame = 48
 824              		@ frame_needed = 1, uses_anonymous_args = 0
 825 0000 80B5     		push	{r7, lr}
 826              		.cfi_def_cfa_offset 8
 827              		.cfi_offset 7, -8
 828              		.cfi_offset 14, -4
 829 0002 8CB0     		sub	sp, sp, #48
 830              		.cfi_def_cfa_offset 56
 831 0004 00AF     		add	r7, sp, #0
 832              		.cfi_def_cfa_register 7
 833 0006 F860     		str	r0, [r7, #12]
 834 0008 B960     		str	r1, [r7, #8]
 835 000a 7A60     		str	r2, [r7, #4]
 836 000c 3B60     		str	r3, [r7]
 923:..\Source/queue.c **** BaseType_t xReturn;
 924:..\Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 925:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 837              		.loc 1 925 0
 838 000e FB68     		ldr	r3, [r7, #12]
 839 0010 BB62     		str	r3, [r7, #40]
 840              	.LBB23:
 841              	.LBB24:
 842              		.file 2 "..\\Source\\portable\\GCC\\ARM_CM3/portmacro.h"
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 32


   1:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*
   2:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     All rights reserved
   4:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
   5:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
   7:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     This file is part of the FreeRTOS distribution.
   8:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
   9:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     the terms of the GNU General Public License (version 2) as published by the
  11:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  13:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  14:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  19:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  20:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     link: http://www.freertos.org/a00114.html
  24:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  25:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  26:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  27:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    robust, strictly quality controlled, supported, and cross          *
  29:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    platform software that is more than just the market leader, it     *
  30:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    is the industry's de facto standard.                               *
  31:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  32:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    Help yourself get started quickly while simultaneously helping     *
  33:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    tutorial book, reference manual, or both:                          *
  35:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  37:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  38:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  39:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     defined configASSERT()?
  42:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  43:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     embedded software for free we request you assist our global community by
  45:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     participating in the support forum.
  46:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  47:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     be as productive as possible as early as possible.  Now you can receive
  49:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  52:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  56:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 33


  58:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  59:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  63:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     engineered and independently SIL3 certified version for use in safety and
  65:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     mission critical applications that require provable dependability.
  66:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  67:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     1 tab == 4 spaces!
  68:..\Source\portable\GCC\ARM_CM3/portmacro.h **** */
  69:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  70:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  71:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  72:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define PORTMACRO_H
  73:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  74:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef __cplusplus
  75:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern "C" {
  76:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  77:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  78:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  79:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Port specific definitions.
  80:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  81:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  82:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * given hardware and compiler.
  83:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  84:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * These settings should not be altered.
  85:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  86:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  87:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  88:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Type definitions. */
  89:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCHAR		char
  90:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portFLOAT		float
  91:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDOUBLE		double
  92:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portLONG		long
  93:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSHORT		short
  94:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  95:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  96:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  97:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  98:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef long BaseType_t;
  99:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
 100:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 101:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
 102:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
 103:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
 104:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #else
 105:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
 106:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
 107:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 108:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
 109:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
 110:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
 111:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 112:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 113:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 114:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specifics. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 34


 115:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
 116:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
 117:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
 118:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 119:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 120:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Scheduler utilities. */
 121:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD() 															\
 122:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {																				\
 123:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
 124:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
 125:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 																				\
 126:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
 127:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
 128:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" );													\
 129:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
 130:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 131:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 132:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
 133:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
 134:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
 135:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
 136:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 137:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 138:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Critical section management. */
 139:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
 140:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
 141:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 142:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 143:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 144:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 145:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 146:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 147:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 148:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 149:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 150:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 151:..\Source\portable\GCC\ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 152:..\Source\portable\GCC\ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 153:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 154:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 155:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 156:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 157:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 158:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 159:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 160:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 161:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 162:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 163:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 164:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 165:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 166:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 167:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 168:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 169:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 170:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 171:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Generic helper function. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 35


 172:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 173:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 174:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 175:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 176:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 177:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		return ucReturn;
 178:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 179:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 180:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 181:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 182:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 183:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#endif
 184:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 185:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 186:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 187:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 188:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 189:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 190:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 191:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 192:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 193:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 194:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 195:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 196:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 197:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef configASSERT
 198:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 199:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 200:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 201:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 202:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 203:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNOP()
 204:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 205:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portINLINE	__inline
 206:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 207:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 208:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 209:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 210:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 211:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 212:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 213:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 214:..\Source\portable\GCC\ARM_CM3/portmacro.h **** BaseType_t xReturn;
 215:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 216:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 217:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 218:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 219:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 220:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 221:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 222:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 223:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	else
 224:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 225:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 226:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 227:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 228:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return xReturn;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 36


 229:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 230:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 231:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 232:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 233:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 234:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 235:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 236:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 237:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 238:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 239:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n"	\
 240:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 241:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 242:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 243:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 244:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 245:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 246:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 247:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 248:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 249:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 250:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 251:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 252:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 843              		.loc 2 253 0
 844              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 845 0012 EFF31182 			mrs r2, basepri											
 846 0016 4FF0A003 		mov r3, #160												
 847 001a 83F31188 		msr basepri, r3											
 848 001e BFF36F8F 		isb														
 849 0022 BFF34F8F 		dsb														
 850              	
 851              	@ 0 "" 2
 852              		.thumb
 853 0026 FA61     		str	r2, [r7, #28]
 854 0028 BB61     		str	r3, [r7, #24]
 254:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 255:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 256:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n"	\
 257:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 258:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 259:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 260:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 261:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 262:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 263:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 264:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	warnings. */
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 855              		.loc 2 265 0
 856 002a FB69     		ldr	r3, [r7, #28]
 857              	.LBE24:
 858              	.LBE23:
 926:..\Source/queue.c **** 
 927:..\Source/queue.c **** 	configASSERT( pxQueue );
 928:..\Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 929:..\Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 37


 930:..\Source/queue.c **** 
 931:..\Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 932:..\Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 933:..\Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 934:..\Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 935:..\Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 936:..\Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 937:..\Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 938:..\Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 939:..\Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 940:..\Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 941:..\Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 942:..\Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 943:..\Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 944:..\Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 945:..\Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 946:..\Source/queue.c **** 
 947:..\Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 948:..\Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 949:..\Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 950:..\Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 951:..\Source/queue.c **** 	post). */
 952:..\Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 859              		.loc 1 952 0
 860 002c 7B62     		str	r3, [r7, #36]
 953:..\Source/queue.c **** 	{
 954:..\Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 861              		.loc 1 954 0
 862 002e BB6A     		ldr	r3, [r7, #40]
 863 0030 9A6B     		ldr	r2, [r3, #56]
 864 0032 BB6A     		ldr	r3, [r7, #40]
 865 0034 DB6B     		ldr	r3, [r3, #60]
 866 0036 9A42     		cmp	r2, r3
 867 0038 02D3     		bcc	.L52
 868              		.loc 1 954 0 is_stmt 0 discriminator 1
 869 003a 3B68     		ldr	r3, [r7]
 870 003c 022B     		cmp	r3, #2
 871 003e 2CD1     		bne	.L53
 872              	.L52:
 873              	.LBB25:
 955:..\Source/queue.c **** 		{
 956:..\Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 874              		.loc 1 956 0 is_stmt 1
 875 0040 BB6A     		ldr	r3, [r7, #40]
 876 0042 93F84530 		ldrb	r3, [r3, #69]
 877 0046 87F82330 		strb	r3, [r7, #35]
 957:..\Source/queue.c **** 
 958:..\Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 959:..\Source/queue.c **** 
 960:..\Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 961:..\Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 962:..\Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 963:..\Source/queue.c **** 			called here even though the disinherit function does not check if
 964:..\Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 965:..\Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 878              		.loc 1 965 0
 879 004a B86A     		ldr	r0, [r7, #40]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 38


 880 004c B968     		ldr	r1, [r7, #8]
 881 004e 3A68     		ldr	r2, [r7]
 882 0050 FFF7FEFF 		bl	prvCopyDataToQueue
 966:..\Source/queue.c **** 
 967:..\Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 968:..\Source/queue.c **** 			be done when the queue is unlocked later. */
 969:..\Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 883              		.loc 1 969 0
 884 0054 97F92330 		ldrsb	r3, [r7, #35]
 885 0058 B3F1FF3F 		cmp	r3, #-1
 886 005c 12D1     		bne	.L54
 970:..\Source/queue.c **** 			{
 971:..\Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 972:..\Source/queue.c **** 				{
 973:..\Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 974:..\Source/queue.c **** 					{
 975:..\Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 976:..\Source/queue.c **** 						{
 977:..\Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 978:..\Source/queue.c **** 							to the queue set caused a higher priority task to
 979:..\Source/queue.c **** 							unblock.  A context switch is required. */
 980:..\Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 981:..\Source/queue.c **** 							{
 982:..\Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 983:..\Source/queue.c **** 							}
 984:..\Source/queue.c **** 							else
 985:..\Source/queue.c **** 							{
 986:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 987:..\Source/queue.c **** 							}
 988:..\Source/queue.c **** 						}
 989:..\Source/queue.c **** 						else
 990:..\Source/queue.c **** 						{
 991:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 992:..\Source/queue.c **** 						}
 993:..\Source/queue.c **** 					}
 994:..\Source/queue.c **** 					else
 995:..\Source/queue.c **** 					{
 996:..\Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 997:..\Source/queue.c **** 						{
 998:..\Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 999:..\Source/queue.c **** 							{
1000:..\Source/queue.c **** 								/* The task waiting has a higher priority so
1001:..\Source/queue.c **** 								record that a context switch is required. */
1002:..\Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1003:..\Source/queue.c **** 								{
1004:..\Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1005:..\Source/queue.c **** 								}
1006:..\Source/queue.c **** 								else
1007:..\Source/queue.c **** 								{
1008:..\Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1009:..\Source/queue.c **** 								}
1010:..\Source/queue.c **** 							}
1011:..\Source/queue.c **** 							else
1012:..\Source/queue.c **** 							{
1013:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1014:..\Source/queue.c **** 							}
1015:..\Source/queue.c **** 						}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 39


1016:..\Source/queue.c **** 						else
1017:..\Source/queue.c **** 						{
1018:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1019:..\Source/queue.c **** 						}
1020:..\Source/queue.c **** 					}
1021:..\Source/queue.c **** 				}
1022:..\Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1023:..\Source/queue.c **** 				{
1024:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 887              		.loc 1 1024 0
 888 005e BB6A     		ldr	r3, [r7, #40]
 889 0060 5B6A     		ldr	r3, [r3, #36]
 890 0062 002B     		cmp	r3, #0
 891 0064 16D0     		beq	.L55
1025:..\Source/queue.c **** 					{
1026:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 892              		.loc 1 1026 0
 893 0066 BB6A     		ldr	r3, [r7, #40]
 894 0068 2433     		adds	r3, r3, #36
 895 006a 1846     		mov	r0, r3
 896 006c FFF7FEFF 		bl	xTaskRemoveFromEventList
 897 0070 0346     		mov	r3, r0
 898 0072 002B     		cmp	r3, #0
 899 0074 0ED0     		beq	.L55
1027:..\Source/queue.c **** 						{
1028:..\Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1029:..\Source/queue.c **** 							context	switch is required. */
1030:..\Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 900              		.loc 1 1030 0
 901 0076 7B68     		ldr	r3, [r7, #4]
 902 0078 002B     		cmp	r3, #0
 903 007a 0BD0     		beq	.L55
1031:..\Source/queue.c **** 							{
1032:..\Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 904              		.loc 1 1032 0
 905 007c 7B68     		ldr	r3, [r7, #4]
 906 007e 0122     		movs	r2, #1
 907 0080 1A60     		str	r2, [r3]
 908 0082 07E0     		b	.L55
 909              	.L54:
1033:..\Source/queue.c **** 							}
1034:..\Source/queue.c **** 							else
1035:..\Source/queue.c **** 							{
1036:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1037:..\Source/queue.c **** 							}
1038:..\Source/queue.c **** 						}
1039:..\Source/queue.c **** 						else
1040:..\Source/queue.c **** 						{
1041:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1042:..\Source/queue.c **** 						}
1043:..\Source/queue.c **** 					}
1044:..\Source/queue.c **** 					else
1045:..\Source/queue.c **** 					{
1046:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1047:..\Source/queue.c **** 					}
1048:..\Source/queue.c **** 				}
1049:..\Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 40


1050:..\Source/queue.c **** 			}
1051:..\Source/queue.c **** 			else
1052:..\Source/queue.c **** 			{
1053:..\Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1054:..\Source/queue.c **** 				knows that data was posted while it was locked. */
1055:..\Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 910              		.loc 1 1055 0
 911 0084 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 912 0088 0133     		adds	r3, r3, #1
 913 008a DBB2     		uxtb	r3, r3
 914 008c DAB2     		uxtb	r2, r3
 915 008e BB6A     		ldr	r3, [r7, #40]
 916 0090 83F84520 		strb	r2, [r3, #69]
 917              	.L55:
1056:..\Source/queue.c **** 			}
1057:..\Source/queue.c **** 
1058:..\Source/queue.c **** 			xReturn = pdPASS;
 918              		.loc 1 1058 0
 919 0094 0123     		movs	r3, #1
 920 0096 FB62     		str	r3, [r7, #44]
 921              	.LBE25:
 955:..\Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 922              		.loc 1 955 0
 923 0098 01E0     		b	.L56
 924              	.L53:
1059:..\Source/queue.c **** 		}
1060:..\Source/queue.c **** 		else
1061:..\Source/queue.c **** 		{
1062:..\Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1063:..\Source/queue.c **** 			xReturn = errQUEUE_FULL;
 925              		.loc 1 1063 0
 926 009a 0023     		movs	r3, #0
 927 009c FB62     		str	r3, [r7, #44]
 928              	.L56:
 929 009e 7B6A     		ldr	r3, [r7, #36]
 930 00a0 7B61     		str	r3, [r7, #20]
 931              	.LBB26:
 932              	.LBB27:
 266:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 267:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 268:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 269:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 270:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 271:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 933              		.loc 2 271 0
 934 00a2 7B69     		ldr	r3, [r7, #20]
 935              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 936 00a4 83F31188 			msr basepri, r3	
 937              	@ 0 "" 2
 938              		.thumb
 939              	.LBE27:
 940              	.LBE26:
1064:..\Source/queue.c **** 		}
1065:..\Source/queue.c **** 	}
1066:..\Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1067:..\Source/queue.c **** 
1068:..\Source/queue.c **** 	return xReturn;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 41


 941              		.loc 1 1068 0
 942 00a8 FB6A     		ldr	r3, [r7, #44]
1069:..\Source/queue.c **** }
 943              		.loc 1 1069 0
 944 00aa 1846     		mov	r0, r3
 945 00ac 3037     		adds	r7, r7, #48
 946              		.cfi_def_cfa_offset 8
 947 00ae BD46     		mov	sp, r7
 948              		.cfi_def_cfa_register 13
 949              		@ sp needed
 950 00b0 80BD     		pop	{r7, pc}
 951              		.cfi_endproc
 952              	.LFE77:
 953              		.size	xQueueGenericSendFromISR, .-xQueueGenericSendFromISR
 954 00b2 00BF     		.section	.text.xQueueGiveFromISR,"ax",%progbits
 955              		.align	2
 956              		.global	xQueueGiveFromISR
 957              		.thumb
 958              		.thumb_func
 959              		.type	xQueueGiveFromISR, %function
 960              	xQueueGiveFromISR:
 961              	.LFB78:
1070:..\Source/queue.c **** /*-----------------------------------------------------------*/
1071:..\Source/queue.c **** 
1072:..\Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1073:..\Source/queue.c **** {
 962              		.loc 1 1073 0
 963              		.cfi_startproc
 964              		@ args = 0, pretend = 0, frame = 40
 965              		@ frame_needed = 1, uses_anonymous_args = 0
 966 0000 80B5     		push	{r7, lr}
 967              		.cfi_def_cfa_offset 8
 968              		.cfi_offset 7, -8
 969              		.cfi_offset 14, -4
 970 0002 8AB0     		sub	sp, sp, #40
 971              		.cfi_def_cfa_offset 48
 972 0004 00AF     		add	r7, sp, #0
 973              		.cfi_def_cfa_register 7
 974 0006 7860     		str	r0, [r7, #4]
 975 0008 3960     		str	r1, [r7]
1074:..\Source/queue.c **** BaseType_t xReturn;
1075:..\Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1076:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 976              		.loc 1 1076 0
 977 000a 7B68     		ldr	r3, [r7, #4]
 978 000c 3B62     		str	r3, [r7, #32]
 979              	.LBB28:
 980              	.LBB29:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 981              		.loc 2 253 0
 982              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 983 000e EFF31182 			mrs r2, basepri											
 984 0012 4FF0A003 		mov r3, #160												
 985 0016 83F31188 		msr basepri, r3											
 986 001a BFF36F8F 		isb														
 987 001e BFF34F8F 		dsb														
 988              	
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 42


 989              	@ 0 "" 2
 990              		.thumb
 991 0022 3A61     		str	r2, [r7, #16]
 992 0024 FB60     		str	r3, [r7, #12]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 993              		.loc 2 265 0
 994 0026 3B69     		ldr	r3, [r7, #16]
 995              	.LBE29:
 996              	.LBE28:
1077:..\Source/queue.c **** 
1078:..\Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1079:..\Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1080:..\Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1081:..\Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1082:..\Source/queue.c **** 	post). */
1083:..\Source/queue.c **** 
1084:..\Source/queue.c **** 	configASSERT( pxQueue );
1085:..\Source/queue.c **** 
1086:..\Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1087:..\Source/queue.c **** 	if the item size is not 0. */
1088:..\Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1089:..\Source/queue.c **** 
1090:..\Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1091:..\Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1092:..\Source/queue.c **** 	interrupts, only tasks. */
1093:..\Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
1094:..\Source/queue.c **** 
1095:..\Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1096:..\Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1097:..\Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1098:..\Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1099:..\Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1100:..\Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1101:..\Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1102:..\Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1103:..\Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1104:..\Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1105:..\Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1106:..\Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1107:..\Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1108:..\Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1109:..\Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1110:..\Source/queue.c **** 
1111:..\Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 997              		.loc 1 1111 0
 998 0028 FB61     		str	r3, [r7, #28]
 999              	.LBB30:
1112:..\Source/queue.c **** 	{
1113:..\Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1000              		.loc 1 1113 0
 1001 002a 3B6A     		ldr	r3, [r7, #32]
 1002 002c 9B6B     		ldr	r3, [r3, #56]
 1003 002e BB61     		str	r3, [r7, #24]
1114:..\Source/queue.c **** 
1115:..\Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1116:..\Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1117:..\Source/queue.c **** 		space'. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 43


1118:..\Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1004              		.loc 1 1118 0
 1005 0030 3B6A     		ldr	r3, [r7, #32]
 1006 0032 DA6B     		ldr	r2, [r3, #60]
 1007 0034 BB69     		ldr	r3, [r7, #24]
 1008 0036 9A42     		cmp	r2, r3
 1009 0038 29D9     		bls	.L60
 1010              	.LBB31:
1119:..\Source/queue.c **** 		{
1120:..\Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1011              		.loc 1 1120 0
 1012 003a 3B6A     		ldr	r3, [r7, #32]
 1013 003c 93F84530 		ldrb	r3, [r3, #69]
 1014 0040 FB75     		strb	r3, [r7, #23]
1121:..\Source/queue.c **** 
1122:..\Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
1123:..\Source/queue.c **** 
1124:..\Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1125:..\Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1126:..\Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1127:..\Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1128:..\Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1129:..\Source/queue.c **** 			messages (semaphores) available. */
1130:..\Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 1015              		.loc 1 1130 0
 1016 0042 BB69     		ldr	r3, [r7, #24]
 1017 0044 5A1C     		adds	r2, r3, #1
 1018 0046 3B6A     		ldr	r3, [r7, #32]
 1019 0048 9A63     		str	r2, [r3, #56]
1131:..\Source/queue.c **** 
1132:..\Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1133:..\Source/queue.c **** 			be done when the queue is unlocked later. */
1134:..\Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1020              		.loc 1 1134 0
 1021 004a 97F91730 		ldrsb	r3, [r7, #23]
 1022 004e B3F1FF3F 		cmp	r3, #-1
 1023 0052 12D1     		bne	.L61
1135:..\Source/queue.c **** 			{
1136:..\Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1137:..\Source/queue.c **** 				{
1138:..\Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1139:..\Source/queue.c **** 					{
1140:..\Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1141:..\Source/queue.c **** 						{
1142:..\Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1143:..\Source/queue.c **** 							posting	to the queue set caused a higher priority
1144:..\Source/queue.c **** 							task to	unblock.  A context switch is required. */
1145:..\Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1146:..\Source/queue.c **** 							{
1147:..\Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1148:..\Source/queue.c **** 							}
1149:..\Source/queue.c **** 							else
1150:..\Source/queue.c **** 							{
1151:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1152:..\Source/queue.c **** 							}
1153:..\Source/queue.c **** 						}
1154:..\Source/queue.c **** 						else
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 44


1155:..\Source/queue.c **** 						{
1156:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1157:..\Source/queue.c **** 						}
1158:..\Source/queue.c **** 					}
1159:..\Source/queue.c **** 					else
1160:..\Source/queue.c **** 					{
1161:..\Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1162:..\Source/queue.c **** 						{
1163:..\Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1164:..\Source/queue.c **** 							{
1165:..\Source/queue.c **** 								/* The task waiting has a higher priority so
1166:..\Source/queue.c **** 								record that a context switch is required. */
1167:..\Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1168:..\Source/queue.c **** 								{
1169:..\Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1170:..\Source/queue.c **** 								}
1171:..\Source/queue.c **** 								else
1172:..\Source/queue.c **** 								{
1173:..\Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1174:..\Source/queue.c **** 								}
1175:..\Source/queue.c **** 							}
1176:..\Source/queue.c **** 							else
1177:..\Source/queue.c **** 							{
1178:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1179:..\Source/queue.c **** 							}
1180:..\Source/queue.c **** 						}
1181:..\Source/queue.c **** 						else
1182:..\Source/queue.c **** 						{
1183:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1184:..\Source/queue.c **** 						}
1185:..\Source/queue.c **** 					}
1186:..\Source/queue.c **** 				}
1187:..\Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1188:..\Source/queue.c **** 				{
1189:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1024              		.loc 1 1189 0
 1025 0054 3B6A     		ldr	r3, [r7, #32]
 1026 0056 5B6A     		ldr	r3, [r3, #36]
 1027 0058 002B     		cmp	r3, #0
 1028 005a 15D0     		beq	.L62
1190:..\Source/queue.c **** 					{
1191:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1029              		.loc 1 1191 0
 1030 005c 3B6A     		ldr	r3, [r7, #32]
 1031 005e 2433     		adds	r3, r3, #36
 1032 0060 1846     		mov	r0, r3
 1033 0062 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1034 0066 0346     		mov	r3, r0
 1035 0068 002B     		cmp	r3, #0
 1036 006a 0DD0     		beq	.L62
1192:..\Source/queue.c **** 						{
1193:..\Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1194:..\Source/queue.c **** 							context	switch is required. */
1195:..\Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1037              		.loc 1 1195 0
 1038 006c 3B68     		ldr	r3, [r7]
 1039 006e 002B     		cmp	r3, #0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 45


 1040 0070 0AD0     		beq	.L62
1196:..\Source/queue.c **** 							{
1197:..\Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1041              		.loc 1 1197 0
 1042 0072 3B68     		ldr	r3, [r7]
 1043 0074 0122     		movs	r2, #1
 1044 0076 1A60     		str	r2, [r3]
 1045 0078 06E0     		b	.L62
 1046              	.L61:
1198:..\Source/queue.c **** 							}
1199:..\Source/queue.c **** 							else
1200:..\Source/queue.c **** 							{
1201:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1202:..\Source/queue.c **** 							}
1203:..\Source/queue.c **** 						}
1204:..\Source/queue.c **** 						else
1205:..\Source/queue.c **** 						{
1206:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1207:..\Source/queue.c **** 						}
1208:..\Source/queue.c **** 					}
1209:..\Source/queue.c **** 					else
1210:..\Source/queue.c **** 					{
1211:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1212:..\Source/queue.c **** 					}
1213:..\Source/queue.c **** 				}
1214:..\Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1215:..\Source/queue.c **** 			}
1216:..\Source/queue.c **** 			else
1217:..\Source/queue.c **** 			{
1218:..\Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1219:..\Source/queue.c **** 				knows that data was posted while it was locked. */
1220:..\Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1047              		.loc 1 1220 0
 1048 007a FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 1049 007c 0133     		adds	r3, r3, #1
 1050 007e DBB2     		uxtb	r3, r3
 1051 0080 DAB2     		uxtb	r2, r3
 1052 0082 3B6A     		ldr	r3, [r7, #32]
 1053 0084 83F84520 		strb	r2, [r3, #69]
 1054              	.L62:
1221:..\Source/queue.c **** 			}
1222:..\Source/queue.c **** 
1223:..\Source/queue.c **** 			xReturn = pdPASS;
 1055              		.loc 1 1223 0
 1056 0088 0123     		movs	r3, #1
 1057 008a 7B62     		str	r3, [r7, #36]
 1058              	.LBE31:
 1059 008c 01E0     		b	.L63
 1060              	.L60:
1224:..\Source/queue.c **** 		}
1225:..\Source/queue.c **** 		else
1226:..\Source/queue.c **** 		{
1227:..\Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1228:..\Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1061              		.loc 1 1228 0
 1062 008e 0023     		movs	r3, #0
 1063 0090 7B62     		str	r3, [r7, #36]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 46


 1064              	.L63:
 1065 0092 FB69     		ldr	r3, [r7, #28]
 1066 0094 BB60     		str	r3, [r7, #8]
 1067              	.LBE30:
 1068              	.LBB32:
 1069              	.LBB33:
 1070              		.loc 2 271 0
 1071 0096 BB68     		ldr	r3, [r7, #8]
 1072              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1073 0098 83F31188 			msr basepri, r3	
 1074              	@ 0 "" 2
 1075              		.thumb
 1076              	.LBE33:
 1077              	.LBE32:
1229:..\Source/queue.c **** 		}
1230:..\Source/queue.c **** 	}
1231:..\Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1232:..\Source/queue.c **** 
1233:..\Source/queue.c **** 	return xReturn;
 1078              		.loc 1 1233 0
 1079 009c 7B6A     		ldr	r3, [r7, #36]
1234:..\Source/queue.c **** }
 1080              		.loc 1 1234 0
 1081 009e 1846     		mov	r0, r3
 1082 00a0 2837     		adds	r7, r7, #40
 1083              		.cfi_def_cfa_offset 8
 1084 00a2 BD46     		mov	sp, r7
 1085              		.cfi_def_cfa_register 13
 1086              		@ sp needed
 1087 00a4 80BD     		pop	{r7, pc}
 1088              		.cfi_endproc
 1089              	.LFE78:
 1090              		.size	xQueueGiveFromISR, .-xQueueGiveFromISR
 1091 00a6 00BF     		.section	.text.xQueueGenericReceive,"ax",%progbits
 1092              		.align	2
 1093              		.global	xQueueGenericReceive
 1094              		.thumb
 1095              		.thumb_func
 1096              		.type	xQueueGenericReceive, %function
 1097              	xQueueGenericReceive:
 1098              	.LFB79:
1235:..\Source/queue.c **** /*-----------------------------------------------------------*/
1236:..\Source/queue.c **** 
1237:..\Source/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1238:..\Source/queue.c **** {
 1099              		.loc 1 1238 0
 1100              		.cfi_startproc
 1101              		@ args = 0, pretend = 0, frame = 40
 1102              		@ frame_needed = 1, uses_anonymous_args = 0
 1103 0000 80B5     		push	{r7, lr}
 1104              		.cfi_def_cfa_offset 8
 1105              		.cfi_offset 7, -8
 1106              		.cfi_offset 14, -4
 1107 0002 8AB0     		sub	sp, sp, #40
 1108              		.cfi_def_cfa_offset 48
 1109 0004 00AF     		add	r7, sp, #0
 1110              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 47


 1111 0006 F860     		str	r0, [r7, #12]
 1112 0008 B960     		str	r1, [r7, #8]
 1113 000a 7A60     		str	r2, [r7, #4]
 1114 000c 3B60     		str	r3, [r7]
1239:..\Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1115              		.loc 1 1239 0
 1116 000e 0023     		movs	r3, #0
 1117 0010 7B62     		str	r3, [r7, #36]
1240:..\Source/queue.c **** TimeOut_t xTimeOut;
1241:..\Source/queue.c **** int8_t *pcOriginalReadPosition;
1242:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1118              		.loc 1 1242 0
 1119 0012 FB68     		ldr	r3, [r7, #12]
 1120 0014 3B62     		str	r3, [r7, #32]
 1121              	.L80:
1243:..\Source/queue.c **** 
1244:..\Source/queue.c **** 	configASSERT( pxQueue );
1245:..\Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1246:..\Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1247:..\Source/queue.c **** 	{
1248:..\Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1249:..\Source/queue.c **** 	}
1250:..\Source/queue.c **** 	#endif
1251:..\Source/queue.c **** 
1252:..\Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1253:..\Source/queue.c **** 	statements within the function itself.  This is done in the interest
1254:..\Source/queue.c **** 	of execution time efficiency. */
1255:..\Source/queue.c **** 
1256:..\Source/queue.c **** 	for( ;; )
1257:..\Source/queue.c **** 	{
1258:..\Source/queue.c **** 		taskENTER_CRITICAL();
 1122              		.loc 1 1258 0
 1123 0016 FFF7FEFF 		bl	vPortEnterCritical
 1124              	.LBB34:
1259:..\Source/queue.c **** 		{
1260:..\Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1125              		.loc 1 1260 0
 1126 001a 3B6A     		ldr	r3, [r7, #32]
 1127 001c 9B6B     		ldr	r3, [r3, #56]
 1128 001e FB61     		str	r3, [r7, #28]
1261:..\Source/queue.c **** 
1262:..\Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1263:..\Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1264:..\Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1129              		.loc 1 1264 0
 1130 0020 FB69     		ldr	r3, [r7, #28]
 1131 0022 002B     		cmp	r3, #0
 1132 0024 46D0     		beq	.L66
1265:..\Source/queue.c **** 			{
1266:..\Source/queue.c **** 				/* Remember the read position in case the queue is only being
1267:..\Source/queue.c **** 				peeked. */
1268:..\Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1133              		.loc 1 1268 0
 1134 0026 3B6A     		ldr	r3, [r7, #32]
 1135 0028 DB68     		ldr	r3, [r3, #12]
 1136 002a BB61     		str	r3, [r7, #24]
1269:..\Source/queue.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 48


1270:..\Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1137              		.loc 1 1270 0
 1138 002c 386A     		ldr	r0, [r7, #32]
 1139 002e B968     		ldr	r1, [r7, #8]
 1140 0030 FFF7FEFF 		bl	prvCopyDataFromQueue
1271:..\Source/queue.c **** 
1272:..\Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1141              		.loc 1 1272 0
 1142 0034 3B68     		ldr	r3, [r7]
 1143 0036 002B     		cmp	r3, #0
 1144 0038 21D1     		bne	.L67
1273:..\Source/queue.c **** 				{
1274:..\Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
1275:..\Source/queue.c **** 
1276:..\Source/queue.c **** 					/* Actually removing data, not just peeking. */
1277:..\Source/queue.c **** 					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1145              		.loc 1 1277 0
 1146 003a FB69     		ldr	r3, [r7, #28]
 1147 003c 5A1E     		subs	r2, r3, #1
 1148 003e 3B6A     		ldr	r3, [r7, #32]
 1149 0040 9A63     		str	r2, [r3, #56]
1278:..\Source/queue.c **** 
1279:..\Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1280:..\Source/queue.c **** 					{
1281:..\Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1150              		.loc 1 1281 0
 1151 0042 3B6A     		ldr	r3, [r7, #32]
 1152 0044 1B68     		ldr	r3, [r3]
 1153 0046 002B     		cmp	r3, #0
 1154 0048 04D1     		bne	.L68
1282:..\Source/queue.c **** 						{
1283:..\Source/queue.c **** 							/* Record the information required to implement
1284:..\Source/queue.c **** 							priority inheritance should it become necessary. */
1285:..\Source/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is 
 1155              		.loc 1 1285 0
 1156 004a FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1157 004e 0246     		mov	r2, r0
 1158 0050 3B6A     		ldr	r3, [r7, #32]
 1159 0052 5A60     		str	r2, [r3, #4]
 1160              	.L68:
1286:..\Source/queue.c **** 						}
1287:..\Source/queue.c **** 						else
1288:..\Source/queue.c **** 						{
1289:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1290:..\Source/queue.c **** 						}
1291:..\Source/queue.c **** 					}
1292:..\Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1293:..\Source/queue.c **** 
1294:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1161              		.loc 1 1294 0
 1162 0054 3B6A     		ldr	r3, [r7, #32]
 1163 0056 1B69     		ldr	r3, [r3, #16]
 1164 0058 002B     		cmp	r3, #0
 1165 005a 27D0     		beq	.L69
1295:..\Source/queue.c **** 					{
1296:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1166              		.loc 1 1296 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 49


 1167 005c 3B6A     		ldr	r3, [r7, #32]
 1168 005e 1033     		adds	r3, r3, #16
 1169 0060 1846     		mov	r0, r3
 1170 0062 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1171 0066 0346     		mov	r3, r0
 1172 0068 002B     		cmp	r3, #0
 1173 006a 1FD0     		beq	.L69
1297:..\Source/queue.c **** 						{
1298:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1174              		.loc 1 1298 0
 1175 006c 514B     		ldr	r3, .L82
 1176 006e 4FF08052 		mov	r2, #268435456
 1177 0072 1A60     		str	r2, [r3]
 1178              	@ 1298 "..\Source\queue.c" 1
 1179 0074 BFF34F8F 		dsb
 1180              	@ 0 "" 2
 1181              	@ 1298 "..\Source\queue.c" 1
 1182 0078 BFF36F8F 		isb
 1183              	@ 0 "" 2
 1184              		.thumb
 1185 007c 16E0     		b	.L69
 1186              	.L67:
1299:..\Source/queue.c **** 						}
1300:..\Source/queue.c **** 						else
1301:..\Source/queue.c **** 						{
1302:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1303:..\Source/queue.c **** 						}
1304:..\Source/queue.c **** 					}
1305:..\Source/queue.c **** 					else
1306:..\Source/queue.c **** 					{
1307:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1308:..\Source/queue.c **** 					}
1309:..\Source/queue.c **** 				}
1310:..\Source/queue.c **** 				else
1311:..\Source/queue.c **** 				{
1312:..\Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
1313:..\Source/queue.c **** 
1314:..\Source/queue.c **** 					/* The data is not being removed, so reset the read
1315:..\Source/queue.c **** 					pointer. */
1316:..\Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1187              		.loc 1 1316 0
 1188 007e 3B6A     		ldr	r3, [r7, #32]
 1189 0080 BA69     		ldr	r2, [r7, #24]
 1190 0082 DA60     		str	r2, [r3, #12]
1317:..\Source/queue.c **** 
1318:..\Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1319:..\Source/queue.c **** 					any other tasks waiting for the data. */
1320:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1191              		.loc 1 1320 0
 1192 0084 3B6A     		ldr	r3, [r7, #32]
 1193 0086 5B6A     		ldr	r3, [r3, #36]
 1194 0088 002B     		cmp	r3, #0
 1195 008a 0FD0     		beq	.L69
1321:..\Source/queue.c **** 					{
1322:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1196              		.loc 1 1322 0
 1197 008c 3B6A     		ldr	r3, [r7, #32]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 50


 1198 008e 2433     		adds	r3, r3, #36
 1199 0090 1846     		mov	r0, r3
 1200 0092 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1201 0096 0346     		mov	r3, r0
 1202 0098 002B     		cmp	r3, #0
 1203 009a 07D0     		beq	.L69
1323:..\Source/queue.c **** 						{
1324:..\Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1325:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1204              		.loc 1 1325 0
 1205 009c 454B     		ldr	r3, .L82
 1206 009e 4FF08052 		mov	r2, #268435456
 1207 00a2 1A60     		str	r2, [r3]
 1208              	@ 1325 "..\Source\queue.c" 1
 1209 00a4 BFF34F8F 		dsb
 1210              	@ 0 "" 2
 1211              	@ 1325 "..\Source\queue.c" 1
 1212 00a8 BFF36F8F 		isb
 1213              	@ 0 "" 2
 1214              		.thumb
 1215              	.L69:
1326:..\Source/queue.c **** 						}
1327:..\Source/queue.c **** 						else
1328:..\Source/queue.c **** 						{
1329:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1330:..\Source/queue.c **** 						}
1331:..\Source/queue.c **** 					}
1332:..\Source/queue.c **** 					else
1333:..\Source/queue.c **** 					{
1334:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1335:..\Source/queue.c **** 					}
1336:..\Source/queue.c **** 				}
1337:..\Source/queue.c **** 
1338:..\Source/queue.c **** 				taskEXIT_CRITICAL();
 1216              		.loc 1 1338 0
 1217 00ac FFF7FEFF 		bl	vPortExitCritical
1339:..\Source/queue.c **** 				return pdPASS;
 1218              		.loc 1 1339 0
 1219 00b0 0123     		movs	r3, #1
 1220 00b2 7AE0     		b	.L81
 1221              	.L66:
1340:..\Source/queue.c **** 			}
1341:..\Source/queue.c **** 			else
1342:..\Source/queue.c **** 			{
1343:..\Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1222              		.loc 1 1343 0
 1223 00b4 7B68     		ldr	r3, [r7, #4]
 1224 00b6 002B     		cmp	r3, #0
 1225 00b8 03D1     		bne	.L71
1344:..\Source/queue.c **** 				{
1345:..\Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1346:..\Source/queue.c **** 					the block time has expired) so leave now. */
1347:..\Source/queue.c **** 					taskEXIT_CRITICAL();
 1226              		.loc 1 1347 0
 1227 00ba FFF7FEFF 		bl	vPortExitCritical
1348:..\Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
1349:..\Source/queue.c **** 					return errQUEUE_EMPTY;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 51


 1228              		.loc 1 1349 0
 1229 00be 0023     		movs	r3, #0
 1230 00c0 73E0     		b	.L81
 1231              	.L71:
1350:..\Source/queue.c **** 				}
1351:..\Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1232              		.loc 1 1351 0
 1233 00c2 7B6A     		ldr	r3, [r7, #36]
 1234 00c4 002B     		cmp	r3, #0
 1235 00c6 06D1     		bne	.L72
1352:..\Source/queue.c **** 				{
1353:..\Source/queue.c **** 					/* The queue was empty and a block time was specified so
1354:..\Source/queue.c **** 					configure the timeout structure. */
1355:..\Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1236              		.loc 1 1355 0
 1237 00c8 07F11003 		add	r3, r7, #16
 1238 00cc 1846     		mov	r0, r3
 1239 00ce FFF7FEFF 		bl	vTaskSetTimeOutState
1356:..\Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1240              		.loc 1 1356 0
 1241 00d2 0123     		movs	r3, #1
 1242 00d4 7B62     		str	r3, [r7, #36]
 1243              	.L72:
 1244              	.LBE34:
1357:..\Source/queue.c **** 				}
1358:..\Source/queue.c **** 				else
1359:..\Source/queue.c **** 				{
1360:..\Source/queue.c **** 					/* Entry time was already set. */
1361:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1362:..\Source/queue.c **** 				}
1363:..\Source/queue.c **** 			}
1364:..\Source/queue.c **** 		}
1365:..\Source/queue.c **** 		taskEXIT_CRITICAL();
 1245              		.loc 1 1365 0
 1246 00d6 FFF7FEFF 		bl	vPortExitCritical
1366:..\Source/queue.c **** 
1367:..\Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1368:..\Source/queue.c **** 		now the critical section has been exited. */
1369:..\Source/queue.c **** 
1370:..\Source/queue.c **** 		vTaskSuspendAll();
 1247              		.loc 1 1370 0
 1248 00da FFF7FEFF 		bl	vTaskSuspendAll
1371:..\Source/queue.c **** 		prvLockQueue( pxQueue );
 1249              		.loc 1 1371 0
 1250 00de FFF7FEFF 		bl	vPortEnterCritical
 1251 00e2 3B6A     		ldr	r3, [r7, #32]
 1252 00e4 93F84430 		ldrb	r3, [r3, #68]
 1253 00e8 DBB2     		uxtb	r3, r3
 1254 00ea 5BB2     		sxtb	r3, r3
 1255 00ec B3F1FF3F 		cmp	r3, #-1
 1256 00f0 03D1     		bne	.L73
 1257              		.loc 1 1371 0 is_stmt 0 discriminator 1
 1258 00f2 3B6A     		ldr	r3, [r7, #32]
 1259 00f4 0022     		movs	r2, #0
 1260 00f6 83F84420 		strb	r2, [r3, #68]
 1261              	.L73:
 1262              		.loc 1 1371 0 discriminator 3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 52


 1263 00fa 3B6A     		ldr	r3, [r7, #32]
 1264 00fc 93F84530 		ldrb	r3, [r3, #69]
 1265 0100 DBB2     		uxtb	r3, r3
 1266 0102 5BB2     		sxtb	r3, r3
 1267 0104 B3F1FF3F 		cmp	r3, #-1
 1268 0108 03D1     		bne	.L74
 1269              		.loc 1 1371 0 discriminator 4
 1270 010a 3B6A     		ldr	r3, [r7, #32]
 1271 010c 0022     		movs	r2, #0
 1272 010e 83F84520 		strb	r2, [r3, #69]
 1273              	.L74:
 1274              		.loc 1 1371 0 discriminator 6
 1275 0112 FFF7FEFF 		bl	vPortExitCritical
1372:..\Source/queue.c **** 
1373:..\Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1374:..\Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1276              		.loc 1 1374 0 is_stmt 1 discriminator 6
 1277 0116 07F11002 		add	r2, r7, #16
 1278 011a 3B1D     		adds	r3, r7, #4
 1279 011c 1046     		mov	r0, r2
 1280 011e 1946     		mov	r1, r3
 1281 0120 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1282 0124 0346     		mov	r3, r0
 1283 0126 002B     		cmp	r3, #0
 1284 0128 31D1     		bne	.L75
1375:..\Source/queue.c **** 		{
1376:..\Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1285              		.loc 1 1376 0
 1286 012a 386A     		ldr	r0, [r7, #32]
 1287 012c FFF7FEFF 		bl	prvIsQueueEmpty
 1288 0130 0346     		mov	r3, r0
 1289 0132 002B     		cmp	r3, #0
 1290 0134 25D0     		beq	.L76
1377:..\Source/queue.c **** 			{
1378:..\Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1379:..\Source/queue.c **** 
1380:..\Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1381:..\Source/queue.c **** 				{
1382:..\Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1291              		.loc 1 1382 0
 1292 0136 3B6A     		ldr	r3, [r7, #32]
 1293 0138 1B68     		ldr	r3, [r3]
 1294 013a 002B     		cmp	r3, #0
 1295 013c 08D1     		bne	.L77
1383:..\Source/queue.c **** 					{
1384:..\Source/queue.c **** 						taskENTER_CRITICAL();
 1296              		.loc 1 1384 0
 1297 013e FFF7FEFF 		bl	vPortEnterCritical
1385:..\Source/queue.c **** 						{
1386:..\Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1298              		.loc 1 1386 0
 1299 0142 3B6A     		ldr	r3, [r7, #32]
 1300 0144 5B68     		ldr	r3, [r3, #4]
 1301 0146 1846     		mov	r0, r3
 1302 0148 FFF7FEFF 		bl	vTaskPriorityInherit
1387:..\Source/queue.c **** 						}
1388:..\Source/queue.c **** 						taskEXIT_CRITICAL();
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 53


 1303              		.loc 1 1388 0
 1304 014c FFF7FEFF 		bl	vPortExitCritical
 1305              	.L77:
1389:..\Source/queue.c **** 					}
1390:..\Source/queue.c **** 					else
1391:..\Source/queue.c **** 					{
1392:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1393:..\Source/queue.c **** 					}
1394:..\Source/queue.c **** 				}
1395:..\Source/queue.c **** 				#endif
1396:..\Source/queue.c **** 
1397:..\Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1306              		.loc 1 1397 0
 1307 0150 3B6A     		ldr	r3, [r7, #32]
 1308 0152 03F12402 		add	r2, r3, #36
 1309 0156 7B68     		ldr	r3, [r7, #4]
 1310 0158 1046     		mov	r0, r2
 1311 015a 1946     		mov	r1, r3
 1312 015c FFF7FEFF 		bl	vTaskPlaceOnEventList
1398:..\Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1313              		.loc 1 1398 0
 1314 0160 386A     		ldr	r0, [r7, #32]
 1315 0162 FFF7FEFF 		bl	prvUnlockQueue
1399:..\Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1316              		.loc 1 1399 0
 1317 0166 FFF7FEFF 		bl	xTaskResumeAll
 1318 016a 0346     		mov	r3, r0
 1319 016c 002B     		cmp	r3, #0
 1320 016e 1BD1     		bne	.L79
1400:..\Source/queue.c **** 				{
1401:..\Source/queue.c **** 					portYIELD_WITHIN_API();
 1321              		.loc 1 1401 0
 1322 0170 104B     		ldr	r3, .L82
 1323 0172 4FF08052 		mov	r2, #268435456
 1324 0176 1A60     		str	r2, [r3]
 1325              	@ 1401 "..\Source\queue.c" 1
 1326 0178 BFF34F8F 		dsb
 1327              	@ 0 "" 2
 1328              	@ 1401 "..\Source\queue.c" 1
 1329 017c BFF36F8F 		isb
 1330              	@ 0 "" 2
 1331              		.thumb
 1332 0180 12E0     		b	.L79
 1333              	.L76:
1402:..\Source/queue.c **** 				}
1403:..\Source/queue.c **** 				else
1404:..\Source/queue.c **** 				{
1405:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1406:..\Source/queue.c **** 				}
1407:..\Source/queue.c **** 			}
1408:..\Source/queue.c **** 			else
1409:..\Source/queue.c **** 			{
1410:..\Source/queue.c **** 				/* Try again. */
1411:..\Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1334              		.loc 1 1411 0
 1335 0182 386A     		ldr	r0, [r7, #32]
 1336 0184 FFF7FEFF 		bl	prvUnlockQueue
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 54


1412:..\Source/queue.c **** 				( void ) xTaskResumeAll();
 1337              		.loc 1 1412 0
 1338 0188 FFF7FEFF 		bl	xTaskResumeAll
 1339 018c 43E7     		b	.L80
 1340              	.L75:
1413:..\Source/queue.c **** 			}
1414:..\Source/queue.c **** 		}
1415:..\Source/queue.c **** 		else
1416:..\Source/queue.c **** 		{
1417:..\Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1341              		.loc 1 1417 0
 1342 018e 386A     		ldr	r0, [r7, #32]
 1343 0190 FFF7FEFF 		bl	prvUnlockQueue
1418:..\Source/queue.c **** 			( void ) xTaskResumeAll();
 1344              		.loc 1 1418 0
 1345 0194 FFF7FEFF 		bl	xTaskResumeAll
1419:..\Source/queue.c **** 
1420:..\Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1346              		.loc 1 1420 0
 1347 0198 386A     		ldr	r0, [r7, #32]
 1348 019a FFF7FEFF 		bl	prvIsQueueEmpty
 1349 019e 0346     		mov	r3, r0
 1350 01a0 002B     		cmp	r3, #0
 1351 01a2 01D0     		beq	.L79
1421:..\Source/queue.c **** 			{
1422:..\Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
1423:..\Source/queue.c **** 				return errQUEUE_EMPTY;
 1352              		.loc 1 1423 0
 1353 01a4 0023     		movs	r3, #0
 1354 01a6 00E0     		b	.L81
 1355              	.L79:
1424:..\Source/queue.c **** 			}
1425:..\Source/queue.c **** 			else
1426:..\Source/queue.c **** 			{
1427:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1428:..\Source/queue.c **** 			}
1429:..\Source/queue.c **** 		}
1430:..\Source/queue.c **** 	}
 1356              		.loc 1 1430 0 discriminator 3
 1357 01a8 35E7     		b	.L80
 1358              	.L81:
1431:..\Source/queue.c **** }
 1359              		.loc 1 1431 0 discriminator 4
 1360 01aa 1846     		mov	r0, r3
 1361 01ac 2837     		adds	r7, r7, #40
 1362              		.cfi_def_cfa_offset 8
 1363 01ae BD46     		mov	sp, r7
 1364              		.cfi_def_cfa_register 13
 1365              		@ sp needed
 1366 01b0 80BD     		pop	{r7, pc}
 1367              	.L83:
 1368 01b2 00BF     		.align	2
 1369              	.L82:
 1370 01b4 04ED00E0 		.word	-536810236
 1371              		.cfi_endproc
 1372              	.LFE79:
 1373              		.size	xQueueGenericReceive, .-xQueueGenericReceive
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 55


 1374              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1375              		.align	2
 1376              		.global	xQueueReceiveFromISR
 1377              		.thumb
 1378              		.thumb_func
 1379              		.type	xQueueReceiveFromISR, %function
 1380              	xQueueReceiveFromISR:
 1381              	.LFB80:
1432:..\Source/queue.c **** /*-----------------------------------------------------------*/
1433:..\Source/queue.c **** 
1434:..\Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1435:..\Source/queue.c **** {
 1382              		.loc 1 1435 0
 1383              		.cfi_startproc
 1384              		@ args = 0, pretend = 0, frame = 48
 1385              		@ frame_needed = 1, uses_anonymous_args = 0
 1386 0000 80B5     		push	{r7, lr}
 1387              		.cfi_def_cfa_offset 8
 1388              		.cfi_offset 7, -8
 1389              		.cfi_offset 14, -4
 1390 0002 8CB0     		sub	sp, sp, #48
 1391              		.cfi_def_cfa_offset 56
 1392 0004 00AF     		add	r7, sp, #0
 1393              		.cfi_def_cfa_register 7
 1394 0006 F860     		str	r0, [r7, #12]
 1395 0008 B960     		str	r1, [r7, #8]
 1396 000a 7A60     		str	r2, [r7, #4]
1436:..\Source/queue.c **** BaseType_t xReturn;
1437:..\Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1438:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1397              		.loc 1 1438 0
 1398 000c FB68     		ldr	r3, [r7, #12]
 1399 000e BB62     		str	r3, [r7, #40]
 1400              	.LBB35:
 1401              	.LBB36:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1402              		.loc 2 253 0
 1403              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1404 0010 EFF31182 			mrs r2, basepri											
 1405 0014 4FF0A003 		mov r3, #160												
 1406 0018 83F31188 		msr basepri, r3											
 1407 001c BFF36F8F 		isb														
 1408 0020 BFF34F8F 		dsb														
 1409              	
 1410              	@ 0 "" 2
 1411              		.thumb
 1412 0024 BA61     		str	r2, [r7, #24]
 1413 0026 7B61     		str	r3, [r7, #20]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1414              		.loc 2 265 0
 1415 0028 BB69     		ldr	r3, [r7, #24]
 1416              	.LBE36:
 1417              	.LBE35:
1439:..\Source/queue.c **** 
1440:..\Source/queue.c **** 	configASSERT( pxQueue );
1441:..\Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1442:..\Source/queue.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 56


1443:..\Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1444:..\Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1445:..\Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1446:..\Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1447:..\Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1448:..\Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1449:..\Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1450:..\Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1451:..\Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1452:..\Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1453:..\Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1454:..\Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1455:..\Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1456:..\Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1457:..\Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1458:..\Source/queue.c **** 
1459:..\Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1418              		.loc 1 1459 0
 1419 002a 7B62     		str	r3, [r7, #36]
 1420              	.LBB37:
1460:..\Source/queue.c **** 	{
1461:..\Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1421              		.loc 1 1461 0
 1422 002c BB6A     		ldr	r3, [r7, #40]
 1423 002e 9B6B     		ldr	r3, [r3, #56]
 1424 0030 3B62     		str	r3, [r7, #32]
1462:..\Source/queue.c **** 
1463:..\Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1464:..\Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1425              		.loc 1 1464 0
 1426 0032 3B6A     		ldr	r3, [r7, #32]
 1427 0034 002B     		cmp	r3, #0
 1428 0036 2DD0     		beq	.L86
 1429              	.LBB38:
1465:..\Source/queue.c **** 		{
1466:..\Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 1430              		.loc 1 1466 0
 1431 0038 BB6A     		ldr	r3, [r7, #40]
 1432 003a 93F84430 		ldrb	r3, [r3, #68]
 1433 003e FB77     		strb	r3, [r7, #31]
1467:..\Source/queue.c **** 
1468:..\Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1469:..\Source/queue.c **** 
1470:..\Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1434              		.loc 1 1470 0
 1435 0040 B86A     		ldr	r0, [r7, #40]
 1436 0042 B968     		ldr	r1, [r7, #8]
 1437 0044 FFF7FEFF 		bl	prvCopyDataFromQueue
1471:..\Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1438              		.loc 1 1471 0
 1439 0048 3B6A     		ldr	r3, [r7, #32]
 1440 004a 5A1E     		subs	r2, r3, #1
 1441 004c BB6A     		ldr	r3, [r7, #40]
 1442 004e 9A63     		str	r2, [r3, #56]
1472:..\Source/queue.c **** 
1473:..\Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1474:..\Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 57


1475:..\Source/queue.c **** 			will know that an ISR has removed data while the queue was
1476:..\Source/queue.c **** 			locked. */
1477:..\Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
 1443              		.loc 1 1477 0
 1444 0050 97F91F30 		ldrsb	r3, [r7, #31]
 1445 0054 B3F1FF3F 		cmp	r3, #-1
 1446 0058 12D1     		bne	.L87
1478:..\Source/queue.c **** 			{
1479:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1447              		.loc 1 1479 0
 1448 005a BB6A     		ldr	r3, [r7, #40]
 1449 005c 1B69     		ldr	r3, [r3, #16]
 1450 005e 002B     		cmp	r3, #0
 1451 0060 15D0     		beq	.L88
1480:..\Source/queue.c **** 				{
1481:..\Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1452              		.loc 1 1481 0
 1453 0062 BB6A     		ldr	r3, [r7, #40]
 1454 0064 1033     		adds	r3, r3, #16
 1455 0066 1846     		mov	r0, r3
 1456 0068 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1457 006c 0346     		mov	r3, r0
 1458 006e 002B     		cmp	r3, #0
 1459 0070 0DD0     		beq	.L88
1482:..\Source/queue.c **** 					{
1483:..\Source/queue.c **** 						/* The task waiting has a higher priority than us so
1484:..\Source/queue.c **** 						force a context switch. */
1485:..\Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1460              		.loc 1 1485 0
 1461 0072 7B68     		ldr	r3, [r7, #4]
 1462 0074 002B     		cmp	r3, #0
 1463 0076 0AD0     		beq	.L88
1486:..\Source/queue.c **** 						{
1487:..\Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1464              		.loc 1 1487 0
 1465 0078 7B68     		ldr	r3, [r7, #4]
 1466 007a 0122     		movs	r2, #1
 1467 007c 1A60     		str	r2, [r3]
 1468 007e 06E0     		b	.L88
 1469              	.L87:
1488:..\Source/queue.c **** 						}
1489:..\Source/queue.c **** 						else
1490:..\Source/queue.c **** 						{
1491:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1492:..\Source/queue.c **** 						}
1493:..\Source/queue.c **** 					}
1494:..\Source/queue.c **** 					else
1495:..\Source/queue.c **** 					{
1496:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1497:..\Source/queue.c **** 					}
1498:..\Source/queue.c **** 				}
1499:..\Source/queue.c **** 				else
1500:..\Source/queue.c **** 				{
1501:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1502:..\Source/queue.c **** 				}
1503:..\Source/queue.c **** 			}
1504:..\Source/queue.c **** 			else
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 58


1505:..\Source/queue.c **** 			{
1506:..\Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1507:..\Source/queue.c **** 				knows that data was removed while it was locked. */
1508:..\Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 1470              		.loc 1 1508 0
 1471 0080 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 1472 0082 0133     		adds	r3, r3, #1
 1473 0084 DBB2     		uxtb	r3, r3
 1474 0086 DAB2     		uxtb	r2, r3
 1475 0088 BB6A     		ldr	r3, [r7, #40]
 1476 008a 83F84420 		strb	r2, [r3, #68]
 1477              	.L88:
1509:..\Source/queue.c **** 			}
1510:..\Source/queue.c **** 
1511:..\Source/queue.c **** 			xReturn = pdPASS;
 1478              		.loc 1 1511 0
 1479 008e 0123     		movs	r3, #1
 1480 0090 FB62     		str	r3, [r7, #44]
 1481              	.LBE38:
 1482 0092 01E0     		b	.L89
 1483              	.L86:
1512:..\Source/queue.c **** 		}
1513:..\Source/queue.c **** 		else
1514:..\Source/queue.c **** 		{
1515:..\Source/queue.c **** 			xReturn = pdFAIL;
 1484              		.loc 1 1515 0
 1485 0094 0023     		movs	r3, #0
 1486 0096 FB62     		str	r3, [r7, #44]
 1487              	.L89:
 1488 0098 7B6A     		ldr	r3, [r7, #36]
 1489 009a 3B61     		str	r3, [r7, #16]
 1490              	.LBE37:
 1491              	.LBB39:
 1492              	.LBB40:
 1493              		.loc 2 271 0
 1494 009c 3B69     		ldr	r3, [r7, #16]
 1495              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1496 009e 83F31188 			msr basepri, r3	
 1497              	@ 0 "" 2
 1498              		.thumb
 1499              	.LBE40:
 1500              	.LBE39:
1516:..\Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1517:..\Source/queue.c **** 		}
1518:..\Source/queue.c **** 	}
1519:..\Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1520:..\Source/queue.c **** 
1521:..\Source/queue.c **** 	return xReturn;
 1501              		.loc 1 1521 0
 1502 00a2 FB6A     		ldr	r3, [r7, #44]
1522:..\Source/queue.c **** }
 1503              		.loc 1 1522 0
 1504 00a4 1846     		mov	r0, r3
 1505 00a6 3037     		adds	r7, r7, #48
 1506              		.cfi_def_cfa_offset 8
 1507 00a8 BD46     		mov	sp, r7
 1508              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 59


 1509              		@ sp needed
 1510 00aa 80BD     		pop	{r7, pc}
 1511              		.cfi_endproc
 1512              	.LFE80:
 1513              		.size	xQueueReceiveFromISR, .-xQueueReceiveFromISR
 1514              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1515              		.align	2
 1516              		.global	xQueuePeekFromISR
 1517              		.thumb
 1518              		.thumb_func
 1519              		.type	xQueuePeekFromISR, %function
 1520              	xQueuePeekFromISR:
 1521              	.LFB81:
1523:..\Source/queue.c **** /*-----------------------------------------------------------*/
1524:..\Source/queue.c **** 
1525:..\Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1526:..\Source/queue.c **** {
 1522              		.loc 1 1526 0
 1523              		.cfi_startproc
 1524              		@ args = 0, pretend = 0, frame = 40
 1525              		@ frame_needed = 1, uses_anonymous_args = 0
 1526 0000 80B5     		push	{r7, lr}
 1527              		.cfi_def_cfa_offset 8
 1528              		.cfi_offset 7, -8
 1529              		.cfi_offset 14, -4
 1530 0002 8AB0     		sub	sp, sp, #40
 1531              		.cfi_def_cfa_offset 48
 1532 0004 00AF     		add	r7, sp, #0
 1533              		.cfi_def_cfa_register 7
 1534 0006 7860     		str	r0, [r7, #4]
 1535 0008 3960     		str	r1, [r7]
1527:..\Source/queue.c **** BaseType_t xReturn;
1528:..\Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1529:..\Source/queue.c **** int8_t *pcOriginalReadPosition;
1530:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1536              		.loc 1 1530 0
 1537 000a 7B68     		ldr	r3, [r7, #4]
 1538 000c 3B62     		str	r3, [r7, #32]
 1539              	.LBB41:
 1540              	.LBB42:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1541              		.loc 2 253 0
 1542              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1543 000e EFF31182 			mrs r2, basepri											
 1544 0012 4FF0A003 		mov r3, #160												
 1545 0016 83F31188 		msr basepri, r3											
 1546 001a BFF36F8F 		isb														
 1547 001e BFF34F8F 		dsb														
 1548              	
 1549              	@ 0 "" 2
 1550              		.thumb
 1551 0022 7A61     		str	r2, [r7, #20]
 1552 0024 3B61     		str	r3, [r7, #16]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1553              		.loc 2 265 0
 1554 0026 7B69     		ldr	r3, [r7, #20]
 1555              	.LBE42:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 60


 1556              	.LBE41:
1531:..\Source/queue.c **** 
1532:..\Source/queue.c **** 	configASSERT( pxQueue );
1533:..\Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1534:..\Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1535:..\Source/queue.c **** 
1536:..\Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1537:..\Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1538:..\Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1539:..\Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1540:..\Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1541:..\Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1542:..\Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1543:..\Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1544:..\Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1545:..\Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1546:..\Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1547:..\Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1548:..\Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1549:..\Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1550:..\Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1551:..\Source/queue.c **** 
1552:..\Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1557              		.loc 1 1552 0
 1558 0028 FB61     		str	r3, [r7, #28]
1553:..\Source/queue.c **** 	{
1554:..\Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1555:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1559              		.loc 1 1555 0
 1560 002a 3B6A     		ldr	r3, [r7, #32]
 1561 002c 9B6B     		ldr	r3, [r3, #56]
 1562 002e 002B     		cmp	r3, #0
 1563 0030 0CD0     		beq	.L93
1556:..\Source/queue.c **** 		{
1557:..\Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1558:..\Source/queue.c **** 
1559:..\Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1560:..\Source/queue.c **** 			actually being removed from the queue. */
1561:..\Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1564              		.loc 1 1561 0
 1565 0032 3B6A     		ldr	r3, [r7, #32]
 1566 0034 DB68     		ldr	r3, [r3, #12]
 1567 0036 BB61     		str	r3, [r7, #24]
1562:..\Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1568              		.loc 1 1562 0
 1569 0038 386A     		ldr	r0, [r7, #32]
 1570 003a 3968     		ldr	r1, [r7]
 1571 003c FFF7FEFF 		bl	prvCopyDataFromQueue
1563:..\Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1572              		.loc 1 1563 0
 1573 0040 3B6A     		ldr	r3, [r7, #32]
 1574 0042 BA69     		ldr	r2, [r7, #24]
 1575 0044 DA60     		str	r2, [r3, #12]
1564:..\Source/queue.c **** 
1565:..\Source/queue.c **** 			xReturn = pdPASS;
 1576              		.loc 1 1565 0
 1577 0046 0123     		movs	r3, #1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 61


 1578 0048 7B62     		str	r3, [r7, #36]
 1579 004a 01E0     		b	.L94
 1580              	.L93:
1566:..\Source/queue.c **** 		}
1567:..\Source/queue.c **** 		else
1568:..\Source/queue.c **** 		{
1569:..\Source/queue.c **** 			xReturn = pdFAIL;
 1581              		.loc 1 1569 0
 1582 004c 0023     		movs	r3, #0
 1583 004e 7B62     		str	r3, [r7, #36]
 1584              	.L94:
 1585 0050 FB69     		ldr	r3, [r7, #28]
 1586 0052 FB60     		str	r3, [r7, #12]
 1587              	.LBB43:
 1588              	.LBB44:
 1589              		.loc 2 271 0
 1590 0054 FB68     		ldr	r3, [r7, #12]
 1591              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1592 0056 83F31188 			msr basepri, r3	
 1593              	@ 0 "" 2
 1594              		.thumb
 1595              	.LBE44:
 1596              	.LBE43:
1570:..\Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1571:..\Source/queue.c **** 		}
1572:..\Source/queue.c **** 	}
1573:..\Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1574:..\Source/queue.c **** 
1575:..\Source/queue.c **** 	return xReturn;
 1597              		.loc 1 1575 0
 1598 005a 7B6A     		ldr	r3, [r7, #36]
1576:..\Source/queue.c **** }
 1599              		.loc 1 1576 0
 1600 005c 1846     		mov	r0, r3
 1601 005e 2837     		adds	r7, r7, #40
 1602              		.cfi_def_cfa_offset 8
 1603 0060 BD46     		mov	sp, r7
 1604              		.cfi_def_cfa_register 13
 1605              		@ sp needed
 1606 0062 80BD     		pop	{r7, pc}
 1607              		.cfi_endproc
 1608              	.LFE81:
 1609              		.size	xQueuePeekFromISR, .-xQueuePeekFromISR
 1610              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1611              		.align	2
 1612              		.global	uxQueueMessagesWaiting
 1613              		.thumb
 1614              		.thumb_func
 1615              		.type	uxQueueMessagesWaiting, %function
 1616              	uxQueueMessagesWaiting:
 1617              	.LFB82:
1577:..\Source/queue.c **** /*-----------------------------------------------------------*/
1578:..\Source/queue.c **** 
1579:..\Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1580:..\Source/queue.c **** {
 1618              		.loc 1 1580 0
 1619              		.cfi_startproc
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 62


 1620              		@ args = 0, pretend = 0, frame = 16
 1621              		@ frame_needed = 1, uses_anonymous_args = 0
 1622 0000 80B5     		push	{r7, lr}
 1623              		.cfi_def_cfa_offset 8
 1624              		.cfi_offset 7, -8
 1625              		.cfi_offset 14, -4
 1626 0002 84B0     		sub	sp, sp, #16
 1627              		.cfi_def_cfa_offset 24
 1628 0004 00AF     		add	r7, sp, #0
 1629              		.cfi_def_cfa_register 7
 1630 0006 7860     		str	r0, [r7, #4]
1581:..\Source/queue.c **** UBaseType_t uxReturn;
1582:..\Source/queue.c **** 
1583:..\Source/queue.c **** 	configASSERT( xQueue );
1584:..\Source/queue.c **** 
1585:..\Source/queue.c **** 	taskENTER_CRITICAL();
 1631              		.loc 1 1585 0
 1632 0008 FFF7FEFF 		bl	vPortEnterCritical
1586:..\Source/queue.c **** 	{
1587:..\Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1633              		.loc 1 1587 0
 1634 000c 7B68     		ldr	r3, [r7, #4]
 1635 000e 9B6B     		ldr	r3, [r3, #56]
 1636 0010 FB60     		str	r3, [r7, #12]
1588:..\Source/queue.c **** 	}
1589:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 1637              		.loc 1 1589 0
 1638 0012 FFF7FEFF 		bl	vPortExitCritical
1590:..\Source/queue.c **** 
1591:..\Source/queue.c **** 	return uxReturn;
 1639              		.loc 1 1591 0
 1640 0016 FB68     		ldr	r3, [r7, #12]
1592:..\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1641              		.loc 1 1592 0
 1642 0018 1846     		mov	r0, r3
 1643 001a 1037     		adds	r7, r7, #16
 1644              		.cfi_def_cfa_offset 8
 1645 001c BD46     		mov	sp, r7
 1646              		.cfi_def_cfa_register 13
 1647              		@ sp needed
 1648 001e 80BD     		pop	{r7, pc}
 1649              		.cfi_endproc
 1650              	.LFE82:
 1651              		.size	uxQueueMessagesWaiting, .-uxQueueMessagesWaiting
 1652              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1653              		.align	2
 1654              		.global	uxQueueSpacesAvailable
 1655              		.thumb
 1656              		.thumb_func
 1657              		.type	uxQueueSpacesAvailable, %function
 1658              	uxQueueSpacesAvailable:
 1659              	.LFB83:
1593:..\Source/queue.c **** /*-----------------------------------------------------------*/
1594:..\Source/queue.c **** 
1595:..\Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1596:..\Source/queue.c **** {
 1660              		.loc 1 1596 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 63


 1661              		.cfi_startproc
 1662              		@ args = 0, pretend = 0, frame = 16
 1663              		@ frame_needed = 1, uses_anonymous_args = 0
 1664 0000 80B5     		push	{r7, lr}
 1665              		.cfi_def_cfa_offset 8
 1666              		.cfi_offset 7, -8
 1667              		.cfi_offset 14, -4
 1668 0002 84B0     		sub	sp, sp, #16
 1669              		.cfi_def_cfa_offset 24
 1670 0004 00AF     		add	r7, sp, #0
 1671              		.cfi_def_cfa_register 7
 1672 0006 7860     		str	r0, [r7, #4]
1597:..\Source/queue.c **** UBaseType_t uxReturn;
1598:..\Source/queue.c **** Queue_t *pxQueue;
1599:..\Source/queue.c **** 
1600:..\Source/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
 1673              		.loc 1 1600 0
 1674 0008 7B68     		ldr	r3, [r7, #4]
 1675 000a FB60     		str	r3, [r7, #12]
1601:..\Source/queue.c **** 	configASSERT( pxQueue );
1602:..\Source/queue.c **** 
1603:..\Source/queue.c **** 	taskENTER_CRITICAL();
 1676              		.loc 1 1603 0
 1677 000c FFF7FEFF 		bl	vPortEnterCritical
1604:..\Source/queue.c **** 	{
1605:..\Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1678              		.loc 1 1605 0
 1679 0010 FB68     		ldr	r3, [r7, #12]
 1680 0012 DA6B     		ldr	r2, [r3, #60]
 1681 0014 FB68     		ldr	r3, [r7, #12]
 1682 0016 9B6B     		ldr	r3, [r3, #56]
 1683 0018 D31A     		subs	r3, r2, r3
 1684 001a BB60     		str	r3, [r7, #8]
1606:..\Source/queue.c **** 	}
1607:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 1685              		.loc 1 1607 0
 1686 001c FFF7FEFF 		bl	vPortExitCritical
1608:..\Source/queue.c **** 
1609:..\Source/queue.c **** 	return uxReturn;
 1687              		.loc 1 1609 0
 1688 0020 BB68     		ldr	r3, [r7, #8]
1610:..\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1689              		.loc 1 1610 0
 1690 0022 1846     		mov	r0, r3
 1691 0024 1037     		adds	r7, r7, #16
 1692              		.cfi_def_cfa_offset 8
 1693 0026 BD46     		mov	sp, r7
 1694              		.cfi_def_cfa_register 13
 1695              		@ sp needed
 1696 0028 80BD     		pop	{r7, pc}
 1697              		.cfi_endproc
 1698              	.LFE83:
 1699              		.size	uxQueueSpacesAvailable, .-uxQueueSpacesAvailable
 1700 002a 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1701              		.align	2
 1702              		.global	uxQueueMessagesWaitingFromISR
 1703              		.thumb
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 64


 1704              		.thumb_func
 1705              		.type	uxQueueMessagesWaitingFromISR, %function
 1706              	uxQueueMessagesWaitingFromISR:
 1707              	.LFB84:
1611:..\Source/queue.c **** /*-----------------------------------------------------------*/
1612:..\Source/queue.c **** 
1613:..\Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1614:..\Source/queue.c **** {
 1708              		.loc 1 1614 0
 1709              		.cfi_startproc
 1710              		@ args = 0, pretend = 0, frame = 16
 1711              		@ frame_needed = 1, uses_anonymous_args = 0
 1712              		@ link register save eliminated.
 1713 0000 80B4     		push	{r7}
 1714              		.cfi_def_cfa_offset 4
 1715              		.cfi_offset 7, -4
 1716 0002 85B0     		sub	sp, sp, #20
 1717              		.cfi_def_cfa_offset 24
 1718 0004 00AF     		add	r7, sp, #0
 1719              		.cfi_def_cfa_register 7
 1720 0006 7860     		str	r0, [r7, #4]
1615:..\Source/queue.c **** UBaseType_t uxReturn;
1616:..\Source/queue.c **** 
1617:..\Source/queue.c **** 	configASSERT( xQueue );
1618:..\Source/queue.c **** 
1619:..\Source/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1721              		.loc 1 1619 0
 1722 0008 7B68     		ldr	r3, [r7, #4]
 1723 000a 9B6B     		ldr	r3, [r3, #56]
 1724 000c FB60     		str	r3, [r7, #12]
1620:..\Source/queue.c **** 
1621:..\Source/queue.c **** 	return uxReturn;
 1725              		.loc 1 1621 0
 1726 000e FB68     		ldr	r3, [r7, #12]
1622:..\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1727              		.loc 1 1622 0
 1728 0010 1846     		mov	r0, r3
 1729 0012 1437     		adds	r7, r7, #20
 1730              		.cfi_def_cfa_offset 4
 1731 0014 BD46     		mov	sp, r7
 1732              		.cfi_def_cfa_register 13
 1733              		@ sp needed
 1734 0016 5DF8047B 		ldr	r7, [sp], #4
 1735              		.cfi_restore 7
 1736              		.cfi_def_cfa_offset 0
 1737 001a 7047     		bx	lr
 1738              		.cfi_endproc
 1739              	.LFE84:
 1740              		.size	uxQueueMessagesWaitingFromISR, .-uxQueueMessagesWaitingFromISR
 1741              		.section	.text.vQueueDelete,"ax",%progbits
 1742              		.align	2
 1743              		.global	vQueueDelete
 1744              		.thumb
 1745              		.thumb_func
 1746              		.type	vQueueDelete, %function
 1747              	vQueueDelete:
 1748              	.LFB85:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 65


1623:..\Source/queue.c **** /*-----------------------------------------------------------*/
1624:..\Source/queue.c **** 
1625:..\Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1626:..\Source/queue.c **** {
 1749              		.loc 1 1626 0
 1750              		.cfi_startproc
 1751              		@ args = 0, pretend = 0, frame = 16
 1752              		@ frame_needed = 1, uses_anonymous_args = 0
 1753 0000 80B5     		push	{r7, lr}
 1754              		.cfi_def_cfa_offset 8
 1755              		.cfi_offset 7, -8
 1756              		.cfi_offset 14, -4
 1757 0002 84B0     		sub	sp, sp, #16
 1758              		.cfi_def_cfa_offset 24
 1759 0004 00AF     		add	r7, sp, #0
 1760              		.cfi_def_cfa_register 7
 1761 0006 7860     		str	r0, [r7, #4]
1627:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1762              		.loc 1 1627 0
 1763 0008 7B68     		ldr	r3, [r7, #4]
 1764 000a FB60     		str	r3, [r7, #12]
1628:..\Source/queue.c **** 
1629:..\Source/queue.c **** 	configASSERT( pxQueue );
1630:..\Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1631:..\Source/queue.c **** 
1632:..\Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1633:..\Source/queue.c **** 	{
1634:..\Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 1765              		.loc 1 1634 0
 1766 000c F868     		ldr	r0, [r7, #12]
 1767 000e FFF7FEFF 		bl	vQueueUnregisterQueue
1635:..\Source/queue.c **** 	}
1636:..\Source/queue.c **** 	#endif
1637:..\Source/queue.c **** 
1638:..\Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1639:..\Source/queue.c **** 	{
1640:..\Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1641:..\Source/queue.c **** 		again. */
1642:..\Source/queue.c **** 		vPortFree( pxQueue );
 1768              		.loc 1 1642 0
 1769 0012 F868     		ldr	r0, [r7, #12]
 1770 0014 FFF7FEFF 		bl	vPortFree
1643:..\Source/queue.c **** 	}
1644:..\Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1645:..\Source/queue.c **** 	{
1646:..\Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1647:..\Source/queue.c **** 		check before attempting to free the memory. */
1648:..\Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1649:..\Source/queue.c **** 		{
1650:..\Source/queue.c **** 			vPortFree( pxQueue );
1651:..\Source/queue.c **** 		}
1652:..\Source/queue.c **** 		else
1653:..\Source/queue.c **** 		{
1654:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1655:..\Source/queue.c **** 		}
1656:..\Source/queue.c **** 	}
1657:..\Source/queue.c **** 	#else
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 66


1658:..\Source/queue.c **** 	{
1659:..\Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
1660:..\Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
1661:..\Source/queue.c **** 		( void ) pxQueue;
1662:..\Source/queue.c **** 	}
1663:..\Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1664:..\Source/queue.c **** }
 1771              		.loc 1 1664 0
 1772 0018 1037     		adds	r7, r7, #16
 1773              		.cfi_def_cfa_offset 8
 1774 001a BD46     		mov	sp, r7
 1775              		.cfi_def_cfa_register 13
 1776              		@ sp needed
 1777 001c 80BD     		pop	{r7, pc}
 1778              		.cfi_endproc
 1779              	.LFE85:
 1780              		.size	vQueueDelete, .-vQueueDelete
 1781 001e 00BF     		.section	.text.prvCopyDataToQueue,"ax",%progbits
 1782              		.align	2
 1783              		.thumb
 1784              		.thumb_func
 1785              		.type	prvCopyDataToQueue, %function
 1786              	prvCopyDataToQueue:
 1787              	.LFB86:
1665:..\Source/queue.c **** /*-----------------------------------------------------------*/
1666:..\Source/queue.c **** 
1667:..\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1668:..\Source/queue.c **** 
1669:..\Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1670:..\Source/queue.c **** 	{
1671:..\Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
1672:..\Source/queue.c **** 	}
1673:..\Source/queue.c **** 
1674:..\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1675:..\Source/queue.c **** /*-----------------------------------------------------------*/
1676:..\Source/queue.c **** 
1677:..\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1678:..\Source/queue.c **** 
1679:..\Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1680:..\Source/queue.c **** 	{
1681:..\Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
1682:..\Source/queue.c **** 	}
1683:..\Source/queue.c **** 
1684:..\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1685:..\Source/queue.c **** /*-----------------------------------------------------------*/
1686:..\Source/queue.c **** 
1687:..\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1688:..\Source/queue.c **** 
1689:..\Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1690:..\Source/queue.c **** 	{
1691:..\Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
1692:..\Source/queue.c **** 	}
1693:..\Source/queue.c **** 
1694:..\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1695:..\Source/queue.c **** /*-----------------------------------------------------------*/
1696:..\Source/queue.c **** 
1697:..\Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 67


1698:..\Source/queue.c **** {
 1788              		.loc 1 1698 0
 1789              		.cfi_startproc
 1790              		@ args = 0, pretend = 0, frame = 24
 1791              		@ frame_needed = 1, uses_anonymous_args = 0
 1792 0000 80B5     		push	{r7, lr}
 1793              		.cfi_def_cfa_offset 8
 1794              		.cfi_offset 7, -8
 1795              		.cfi_offset 14, -4
 1796 0002 86B0     		sub	sp, sp, #24
 1797              		.cfi_def_cfa_offset 32
 1798 0004 00AF     		add	r7, sp, #0
 1799              		.cfi_def_cfa_register 7
 1800 0006 F860     		str	r0, [r7, #12]
 1801 0008 B960     		str	r1, [r7, #8]
 1802 000a 7A60     		str	r2, [r7, #4]
1699:..\Source/queue.c **** BaseType_t xReturn = pdFALSE;
 1803              		.loc 1 1699 0
 1804 000c 0023     		movs	r3, #0
 1805 000e 7B61     		str	r3, [r7, #20]
1700:..\Source/queue.c **** UBaseType_t uxMessagesWaiting;
1701:..\Source/queue.c **** 
1702:..\Source/queue.c **** 	/* This function is called from a critical section. */
1703:..\Source/queue.c **** 
1704:..\Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1806              		.loc 1 1704 0
 1807 0010 FB68     		ldr	r3, [r7, #12]
 1808 0012 9B6B     		ldr	r3, [r3, #56]
 1809 0014 3B61     		str	r3, [r7, #16]
1705:..\Source/queue.c **** 
1706:..\Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 1810              		.loc 1 1706 0
 1811 0016 FB68     		ldr	r3, [r7, #12]
 1812 0018 1B6C     		ldr	r3, [r3, #64]
 1813 001a 002B     		cmp	r3, #0
 1814 001c 0DD1     		bne	.L104
1707:..\Source/queue.c **** 	{
1708:..\Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1709:..\Source/queue.c **** 		{
1710:..\Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1815              		.loc 1 1710 0
 1816 001e FB68     		ldr	r3, [r7, #12]
 1817 0020 1B68     		ldr	r3, [r3]
 1818 0022 002B     		cmp	r3, #0
 1819 0024 4FD1     		bne	.L105
1711:..\Source/queue.c **** 			{
1712:..\Source/queue.c **** 				/* The mutex is no longer being held. */
1713:..\Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1820              		.loc 1 1713 0
 1821 0026 FB68     		ldr	r3, [r7, #12]
 1822 0028 5B68     		ldr	r3, [r3, #4]
 1823 002a 1846     		mov	r0, r3
 1824 002c FFF7FEFF 		bl	xTaskPriorityDisinherit
 1825 0030 7861     		str	r0, [r7, #20]
1714:..\Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 1826              		.loc 1 1714 0
 1827 0032 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 68


 1828 0034 0022     		movs	r2, #0
 1829 0036 5A60     		str	r2, [r3, #4]
 1830 0038 45E0     		b	.L105
 1831              	.L104:
1715:..\Source/queue.c **** 			}
1716:..\Source/queue.c **** 			else
1717:..\Source/queue.c **** 			{
1718:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1719:..\Source/queue.c **** 			}
1720:..\Source/queue.c **** 		}
1721:..\Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1722:..\Source/queue.c **** 	}
1723:..\Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 1832              		.loc 1 1723 0
 1833 003a 7B68     		ldr	r3, [r7, #4]
 1834 003c 002B     		cmp	r3, #0
 1835 003e 1AD1     		bne	.L106
1724:..\Source/queue.c **** 	{
1725:..\Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 1836              		.loc 1 1725 0
 1837 0040 FB68     		ldr	r3, [r7, #12]
 1838 0042 9A68     		ldr	r2, [r3, #8]
 1839 0044 FB68     		ldr	r3, [r7, #12]
 1840 0046 1B6C     		ldr	r3, [r3, #64]
 1841 0048 1046     		mov	r0, r2
 1842 004a B968     		ldr	r1, [r7, #8]
 1843 004c 1A46     		mov	r2, r3
 1844 004e FFF7FEFF 		bl	memcpy
1726:..\Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1845              		.loc 1 1726 0
 1846 0052 FB68     		ldr	r3, [r7, #12]
 1847 0054 9A68     		ldr	r2, [r3, #8]
 1848 0056 FB68     		ldr	r3, [r7, #12]
 1849 0058 1B6C     		ldr	r3, [r3, #64]
 1850 005a 1A44     		add	r2, r2, r3
 1851 005c FB68     		ldr	r3, [r7, #12]
 1852 005e 9A60     		str	r2, [r3, #8]
1727:..\Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 1853              		.loc 1 1727 0
 1854 0060 FB68     		ldr	r3, [r7, #12]
 1855 0062 9A68     		ldr	r2, [r3, #8]
 1856 0064 FB68     		ldr	r3, [r7, #12]
 1857 0066 5B68     		ldr	r3, [r3, #4]
 1858 0068 9A42     		cmp	r2, r3
 1859 006a 2CD3     		bcc	.L105
1728:..\Source/queue.c **** 		{
1729:..\Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 1860              		.loc 1 1729 0
 1861 006c FB68     		ldr	r3, [r7, #12]
 1862 006e 1A68     		ldr	r2, [r3]
 1863 0070 FB68     		ldr	r3, [r7, #12]
 1864 0072 9A60     		str	r2, [r3, #8]
 1865 0074 27E0     		b	.L105
 1866              	.L106:
1730:..\Source/queue.c **** 		}
1731:..\Source/queue.c **** 		else
1732:..\Source/queue.c **** 		{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 69


1733:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1734:..\Source/queue.c **** 		}
1735:..\Source/queue.c **** 	}
1736:..\Source/queue.c **** 	else
1737:..\Source/queue.c **** 	{
1738:..\Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 1867              		.loc 1 1738 0
 1868 0076 FB68     		ldr	r3, [r7, #12]
 1869 0078 DA68     		ldr	r2, [r3, #12]
 1870 007a FB68     		ldr	r3, [r7, #12]
 1871 007c 1B6C     		ldr	r3, [r3, #64]
 1872 007e 1046     		mov	r0, r2
 1873 0080 B968     		ldr	r1, [r7, #8]
 1874 0082 1A46     		mov	r2, r3
 1875 0084 FFF7FEFF 		bl	memcpy
1739:..\Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 1876              		.loc 1 1739 0
 1877 0088 FB68     		ldr	r3, [r7, #12]
 1878 008a DA68     		ldr	r2, [r3, #12]
 1879 008c FB68     		ldr	r3, [r7, #12]
 1880 008e 1B6C     		ldr	r3, [r3, #64]
 1881 0090 5B42     		negs	r3, r3
 1882 0092 1A44     		add	r2, r2, r3
 1883 0094 FB68     		ldr	r3, [r7, #12]
 1884 0096 DA60     		str	r2, [r3, #12]
1740:..\Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 1885              		.loc 1 1740 0
 1886 0098 FB68     		ldr	r3, [r7, #12]
 1887 009a DA68     		ldr	r2, [r3, #12]
 1888 009c FB68     		ldr	r3, [r7, #12]
 1889 009e 1B68     		ldr	r3, [r3]
 1890 00a0 9A42     		cmp	r2, r3
 1891 00a2 07D2     		bcs	.L107
1741:..\Source/queue.c **** 		{
1742:..\Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1892              		.loc 1 1742 0
 1893 00a4 FB68     		ldr	r3, [r7, #12]
 1894 00a6 5A68     		ldr	r2, [r3, #4]
 1895 00a8 FB68     		ldr	r3, [r7, #12]
 1896 00aa 1B6C     		ldr	r3, [r3, #64]
 1897 00ac 5B42     		negs	r3, r3
 1898 00ae 1A44     		add	r2, r2, r3
 1899 00b0 FB68     		ldr	r3, [r7, #12]
 1900 00b2 DA60     		str	r2, [r3, #12]
 1901              	.L107:
1743:..\Source/queue.c **** 		}
1744:..\Source/queue.c **** 		else
1745:..\Source/queue.c **** 		{
1746:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1747:..\Source/queue.c **** 		}
1748:..\Source/queue.c **** 
1749:..\Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 1902              		.loc 1 1749 0
 1903 00b4 7B68     		ldr	r3, [r7, #4]
 1904 00b6 022B     		cmp	r3, #2
 1905 00b8 05D1     		bne	.L105
1750:..\Source/queue.c **** 		{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 70


1751:..\Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1906              		.loc 1 1751 0
 1907 00ba 3B69     		ldr	r3, [r7, #16]
 1908 00bc 002B     		cmp	r3, #0
 1909 00be 02D0     		beq	.L105
1752:..\Source/queue.c **** 			{
1753:..\Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1754:..\Source/queue.c **** 				one from the recorded number of items in the queue so when
1755:..\Source/queue.c **** 				one is added again below the number of recorded items remains
1756:..\Source/queue.c **** 				correct. */
1757:..\Source/queue.c **** 				--uxMessagesWaiting;
 1910              		.loc 1 1757 0
 1911 00c0 3B69     		ldr	r3, [r7, #16]
 1912 00c2 013B     		subs	r3, r3, #1
 1913 00c4 3B61     		str	r3, [r7, #16]
 1914              	.L105:
1758:..\Source/queue.c **** 			}
1759:..\Source/queue.c **** 			else
1760:..\Source/queue.c **** 			{
1761:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1762:..\Source/queue.c **** 			}
1763:..\Source/queue.c **** 		}
1764:..\Source/queue.c **** 		else
1765:..\Source/queue.c **** 		{
1766:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1767:..\Source/queue.c **** 		}
1768:..\Source/queue.c **** 	}
1769:..\Source/queue.c **** 
1770:..\Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 1915              		.loc 1 1770 0
 1916 00c6 3B69     		ldr	r3, [r7, #16]
 1917 00c8 5A1C     		adds	r2, r3, #1
 1918 00ca FB68     		ldr	r3, [r7, #12]
 1919 00cc 9A63     		str	r2, [r3, #56]
1771:..\Source/queue.c **** 
1772:..\Source/queue.c **** 	return xReturn;
 1920              		.loc 1 1772 0
 1921 00ce 7B69     		ldr	r3, [r7, #20]
1773:..\Source/queue.c **** }
 1922              		.loc 1 1773 0
 1923 00d0 1846     		mov	r0, r3
 1924 00d2 1837     		adds	r7, r7, #24
 1925              		.cfi_def_cfa_offset 8
 1926 00d4 BD46     		mov	sp, r7
 1927              		.cfi_def_cfa_register 13
 1928              		@ sp needed
 1929 00d6 80BD     		pop	{r7, pc}
 1930              		.cfi_endproc
 1931              	.LFE86:
 1932              		.size	prvCopyDataToQueue, .-prvCopyDataToQueue
 1933              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 1934              		.align	2
 1935              		.thumb
 1936              		.thumb_func
 1937              		.type	prvCopyDataFromQueue, %function
 1938              	prvCopyDataFromQueue:
 1939              	.LFB87:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 71


1774:..\Source/queue.c **** /*-----------------------------------------------------------*/
1775:..\Source/queue.c **** 
1776:..\Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1777:..\Source/queue.c **** {
 1940              		.loc 1 1777 0
 1941              		.cfi_startproc
 1942              		@ args = 0, pretend = 0, frame = 8
 1943              		@ frame_needed = 1, uses_anonymous_args = 0
 1944 0000 80B5     		push	{r7, lr}
 1945              		.cfi_def_cfa_offset 8
 1946              		.cfi_offset 7, -8
 1947              		.cfi_offset 14, -4
 1948 0002 82B0     		sub	sp, sp, #8
 1949              		.cfi_def_cfa_offset 16
 1950 0004 00AF     		add	r7, sp, #0
 1951              		.cfi_def_cfa_register 7
 1952 0006 7860     		str	r0, [r7, #4]
 1953 0008 3960     		str	r1, [r7]
1778:..\Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 1954              		.loc 1 1778 0
 1955 000a 7B68     		ldr	r3, [r7, #4]
 1956 000c 1B6C     		ldr	r3, [r3, #64]
 1957 000e 002B     		cmp	r3, #0
 1958 0010 19D0     		beq	.L109
1779:..\Source/queue.c **** 	{
1780:..\Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 1959              		.loc 1 1780 0
 1960 0012 7B68     		ldr	r3, [r7, #4]
 1961 0014 DA68     		ldr	r2, [r3, #12]
 1962 0016 7B68     		ldr	r3, [r7, #4]
 1963 0018 1B6C     		ldr	r3, [r3, #64]
 1964 001a 1A44     		add	r2, r2, r3
 1965 001c 7B68     		ldr	r3, [r7, #4]
 1966 001e DA60     		str	r2, [r3, #12]
1781:..\Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 1967              		.loc 1 1781 0
 1968 0020 7B68     		ldr	r3, [r7, #4]
 1969 0022 DA68     		ldr	r2, [r3, #12]
 1970 0024 7B68     		ldr	r3, [r7, #4]
 1971 0026 5B68     		ldr	r3, [r3, #4]
 1972 0028 9A42     		cmp	r2, r3
 1973 002a 03D3     		bcc	.L111
1782:..\Source/queue.c **** 		{
1783:..\Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 1974              		.loc 1 1783 0
 1975 002c 7B68     		ldr	r3, [r7, #4]
 1976 002e 1A68     		ldr	r2, [r3]
 1977 0030 7B68     		ldr	r3, [r7, #4]
 1978 0032 DA60     		str	r2, [r3, #12]
 1979              	.L111:
1784:..\Source/queue.c **** 		}
1785:..\Source/queue.c **** 		else
1786:..\Source/queue.c **** 		{
1787:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1788:..\Source/queue.c **** 		}
1789:..\Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 1980              		.loc 1 1789 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 72


 1981 0034 7B68     		ldr	r3, [r7, #4]
 1982 0036 DA68     		ldr	r2, [r3, #12]
 1983 0038 7B68     		ldr	r3, [r7, #4]
 1984 003a 1B6C     		ldr	r3, [r3, #64]
 1985 003c 3868     		ldr	r0, [r7]
 1986 003e 1146     		mov	r1, r2
 1987 0040 1A46     		mov	r2, r3
 1988 0042 FFF7FEFF 		bl	memcpy
 1989              	.L109:
1790:..\Source/queue.c **** 	}
1791:..\Source/queue.c **** }
 1990              		.loc 1 1791 0
 1991 0046 0837     		adds	r7, r7, #8
 1992              		.cfi_def_cfa_offset 8
 1993 0048 BD46     		mov	sp, r7
 1994              		.cfi_def_cfa_register 13
 1995              		@ sp needed
 1996 004a 80BD     		pop	{r7, pc}
 1997              		.cfi_endproc
 1998              	.LFE87:
 1999              		.size	prvCopyDataFromQueue, .-prvCopyDataFromQueue
 2000              		.section	.text.prvUnlockQueue,"ax",%progbits
 2001              		.align	2
 2002              		.thumb
 2003              		.thumb_func
 2004              		.type	prvUnlockQueue, %function
 2005              	prvUnlockQueue:
 2006              	.LFB88:
1792:..\Source/queue.c **** /*-----------------------------------------------------------*/
1793:..\Source/queue.c **** 
1794:..\Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1795:..\Source/queue.c **** {
 2007              		.loc 1 1795 0
 2008              		.cfi_startproc
 2009              		@ args = 0, pretend = 0, frame = 16
 2010              		@ frame_needed = 1, uses_anonymous_args = 0
 2011 0000 80B5     		push	{r7, lr}
 2012              		.cfi_def_cfa_offset 8
 2013              		.cfi_offset 7, -8
 2014              		.cfi_offset 14, -4
 2015 0002 84B0     		sub	sp, sp, #16
 2016              		.cfi_def_cfa_offset 24
 2017 0004 00AF     		add	r7, sp, #0
 2018              		.cfi_def_cfa_register 7
 2019 0006 7860     		str	r0, [r7, #4]
1796:..\Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1797:..\Source/queue.c **** 
1798:..\Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1799:..\Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1800:..\Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1801:..\Source/queue.c **** 	updated. */
1802:..\Source/queue.c **** 	taskENTER_CRITICAL();
 2020              		.loc 1 1802 0
 2021 0008 FFF7FEFF 		bl	vPortEnterCritical
 2022              	.LBB45:
1803:..\Source/queue.c **** 	{
1804:..\Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 73


 2023              		.loc 1 1804 0
 2024 000c 7B68     		ldr	r3, [r7, #4]
 2025 000e 93F84530 		ldrb	r3, [r3, #69]
 2026 0012 FB73     		strb	r3, [r7, #15]
1805:..\Source/queue.c **** 
1806:..\Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1807:..\Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 2027              		.loc 1 1807 0
 2028 0014 13E0     		b	.L113
 2029              	.L117:
1808:..\Source/queue.c **** 		{
1809:..\Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1810:..\Source/queue.c **** 			blocked waiting for data to become available? */
1811:..\Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1812:..\Source/queue.c **** 			{
1813:..\Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1814:..\Source/queue.c **** 				{
1815:..\Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1816:..\Source/queue.c **** 					{
1817:..\Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1818:..\Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1819:..\Source/queue.c **** 						A context switch is required. */
1820:..\Source/queue.c **** 						vTaskMissedYield();
1821:..\Source/queue.c **** 					}
1822:..\Source/queue.c **** 					else
1823:..\Source/queue.c **** 					{
1824:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1825:..\Source/queue.c **** 					}
1826:..\Source/queue.c **** 				}
1827:..\Source/queue.c **** 				else
1828:..\Source/queue.c **** 				{
1829:..\Source/queue.c **** 					/* Tasks that are removed from the event list will get
1830:..\Source/queue.c **** 					added to the pending ready list as the scheduler is still
1831:..\Source/queue.c **** 					suspended. */
1832:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1833:..\Source/queue.c **** 					{
1834:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1835:..\Source/queue.c **** 						{
1836:..\Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1837:..\Source/queue.c **** 							context	switch is required. */
1838:..\Source/queue.c **** 							vTaskMissedYield();
1839:..\Source/queue.c **** 						}
1840:..\Source/queue.c **** 						else
1841:..\Source/queue.c **** 						{
1842:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1843:..\Source/queue.c **** 						}
1844:..\Source/queue.c **** 					}
1845:..\Source/queue.c **** 					else
1846:..\Source/queue.c **** 					{
1847:..\Source/queue.c **** 						break;
1848:..\Source/queue.c **** 					}
1849:..\Source/queue.c **** 				}
1850:..\Source/queue.c **** 			}
1851:..\Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1852:..\Source/queue.c **** 			{
1853:..\Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1854:..\Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 74


1855:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2030              		.loc 1 1855 0
 2031 0016 7B68     		ldr	r3, [r7, #4]
 2032 0018 5B6A     		ldr	r3, [r3, #36]
 2033 001a 002B     		cmp	r3, #0
 2034 001c 0AD0     		beq	.L114
1856:..\Source/queue.c **** 				{
1857:..\Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2035              		.loc 1 1857 0
 2036 001e 7B68     		ldr	r3, [r7, #4]
 2037 0020 2433     		adds	r3, r3, #36
 2038 0022 1846     		mov	r0, r3
 2039 0024 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2040 0028 0346     		mov	r3, r0
 2041 002a 002B     		cmp	r3, #0
 2042 002c 03D0     		beq	.L115
1858:..\Source/queue.c **** 					{
1859:..\Source/queue.c **** 						/* The task waiting has a higher priority so record that
1860:..\Source/queue.c **** 						a context switch is required. */
1861:..\Source/queue.c **** 						vTaskMissedYield();
 2043              		.loc 1 1861 0
 2044 002e FFF7FEFF 		bl	vTaskMissedYield
 2045 0032 00E0     		b	.L115
 2046              	.L114:
1862:..\Source/queue.c **** 					}
1863:..\Source/queue.c **** 					else
1864:..\Source/queue.c **** 					{
1865:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1866:..\Source/queue.c **** 					}
1867:..\Source/queue.c **** 				}
1868:..\Source/queue.c **** 				else
1869:..\Source/queue.c **** 				{
1870:..\Source/queue.c **** 					break;
 2047              		.loc 1 1870 0
 2048 0034 07E0     		b	.L116
 2049              	.L115:
1871:..\Source/queue.c **** 				}
1872:..\Source/queue.c **** 			}
1873:..\Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1874:..\Source/queue.c **** 
1875:..\Source/queue.c **** 			--cTxLock;
 2050              		.loc 1 1875 0
 2051 0036 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2052 0038 013B     		subs	r3, r3, #1
 2053 003a DBB2     		uxtb	r3, r3
 2054 003c FB73     		strb	r3, [r7, #15]
 2055              	.L113:
1807:..\Source/queue.c **** 		{
 2056              		.loc 1 1807 0
 2057 003e 97F90F30 		ldrsb	r3, [r7, #15]
 2058 0042 002B     		cmp	r3, #0
 2059 0044 E7DC     		bgt	.L117
 2060              	.L116:
1876:..\Source/queue.c **** 		}
1877:..\Source/queue.c **** 
1878:..\Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 2061              		.loc 1 1878 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 75


 2062 0046 7B68     		ldr	r3, [r7, #4]
 2063 0048 FF22     		movs	r2, #255
 2064 004a 83F84520 		strb	r2, [r3, #69]
 2065              	.LBE45:
1879:..\Source/queue.c **** 	}
1880:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 2066              		.loc 1 1880 0
 2067 004e FFF7FEFF 		bl	vPortExitCritical
1881:..\Source/queue.c **** 
1882:..\Source/queue.c **** 	/* Do the same for the Rx lock. */
1883:..\Source/queue.c **** 	taskENTER_CRITICAL();
 2068              		.loc 1 1883 0
 2069 0052 FFF7FEFF 		bl	vPortEnterCritical
 2070              	.LBB46:
1884:..\Source/queue.c **** 	{
1885:..\Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 2071              		.loc 1 1885 0
 2072 0056 7B68     		ldr	r3, [r7, #4]
 2073 0058 93F84430 		ldrb	r3, [r3, #68]
 2074 005c BB73     		strb	r3, [r7, #14]
1886:..\Source/queue.c **** 
1887:..\Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 2075              		.loc 1 1887 0
 2076 005e 13E0     		b	.L118
 2077              	.L122:
1888:..\Source/queue.c **** 		{
1889:..\Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2078              		.loc 1 1889 0
 2079 0060 7B68     		ldr	r3, [r7, #4]
 2080 0062 1B69     		ldr	r3, [r3, #16]
 2081 0064 002B     		cmp	r3, #0
 2082 0066 0ED0     		beq	.L119
1890:..\Source/queue.c **** 			{
1891:..\Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2083              		.loc 1 1891 0
 2084 0068 7B68     		ldr	r3, [r7, #4]
 2085 006a 1033     		adds	r3, r3, #16
 2086 006c 1846     		mov	r0, r3
 2087 006e FFF7FEFF 		bl	xTaskRemoveFromEventList
 2088 0072 0346     		mov	r3, r0
 2089 0074 002B     		cmp	r3, #0
 2090 0076 01D0     		beq	.L120
1892:..\Source/queue.c **** 				{
1893:..\Source/queue.c **** 					vTaskMissedYield();
 2091              		.loc 1 1893 0
 2092 0078 FFF7FEFF 		bl	vTaskMissedYield
 2093              	.L120:
1894:..\Source/queue.c **** 				}
1895:..\Source/queue.c **** 				else
1896:..\Source/queue.c **** 				{
1897:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1898:..\Source/queue.c **** 				}
1899:..\Source/queue.c **** 
1900:..\Source/queue.c **** 				--cRxLock;
 2094              		.loc 1 1900 0
 2095 007c BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 2096 007e 013B     		subs	r3, r3, #1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 76


 2097 0080 DBB2     		uxtb	r3, r3
 2098 0082 BB73     		strb	r3, [r7, #14]
 2099 0084 00E0     		b	.L118
 2100              	.L119:
1901:..\Source/queue.c **** 			}
1902:..\Source/queue.c **** 			else
1903:..\Source/queue.c **** 			{
1904:..\Source/queue.c **** 				break;
 2101              		.loc 1 1904 0
 2102 0086 03E0     		b	.L121
 2103              	.L118:
1887:..\Source/queue.c **** 		{
 2104              		.loc 1 1887 0
 2105 0088 97F90E30 		ldrsb	r3, [r7, #14]
 2106 008c 002B     		cmp	r3, #0
 2107 008e E7DC     		bgt	.L122
 2108              	.L121:
1905:..\Source/queue.c **** 			}
1906:..\Source/queue.c **** 		}
1907:..\Source/queue.c **** 
1908:..\Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 2109              		.loc 1 1908 0
 2110 0090 7B68     		ldr	r3, [r7, #4]
 2111 0092 FF22     		movs	r2, #255
 2112 0094 83F84420 		strb	r2, [r3, #68]
 2113              	.LBE46:
1909:..\Source/queue.c **** 	}
1910:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 2114              		.loc 1 1910 0
 2115 0098 FFF7FEFF 		bl	vPortExitCritical
1911:..\Source/queue.c **** }
 2116              		.loc 1 1911 0
 2117 009c 1037     		adds	r7, r7, #16
 2118              		.cfi_def_cfa_offset 8
 2119 009e BD46     		mov	sp, r7
 2120              		.cfi_def_cfa_register 13
 2121              		@ sp needed
 2122 00a0 80BD     		pop	{r7, pc}
 2123              		.cfi_endproc
 2124              	.LFE88:
 2125              		.size	prvUnlockQueue, .-prvUnlockQueue
 2126 00a2 00BF     		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2127              		.align	2
 2128              		.thumb
 2129              		.thumb_func
 2130              		.type	prvIsQueueEmpty, %function
 2131              	prvIsQueueEmpty:
 2132              	.LFB89:
1912:..\Source/queue.c **** /*-----------------------------------------------------------*/
1913:..\Source/queue.c **** 
1914:..\Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1915:..\Source/queue.c **** {
 2133              		.loc 1 1915 0
 2134              		.cfi_startproc
 2135              		@ args = 0, pretend = 0, frame = 16
 2136              		@ frame_needed = 1, uses_anonymous_args = 0
 2137 0000 80B5     		push	{r7, lr}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 77


 2138              		.cfi_def_cfa_offset 8
 2139              		.cfi_offset 7, -8
 2140              		.cfi_offset 14, -4
 2141 0002 84B0     		sub	sp, sp, #16
 2142              		.cfi_def_cfa_offset 24
 2143 0004 00AF     		add	r7, sp, #0
 2144              		.cfi_def_cfa_register 7
 2145 0006 7860     		str	r0, [r7, #4]
1916:..\Source/queue.c **** BaseType_t xReturn;
1917:..\Source/queue.c **** 
1918:..\Source/queue.c **** 	taskENTER_CRITICAL();
 2146              		.loc 1 1918 0
 2147 0008 FFF7FEFF 		bl	vPortEnterCritical
1919:..\Source/queue.c **** 	{
1920:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2148              		.loc 1 1920 0
 2149 000c 7B68     		ldr	r3, [r7, #4]
 2150 000e 9B6B     		ldr	r3, [r3, #56]
 2151 0010 002B     		cmp	r3, #0
 2152 0012 02D1     		bne	.L124
1921:..\Source/queue.c **** 		{
1922:..\Source/queue.c **** 			xReturn = pdTRUE;
 2153              		.loc 1 1922 0
 2154 0014 0123     		movs	r3, #1
 2155 0016 FB60     		str	r3, [r7, #12]
 2156 0018 01E0     		b	.L125
 2157              	.L124:
1923:..\Source/queue.c **** 		}
1924:..\Source/queue.c **** 		else
1925:..\Source/queue.c **** 		{
1926:..\Source/queue.c **** 			xReturn = pdFALSE;
 2158              		.loc 1 1926 0
 2159 001a 0023     		movs	r3, #0
 2160 001c FB60     		str	r3, [r7, #12]
 2161              	.L125:
1927:..\Source/queue.c **** 		}
1928:..\Source/queue.c **** 	}
1929:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 2162              		.loc 1 1929 0
 2163 001e FFF7FEFF 		bl	vPortExitCritical
1930:..\Source/queue.c **** 
1931:..\Source/queue.c **** 	return xReturn;
 2164              		.loc 1 1931 0
 2165 0022 FB68     		ldr	r3, [r7, #12]
1932:..\Source/queue.c **** }
 2166              		.loc 1 1932 0
 2167 0024 1846     		mov	r0, r3
 2168 0026 1037     		adds	r7, r7, #16
 2169              		.cfi_def_cfa_offset 8
 2170 0028 BD46     		mov	sp, r7
 2171              		.cfi_def_cfa_register 13
 2172              		@ sp needed
 2173 002a 80BD     		pop	{r7, pc}
 2174              		.cfi_endproc
 2175              	.LFE89:
 2176              		.size	prvIsQueueEmpty, .-prvIsQueueEmpty
 2177              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 78


 2178              		.align	2
 2179              		.global	xQueueIsQueueEmptyFromISR
 2180              		.thumb
 2181              		.thumb_func
 2182              		.type	xQueueIsQueueEmptyFromISR, %function
 2183              	xQueueIsQueueEmptyFromISR:
 2184              	.LFB90:
1933:..\Source/queue.c **** /*-----------------------------------------------------------*/
1934:..\Source/queue.c **** 
1935:..\Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1936:..\Source/queue.c **** {
 2185              		.loc 1 1936 0
 2186              		.cfi_startproc
 2187              		@ args = 0, pretend = 0, frame = 16
 2188              		@ frame_needed = 1, uses_anonymous_args = 0
 2189              		@ link register save eliminated.
 2190 0000 80B4     		push	{r7}
 2191              		.cfi_def_cfa_offset 4
 2192              		.cfi_offset 7, -4
 2193 0002 85B0     		sub	sp, sp, #20
 2194              		.cfi_def_cfa_offset 24
 2195 0004 00AF     		add	r7, sp, #0
 2196              		.cfi_def_cfa_register 7
 2197 0006 7860     		str	r0, [r7, #4]
1937:..\Source/queue.c **** BaseType_t xReturn;
1938:..\Source/queue.c **** 
1939:..\Source/queue.c **** 	configASSERT( xQueue );
1940:..\Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2198              		.loc 1 1940 0
 2199 0008 7B68     		ldr	r3, [r7, #4]
 2200 000a 9B6B     		ldr	r3, [r3, #56]
 2201 000c 002B     		cmp	r3, #0
 2202 000e 02D1     		bne	.L128
1941:..\Source/queue.c **** 	{
1942:..\Source/queue.c **** 		xReturn = pdTRUE;
 2203              		.loc 1 1942 0
 2204 0010 0123     		movs	r3, #1
 2205 0012 FB60     		str	r3, [r7, #12]
 2206 0014 01E0     		b	.L129
 2207              	.L128:
1943:..\Source/queue.c **** 	}
1944:..\Source/queue.c **** 	else
1945:..\Source/queue.c **** 	{
1946:..\Source/queue.c **** 		xReturn = pdFALSE;
 2208              		.loc 1 1946 0
 2209 0016 0023     		movs	r3, #0
 2210 0018 FB60     		str	r3, [r7, #12]
 2211              	.L129:
1947:..\Source/queue.c **** 	}
1948:..\Source/queue.c **** 
1949:..\Source/queue.c **** 	return xReturn;
 2212              		.loc 1 1949 0
 2213 001a FB68     		ldr	r3, [r7, #12]
1950:..\Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2214              		.loc 1 1950 0
 2215 001c 1846     		mov	r0, r3
 2216 001e 1437     		adds	r7, r7, #20
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 79


 2217              		.cfi_def_cfa_offset 4
 2218 0020 BD46     		mov	sp, r7
 2219              		.cfi_def_cfa_register 13
 2220              		@ sp needed
 2221 0022 5DF8047B 		ldr	r7, [sp], #4
 2222              		.cfi_restore 7
 2223              		.cfi_def_cfa_offset 0
 2224 0026 7047     		bx	lr
 2225              		.cfi_endproc
 2226              	.LFE90:
 2227              		.size	xQueueIsQueueEmptyFromISR, .-xQueueIsQueueEmptyFromISR
 2228              		.section	.text.prvIsQueueFull,"ax",%progbits
 2229              		.align	2
 2230              		.thumb
 2231              		.thumb_func
 2232              		.type	prvIsQueueFull, %function
 2233              	prvIsQueueFull:
 2234              	.LFB91:
1951:..\Source/queue.c **** /*-----------------------------------------------------------*/
1952:..\Source/queue.c **** 
1953:..\Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1954:..\Source/queue.c **** {
 2235              		.loc 1 1954 0
 2236              		.cfi_startproc
 2237              		@ args = 0, pretend = 0, frame = 16
 2238              		@ frame_needed = 1, uses_anonymous_args = 0
 2239 0000 80B5     		push	{r7, lr}
 2240              		.cfi_def_cfa_offset 8
 2241              		.cfi_offset 7, -8
 2242              		.cfi_offset 14, -4
 2243 0002 84B0     		sub	sp, sp, #16
 2244              		.cfi_def_cfa_offset 24
 2245 0004 00AF     		add	r7, sp, #0
 2246              		.cfi_def_cfa_register 7
 2247 0006 7860     		str	r0, [r7, #4]
1955:..\Source/queue.c **** BaseType_t xReturn;
1956:..\Source/queue.c **** 
1957:..\Source/queue.c **** 	taskENTER_CRITICAL();
 2248              		.loc 1 1957 0
 2249 0008 FFF7FEFF 		bl	vPortEnterCritical
1958:..\Source/queue.c **** 	{
1959:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2250              		.loc 1 1959 0
 2251 000c 7B68     		ldr	r3, [r7, #4]
 2252 000e 9A6B     		ldr	r2, [r3, #56]
 2253 0010 7B68     		ldr	r3, [r7, #4]
 2254 0012 DB6B     		ldr	r3, [r3, #60]
 2255 0014 9A42     		cmp	r2, r3
 2256 0016 02D1     		bne	.L132
1960:..\Source/queue.c **** 		{
1961:..\Source/queue.c **** 			xReturn = pdTRUE;
 2257              		.loc 1 1961 0
 2258 0018 0123     		movs	r3, #1
 2259 001a FB60     		str	r3, [r7, #12]
 2260 001c 01E0     		b	.L133
 2261              	.L132:
1962:..\Source/queue.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 80


1963:..\Source/queue.c **** 		else
1964:..\Source/queue.c **** 		{
1965:..\Source/queue.c **** 			xReturn = pdFALSE;
 2262              		.loc 1 1965 0
 2263 001e 0023     		movs	r3, #0
 2264 0020 FB60     		str	r3, [r7, #12]
 2265              	.L133:
1966:..\Source/queue.c **** 		}
1967:..\Source/queue.c **** 	}
1968:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 2266              		.loc 1 1968 0
 2267 0022 FFF7FEFF 		bl	vPortExitCritical
1969:..\Source/queue.c **** 
1970:..\Source/queue.c **** 	return xReturn;
 2268              		.loc 1 1970 0
 2269 0026 FB68     		ldr	r3, [r7, #12]
1971:..\Source/queue.c **** }
 2270              		.loc 1 1971 0
 2271 0028 1846     		mov	r0, r3
 2272 002a 1037     		adds	r7, r7, #16
 2273              		.cfi_def_cfa_offset 8
 2274 002c BD46     		mov	sp, r7
 2275              		.cfi_def_cfa_register 13
 2276              		@ sp needed
 2277 002e 80BD     		pop	{r7, pc}
 2278              		.cfi_endproc
 2279              	.LFE91:
 2280              		.size	prvIsQueueFull, .-prvIsQueueFull
 2281              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2282              		.align	2
 2283              		.global	xQueueIsQueueFullFromISR
 2284              		.thumb
 2285              		.thumb_func
 2286              		.type	xQueueIsQueueFullFromISR, %function
 2287              	xQueueIsQueueFullFromISR:
 2288              	.LFB92:
1972:..\Source/queue.c **** /*-----------------------------------------------------------*/
1973:..\Source/queue.c **** 
1974:..\Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1975:..\Source/queue.c **** {
 2289              		.loc 1 1975 0
 2290              		.cfi_startproc
 2291              		@ args = 0, pretend = 0, frame = 16
 2292              		@ frame_needed = 1, uses_anonymous_args = 0
 2293              		@ link register save eliminated.
 2294 0000 80B4     		push	{r7}
 2295              		.cfi_def_cfa_offset 4
 2296              		.cfi_offset 7, -4
 2297 0002 85B0     		sub	sp, sp, #20
 2298              		.cfi_def_cfa_offset 24
 2299 0004 00AF     		add	r7, sp, #0
 2300              		.cfi_def_cfa_register 7
 2301 0006 7860     		str	r0, [r7, #4]
1976:..\Source/queue.c **** BaseType_t xReturn;
1977:..\Source/queue.c **** 
1978:..\Source/queue.c **** 	configASSERT( xQueue );
1979:..\Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 81


 2302              		.loc 1 1979 0
 2303 0008 7B68     		ldr	r3, [r7, #4]
 2304 000a 9A6B     		ldr	r2, [r3, #56]
 2305 000c 7B68     		ldr	r3, [r7, #4]
 2306 000e DB6B     		ldr	r3, [r3, #60]
 2307 0010 9A42     		cmp	r2, r3
 2308 0012 02D1     		bne	.L136
1980:..\Source/queue.c **** 	{
1981:..\Source/queue.c **** 		xReturn = pdTRUE;
 2309              		.loc 1 1981 0
 2310 0014 0123     		movs	r3, #1
 2311 0016 FB60     		str	r3, [r7, #12]
 2312 0018 01E0     		b	.L137
 2313              	.L136:
1982:..\Source/queue.c **** 	}
1983:..\Source/queue.c **** 	else
1984:..\Source/queue.c **** 	{
1985:..\Source/queue.c **** 		xReturn = pdFALSE;
 2314              		.loc 1 1985 0
 2315 001a 0023     		movs	r3, #0
 2316 001c FB60     		str	r3, [r7, #12]
 2317              	.L137:
1986:..\Source/queue.c **** 	}
1987:..\Source/queue.c **** 
1988:..\Source/queue.c **** 	return xReturn;
 2318              		.loc 1 1988 0
 2319 001e FB68     		ldr	r3, [r7, #12]
1989:..\Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2320              		.loc 1 1989 0
 2321 0020 1846     		mov	r0, r3
 2322 0022 1437     		adds	r7, r7, #20
 2323              		.cfi_def_cfa_offset 4
 2324 0024 BD46     		mov	sp, r7
 2325              		.cfi_def_cfa_register 13
 2326              		@ sp needed
 2327 0026 5DF8047B 		ldr	r7, [sp], #4
 2328              		.cfi_restore 7
 2329              		.cfi_def_cfa_offset 0
 2330 002a 7047     		bx	lr
 2331              		.cfi_endproc
 2332              	.LFE92:
 2333              		.size	xQueueIsQueueFullFromISR, .-xQueueIsQueueFullFromISR
 2334              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2335              		.align	2
 2336              		.global	vQueueAddToRegistry
 2337              		.thumb
 2338              		.thumb_func
 2339              		.type	vQueueAddToRegistry, %function
 2340              	vQueueAddToRegistry:
 2341              	.LFB93:
1990:..\Source/queue.c **** /*-----------------------------------------------------------*/
1991:..\Source/queue.c **** 
1992:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1993:..\Source/queue.c **** 
1994:..\Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
1995:..\Source/queue.c **** 	{
1996:..\Source/queue.c **** 	BaseType_t xReturn;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 82


1997:..\Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1998:..\Source/queue.c **** 
1999:..\Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2000:..\Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2001:..\Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2002:..\Source/queue.c **** 		portDISABLE_INTERRUPTS();
2003:..\Source/queue.c **** 		{
2004:..\Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2005:..\Source/queue.c **** 			{
2006:..\Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2007:..\Source/queue.c **** 				posting? */
2008:..\Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2009:..\Source/queue.c **** 				{
2010:..\Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2011:..\Source/queue.c **** 					return indicating that we need to block. */
2012:..\Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2013:..\Source/queue.c **** 					portENABLE_INTERRUPTS();
2014:..\Source/queue.c **** 					return errQUEUE_BLOCKED;
2015:..\Source/queue.c **** 				}
2016:..\Source/queue.c **** 				else
2017:..\Source/queue.c **** 				{
2018:..\Source/queue.c **** 					portENABLE_INTERRUPTS();
2019:..\Source/queue.c **** 					return errQUEUE_FULL;
2020:..\Source/queue.c **** 				}
2021:..\Source/queue.c **** 			}
2022:..\Source/queue.c **** 		}
2023:..\Source/queue.c **** 		portENABLE_INTERRUPTS();
2024:..\Source/queue.c **** 
2025:..\Source/queue.c **** 		portDISABLE_INTERRUPTS();
2026:..\Source/queue.c **** 		{
2027:..\Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2028:..\Source/queue.c **** 			{
2029:..\Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2030:..\Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2031:..\Source/queue.c **** 				xReturn = pdPASS;
2032:..\Source/queue.c **** 
2033:..\Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2034:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2035:..\Source/queue.c **** 				{
2036:..\Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2037:..\Source/queue.c **** 					into the ready list as we are within a critical section.
2038:..\Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2039:..\Source/queue.c **** 					the event were caused from within an interrupt. */
2040:..\Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2041:..\Source/queue.c **** 					{
2042:..\Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2043:..\Source/queue.c **** 						that a yield might be appropriate. */
2044:..\Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2045:..\Source/queue.c **** 					}
2046:..\Source/queue.c **** 					else
2047:..\Source/queue.c **** 					{
2048:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2049:..\Source/queue.c **** 					}
2050:..\Source/queue.c **** 				}
2051:..\Source/queue.c **** 				else
2052:..\Source/queue.c **** 				{
2053:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 83


2054:..\Source/queue.c **** 				}
2055:..\Source/queue.c **** 			}
2056:..\Source/queue.c **** 			else
2057:..\Source/queue.c **** 			{
2058:..\Source/queue.c **** 				xReturn = errQUEUE_FULL;
2059:..\Source/queue.c **** 			}
2060:..\Source/queue.c **** 		}
2061:..\Source/queue.c **** 		portENABLE_INTERRUPTS();
2062:..\Source/queue.c **** 
2063:..\Source/queue.c **** 		return xReturn;
2064:..\Source/queue.c **** 	}
2065:..\Source/queue.c **** 
2066:..\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2067:..\Source/queue.c **** /*-----------------------------------------------------------*/
2068:..\Source/queue.c **** 
2069:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2070:..\Source/queue.c **** 
2071:..\Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2072:..\Source/queue.c **** 	{
2073:..\Source/queue.c **** 	BaseType_t xReturn;
2074:..\Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2075:..\Source/queue.c **** 
2076:..\Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2077:..\Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2078:..\Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2079:..\Source/queue.c **** 		portDISABLE_INTERRUPTS();
2080:..\Source/queue.c **** 		{
2081:..\Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2082:..\Source/queue.c **** 			{
2083:..\Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2084:..\Source/queue.c **** 				leave with nothing? */
2085:..\Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2086:..\Source/queue.c **** 				{
2087:..\Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2088:..\Source/queue.c **** 					indicating that we need to block. */
2089:..\Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2090:..\Source/queue.c **** 					portENABLE_INTERRUPTS();
2091:..\Source/queue.c **** 					return errQUEUE_BLOCKED;
2092:..\Source/queue.c **** 				}
2093:..\Source/queue.c **** 				else
2094:..\Source/queue.c **** 				{
2095:..\Source/queue.c **** 					portENABLE_INTERRUPTS();
2096:..\Source/queue.c **** 					return errQUEUE_FULL;
2097:..\Source/queue.c **** 				}
2098:..\Source/queue.c **** 			}
2099:..\Source/queue.c **** 			else
2100:..\Source/queue.c **** 			{
2101:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2102:..\Source/queue.c **** 			}
2103:..\Source/queue.c **** 		}
2104:..\Source/queue.c **** 		portENABLE_INTERRUPTS();
2105:..\Source/queue.c **** 
2106:..\Source/queue.c **** 		portDISABLE_INTERRUPTS();
2107:..\Source/queue.c **** 		{
2108:..\Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2109:..\Source/queue.c **** 			{
2110:..\Source/queue.c **** 				/* Data is available from the queue. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 84


2111:..\Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2112:..\Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2113:..\Source/queue.c **** 				{
2114:..\Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2115:..\Source/queue.c **** 				}
2116:..\Source/queue.c **** 				else
2117:..\Source/queue.c **** 				{
2118:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2119:..\Source/queue.c **** 				}
2120:..\Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2121:..\Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2122:..\Source/queue.c **** 
2123:..\Source/queue.c **** 				xReturn = pdPASS;
2124:..\Source/queue.c **** 
2125:..\Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2126:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2127:..\Source/queue.c **** 				{
2128:..\Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2129:..\Source/queue.c **** 					into the ready list as we are within a critical section.
2130:..\Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2131:..\Source/queue.c **** 					the event were caused from within an interrupt. */
2132:..\Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2133:..\Source/queue.c **** 					{
2134:..\Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2135:..\Source/queue.c **** 					}
2136:..\Source/queue.c **** 					else
2137:..\Source/queue.c **** 					{
2138:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2139:..\Source/queue.c **** 					}
2140:..\Source/queue.c **** 				}
2141:..\Source/queue.c **** 				else
2142:..\Source/queue.c **** 				{
2143:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2144:..\Source/queue.c **** 				}
2145:..\Source/queue.c **** 			}
2146:..\Source/queue.c **** 			else
2147:..\Source/queue.c **** 			{
2148:..\Source/queue.c **** 				xReturn = pdFAIL;
2149:..\Source/queue.c **** 			}
2150:..\Source/queue.c **** 		}
2151:..\Source/queue.c **** 		portENABLE_INTERRUPTS();
2152:..\Source/queue.c **** 
2153:..\Source/queue.c **** 		return xReturn;
2154:..\Source/queue.c **** 	}
2155:..\Source/queue.c **** 
2156:..\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2157:..\Source/queue.c **** /*-----------------------------------------------------------*/
2158:..\Source/queue.c **** 
2159:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2160:..\Source/queue.c **** 
2161:..\Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
2162:..\Source/queue.c **** 	{
2163:..\Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2164:..\Source/queue.c **** 
2165:..\Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2166:..\Source/queue.c **** 		exit without doing anything. */
2167:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 85


2168:..\Source/queue.c **** 		{
2169:..\Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2170:..\Source/queue.c **** 
2171:..\Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2172:..\Source/queue.c **** 			co-routine has not already been woken. */
2173:..\Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2174:..\Source/queue.c **** 			{
2175:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2176:..\Source/queue.c **** 				{
2177:..\Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2178:..\Source/queue.c **** 					{
2179:..\Source/queue.c **** 						return pdTRUE;
2180:..\Source/queue.c **** 					}
2181:..\Source/queue.c **** 					else
2182:..\Source/queue.c **** 					{
2183:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2184:..\Source/queue.c **** 					}
2185:..\Source/queue.c **** 				}
2186:..\Source/queue.c **** 				else
2187:..\Source/queue.c **** 				{
2188:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2189:..\Source/queue.c **** 				}
2190:..\Source/queue.c **** 			}
2191:..\Source/queue.c **** 			else
2192:..\Source/queue.c **** 			{
2193:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2194:..\Source/queue.c **** 			}
2195:..\Source/queue.c **** 		}
2196:..\Source/queue.c **** 		else
2197:..\Source/queue.c **** 		{
2198:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2199:..\Source/queue.c **** 		}
2200:..\Source/queue.c **** 
2201:..\Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2202:..\Source/queue.c **** 	}
2203:..\Source/queue.c **** 
2204:..\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2205:..\Source/queue.c **** /*-----------------------------------------------------------*/
2206:..\Source/queue.c **** 
2207:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2208:..\Source/queue.c **** 
2209:..\Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2210:..\Source/queue.c **** 	{
2211:..\Source/queue.c **** 	BaseType_t xReturn;
2212:..\Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2213:..\Source/queue.c **** 
2214:..\Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2215:..\Source/queue.c **** 		not then just leave without doing anything. */
2216:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2217:..\Source/queue.c **** 		{
2218:..\Source/queue.c **** 			/* Copy the data from the queue. */
2219:..\Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2220:..\Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2221:..\Source/queue.c **** 			{
2222:..\Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2223:..\Source/queue.c **** 			}
2224:..\Source/queue.c **** 			else
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 86


2225:..\Source/queue.c **** 			{
2226:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2227:..\Source/queue.c **** 			}
2228:..\Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2229:..\Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2230:..\Source/queue.c **** 
2231:..\Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2232:..\Source/queue.c **** 			{
2233:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2234:..\Source/queue.c **** 				{
2235:..\Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2236:..\Source/queue.c **** 					{
2237:..\Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2238:..\Source/queue.c **** 					}
2239:..\Source/queue.c **** 					else
2240:..\Source/queue.c **** 					{
2241:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2242:..\Source/queue.c **** 					}
2243:..\Source/queue.c **** 				}
2244:..\Source/queue.c **** 				else
2245:..\Source/queue.c **** 				{
2246:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2247:..\Source/queue.c **** 				}
2248:..\Source/queue.c **** 			}
2249:..\Source/queue.c **** 			else
2250:..\Source/queue.c **** 			{
2251:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2252:..\Source/queue.c **** 			}
2253:..\Source/queue.c **** 
2254:..\Source/queue.c **** 			xReturn = pdPASS;
2255:..\Source/queue.c **** 		}
2256:..\Source/queue.c **** 		else
2257:..\Source/queue.c **** 		{
2258:..\Source/queue.c **** 			xReturn = pdFAIL;
2259:..\Source/queue.c **** 		}
2260:..\Source/queue.c **** 
2261:..\Source/queue.c **** 		return xReturn;
2262:..\Source/queue.c **** 	}
2263:..\Source/queue.c **** 
2264:..\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2265:..\Source/queue.c **** /*-----------------------------------------------------------*/
2266:..\Source/queue.c **** 
2267:..\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2268:..\Source/queue.c **** 
2269:..\Source/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2270:..\Source/queue.c **** 	{
 2342              		.loc 1 2270 0
 2343              		.cfi_startproc
 2344              		@ args = 0, pretend = 0, frame = 16
 2345              		@ frame_needed = 1, uses_anonymous_args = 0
 2346              		@ link register save eliminated.
 2347 0000 80B4     		push	{r7}
 2348              		.cfi_def_cfa_offset 4
 2349              		.cfi_offset 7, -4
 2350 0002 85B0     		sub	sp, sp, #20
 2351              		.cfi_def_cfa_offset 24
 2352 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 87


 2353              		.cfi_def_cfa_register 7
 2354 0006 7860     		str	r0, [r7, #4]
 2355 0008 3960     		str	r1, [r7]
2271:..\Source/queue.c **** 	UBaseType_t ux;
2272:..\Source/queue.c **** 
2273:..\Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2274:..\Source/queue.c **** 		a free slot. */
2275:..\Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2356              		.loc 1 2275 0
 2357 000a 0023     		movs	r3, #0
 2358 000c FB60     		str	r3, [r7, #12]
 2359 000e 14E0     		b	.L140
 2360              	.L143:
2276:..\Source/queue.c **** 		{
2277:..\Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2361              		.loc 1 2277 0
 2362 0010 0E4A     		ldr	r2, .L144
 2363 0012 FB68     		ldr	r3, [r7, #12]
 2364 0014 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2365 0018 002B     		cmp	r3, #0
 2366 001a 0BD1     		bne	.L141
2278:..\Source/queue.c **** 			{
2279:..\Source/queue.c **** 				/* Store the information on this queue. */
2280:..\Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2367              		.loc 1 2280 0
 2368 001c 0B49     		ldr	r1, .L144
 2369 001e FB68     		ldr	r3, [r7, #12]
 2370 0020 3A68     		ldr	r2, [r7]
 2371 0022 41F83320 		str	r2, [r1, r3, lsl #3]
2281:..\Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2372              		.loc 1 2281 0
 2373 0026 094A     		ldr	r2, .L144
 2374 0028 FB68     		ldr	r3, [r7, #12]
 2375 002a DB00     		lsls	r3, r3, #3
 2376 002c 1344     		add	r3, r3, r2
 2377 002e 7A68     		ldr	r2, [r7, #4]
 2378 0030 5A60     		str	r2, [r3, #4]
2282:..\Source/queue.c **** 
2283:..\Source/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2284:..\Source/queue.c **** 				break;
 2379              		.loc 1 2284 0
 2380 0032 05E0     		b	.L139
 2381              	.L141:
2275:..\Source/queue.c **** 		{
 2382              		.loc 1 2275 0 discriminator 2
 2383 0034 FB68     		ldr	r3, [r7, #12]
 2384 0036 0133     		adds	r3, r3, #1
 2385 0038 FB60     		str	r3, [r7, #12]
 2386              	.L140:
2275:..\Source/queue.c **** 		{
 2387              		.loc 1 2275 0 is_stmt 0 discriminator 1
 2388 003a FB68     		ldr	r3, [r7, #12]
 2389 003c 092B     		cmp	r3, #9
 2390 003e E7D9     		bls	.L143
 2391              	.L139:
2285:..\Source/queue.c **** 			}
2286:..\Source/queue.c **** 			else
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 88


2287:..\Source/queue.c **** 			{
2288:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2289:..\Source/queue.c **** 			}
2290:..\Source/queue.c **** 		}
2291:..\Source/queue.c **** 	}
 2392              		.loc 1 2291 0 is_stmt 1
 2393 0040 1437     		adds	r7, r7, #20
 2394              		.cfi_def_cfa_offset 4
 2395 0042 BD46     		mov	sp, r7
 2396              		.cfi_def_cfa_register 13
 2397              		@ sp needed
 2398 0044 5DF8047B 		ldr	r7, [sp], #4
 2399              		.cfi_restore 7
 2400              		.cfi_def_cfa_offset 0
 2401 0048 7047     		bx	lr
 2402              	.L145:
 2403 004a 00BF     		.align	2
 2404              	.L144:
 2405 004c 00000000 		.word	xQueueRegistry
 2406              		.cfi_endproc
 2407              	.LFE93:
 2408              		.size	vQueueAddToRegistry, .-vQueueAddToRegistry
 2409              		.section	.text.pcQueueGetName,"ax",%progbits
 2410              		.align	2
 2411              		.global	pcQueueGetName
 2412              		.thumb
 2413              		.thumb_func
 2414              		.type	pcQueueGetName, %function
 2415              	pcQueueGetName:
 2416              	.LFB94:
2292:..\Source/queue.c **** 
2293:..\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2294:..\Source/queue.c **** /*-----------------------------------------------------------*/
2295:..\Source/queue.c **** 
2296:..\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2297:..\Source/queue.c **** 
2298:..\Source/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2299:..\Source/queue.c **** 	{
 2417              		.loc 1 2299 0
 2418              		.cfi_startproc
 2419              		@ args = 0, pretend = 0, frame = 16
 2420              		@ frame_needed = 1, uses_anonymous_args = 0
 2421              		@ link register save eliminated.
 2422 0000 80B4     		push	{r7}
 2423              		.cfi_def_cfa_offset 4
 2424              		.cfi_offset 7, -4
 2425 0002 85B0     		sub	sp, sp, #20
 2426              		.cfi_def_cfa_offset 24
 2427 0004 00AF     		add	r7, sp, #0
 2428              		.cfi_def_cfa_register 7
 2429 0006 7860     		str	r0, [r7, #4]
2300:..\Source/queue.c **** 	UBaseType_t ux;
2301:..\Source/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 2430              		.loc 1 2301 0
 2431 0008 0023     		movs	r3, #0
 2432 000a BB60     		str	r3, [r7, #8]
2302:..\Source/queue.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 89


2303:..\Source/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2304:..\Source/queue.c **** 		removing entries from the registry while it is being searched. */
2305:..\Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2433              		.loc 1 2305 0
 2434 000c 0023     		movs	r3, #0
 2435 000e FB60     		str	r3, [r7, #12]
 2436 0010 10E0     		b	.L147
 2437              	.L150:
2306:..\Source/queue.c **** 		{
2307:..\Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2438              		.loc 1 2307 0
 2439 0012 0D4A     		ldr	r2, .L152
 2440 0014 FB68     		ldr	r3, [r7, #12]
 2441 0016 DB00     		lsls	r3, r3, #3
 2442 0018 1344     		add	r3, r3, r2
 2443 001a 5A68     		ldr	r2, [r3, #4]
 2444 001c 7B68     		ldr	r3, [r7, #4]
 2445 001e 9A42     		cmp	r2, r3
 2446 0020 05D1     		bne	.L148
2308:..\Source/queue.c **** 			{
2309:..\Source/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 2447              		.loc 1 2309 0
 2448 0022 094A     		ldr	r2, .L152
 2449 0024 FB68     		ldr	r3, [r7, #12]
 2450 0026 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2451 002a BB60     		str	r3, [r7, #8]
2310:..\Source/queue.c **** 				break;
 2452              		.loc 1 2310 0
 2453 002c 05E0     		b	.L149
 2454              	.L148:
2305:..\Source/queue.c **** 		{
 2455              		.loc 1 2305 0 discriminator 2
 2456 002e FB68     		ldr	r3, [r7, #12]
 2457 0030 0133     		adds	r3, r3, #1
 2458 0032 FB60     		str	r3, [r7, #12]
 2459              	.L147:
2305:..\Source/queue.c **** 		{
 2460              		.loc 1 2305 0 is_stmt 0 discriminator 1
 2461 0034 FB68     		ldr	r3, [r7, #12]
 2462 0036 092B     		cmp	r3, #9
 2463 0038 EBD9     		bls	.L150
 2464              	.L149:
2311:..\Source/queue.c **** 			}
2312:..\Source/queue.c **** 			else
2313:..\Source/queue.c **** 			{
2314:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2315:..\Source/queue.c **** 			}
2316:..\Source/queue.c **** 		}
2317:..\Source/queue.c **** 
2318:..\Source/queue.c **** 		return pcReturn;
 2465              		.loc 1 2318 0 is_stmt 1
 2466 003a BB68     		ldr	r3, [r7, #8]
2319:..\Source/queue.c **** 	}
 2467              		.loc 1 2319 0
 2468 003c 1846     		mov	r0, r3
 2469 003e 1437     		adds	r7, r7, #20
 2470              		.cfi_def_cfa_offset 4
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 90


 2471 0040 BD46     		mov	sp, r7
 2472              		.cfi_def_cfa_register 13
 2473              		@ sp needed
 2474 0042 5DF8047B 		ldr	r7, [sp], #4
 2475              		.cfi_restore 7
 2476              		.cfi_def_cfa_offset 0
 2477 0046 7047     		bx	lr
 2478              	.L153:
 2479              		.align	2
 2480              	.L152:
 2481 0048 00000000 		.word	xQueueRegistry
 2482              		.cfi_endproc
 2483              	.LFE94:
 2484              		.size	pcQueueGetName, .-pcQueueGetName
 2485              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2486              		.align	2
 2487              		.global	vQueueUnregisterQueue
 2488              		.thumb
 2489              		.thumb_func
 2490              		.type	vQueueUnregisterQueue, %function
 2491              	vQueueUnregisterQueue:
 2492              	.LFB95:
2320:..\Source/queue.c **** 
2321:..\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2322:..\Source/queue.c **** /*-----------------------------------------------------------*/
2323:..\Source/queue.c **** 
2324:..\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2325:..\Source/queue.c **** 
2326:..\Source/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2327:..\Source/queue.c **** 	{
 2493              		.loc 1 2327 0
 2494              		.cfi_startproc
 2495              		@ args = 0, pretend = 0, frame = 16
 2496              		@ frame_needed = 1, uses_anonymous_args = 0
 2497              		@ link register save eliminated.
 2498 0000 80B4     		push	{r7}
 2499              		.cfi_def_cfa_offset 4
 2500              		.cfi_offset 7, -4
 2501 0002 85B0     		sub	sp, sp, #20
 2502              		.cfi_def_cfa_offset 24
 2503 0004 00AF     		add	r7, sp, #0
 2504              		.cfi_def_cfa_register 7
 2505 0006 7860     		str	r0, [r7, #4]
2328:..\Source/queue.c **** 	UBaseType_t ux;
2329:..\Source/queue.c **** 
2330:..\Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2331:..\Source/queue.c **** 		registry. */
2332:..\Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2506              		.loc 1 2332 0
 2507 0008 0023     		movs	r3, #0
 2508 000a FB60     		str	r3, [r7, #12]
 2509 000c 16E0     		b	.L155
 2510              	.L158:
2333:..\Source/queue.c **** 		{
2334:..\Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2511              		.loc 1 2334 0
 2512 000e 0F4A     		ldr	r2, .L159
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 91


 2513 0010 FB68     		ldr	r3, [r7, #12]
 2514 0012 DB00     		lsls	r3, r3, #3
 2515 0014 1344     		add	r3, r3, r2
 2516 0016 5A68     		ldr	r2, [r3, #4]
 2517 0018 7B68     		ldr	r3, [r7, #4]
 2518 001a 9A42     		cmp	r2, r3
 2519 001c 0BD1     		bne	.L156
2335:..\Source/queue.c **** 			{
2336:..\Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2337:..\Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2520              		.loc 1 2337 0
 2521 001e 0B4A     		ldr	r2, .L159
 2522 0020 FB68     		ldr	r3, [r7, #12]
 2523 0022 0021     		movs	r1, #0
 2524 0024 42F83310 		str	r1, [r2, r3, lsl #3]
2338:..\Source/queue.c **** 
2339:..\Source/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2340:..\Source/queue.c **** 				appear in the registry twice if it is added, removed, then
2341:..\Source/queue.c **** 				added again. */
2342:..\Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 2525              		.loc 1 2342 0
 2526 0028 084A     		ldr	r2, .L159
 2527 002a FB68     		ldr	r3, [r7, #12]
 2528 002c DB00     		lsls	r3, r3, #3
 2529 002e 1344     		add	r3, r3, r2
 2530 0030 0022     		movs	r2, #0
 2531 0032 5A60     		str	r2, [r3, #4]
2343:..\Source/queue.c **** 				break;
 2532              		.loc 1 2343 0
 2533 0034 05E0     		b	.L154
 2534              	.L156:
2332:..\Source/queue.c **** 		{
 2535              		.loc 1 2332 0 discriminator 2
 2536 0036 FB68     		ldr	r3, [r7, #12]
 2537 0038 0133     		adds	r3, r3, #1
 2538 003a FB60     		str	r3, [r7, #12]
 2539              	.L155:
2332:..\Source/queue.c **** 		{
 2540              		.loc 1 2332 0 is_stmt 0 discriminator 1
 2541 003c FB68     		ldr	r3, [r7, #12]
 2542 003e 092B     		cmp	r3, #9
 2543 0040 E5D9     		bls	.L158
 2544              	.L154:
2344:..\Source/queue.c **** 			}
2345:..\Source/queue.c **** 			else
2346:..\Source/queue.c **** 			{
2347:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2348:..\Source/queue.c **** 			}
2349:..\Source/queue.c **** 		}
2350:..\Source/queue.c **** 
2351:..\Source/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2545              		.loc 1 2351 0 is_stmt 1
 2546 0042 1437     		adds	r7, r7, #20
 2547              		.cfi_def_cfa_offset 4
 2548 0044 BD46     		mov	sp, r7
 2549              		.cfi_def_cfa_register 13
 2550              		@ sp needed
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 92


 2551 0046 5DF8047B 		ldr	r7, [sp], #4
 2552              		.cfi_restore 7
 2553              		.cfi_def_cfa_offset 0
 2554 004a 7047     		bx	lr
 2555              	.L160:
 2556              		.align	2
 2557              	.L159:
 2558 004c 00000000 		.word	xQueueRegistry
 2559              		.cfi_endproc
 2560              	.LFE95:
 2561              		.size	vQueueUnregisterQueue, .-vQueueUnregisterQueue
 2562              		.text
 2563              	.Letext0:
 2564              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 2565              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 2566              		.file 5 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 2567              		.file 6 "..\\Source\\include/list.h"
 2568              		.file 7 "..\\Source\\include/task.h"
 2569              		.file 8 "..\\Source\\include/queue.h"
 2570              		.file 9 "Generated_Source\\PSoC5/core_cm3.h"
 2571              		.section	.debug_info,"",%progbits
 2572              	.Ldebug_info0:
 2573 0000 C20E0000 		.4byte	0xec2
 2574 0004 0400     		.2byte	0x4
 2575 0006 00000000 		.4byte	.Ldebug_abbrev0
 2576 000a 04       		.byte	0x4
 2577 000b 01       		.uleb128 0x1
 2578 000c C8040000 		.4byte	.LASF125
 2579 0010 01       		.byte	0x1
 2580 0011 37020000 		.4byte	.LASF126
 2581 0015 F3000000 		.4byte	.LASF127
 2582 0019 00000000 		.4byte	.Ldebug_ranges0+0
 2583 001d 00000000 		.4byte	0
 2584 0021 00000000 		.4byte	.Ldebug_line0
 2585 0025 02       		.uleb128 0x2
 2586 0026 B9020000 		.4byte	.LASF1
 2587 002a 03       		.byte	0x3
 2588 002b D4       		.byte	0xd4
 2589 002c 30000000 		.4byte	0x30
 2590 0030 03       		.uleb128 0x3
 2591 0031 04       		.byte	0x4
 2592 0032 07       		.byte	0x7
 2593 0033 5E000000 		.4byte	.LASF0
 2594 0037 04       		.uleb128 0x4
 2595 0038 04       		.byte	0x4
 2596 0039 05       		.byte	0x5
 2597 003a 696E7400 		.ascii	"int\000"
 2598 003e 02       		.uleb128 0x2
 2599 003f D0050000 		.4byte	.LASF2
 2600 0043 04       		.byte	0x4
 2601 0044 1B       		.byte	0x1b
 2602 0045 49000000 		.4byte	0x49
 2603 0049 03       		.uleb128 0x3
 2604 004a 01       		.byte	0x1
 2605 004b 06       		.byte	0x6
 2606 004c 9D070000 		.4byte	.LASF3
 2607 0050 02       		.uleb128 0x2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 93


 2608 0051 AF060000 		.4byte	.LASF4
 2609 0055 04       		.byte	0x4
 2610 0056 1D       		.byte	0x1d
 2611 0057 5B000000 		.4byte	0x5b
 2612 005b 03       		.uleb128 0x3
 2613 005c 01       		.byte	0x1
 2614 005d 08       		.byte	0x8
 2615 005e FE060000 		.4byte	.LASF5
 2616 0062 03       		.uleb128 0x3
 2617 0063 02       		.byte	0x2
 2618 0064 05       		.byte	0x5
 2619 0065 2D060000 		.4byte	.LASF6
 2620 0069 03       		.uleb128 0x3
 2621 006a 02       		.byte	0x2
 2622 006b 07       		.byte	0x7
 2623 006c A9070000 		.4byte	.LASF7
 2624 0070 02       		.uleb128 0x2
 2625 0071 88000000 		.4byte	.LASF8
 2626 0075 04       		.byte	0x4
 2627 0076 3F       		.byte	0x3f
 2628 0077 7B000000 		.4byte	0x7b
 2629 007b 03       		.uleb128 0x3
 2630 007c 04       		.byte	0x4
 2631 007d 05       		.byte	0x5
 2632 007e 42060000 		.4byte	.LASF9
 2633 0082 02       		.uleb128 0x2
 2634 0083 0C070000 		.4byte	.LASF10
 2635 0087 04       		.byte	0x4
 2636 0088 41       		.byte	0x41
 2637 0089 8D000000 		.4byte	0x8d
 2638 008d 03       		.uleb128 0x3
 2639 008e 04       		.byte	0x4
 2640 008f 07       		.byte	0x7
 2641 0090 D2060000 		.4byte	.LASF11
 2642 0094 03       		.uleb128 0x3
 2643 0095 08       		.byte	0x8
 2644 0096 05       		.byte	0x5
 2645 0097 5A040000 		.4byte	.LASF12
 2646 009b 03       		.uleb128 0x3
 2647 009c 08       		.byte	0x8
 2648 009d 07       		.byte	0x7
 2649 009e 5E020000 		.4byte	.LASF13
 2650 00a2 03       		.uleb128 0x3
 2651 00a3 04       		.byte	0x4
 2652 00a4 07       		.byte	0x7
 2653 00a5 C9060000 		.4byte	.LASF14
 2654 00a9 05       		.uleb128 0x5
 2655 00aa 04       		.byte	0x4
 2656 00ab 03       		.uleb128 0x3
 2657 00ac 01       		.byte	0x1
 2658 00ad 08       		.byte	0x8
 2659 00ae 69030000 		.4byte	.LASF15
 2660 00b2 06       		.uleb128 0x6
 2661 00b3 04       		.byte	0x4
 2662 00b4 B8000000 		.4byte	0xb8
 2663 00b8 07       		.uleb128 0x7
 2664 00b9 AB000000 		.4byte	0xab
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 94


 2665 00bd 06       		.uleb128 0x6
 2666 00be 04       		.byte	0x4
 2667 00bf C3000000 		.4byte	0xc3
 2668 00c3 08       		.uleb128 0x8
 2669 00c4 02       		.uleb128 0x2
 2670 00c5 E6010000 		.4byte	.LASF16
 2671 00c9 05       		.byte	0x5
 2672 00ca 14       		.byte	0x14
 2673 00cb 3E000000 		.4byte	0x3e
 2674 00cf 02       		.uleb128 0x2
 2675 00d0 06040000 		.4byte	.LASF17
 2676 00d4 05       		.byte	0x5
 2677 00d5 15       		.byte	0x15
 2678 00d6 50000000 		.4byte	0x50
 2679 00da 02       		.uleb128 0x2
 2680 00db E4060000 		.4byte	.LASF18
 2681 00df 05       		.byte	0x5
 2682 00e0 2C       		.byte	0x2c
 2683 00e1 70000000 		.4byte	0x70
 2684 00e5 02       		.uleb128 0x2
 2685 00e6 DD010000 		.4byte	.LASF19
 2686 00ea 05       		.byte	0x5
 2687 00eb 2D       		.byte	0x2d
 2688 00ec 82000000 		.4byte	0x82
 2689 00f0 03       		.uleb128 0x3
 2690 00f1 04       		.byte	0x4
 2691 00f2 04       		.byte	0x4
 2692 00f3 21020000 		.4byte	.LASF20
 2693 00f7 03       		.uleb128 0x3
 2694 00f8 08       		.byte	0x8
 2695 00f9 04       		.byte	0x4
 2696 00fa C3070000 		.4byte	.LASF21
 2697 00fe 02       		.uleb128 0x2
 2698 00ff 7B040000 		.4byte	.LASF22
 2699 0103 02       		.byte	0x2
 2700 0104 62       		.byte	0x62
 2701 0105 7B000000 		.4byte	0x7b
 2702 0109 02       		.uleb128 0x2
 2703 010a 95030000 		.4byte	.LASF23
 2704 010e 02       		.byte	0x2
 2705 010f 63       		.byte	0x63
 2706 0110 8D000000 		.4byte	0x8d
 2707 0114 02       		.uleb128 0x2
 2708 0115 C5050000 		.4byte	.LASF24
 2709 0119 02       		.byte	0x2
 2710 011a 69       		.byte	0x69
 2711 011b E5000000 		.4byte	0xe5
 2712 011f 06       		.uleb128 0x6
 2713 0120 04       		.byte	0x4
 2714 0121 CF000000 		.4byte	0xcf
 2715 0125 09       		.uleb128 0x9
 2716 0126 92000000 		.4byte	.LASF31
 2717 012a 14       		.byte	0x14
 2718 012b 06       		.byte	0x6
 2719 012c B5       		.byte	0xb5
 2720 012d 6E010000 		.4byte	0x16e
 2721 0131 0A       		.uleb128 0xa
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 95


 2722 0132 37060000 		.4byte	.LASF25
 2723 0136 06       		.byte	0x6
 2724 0137 B8       		.byte	0xb8
 2725 0138 14010000 		.4byte	0x114
 2726 013c 00       		.byte	0
 2727 013d 0A       		.uleb128 0xa
 2728 013e C1040000 		.4byte	.LASF26
 2729 0142 06       		.byte	0x6
 2730 0143 B9       		.byte	0xb9
 2731 0144 6E010000 		.4byte	0x16e
 2732 0148 04       		.byte	0x4
 2733 0149 0A       		.uleb128 0xa
 2734 014a 8E020000 		.4byte	.LASF27
 2735 014e 06       		.byte	0x6
 2736 014f BA       		.byte	0xba
 2737 0150 6E010000 		.4byte	0x16e
 2738 0154 08       		.byte	0x8
 2739 0155 0A       		.uleb128 0xa
 2740 0156 39070000 		.4byte	.LASF28
 2741 015a 06       		.byte	0x6
 2742 015b BB       		.byte	0xbb
 2743 015c A9000000 		.4byte	0xa9
 2744 0160 0C       		.byte	0xc
 2745 0161 0A       		.uleb128 0xa
 2746 0162 00060000 		.4byte	.LASF29
 2747 0166 06       		.byte	0x6
 2748 0167 BC       		.byte	0xbc
 2749 0168 A9000000 		.4byte	0xa9
 2750 016c 10       		.byte	0x10
 2751 016d 00       		.byte	0
 2752 016e 06       		.uleb128 0x6
 2753 016f 04       		.byte	0x4
 2754 0170 25010000 		.4byte	0x125
 2755 0174 02       		.uleb128 0x2
 2756 0175 6E030000 		.4byte	.LASF30
 2757 0179 06       		.byte	0x6
 2758 017a BF       		.byte	0xbf
 2759 017b 25010000 		.4byte	0x125
 2760 017f 09       		.uleb128 0x9
 2761 0180 DD020000 		.4byte	.LASF32
 2762 0184 0C       		.byte	0xc
 2763 0185 06       		.byte	0x6
 2764 0186 C1       		.byte	0xc1
 2765 0187 B0010000 		.4byte	0x1b0
 2766 018b 0A       		.uleb128 0xa
 2767 018c 37060000 		.4byte	.LASF25
 2768 0190 06       		.byte	0x6
 2769 0191 C4       		.byte	0xc4
 2770 0192 14010000 		.4byte	0x114
 2771 0196 00       		.byte	0
 2772 0197 0A       		.uleb128 0xa
 2773 0198 C1040000 		.4byte	.LASF26
 2774 019c 06       		.byte	0x6
 2775 019d C5       		.byte	0xc5
 2776 019e 6E010000 		.4byte	0x16e
 2777 01a2 04       		.byte	0x4
 2778 01a3 0A       		.uleb128 0xa
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 96


 2779 01a4 8E020000 		.4byte	.LASF27
 2780 01a8 06       		.byte	0x6
 2781 01a9 C6       		.byte	0xc6
 2782 01aa 6E010000 		.4byte	0x16e
 2783 01ae 08       		.byte	0x8
 2784 01af 00       		.byte	0
 2785 01b0 02       		.uleb128 0x2
 2786 01b1 F7030000 		.4byte	.LASF33
 2787 01b5 06       		.byte	0x6
 2788 01b6 C8       		.byte	0xc8
 2789 01b7 7F010000 		.4byte	0x17f
 2790 01bb 09       		.uleb128 0x9
 2791 01bc ED020000 		.4byte	.LASF34
 2792 01c0 14       		.byte	0x14
 2793 01c1 06       		.byte	0x6
 2794 01c2 CD       		.byte	0xcd
 2795 01c3 EC010000 		.4byte	0x1ec
 2796 01c7 0A       		.uleb128 0xa
 2797 01c8 00000000 		.4byte	.LASF35
 2798 01cc 06       		.byte	0x6
 2799 01cd D0       		.byte	0xd0
 2800 01ce 09010000 		.4byte	0x109
 2801 01d2 00       		.byte	0
 2802 01d3 0A       		.uleb128 0xa
 2803 01d4 6B000000 		.4byte	.LASF36
 2804 01d8 06       		.byte	0x6
 2805 01d9 D1       		.byte	0xd1
 2806 01da EC010000 		.4byte	0x1ec
 2807 01de 04       		.byte	0x4
 2808 01df 0A       		.uleb128 0xa
 2809 01e0 D0030000 		.4byte	.LASF37
 2810 01e4 06       		.byte	0x6
 2811 01e5 D2       		.byte	0xd2
 2812 01e6 B0010000 		.4byte	0x1b0
 2813 01ea 08       		.byte	0x8
 2814 01eb 00       		.byte	0
 2815 01ec 06       		.uleb128 0x6
 2816 01ed 04       		.byte	0x4
 2817 01ee 74010000 		.4byte	0x174
 2818 01f2 02       		.uleb128 0x2
 2819 01f3 B4050000 		.4byte	.LASF38
 2820 01f7 06       		.byte	0x6
 2821 01f8 D4       		.byte	0xd4
 2822 01f9 BB010000 		.4byte	0x1bb
 2823 01fd 09       		.uleb128 0x9
 2824 01fe 73000000 		.4byte	.LASF39
 2825 0202 08       		.byte	0x8
 2826 0203 07       		.byte	0x7
 2827 0204 87       		.byte	0x87
 2828 0205 22020000 		.4byte	0x222
 2829 0209 0A       		.uleb128 0xa
 2830 020a E4000000 		.4byte	.LASF40
 2831 020e 07       		.byte	0x7
 2832 020f 89       		.byte	0x89
 2833 0210 FE000000 		.4byte	0xfe
 2834 0214 00       		.byte	0
 2835 0215 0A       		.uleb128 0xa
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 97


 2836 0216 9D040000 		.4byte	.LASF41
 2837 021a 07       		.byte	0x7
 2838 021b 8A       		.byte	0x8a
 2839 021c 14010000 		.4byte	0x114
 2840 0220 04       		.byte	0x4
 2841 0221 00       		.byte	0
 2842 0222 02       		.uleb128 0x2
 2843 0223 6B050000 		.4byte	.LASF42
 2844 0227 07       		.byte	0x7
 2845 0228 8B       		.byte	0x8b
 2846 0229 FD010000 		.4byte	0x1fd
 2847 022d 02       		.uleb128 0x2
 2848 022e C2030000 		.4byte	.LASF43
 2849 0232 08       		.byte	0x8
 2850 0233 58       		.byte	0x58
 2851 0234 A9000000 		.4byte	0xa9
 2852 0238 0B       		.uleb128 0xb
 2853 0239 04       		.byte	0x4
 2854 023a 01       		.byte	0x1
 2855 023b 88       		.byte	0x88
 2856 023c 57020000 		.4byte	0x257
 2857 0240 0C       		.uleb128 0xc
 2858 0241 8F010000 		.4byte	.LASF44
 2859 0245 01       		.byte	0x1
 2860 0246 8A       		.byte	0x8a
 2861 0247 57020000 		.4byte	0x257
 2862 024b 0C       		.uleb128 0xc
 2863 024c 3A010000 		.4byte	.LASF45
 2864 0250 01       		.byte	0x1
 2865 0251 8B       		.byte	0x8b
 2866 0252 09010000 		.4byte	0x109
 2867 0256 00       		.byte	0
 2868 0257 06       		.uleb128 0x6
 2869 0258 04       		.byte	0x4
 2870 0259 C4000000 		.4byte	0xc4
 2871 025d 09       		.uleb128 0x9
 2872 025e 27020000 		.4byte	.LASF46
 2873 0262 48       		.byte	0x48
 2874 0263 01       		.byte	0x1
 2875 0264 82       		.byte	0x82
 2876 0265 EC020000 		.4byte	0x2ec
 2877 0269 0A       		.uleb128 0xa
 2878 026a 41070000 		.4byte	.LASF47
 2879 026e 01       		.byte	0x1
 2880 026f 84       		.byte	0x84
 2881 0270 57020000 		.4byte	0x257
 2882 0274 00       		.byte	0
 2883 0275 0A       		.uleb128 0xa
 2884 0276 A8060000 		.4byte	.LASF48
 2885 027a 01       		.byte	0x1
 2886 027b 85       		.byte	0x85
 2887 027c 57020000 		.4byte	0x257
 2888 0280 04       		.byte	0x4
 2889 0281 0A       		.uleb128 0xa
 2890 0282 BB050000 		.4byte	.LASF49
 2891 0286 01       		.byte	0x1
 2892 0287 86       		.byte	0x86
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 98


 2893 0288 57020000 		.4byte	0x257
 2894 028c 08       		.byte	0x8
 2895 028d 0D       		.uleb128 0xd
 2896 028e 7500     		.ascii	"u\000"
 2897 0290 01       		.byte	0x1
 2898 0291 8C       		.byte	0x8c
 2899 0292 38020000 		.4byte	0x238
 2900 0296 0C       		.byte	0xc
 2901 0297 0A       		.uleb128 0xa
 2902 0298 B1000000 		.4byte	.LASF50
 2903 029c 01       		.byte	0x1
 2904 029d 8E       		.byte	0x8e
 2905 029e F2010000 		.4byte	0x1f2
 2906 02a2 10       		.byte	0x10
 2907 02a3 0A       		.uleb128 0xa
 2908 02a4 25000000 		.4byte	.LASF51
 2909 02a8 01       		.byte	0x1
 2910 02a9 8F       		.byte	0x8f
 2911 02aa F2010000 		.4byte	0x1f2
 2912 02ae 24       		.byte	0x24
 2913 02af 0A       		.uleb128 0xa
 2914 02b0 99020000 		.4byte	.LASF52
 2915 02b4 01       		.byte	0x1
 2916 02b5 91       		.byte	0x91
 2917 02b6 EC020000 		.4byte	0x2ec
 2918 02ba 38       		.byte	0x38
 2919 02bb 0A       		.uleb128 0xa
 2920 02bc 24060000 		.4byte	.LASF53
 2921 02c0 01       		.byte	0x1
 2922 02c1 92       		.byte	0x92
 2923 02c2 09010000 		.4byte	0x109
 2924 02c6 3C       		.byte	0x3c
 2925 02c7 0A       		.uleb128 0xa
 2926 02c8 41030000 		.4byte	.LASF54
 2927 02cc 01       		.byte	0x1
 2928 02cd 93       		.byte	0x93
 2929 02ce 09010000 		.4byte	0x109
 2930 02d2 40       		.byte	0x40
 2931 02d3 0A       		.uleb128 0xa
 2932 02d4 D4070000 		.4byte	.LASF55
 2933 02d8 01       		.byte	0x1
 2934 02d9 95       		.byte	0x95
 2935 02da F1020000 		.4byte	0x2f1
 2936 02de 44       		.byte	0x44
 2937 02df 0A       		.uleb128 0xa
 2938 02e0 DC000000 		.4byte	.LASF56
 2939 02e4 01       		.byte	0x1
 2940 02e5 96       		.byte	0x96
 2941 02e6 F1020000 		.4byte	0x2f1
 2942 02ea 45       		.byte	0x45
 2943 02eb 00       		.byte	0
 2944 02ec 0E       		.uleb128 0xe
 2945 02ed 09010000 		.4byte	0x109
 2946 02f1 0E       		.uleb128 0xe
 2947 02f2 C4000000 		.4byte	0xc4
 2948 02f6 02       		.uleb128 0x2
 2949 02f7 BC070000 		.4byte	.LASF57
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 99


 2950 02fb 01       		.byte	0x1
 2951 02fc A5       		.byte	0xa5
 2952 02fd 5D020000 		.4byte	0x25d
 2953 0301 02       		.uleb128 0x2
 2954 0302 4F010000 		.4byte	.LASF58
 2955 0306 01       		.byte	0x1
 2956 0307 A9       		.byte	0xa9
 2957 0308 F6020000 		.4byte	0x2f6
 2958 030c 09       		.uleb128 0x9
 2959 030d 9D000000 		.4byte	.LASF59
 2960 0311 08       		.byte	0x8
 2961 0312 01       		.byte	0x1
 2962 0313 B6       		.byte	0xb6
 2963 0314 31030000 		.4byte	0x331
 2964 0318 0A       		.uleb128 0xa
 2965 0319 D1020000 		.4byte	.LASF60
 2966 031d 01       		.byte	0x1
 2967 031e B8       		.byte	0xb8
 2968 031f B2000000 		.4byte	0xb2
 2969 0323 00       		.byte	0
 2970 0324 0A       		.uleb128 0xa
 2971 0325 C9020000 		.4byte	.LASF61
 2972 0329 01       		.byte	0x1
 2973 032a B9       		.byte	0xb9
 2974 032b 2D020000 		.4byte	0x22d
 2975 032f 04       		.byte	0x4
 2976 0330 00       		.byte	0
 2977 0331 02       		.uleb128 0x2
 2978 0332 0E040000 		.4byte	.LASF62
 2979 0336 01       		.byte	0x1
 2980 0337 BA       		.byte	0xba
 2981 0338 0C030000 		.4byte	0x30c
 2982 033c 02       		.uleb128 0x2
 2983 033d 6E010000 		.4byte	.LASF63
 2984 0341 01       		.byte	0x1
 2985 0342 BF       		.byte	0xbf
 2986 0343 31030000 		.4byte	0x331
 2987 0347 0F       		.uleb128 0xf
 2988 0348 47040000 		.4byte	.LASF128
 2989 034c 02       		.byte	0x2
 2990 034d F9       		.byte	0xf9
 2991 034e E5000000 		.4byte	0xe5
 2992 0352 03       		.byte	0x3
 2993 0353 6E030000 		.4byte	0x36e
 2994 0357 10       		.uleb128 0x10
 2995 0358 08020000 		.4byte	.LASF64
 2996 035c 02       		.byte	0x2
 2997 035d FB       		.byte	0xfb
 2998 035e E5000000 		.4byte	0xe5
 2999 0362 10       		.uleb128 0x10
 3000 0363 88030000 		.4byte	.LASF65
 3001 0367 02       		.byte	0x2
 3002 0368 FB       		.byte	0xfb
 3003 0369 E5000000 		.4byte	0xe5
 3004 036d 00       		.byte	0
 3005 036e 11       		.uleb128 0x11
 3006 036f 0C030000 		.4byte	.LASF129
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 100


 3007 0373 02       		.byte	0x2
 3008 0374 0D01     		.2byte	0x10d
 3009 0376 03       		.byte	0x3
 3010 0377 88030000 		.4byte	0x388
 3011 037b 12       		.uleb128 0x12
 3012 037c 8C050000 		.4byte	.LASF130
 3013 0380 02       		.byte	0x2
 3014 0381 0D01     		.2byte	0x10d
 3015 0383 E5000000 		.4byte	0xe5
 3016 0387 00       		.byte	0
 3017 0388 13       		.uleb128 0x13
 3018 0389 70070000 		.4byte	.LASF68
 3019 038d 01       		.byte	0x1
 3020 038e 1701     		.2byte	0x117
 3021 0390 FE000000 		.4byte	0xfe
 3022 0394 00000000 		.4byte	.LFB68
 3023 0398 B4000000 		.4byte	.LFE68-.LFB68
 3024 039c 01       		.uleb128 0x1
 3025 039d 9C       		.byte	0x9c
 3026 039e D0030000 		.4byte	0x3d0
 3027 03a2 14       		.uleb128 0x14
 3028 03a3 1A020000 		.4byte	.LASF66
 3029 03a7 01       		.byte	0x1
 3030 03a8 1701     		.2byte	0x117
 3031 03aa 2D020000 		.4byte	0x22d
 3032 03ae 02       		.uleb128 0x2
 3033 03af 91       		.byte	0x91
 3034 03b0 6C       		.sleb128 -20
 3035 03b1 14       		.uleb128 0x14
 3036 03b2 56050000 		.4byte	.LASF67
 3037 03b6 01       		.byte	0x1
 3038 03b7 1701     		.2byte	0x117
 3039 03b9 FE000000 		.4byte	0xfe
 3040 03bd 02       		.uleb128 0x2
 3041 03be 91       		.byte	0x91
 3042 03bf 68       		.sleb128 -24
 3043 03c0 15       		.uleb128 0x15
 3044 03c1 B9060000 		.4byte	.LASF72
 3045 03c5 01       		.byte	0x1
 3046 03c6 1901     		.2byte	0x119
 3047 03c8 D0030000 		.4byte	0x3d0
 3048 03cc 02       		.uleb128 0x2
 3049 03cd 91       		.byte	0x91
 3050 03ce 74       		.sleb128 -12
 3051 03cf 00       		.byte	0
 3052 03d0 07       		.uleb128 0x7
 3053 03d1 D5030000 		.4byte	0x3d5
 3054 03d5 06       		.uleb128 0x6
 3055 03d6 04       		.byte	0x4
 3056 03d7 01030000 		.4byte	0x301
 3057 03db 13       		.uleb128 0x13
 3058 03dc 21040000 		.4byte	.LASF69
 3059 03e0 01       		.byte	0x1
 3060 03e1 8201     		.2byte	0x182
 3061 03e3 2D020000 		.4byte	0x22d
 3062 03e7 00000000 		.4byte	.LFB69
 3063 03eb 58000000 		.4byte	.LFE69-.LFB69
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 101


 3064 03ef 01       		.uleb128 0x1
 3065 03f0 9C       		.byte	0x9c
 3066 03f1 50040000 		.4byte	0x450
 3067 03f5 14       		.uleb128 0x14
 3068 03f6 D9050000 		.4byte	.LASF70
 3069 03fa 01       		.byte	0x1
 3070 03fb 8201     		.2byte	0x182
 3071 03fd 50040000 		.4byte	0x450
 3072 0401 02       		.uleb128 0x2
 3073 0402 91       		.byte	0x91
 3074 0403 5C       		.sleb128 -36
 3075 0404 14       		.uleb128 0x14
 3076 0405 41030000 		.4byte	.LASF54
 3077 0409 01       		.byte	0x1
 3078 040a 8201     		.2byte	0x182
 3079 040c 50040000 		.4byte	0x450
 3080 0410 02       		.uleb128 0x2
 3081 0411 91       		.byte	0x91
 3082 0412 58       		.sleb128 -40
 3083 0413 14       		.uleb128 0x14
 3084 0414 9B050000 		.4byte	.LASF71
 3085 0418 01       		.byte	0x1
 3086 0419 8201     		.2byte	0x182
 3087 041b 55040000 		.4byte	0x455
 3088 041f 02       		.uleb128 0x2
 3089 0420 91       		.byte	0x91
 3090 0421 57       		.sleb128 -41
 3091 0422 15       		.uleb128 0x15
 3092 0423 7D000000 		.4byte	.LASF73
 3093 0427 01       		.byte	0x1
 3094 0428 8401     		.2byte	0x184
 3095 042a D5030000 		.4byte	0x3d5
 3096 042e 02       		.uleb128 0x2
 3097 042f 91       		.byte	0x91
 3098 0430 68       		.sleb128 -24
 3099 0431 15       		.uleb128 0x15
 3100 0432 58060000 		.4byte	.LASF74
 3101 0436 01       		.byte	0x1
 3102 0437 8501     		.2byte	0x185
 3103 0439 25000000 		.4byte	0x25
 3104 043d 02       		.uleb128 0x2
 3105 043e 91       		.byte	0x91
 3106 043f 6C       		.sleb128 -20
 3107 0440 15       		.uleb128 0x15
 3108 0441 86040000 		.4byte	.LASF75
 3109 0445 01       		.byte	0x1
 3110 0446 8601     		.2byte	0x186
 3111 0448 1F010000 		.4byte	0x11f
 3112 044c 02       		.uleb128 0x2
 3113 044d 91       		.byte	0x91
 3114 044e 64       		.sleb128 -28
 3115 044f 00       		.byte	0
 3116 0450 07       		.uleb128 0x7
 3117 0451 09010000 		.4byte	0x109
 3118 0455 07       		.uleb128 0x7
 3119 0456 CF000000 		.4byte	0xcf
 3120 045a 16       		.uleb128 0x16
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 102


 3121 045b C7010000 		.4byte	.LASF76
 3122 045f 01       		.byte	0x1
 3123 0460 B001     		.2byte	0x1b0
 3124 0462 00000000 		.4byte	.LFB70
 3125 0466 3C000000 		.4byte	.LFE70-.LFB70
 3126 046a 01       		.uleb128 0x1
 3127 046b 9C       		.byte	0x9c
 3128 046c BC040000 		.4byte	0x4bc
 3129 0470 14       		.uleb128 0x14
 3130 0471 D9050000 		.4byte	.LASF70
 3131 0475 01       		.byte	0x1
 3132 0476 B001     		.2byte	0x1b0
 3133 0478 50040000 		.4byte	0x450
 3134 047c 02       		.uleb128 0x2
 3135 047d 91       		.byte	0x91
 3136 047e 74       		.sleb128 -12
 3137 047f 14       		.uleb128 0x14
 3138 0480 41030000 		.4byte	.LASF54
 3139 0484 01       		.byte	0x1
 3140 0485 B001     		.2byte	0x1b0
 3141 0487 50040000 		.4byte	0x450
 3142 048b 02       		.uleb128 0x2
 3143 048c 91       		.byte	0x91
 3144 048d 70       		.sleb128 -16
 3145 048e 14       		.uleb128 0x14
 3146 048f 86040000 		.4byte	.LASF75
 3147 0493 01       		.byte	0x1
 3148 0494 B001     		.2byte	0x1b0
 3149 0496 1F010000 		.4byte	0x11f
 3150 049a 02       		.uleb128 0x2
 3151 049b 91       		.byte	0x91
 3152 049c 6C       		.sleb128 -20
 3153 049d 14       		.uleb128 0x14
 3154 049e 9B050000 		.4byte	.LASF71
 3155 04a2 01       		.byte	0x1
 3156 04a3 B001     		.2byte	0x1b0
 3157 04a5 55040000 		.4byte	0x455
 3158 04a9 02       		.uleb128 0x2
 3159 04aa 91       		.byte	0x91
 3160 04ab 6B       		.sleb128 -21
 3161 04ac 14       		.uleb128 0x14
 3162 04ad 7D000000 		.4byte	.LASF73
 3163 04b1 01       		.byte	0x1
 3164 04b2 B001     		.2byte	0x1b0
 3165 04b4 D5030000 		.4byte	0x3d5
 3166 04b8 02       		.uleb128 0x2
 3167 04b9 91       		.byte	0x91
 3168 04ba 00       		.sleb128 0
 3169 04bb 00       		.byte	0
 3170 04bc 16       		.uleb128 0x16
 3171 04bd 68040000 		.4byte	.LASF77
 3172 04c1 01       		.byte	0x1
 3173 04c2 DC01     		.2byte	0x1dc
 3174 04c4 00000000 		.4byte	.LFB71
 3175 04c8 32000000 		.4byte	.LFE71-.LFB71
 3176 04cc 01       		.uleb128 0x1
 3177 04cd 9C       		.byte	0x9c
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 103


 3178 04ce E2040000 		.4byte	0x4e2
 3179 04d2 14       		.uleb128 0x14
 3180 04d3 7D000000 		.4byte	.LASF73
 3181 04d7 01       		.byte	0x1
 3182 04d8 DC01     		.2byte	0x1dc
 3183 04da D5030000 		.4byte	0x3d5
 3184 04de 02       		.uleb128 0x2
 3185 04df 91       		.byte	0x91
 3186 04e0 74       		.sleb128 -12
 3187 04e1 00       		.byte	0
 3188 04e2 13       		.uleb128 0x13
 3189 04e3 35040000 		.4byte	.LASF78
 3190 04e7 01       		.byte	0x1
 3191 04e8 FA01     		.2byte	0x1fa
 3192 04ea 2D020000 		.4byte	0x22d
 3193 04ee 00000000 		.4byte	.LFB72
 3194 04f2 30000000 		.4byte	.LFE72-.LFB72
 3195 04f6 01       		.uleb128 0x1
 3196 04f7 9C       		.byte	0x9c
 3197 04f8 39050000 		.4byte	0x539
 3198 04fc 14       		.uleb128 0x14
 3199 04fd 9B050000 		.4byte	.LASF71
 3200 0501 01       		.byte	0x1
 3201 0502 FA01     		.2byte	0x1fa
 3202 0504 55040000 		.4byte	0x455
 3203 0508 02       		.uleb128 0x2
 3204 0509 91       		.byte	0x91
 3205 050a 67       		.sleb128 -25
 3206 050b 15       		.uleb128 0x15
 3207 050c 7D000000 		.4byte	.LASF73
 3208 0510 01       		.byte	0x1
 3209 0511 FC01     		.2byte	0x1fc
 3210 0513 D5030000 		.4byte	0x3d5
 3211 0517 02       		.uleb128 0x2
 3212 0518 91       		.byte	0x91
 3213 0519 6C       		.sleb128 -20
 3214 051a 15       		.uleb128 0x15
 3215 051b 5B030000 		.4byte	.LASF79
 3216 051f 01       		.byte	0x1
 3217 0520 FD01     		.2byte	0x1fd
 3218 0522 50040000 		.4byte	0x450
 3219 0526 02       		.uleb128 0x2
 3220 0527 91       		.byte	0x91
 3221 0528 74       		.sleb128 -12
 3222 0529 15       		.uleb128 0x15
 3223 052a ED010000 		.4byte	.LASF80
 3224 052e 01       		.byte	0x1
 3225 052f FD01     		.2byte	0x1fd
 3226 0531 50040000 		.4byte	0x450
 3227 0535 02       		.uleb128 0x2
 3228 0536 91       		.byte	0x91
 3229 0537 70       		.sleb128 -16
 3230 0538 00       		.byte	0
 3231 0539 13       		.uleb128 0x13
 3232 053a 48070000 		.4byte	.LASF81
 3233 053e 01       		.byte	0x1
 3234 053f 3C02     		.2byte	0x23c
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 104


 3235 0541 FE000000 		.4byte	0xfe
 3236 0545 00000000 		.4byte	.LFB73
 3237 0549 4C000000 		.4byte	.LFE73-.LFB73
 3238 054d 01       		.uleb128 0x1
 3239 054e 9C       		.byte	0x9c
 3240 054f 81050000 		.4byte	0x581
 3241 0553 14       		.uleb128 0x14
 3242 0554 96040000 		.4byte	.LASF82
 3243 0558 01       		.byte	0x1
 3244 0559 3C02     		.2byte	0x23c
 3245 055b 2D020000 		.4byte	0x22d
 3246 055f 02       		.uleb128 0x2
 3247 0560 91       		.byte	0x91
 3248 0561 64       		.sleb128 -28
 3249 0562 15       		.uleb128 0x15
 3250 0563 C1060000 		.4byte	.LASF83
 3251 0567 01       		.byte	0x1
 3252 0568 3E02     		.2byte	0x23e
 3253 056a FE000000 		.4byte	0xfe
 3254 056e 02       		.uleb128 0x2
 3255 056f 91       		.byte	0x91
 3256 0570 6C       		.sleb128 -20
 3257 0571 15       		.uleb128 0x15
 3258 0572 56000000 		.4byte	.LASF84
 3259 0576 01       		.byte	0x1
 3260 0577 3F02     		.2byte	0x23f
 3261 0579 D0030000 		.4byte	0x3d0
 3262 057d 02       		.uleb128 0x2
 3263 057e 91       		.byte	0x91
 3264 057f 68       		.sleb128 -24
 3265 0580 00       		.byte	0
 3266 0581 13       		.uleb128 0x13
 3267 0582 E7050000 		.4byte	.LASF85
 3268 0586 01       		.byte	0x1
 3269 0587 7302     		.2byte	0x273
 3270 0589 FE000000 		.4byte	0xfe
 3271 058d 00000000 		.4byte	.LFB74
 3272 0591 54000000 		.4byte	.LFE74-.LFB74
 3273 0595 01       		.uleb128 0x1
 3274 0596 9C       		.byte	0x9c
 3275 0597 D8050000 		.4byte	0x5d8
 3276 059b 14       		.uleb128 0x14
 3277 059c 96040000 		.4byte	.LASF82
 3278 05a0 01       		.byte	0x1
 3279 05a1 7302     		.2byte	0x273
 3280 05a3 2D020000 		.4byte	0x22d
 3281 05a7 02       		.uleb128 0x2
 3282 05a8 91       		.byte	0x91
 3283 05a9 64       		.sleb128 -28
 3284 05aa 14       		.uleb128 0x14
 3285 05ab 2C070000 		.4byte	.LASF86
 3286 05af 01       		.byte	0x1
 3287 05b0 7302     		.2byte	0x273
 3288 05b2 14010000 		.4byte	0x114
 3289 05b6 02       		.uleb128 0x2
 3290 05b7 91       		.byte	0x91
 3291 05b8 60       		.sleb128 -32
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 105


 3292 05b9 15       		.uleb128 0x15
 3293 05ba C1060000 		.4byte	.LASF83
 3294 05be 01       		.byte	0x1
 3295 05bf 7502     		.2byte	0x275
 3296 05c1 FE000000 		.4byte	0xfe
 3297 05c5 02       		.uleb128 0x2
 3298 05c6 91       		.byte	0x91
 3299 05c7 6C       		.sleb128 -20
 3300 05c8 15       		.uleb128 0x15
 3301 05c9 56000000 		.4byte	.LASF84
 3302 05cd 01       		.byte	0x1
 3303 05ce 7602     		.2byte	0x276
 3304 05d0 D0030000 		.4byte	0x3d0
 3305 05d4 02       		.uleb128 0x2
 3306 05d5 91       		.byte	0x91
 3307 05d6 68       		.sleb128 -24
 3308 05d7 00       		.byte	0
 3309 05d8 13       		.uleb128 0x13
 3310 05d9 DC070000 		.4byte	.LASF87
 3311 05dd 01       		.byte	0x1
 3312 05de B902     		.2byte	0x2b9
 3313 05e0 2D020000 		.4byte	0x22d
 3314 05e4 00000000 		.4byte	.LFB75
 3315 05e8 2C000000 		.4byte	.LFE75-.LFB75
 3316 05ec 01       		.uleb128 0x1
 3317 05ed 9C       		.byte	0x9c
 3318 05ee 20060000 		.4byte	0x620
 3319 05f2 14       		.uleb128 0x14
 3320 05f3 60050000 		.4byte	.LASF88
 3321 05f7 01       		.byte	0x1
 3322 05f8 B902     		.2byte	0x2b9
 3323 05fa 50040000 		.4byte	0x450
 3324 05fe 02       		.uleb128 0x2
 3325 05ff 91       		.byte	0x91
 3326 0600 6C       		.sleb128 -20
 3327 0601 14       		.uleb128 0x14
 3328 0602 4C030000 		.4byte	.LASF89
 3329 0606 01       		.byte	0x1
 3330 0607 B902     		.2byte	0x2b9
 3331 0609 50040000 		.4byte	0x450
 3332 060d 02       		.uleb128 0x2
 3333 060e 91       		.byte	0x91
 3334 060f 68       		.sleb128 -24
 3335 0610 15       		.uleb128 0x15
 3336 0611 C9020000 		.4byte	.LASF61
 3337 0615 01       		.byte	0x1
 3338 0616 BB02     		.2byte	0x2bb
 3339 0618 2D020000 		.4byte	0x22d
 3340 061c 02       		.uleb128 0x2
 3341 061d 91       		.byte	0x91
 3342 061e 74       		.sleb128 -12
 3343 061f 00       		.byte	0
 3344 0620 13       		.uleb128 0x13
 3345 0621 2F030000 		.4byte	.LASF90
 3346 0625 01       		.byte	0x1
 3347 0626 D302     		.2byte	0x2d3
 3348 0628 FE000000 		.4byte	0xfe
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 106


 3349 062c 00000000 		.4byte	.LFB76
 3350 0630 5C010000 		.4byte	.LFE76-.LFB76
 3351 0634 01       		.uleb128 0x1
 3352 0635 9C       		.byte	0x9c
 3353 0636 B3060000 		.4byte	0x6b3
 3354 063a 14       		.uleb128 0x14
 3355 063b 1A020000 		.4byte	.LASF66
 3356 063f 01       		.byte	0x1
 3357 0640 D302     		.2byte	0x2d3
 3358 0642 2D020000 		.4byte	0x22d
 3359 0646 02       		.uleb128 0x2
 3360 0647 91       		.byte	0x91
 3361 0648 5C       		.sleb128 -36
 3362 0649 14       		.uleb128 0x14
 3363 064a 6A060000 		.4byte	.LASF91
 3364 064e 01       		.byte	0x1
 3365 064f D302     		.2byte	0x2d3
 3366 0651 B3060000 		.4byte	0x6b3
 3367 0655 02       		.uleb128 0x2
 3368 0656 91       		.byte	0x91
 3369 0657 58       		.sleb128 -40
 3370 0658 14       		.uleb128 0x14
 3371 0659 2C070000 		.4byte	.LASF86
 3372 065d 01       		.byte	0x1
 3373 065e D302     		.2byte	0x2d3
 3374 0660 14010000 		.4byte	0x114
 3375 0664 02       		.uleb128 0x2
 3376 0665 91       		.byte	0x91
 3377 0666 54       		.sleb128 -44
 3378 0667 14       		.uleb128 0x14
 3379 0668 57010000 		.4byte	.LASF92
 3380 066c 01       		.byte	0x1
 3381 066d D302     		.2byte	0x2d3
 3382 066f B8060000 		.4byte	0x6b8
 3383 0673 02       		.uleb128 0x2
 3384 0674 91       		.byte	0x91
 3385 0675 50       		.sleb128 -48
 3386 0676 15       		.uleb128 0x15
 3387 0677 AB020000 		.4byte	.LASF93
 3388 067b 01       		.byte	0x1
 3389 067c D502     		.2byte	0x2d5
 3390 067e FE000000 		.4byte	0xfe
 3391 0682 02       		.uleb128 0x2
 3392 0683 91       		.byte	0x91
 3393 0684 74       		.sleb128 -12
 3394 0685 15       		.uleb128 0x15
 3395 0686 F9010000 		.4byte	.LASF94
 3396 068a 01       		.byte	0x1
 3397 068b D502     		.2byte	0x2d5
 3398 068d FE000000 		.4byte	0xfe
 3399 0691 02       		.uleb128 0x2
 3400 0692 91       		.byte	0x91
 3401 0693 6C       		.sleb128 -20
 3402 0694 15       		.uleb128 0x15
 3403 0695 C0020000 		.4byte	.LASF95
 3404 0699 01       		.byte	0x1
 3405 069a D602     		.2byte	0x2d6
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 107


 3406 069c 22020000 		.4byte	0x222
 3407 06a0 02       		.uleb128 0x2
 3408 06a1 91       		.byte	0x91
 3409 06a2 64       		.sleb128 -28
 3410 06a3 15       		.uleb128 0x15
 3411 06a4 B9060000 		.4byte	.LASF72
 3412 06a8 01       		.byte	0x1
 3413 06a9 D702     		.2byte	0x2d7
 3414 06ab D0030000 		.4byte	0x3d0
 3415 06af 02       		.uleb128 0x2
 3416 06b0 91       		.byte	0x91
 3417 06b1 70       		.sleb128 -16
 3418 06b2 00       		.byte	0
 3419 06b3 07       		.uleb128 0x7
 3420 06b4 BD000000 		.4byte	0xbd
 3421 06b8 07       		.uleb128 0x7
 3422 06b9 FE000000 		.4byte	0xfe
 3423 06bd 13       		.uleb128 0x13
 3424 06be F3020000 		.4byte	.LASF96
 3425 06c2 01       		.byte	0x1
 3426 06c3 9903     		.2byte	0x399
 3427 06c5 FE000000 		.4byte	0xfe
 3428 06c9 00000000 		.4byte	.LFB77
 3429 06cd B2000000 		.4byte	.LFE77-.LFB77
 3430 06d1 01       		.uleb128 0x1
 3431 06d2 9C       		.byte	0x9c
 3432 06d3 A6070000 		.4byte	0x7a6
 3433 06d7 14       		.uleb128 0x14
 3434 06d8 1A020000 		.4byte	.LASF66
 3435 06dc 01       		.byte	0x1
 3436 06dd 9903     		.2byte	0x399
 3437 06df 2D020000 		.4byte	0x22d
 3438 06e3 02       		.uleb128 0x2
 3439 06e4 91       		.byte	0x91
 3440 06e5 54       		.sleb128 -44
 3441 06e6 14       		.uleb128 0x14
 3442 06e7 6A060000 		.4byte	.LASF91
 3443 06eb 01       		.byte	0x1
 3444 06ec 9903     		.2byte	0x399
 3445 06ee B3060000 		.4byte	0x6b3
 3446 06f2 02       		.uleb128 0x2
 3447 06f3 91       		.byte	0x91
 3448 06f4 50       		.sleb128 -48
 3449 06f5 14       		.uleb128 0x14
 3450 06f6 3C000000 		.4byte	.LASF97
 3451 06fa 01       		.byte	0x1
 3452 06fb 9903     		.2byte	0x399
 3453 06fd A6070000 		.4byte	0x7a6
 3454 0701 02       		.uleb128 0x2
 3455 0702 91       		.byte	0x91
 3456 0703 4C       		.sleb128 -52
 3457 0704 14       		.uleb128 0x14
 3458 0705 57010000 		.4byte	.LASF92
 3459 0709 01       		.byte	0x1
 3460 070a 9903     		.2byte	0x399
 3461 070c B8060000 		.4byte	0x6b8
 3462 0710 02       		.uleb128 0x2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 108


 3463 0711 91       		.byte	0x91
 3464 0712 48       		.sleb128 -56
 3465 0713 15       		.uleb128 0x15
 3466 0714 C1060000 		.4byte	.LASF83
 3467 0718 01       		.byte	0x1
 3468 0719 9B03     		.2byte	0x39b
 3469 071b FE000000 		.4byte	0xfe
 3470 071f 02       		.uleb128 0x2
 3471 0720 91       		.byte	0x91
 3472 0721 74       		.sleb128 -12
 3473 0722 15       		.uleb128 0x15
 3474 0723 B0010000 		.4byte	.LASF98
 3475 0727 01       		.byte	0x1
 3476 0728 9C03     		.2byte	0x39c
 3477 072a 09010000 		.4byte	0x109
 3478 072e 02       		.uleb128 0x2
 3479 072f 91       		.byte	0x91
 3480 0730 6C       		.sleb128 -20
 3481 0731 15       		.uleb128 0x15
 3482 0732 B9060000 		.4byte	.LASF72
 3483 0736 01       		.byte	0x1
 3484 0737 9D03     		.2byte	0x39d
 3485 0739 D0030000 		.4byte	0x3d0
 3486 073d 02       		.uleb128 0x2
 3487 073e 91       		.byte	0x91
 3488 073f 70       		.sleb128 -16
 3489 0740 17       		.uleb128 0x17
 3490 0741 47030000 		.4byte	0x347
 3491 0745 12000000 		.4byte	.LBB23
 3492 0749 1A000000 		.4byte	.LBE23-.LBB23
 3493 074d 01       		.byte	0x1
 3494 074e B803     		.2byte	0x3b8
 3495 0750 6F070000 		.4byte	0x76f
 3496 0754 18       		.uleb128 0x18
 3497 0755 12000000 		.4byte	.LBB24
 3498 0759 1A000000 		.4byte	.LBE24-.LBB24
 3499 075d 19       		.uleb128 0x19
 3500 075e 57030000 		.4byte	0x357
 3501 0762 02       		.uleb128 0x2
 3502 0763 91       		.byte	0x91
 3503 0764 64       		.sleb128 -28
 3504 0765 19       		.uleb128 0x19
 3505 0766 62030000 		.4byte	0x362
 3506 076a 02       		.uleb128 0x2
 3507 076b 91       		.byte	0x91
 3508 076c 60       		.sleb128 -32
 3509 076d 00       		.byte	0
 3510 076e 00       		.byte	0
 3511 076f 1A       		.uleb128 0x1a
 3512 0770 40000000 		.4byte	.LBB25
 3513 0774 58000000 		.4byte	.LBE25-.LBB25
 3514 0778 8C070000 		.4byte	0x78c
 3515 077c 15       		.uleb128 0x15
 3516 077d DC000000 		.4byte	.LASF56
 3517 0781 01       		.byte	0x1
 3518 0782 BC03     		.2byte	0x3bc
 3519 0784 B1070000 		.4byte	0x7b1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 109


 3520 0788 02       		.uleb128 0x2
 3521 0789 91       		.byte	0x91
 3522 078a 6B       		.sleb128 -21
 3523 078b 00       		.byte	0
 3524 078c 1B       		.uleb128 0x1b
 3525 078d 6E030000 		.4byte	0x36e
 3526 0791 A2000000 		.4byte	.LBB26
 3527 0795 06000000 		.4byte	.LBE26-.LBB26
 3528 0799 01       		.byte	0x1
 3529 079a 2A04     		.2byte	0x42a
 3530 079c 1C       		.uleb128 0x1c
 3531 079d 7B030000 		.4byte	0x37b
 3532 07a1 02       		.uleb128 0x2
 3533 07a2 91       		.byte	0x91
 3534 07a3 5C       		.sleb128 -36
 3535 07a4 00       		.byte	0
 3536 07a5 00       		.byte	0
 3537 07a6 07       		.uleb128 0x7
 3538 07a7 AB070000 		.4byte	0x7ab
 3539 07ab 06       		.uleb128 0x6
 3540 07ac 04       		.byte	0x4
 3541 07ad FE000000 		.4byte	0xfe
 3542 07b1 07       		.uleb128 0x7
 3543 07b2 C4000000 		.4byte	0xc4
 3544 07b6 13       		.uleb128 0x13
 3545 07b7 A1030000 		.4byte	.LASF99
 3546 07bb 01       		.byte	0x1
 3547 07bc 3004     		.2byte	0x430
 3548 07be FE000000 		.4byte	0xfe
 3549 07c2 00000000 		.4byte	.LFB78
 3550 07c6 A6000000 		.4byte	.LFE78-.LFB78
 3551 07ca 01       		.uleb128 0x1
 3552 07cb 9C       		.byte	0x9c
 3553 07cc 9A080000 		.4byte	0x89a
 3554 07d0 14       		.uleb128 0x14
 3555 07d1 1A020000 		.4byte	.LASF66
 3556 07d5 01       		.byte	0x1
 3557 07d6 3004     		.2byte	0x430
 3558 07d8 2D020000 		.4byte	0x22d
 3559 07dc 02       		.uleb128 0x2
 3560 07dd 91       		.byte	0x91
 3561 07de 54       		.sleb128 -44
 3562 07df 14       		.uleb128 0x14
 3563 07e0 3C000000 		.4byte	.LASF97
 3564 07e4 01       		.byte	0x1
 3565 07e5 3004     		.2byte	0x430
 3566 07e7 A6070000 		.4byte	0x7a6
 3567 07eb 02       		.uleb128 0x2
 3568 07ec 91       		.byte	0x91
 3569 07ed 50       		.sleb128 -48
 3570 07ee 15       		.uleb128 0x15
 3571 07ef C1060000 		.4byte	.LASF83
 3572 07f3 01       		.byte	0x1
 3573 07f4 3204     		.2byte	0x432
 3574 07f6 FE000000 		.4byte	0xfe
 3575 07fa 02       		.uleb128 0x2
 3576 07fb 91       		.byte	0x91
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 110


 3577 07fc 74       		.sleb128 -12
 3578 07fd 15       		.uleb128 0x15
 3579 07fe B0010000 		.4byte	.LASF98
 3580 0802 01       		.byte	0x1
 3581 0803 3304     		.2byte	0x433
 3582 0805 09010000 		.4byte	0x109
 3583 0809 02       		.uleb128 0x2
 3584 080a 91       		.byte	0x91
 3585 080b 6C       		.sleb128 -20
 3586 080c 15       		.uleb128 0x15
 3587 080d B9060000 		.4byte	.LASF72
 3588 0811 01       		.byte	0x1
 3589 0812 3404     		.2byte	0x434
 3590 0814 D0030000 		.4byte	0x3d0
 3591 0818 02       		.uleb128 0x2
 3592 0819 91       		.byte	0x91
 3593 081a 70       		.sleb128 -16
 3594 081b 17       		.uleb128 0x17
 3595 081c 47030000 		.4byte	0x347
 3596 0820 0E000000 		.4byte	.LBB28
 3597 0824 1A000000 		.4byte	.LBE28-.LBB28
 3598 0828 01       		.byte	0x1
 3599 0829 5704     		.2byte	0x457
 3600 082b 4A080000 		.4byte	0x84a
 3601 082f 18       		.uleb128 0x18
 3602 0830 0E000000 		.4byte	.LBB29
 3603 0834 1A000000 		.4byte	.LBE29-.LBB29
 3604 0838 19       		.uleb128 0x19
 3605 0839 57030000 		.4byte	0x357
 3606 083d 02       		.uleb128 0x2
 3607 083e 91       		.byte	0x91
 3608 083f 60       		.sleb128 -32
 3609 0840 19       		.uleb128 0x19
 3610 0841 62030000 		.4byte	0x362
 3611 0845 02       		.uleb128 0x2
 3612 0846 91       		.byte	0x91
 3613 0847 5C       		.sleb128 -36
 3614 0848 00       		.byte	0
 3615 0849 00       		.byte	0
 3616 084a 1A       		.uleb128 0x1a
 3617 084b 2A000000 		.4byte	.LBB30
 3618 084f 6C000000 		.4byte	.LBE30-.LBB30
 3619 0853 80080000 		.4byte	0x880
 3620 0857 15       		.uleb128 0x15
 3621 0858 99020000 		.4byte	.LASF52
 3622 085c 01       		.byte	0x1
 3623 085d 5904     		.2byte	0x459
 3624 085f 50040000 		.4byte	0x450
 3625 0863 02       		.uleb128 0x2
 3626 0864 91       		.byte	0x91
 3627 0865 68       		.sleb128 -24
 3628 0866 18       		.uleb128 0x18
 3629 0867 3A000000 		.4byte	.LBB31
 3630 086b 52000000 		.4byte	.LBE31-.LBB31
 3631 086f 15       		.uleb128 0x15
 3632 0870 DC000000 		.4byte	.LASF56
 3633 0874 01       		.byte	0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 111


 3634 0875 6004     		.2byte	0x460
 3635 0877 B1070000 		.4byte	0x7b1
 3636 087b 02       		.uleb128 0x2
 3637 087c 91       		.byte	0x91
 3638 087d 67       		.sleb128 -25
 3639 087e 00       		.byte	0
 3640 087f 00       		.byte	0
 3641 0880 1B       		.uleb128 0x1b
 3642 0881 6E030000 		.4byte	0x36e
 3643 0885 96000000 		.4byte	.LBB32
 3644 0889 06000000 		.4byte	.LBE32-.LBB32
 3645 088d 01       		.byte	0x1
 3646 088e CF04     		.2byte	0x4cf
 3647 0890 1C       		.uleb128 0x1c
 3648 0891 7B030000 		.4byte	0x37b
 3649 0895 02       		.uleb128 0x2
 3650 0896 91       		.byte	0x91
 3651 0897 58       		.sleb128 -40
 3652 0898 00       		.byte	0
 3653 0899 00       		.byte	0
 3654 089a 13       		.uleb128 0x13
 3655 089b 49020000 		.4byte	.LASF100
 3656 089f 01       		.byte	0x1
 3657 08a0 D504     		.2byte	0x4d5
 3658 08a2 FE000000 		.4byte	0xfe
 3659 08a6 00000000 		.4byte	.LFB79
 3660 08aa B8010000 		.4byte	.LFE79-.LFB79
 3661 08ae 01       		.uleb128 0x1
 3662 08af 9C       		.byte	0x9c
 3663 08b0 46090000 		.4byte	0x946
 3664 08b4 14       		.uleb128 0x14
 3665 08b5 1A020000 		.4byte	.LASF66
 3666 08b9 01       		.byte	0x1
 3667 08ba D504     		.2byte	0x4d5
 3668 08bc 2D020000 		.4byte	0x22d
 3669 08c0 02       		.uleb128 0x2
 3670 08c1 91       		.byte	0x91
 3671 08c2 5C       		.sleb128 -36
 3672 08c3 14       		.uleb128 0x14
 3673 08c4 85020000 		.4byte	.LASF101
 3674 08c8 01       		.byte	0x1
 3675 08c9 D504     		.2byte	0x4d5
 3676 08cb 46090000 		.4byte	0x946
 3677 08cf 02       		.uleb128 0x2
 3678 08d0 91       		.byte	0x91
 3679 08d1 58       		.sleb128 -40
 3680 08d2 14       		.uleb128 0x14
 3681 08d3 2C070000 		.4byte	.LASF86
 3682 08d7 01       		.byte	0x1
 3683 08d8 D504     		.2byte	0x4d5
 3684 08da 14010000 		.4byte	0x114
 3685 08de 02       		.uleb128 0x2
 3686 08df 91       		.byte	0x91
 3687 08e0 54       		.sleb128 -44
 3688 08e1 14       		.uleb128 0x14
 3689 08e2 A7050000 		.4byte	.LASF102
 3690 08e6 01       		.byte	0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 112


 3691 08e7 D504     		.2byte	0x4d5
 3692 08e9 B8060000 		.4byte	0x6b8
 3693 08ed 02       		.uleb128 0x2
 3694 08ee 91       		.byte	0x91
 3695 08ef 50       		.sleb128 -48
 3696 08f0 15       		.uleb128 0x15
 3697 08f1 AB020000 		.4byte	.LASF93
 3698 08f5 01       		.byte	0x1
 3699 08f6 D704     		.2byte	0x4d7
 3700 08f8 FE000000 		.4byte	0xfe
 3701 08fc 02       		.uleb128 0x2
 3702 08fd 91       		.byte	0x91
 3703 08fe 74       		.sleb128 -12
 3704 08ff 15       		.uleb128 0x15
 3705 0900 C0020000 		.4byte	.LASF95
 3706 0904 01       		.byte	0x1
 3707 0905 D804     		.2byte	0x4d8
 3708 0907 22020000 		.4byte	0x222
 3709 090b 02       		.uleb128 0x2
 3710 090c 91       		.byte	0x91
 3711 090d 60       		.sleb128 -32
 3712 090e 15       		.uleb128 0x15
 3713 090f 75050000 		.4byte	.LASF103
 3714 0913 01       		.byte	0x1
 3715 0914 D904     		.2byte	0x4d9
 3716 0916 57020000 		.4byte	0x257
 3717 091a 02       		.uleb128 0x2
 3718 091b 91       		.byte	0x91
 3719 091c 68       		.sleb128 -24
 3720 091d 15       		.uleb128 0x15
 3721 091e B9060000 		.4byte	.LASF72
 3722 0922 01       		.byte	0x1
 3723 0923 DA04     		.2byte	0x4da
 3724 0925 D0030000 		.4byte	0x3d0
 3725 0929 02       		.uleb128 0x2
 3726 092a 91       		.byte	0x91
 3727 092b 70       		.sleb128 -16
 3728 092c 18       		.uleb128 0x18
 3729 092d 1A000000 		.4byte	.LBB34
 3730 0931 BC000000 		.4byte	.LBE34-.LBB34
 3731 0935 15       		.uleb128 0x15
 3732 0936 99020000 		.4byte	.LASF52
 3733 093a 01       		.byte	0x1
 3734 093b EC04     		.2byte	0x4ec
 3735 093d 50040000 		.4byte	0x450
 3736 0941 02       		.uleb128 0x2
 3737 0942 91       		.byte	0x91
 3738 0943 6C       		.sleb128 -20
 3739 0944 00       		.byte	0
 3740 0945 00       		.byte	0
 3741 0946 07       		.uleb128 0x7
 3742 0947 A9000000 		.4byte	0xa9
 3743 094b 13       		.uleb128 0x13
 3744 094c 10000000 		.4byte	.LASF104
 3745 0950 01       		.byte	0x1
 3746 0951 9A05     		.2byte	0x59a
 3747 0953 FE000000 		.4byte	0xfe
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 113


 3748 0957 00000000 		.4byte	.LFB80
 3749 095b AC000000 		.4byte	.LFE80-.LFB80
 3750 095f 01       		.uleb128 0x1
 3751 0960 9C       		.byte	0x9c
 3752 0961 3E0A0000 		.4byte	0xa3e
 3753 0965 14       		.uleb128 0x14
 3754 0966 1A020000 		.4byte	.LASF66
 3755 096a 01       		.byte	0x1
 3756 096b 9A05     		.2byte	0x59a
 3757 096d 2D020000 		.4byte	0x22d
 3758 0971 02       		.uleb128 0x2
 3759 0972 91       		.byte	0x91
 3760 0973 54       		.sleb128 -44
 3761 0974 14       		.uleb128 0x14
 3762 0975 85020000 		.4byte	.LASF101
 3763 0979 01       		.byte	0x1
 3764 097a 9A05     		.2byte	0x59a
 3765 097c 46090000 		.4byte	0x946
 3766 0980 02       		.uleb128 0x2
 3767 0981 91       		.byte	0x91
 3768 0982 50       		.sleb128 -48
 3769 0983 14       		.uleb128 0x14
 3770 0984 3C000000 		.4byte	.LASF97
 3771 0988 01       		.byte	0x1
 3772 0989 9A05     		.2byte	0x59a
 3773 098b A6070000 		.4byte	0x7a6
 3774 098f 02       		.uleb128 0x2
 3775 0990 91       		.byte	0x91
 3776 0991 4C       		.sleb128 -52
 3777 0992 15       		.uleb128 0x15
 3778 0993 C1060000 		.4byte	.LASF83
 3779 0997 01       		.byte	0x1
 3780 0998 9C05     		.2byte	0x59c
 3781 099a FE000000 		.4byte	0xfe
 3782 099e 02       		.uleb128 0x2
 3783 099f 91       		.byte	0x91
 3784 09a0 74       		.sleb128 -12
 3785 09a1 15       		.uleb128 0x15
 3786 09a2 B0010000 		.4byte	.LASF98
 3787 09a6 01       		.byte	0x1
 3788 09a7 9D05     		.2byte	0x59d
 3789 09a9 09010000 		.4byte	0x109
 3790 09ad 02       		.uleb128 0x2
 3791 09ae 91       		.byte	0x91
 3792 09af 6C       		.sleb128 -20
 3793 09b0 15       		.uleb128 0x15
 3794 09b1 B9060000 		.4byte	.LASF72
 3795 09b5 01       		.byte	0x1
 3796 09b6 9E05     		.2byte	0x59e
 3797 09b8 D0030000 		.4byte	0x3d0
 3798 09bc 02       		.uleb128 0x2
 3799 09bd 91       		.byte	0x91
 3800 09be 70       		.sleb128 -16
 3801 09bf 17       		.uleb128 0x17
 3802 09c0 47030000 		.4byte	0x347
 3803 09c4 10000000 		.4byte	.LBB35
 3804 09c8 1A000000 		.4byte	.LBE35-.LBB35
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 114


 3805 09cc 01       		.byte	0x1
 3806 09cd B305     		.2byte	0x5b3
 3807 09cf EE090000 		.4byte	0x9ee
 3808 09d3 18       		.uleb128 0x18
 3809 09d4 10000000 		.4byte	.LBB36
 3810 09d8 1A000000 		.4byte	.LBE36-.LBB36
 3811 09dc 19       		.uleb128 0x19
 3812 09dd 57030000 		.4byte	0x357
 3813 09e1 02       		.uleb128 0x2
 3814 09e2 91       		.byte	0x91
 3815 09e3 60       		.sleb128 -32
 3816 09e4 19       		.uleb128 0x19
 3817 09e5 62030000 		.4byte	0x362
 3818 09e9 02       		.uleb128 0x2
 3819 09ea 91       		.byte	0x91
 3820 09eb 5C       		.sleb128 -36
 3821 09ec 00       		.byte	0
 3822 09ed 00       		.byte	0
 3823 09ee 1A       		.uleb128 0x1a
 3824 09ef 2C000000 		.4byte	.LBB37
 3825 09f3 70000000 		.4byte	.LBE37-.LBB37
 3826 09f7 240A0000 		.4byte	0xa24
 3827 09fb 15       		.uleb128 0x15
 3828 09fc 99020000 		.4byte	.LASF52
 3829 0a00 01       		.byte	0x1
 3830 0a01 B505     		.2byte	0x5b5
 3831 0a03 50040000 		.4byte	0x450
 3832 0a07 02       		.uleb128 0x2
 3833 0a08 91       		.byte	0x91
 3834 0a09 68       		.sleb128 -24
 3835 0a0a 18       		.uleb128 0x18
 3836 0a0b 38000000 		.4byte	.LBB38
 3837 0a0f 5A000000 		.4byte	.LBE38-.LBB38
 3838 0a13 15       		.uleb128 0x15
 3839 0a14 D4070000 		.4byte	.LASF55
 3840 0a18 01       		.byte	0x1
 3841 0a19 BA05     		.2byte	0x5ba
 3842 0a1b B1070000 		.4byte	0x7b1
 3843 0a1f 02       		.uleb128 0x2
 3844 0a20 91       		.byte	0x91
 3845 0a21 67       		.sleb128 -25
 3846 0a22 00       		.byte	0
 3847 0a23 00       		.byte	0
 3848 0a24 1B       		.uleb128 0x1b
 3849 0a25 6E030000 		.4byte	0x36e
 3850 0a29 9C000000 		.4byte	.LBB39
 3851 0a2d 06000000 		.4byte	.LBE39-.LBB39
 3852 0a31 01       		.byte	0x1
 3853 0a32 EF05     		.2byte	0x5ef
 3854 0a34 1C       		.uleb128 0x1c
 3855 0a35 7B030000 		.4byte	0x37b
 3856 0a39 02       		.uleb128 0x2
 3857 0a3a 91       		.byte	0x91
 3858 0a3b 58       		.sleb128 -40
 3859 0a3c 00       		.byte	0
 3860 0a3d 00       		.byte	0
 3861 0a3e 13       		.uleb128 0x13
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 115


 3862 0a3f EC060000 		.4byte	.LASF105
 3863 0a43 01       		.byte	0x1
 3864 0a44 F505     		.2byte	0x5f5
 3865 0a46 FE000000 		.4byte	0xfe
 3866 0a4a 00000000 		.4byte	.LFB81
 3867 0a4e 64000000 		.4byte	.LFE81-.LFB81
 3868 0a52 01       		.uleb128 0x1
 3869 0a53 9C       		.byte	0x9c
 3870 0a54 FB0A0000 		.4byte	0xafb
 3871 0a58 14       		.uleb128 0x14
 3872 0a59 1A020000 		.4byte	.LASF66
 3873 0a5d 01       		.byte	0x1
 3874 0a5e F505     		.2byte	0x5f5
 3875 0a60 2D020000 		.4byte	0x22d
 3876 0a64 02       		.uleb128 0x2
 3877 0a65 91       		.byte	0x91
 3878 0a66 54       		.sleb128 -44
 3879 0a67 14       		.uleb128 0x14
 3880 0a68 85020000 		.4byte	.LASF101
 3881 0a6c 01       		.byte	0x1
 3882 0a6d F505     		.2byte	0x5f5
 3883 0a6f 46090000 		.4byte	0x946
 3884 0a73 02       		.uleb128 0x2
 3885 0a74 91       		.byte	0x91
 3886 0a75 50       		.sleb128 -48
 3887 0a76 15       		.uleb128 0x15
 3888 0a77 C1060000 		.4byte	.LASF83
 3889 0a7b 01       		.byte	0x1
 3890 0a7c F705     		.2byte	0x5f7
 3891 0a7e FE000000 		.4byte	0xfe
 3892 0a82 02       		.uleb128 0x2
 3893 0a83 91       		.byte	0x91
 3894 0a84 74       		.sleb128 -12
 3895 0a85 15       		.uleb128 0x15
 3896 0a86 B0010000 		.4byte	.LASF98
 3897 0a8a 01       		.byte	0x1
 3898 0a8b F805     		.2byte	0x5f8
 3899 0a8d 09010000 		.4byte	0x109
 3900 0a91 02       		.uleb128 0x2
 3901 0a92 91       		.byte	0x91
 3902 0a93 6C       		.sleb128 -20
 3903 0a94 15       		.uleb128 0x15
 3904 0a95 75050000 		.4byte	.LASF103
 3905 0a99 01       		.byte	0x1
 3906 0a9a F905     		.2byte	0x5f9
 3907 0a9c 57020000 		.4byte	0x257
 3908 0aa0 02       		.uleb128 0x2
 3909 0aa1 91       		.byte	0x91
 3910 0aa2 68       		.sleb128 -24
 3911 0aa3 15       		.uleb128 0x15
 3912 0aa4 B9060000 		.4byte	.LASF72
 3913 0aa8 01       		.byte	0x1
 3914 0aa9 FA05     		.2byte	0x5fa
 3915 0aab D0030000 		.4byte	0x3d0
 3916 0aaf 02       		.uleb128 0x2
 3917 0ab0 91       		.byte	0x91
 3918 0ab1 70       		.sleb128 -16
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 116


 3919 0ab2 17       		.uleb128 0x17
 3920 0ab3 47030000 		.4byte	0x347
 3921 0ab7 0E000000 		.4byte	.LBB41
 3922 0abb 1A000000 		.4byte	.LBE41-.LBB41
 3923 0abf 01       		.byte	0x1
 3924 0ac0 1006     		.2byte	0x610
 3925 0ac2 E10A0000 		.4byte	0xae1
 3926 0ac6 18       		.uleb128 0x18
 3927 0ac7 0E000000 		.4byte	.LBB42
 3928 0acb 1A000000 		.4byte	.LBE42-.LBB42
 3929 0acf 19       		.uleb128 0x19
 3930 0ad0 57030000 		.4byte	0x357
 3931 0ad4 02       		.uleb128 0x2
 3932 0ad5 91       		.byte	0x91
 3933 0ad6 64       		.sleb128 -28
 3934 0ad7 19       		.uleb128 0x19
 3935 0ad8 62030000 		.4byte	0x362
 3936 0adc 02       		.uleb128 0x2
 3937 0add 91       		.byte	0x91
 3938 0ade 60       		.sleb128 -32
 3939 0adf 00       		.byte	0
 3940 0ae0 00       		.byte	0
 3941 0ae1 1B       		.uleb128 0x1b
 3942 0ae2 6E030000 		.4byte	0x36e
 3943 0ae6 54000000 		.4byte	.LBB43
 3944 0aea 06000000 		.4byte	.LBE43-.LBB43
 3945 0aee 01       		.byte	0x1
 3946 0aef 2506     		.2byte	0x625
 3947 0af1 1C       		.uleb128 0x1c
 3948 0af2 7B030000 		.4byte	0x37b
 3949 0af6 02       		.uleb128 0x2
 3950 0af7 91       		.byte	0x91
 3951 0af8 5C       		.sleb128 -36
 3952 0af9 00       		.byte	0
 3953 0afa 00       		.byte	0
 3954 0afb 13       		.uleb128 0x13
 3955 0afc 91060000 		.4byte	.LASF106
 3956 0b00 01       		.byte	0x1
 3957 0b01 2B06     		.2byte	0x62b
 3958 0b03 09010000 		.4byte	0x109
 3959 0b07 00000000 		.4byte	.LFB82
 3960 0b0b 20000000 		.4byte	.LFE82-.LFB82
 3961 0b0f 01       		.uleb128 0x1
 3962 0b10 9C       		.byte	0x9c
 3963 0b11 340B0000 		.4byte	0xb34
 3964 0b15 14       		.uleb128 0x14
 3965 0b16 1A020000 		.4byte	.LASF66
 3966 0b1a 01       		.byte	0x1
 3967 0b1b 2B06     		.2byte	0x62b
 3968 0b1d 340B0000 		.4byte	0xb34
 3969 0b21 02       		.uleb128 0x2
 3970 0b22 91       		.byte	0x91
 3971 0b23 6C       		.sleb128 -20
 3972 0b24 15       		.uleb128 0x15
 3973 0b25 65010000 		.4byte	.LASF107
 3974 0b29 01       		.byte	0x1
 3975 0b2a 2D06     		.2byte	0x62d
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 117


 3976 0b2c 09010000 		.4byte	0x109
 3977 0b30 02       		.uleb128 0x2
 3978 0b31 91       		.byte	0x91
 3979 0b32 74       		.sleb128 -12
 3980 0b33 00       		.byte	0
 3981 0b34 07       		.uleb128 0x7
 3982 0b35 2D020000 		.4byte	0x22d
 3983 0b39 13       		.uleb128 0x13
 3984 0b3a C5000000 		.4byte	.LASF108
 3985 0b3e 01       		.byte	0x1
 3986 0b3f 3B06     		.2byte	0x63b
 3987 0b41 09010000 		.4byte	0x109
 3988 0b45 00000000 		.4byte	.LFB83
 3989 0b49 2A000000 		.4byte	.LFE83-.LFB83
 3990 0b4d 01       		.uleb128 0x1
 3991 0b4e 9C       		.byte	0x9c
 3992 0b4f 810B0000 		.4byte	0xb81
 3993 0b53 14       		.uleb128 0x14
 3994 0b54 1A020000 		.4byte	.LASF66
 3995 0b58 01       		.byte	0x1
 3996 0b59 3B06     		.2byte	0x63b
 3997 0b5b 340B0000 		.4byte	0xb34
 3998 0b5f 02       		.uleb128 0x2
 3999 0b60 91       		.byte	0x91
 4000 0b61 6C       		.sleb128 -20
 4001 0b62 15       		.uleb128 0x15
 4002 0b63 65010000 		.4byte	.LASF107
 4003 0b67 01       		.byte	0x1
 4004 0b68 3D06     		.2byte	0x63d
 4005 0b6a 09010000 		.4byte	0x109
 4006 0b6e 02       		.uleb128 0x2
 4007 0b6f 91       		.byte	0x91
 4008 0b70 70       		.sleb128 -16
 4009 0b71 15       		.uleb128 0x15
 4010 0b72 B9060000 		.4byte	.LASF72
 4011 0b76 01       		.byte	0x1
 4012 0b77 3E06     		.2byte	0x63e
 4013 0b79 D5030000 		.4byte	0x3d5
 4014 0b7d 02       		.uleb128 0x2
 4015 0b7e 91       		.byte	0x91
 4016 0b7f 74       		.sleb128 -12
 4017 0b80 00       		.byte	0
 4018 0b81 1D       		.uleb128 0x1d
 4019 0b82 D9030000 		.4byte	.LASF109
 4020 0b86 01       		.byte	0x1
 4021 0b87 4D06     		.2byte	0x64d
 4022 0b89 09010000 		.4byte	0x109
 4023 0b8d 00000000 		.4byte	.LFB84
 4024 0b91 1C000000 		.4byte	.LFE84-.LFB84
 4025 0b95 01       		.uleb128 0x1
 4026 0b96 9C       		.byte	0x9c
 4027 0b97 BA0B0000 		.4byte	0xbba
 4028 0b9b 14       		.uleb128 0x14
 4029 0b9c 1A020000 		.4byte	.LASF66
 4030 0ba0 01       		.byte	0x1
 4031 0ba1 4D06     		.2byte	0x64d
 4032 0ba3 340B0000 		.4byte	0xb34
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 118


 4033 0ba7 02       		.uleb128 0x2
 4034 0ba8 91       		.byte	0x91
 4035 0ba9 6C       		.sleb128 -20
 4036 0baa 15       		.uleb128 0x15
 4037 0bab 65010000 		.4byte	.LASF107
 4038 0baf 01       		.byte	0x1
 4039 0bb0 4F06     		.2byte	0x64f
 4040 0bb2 09010000 		.4byte	0x109
 4041 0bb6 02       		.uleb128 0x2
 4042 0bb7 91       		.byte	0x91
 4043 0bb8 74       		.sleb128 -12
 4044 0bb9 00       		.byte	0
 4045 0bba 1E       		.uleb128 0x1e
 4046 0bbb 82010000 		.4byte	.LASF118
 4047 0bbf 01       		.byte	0x1
 4048 0bc0 5906     		.2byte	0x659
 4049 0bc2 00000000 		.4byte	.LFB85
 4050 0bc6 1E000000 		.4byte	.LFE85-.LFB85
 4051 0bca 01       		.uleb128 0x1
 4052 0bcb 9C       		.byte	0x9c
 4053 0bcc EF0B0000 		.4byte	0xbef
 4054 0bd0 14       		.uleb128 0x14
 4055 0bd1 1A020000 		.4byte	.LASF66
 4056 0bd5 01       		.byte	0x1
 4057 0bd6 5906     		.2byte	0x659
 4058 0bd8 2D020000 		.4byte	0x22d
 4059 0bdc 02       		.uleb128 0x2
 4060 0bdd 91       		.byte	0x91
 4061 0bde 6C       		.sleb128 -20
 4062 0bdf 15       		.uleb128 0x15
 4063 0be0 B9060000 		.4byte	.LASF72
 4064 0be4 01       		.byte	0x1
 4065 0be5 5B06     		.2byte	0x65b
 4066 0be7 D0030000 		.4byte	0x3d0
 4067 0beb 02       		.uleb128 0x2
 4068 0bec 91       		.byte	0x91
 4069 0bed 74       		.sleb128 -12
 4070 0bee 00       		.byte	0
 4071 0bef 1F       		.uleb128 0x1f
 4072 0bf0 1C030000 		.4byte	.LASF113
 4073 0bf4 01       		.byte	0x1
 4074 0bf5 A106     		.2byte	0x6a1
 4075 0bf7 FE000000 		.4byte	0xfe
 4076 0bfb 00000000 		.4byte	.LFB86
 4077 0bff D8000000 		.4byte	.LFE86-.LFB86
 4078 0c03 01       		.uleb128 0x1
 4079 0c04 9C       		.byte	0x9c
 4080 0c05 550C0000 		.4byte	0xc55
 4081 0c09 14       		.uleb128 0x14
 4082 0c0a B9060000 		.4byte	.LASF72
 4083 0c0e 01       		.byte	0x1
 4084 0c0f A106     		.2byte	0x6a1
 4085 0c11 D0030000 		.4byte	0x3d0
 4086 0c15 02       		.uleb128 0x2
 4087 0c16 91       		.byte	0x91
 4088 0c17 6C       		.sleb128 -20
 4089 0c18 14       		.uleb128 0x14
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 119


 4090 0c19 6A060000 		.4byte	.LASF91
 4091 0c1d 01       		.byte	0x1
 4092 0c1e A106     		.2byte	0x6a1
 4093 0c20 BD000000 		.4byte	0xbd
 4094 0c24 02       		.uleb128 0x2
 4095 0c25 91       		.byte	0x91
 4096 0c26 68       		.sleb128 -24
 4097 0c27 14       		.uleb128 0x14
 4098 0c28 CA070000 		.4byte	.LASF110
 4099 0c2c 01       		.byte	0x1
 4100 0c2d A106     		.2byte	0x6a1
 4101 0c2f B8060000 		.4byte	0x6b8
 4102 0c33 02       		.uleb128 0x2
 4103 0c34 91       		.byte	0x91
 4104 0c35 64       		.sleb128 -28
 4105 0c36 15       		.uleb128 0x15
 4106 0c37 C1060000 		.4byte	.LASF83
 4107 0c3b 01       		.byte	0x1
 4108 0c3c A306     		.2byte	0x6a3
 4109 0c3e FE000000 		.4byte	0xfe
 4110 0c42 02       		.uleb128 0x2
 4111 0c43 91       		.byte	0x91
 4112 0c44 74       		.sleb128 -12
 4113 0c45 15       		.uleb128 0x15
 4114 0c46 99020000 		.4byte	.LASF52
 4115 0c4a 01       		.byte	0x1
 4116 0c4b A406     		.2byte	0x6a4
 4117 0c4d 09010000 		.4byte	0x109
 4118 0c51 02       		.uleb128 0x2
 4119 0c52 91       		.byte	0x91
 4120 0c53 70       		.sleb128 -16
 4121 0c54 00       		.byte	0
 4122 0c55 16       		.uleb128 0x16
 4123 0c56 17070000 		.4byte	.LASF111
 4124 0c5a 01       		.byte	0x1
 4125 0c5b F006     		.2byte	0x6f0
 4126 0c5d 00000000 		.4byte	.LFB87
 4127 0c61 4C000000 		.4byte	.LFE87-.LFB87
 4128 0c65 01       		.uleb128 0x1
 4129 0c66 9C       		.byte	0x9c
 4130 0c67 8A0C0000 		.4byte	0xc8a
 4131 0c6b 14       		.uleb128 0x14
 4132 0c6c B9060000 		.4byte	.LASF72
 4133 0c70 01       		.byte	0x1
 4134 0c71 F006     		.2byte	0x6f0
 4135 0c73 D0030000 		.4byte	0x3d0
 4136 0c77 02       		.uleb128 0x2
 4137 0c78 91       		.byte	0x91
 4138 0c79 74       		.sleb128 -12
 4139 0c7a 14       		.uleb128 0x14
 4140 0c7b 85020000 		.4byte	.LASF101
 4141 0c7f 01       		.byte	0x1
 4142 0c80 F006     		.2byte	0x6f0
 4143 0c82 46090000 		.4byte	0x946
 4144 0c86 02       		.uleb128 0x2
 4145 0c87 91       		.byte	0x91
 4146 0c88 70       		.sleb128 -16
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 120


 4147 0c89 00       		.byte	0
 4148 0c8a 16       		.uleb128 0x16
 4149 0c8b 61070000 		.4byte	.LASF112
 4150 0c8f 01       		.byte	0x1
 4151 0c90 0207     		.2byte	0x702
 4152 0c92 00000000 		.4byte	.LFB88
 4153 0c96 A2000000 		.4byte	.LFE88-.LFB88
 4154 0c9a 01       		.uleb128 0x1
 4155 0c9b 9C       		.byte	0x9c
 4156 0c9c E60C0000 		.4byte	0xce6
 4157 0ca0 14       		.uleb128 0x14
 4158 0ca1 B9060000 		.4byte	.LASF72
 4159 0ca5 01       		.byte	0x1
 4160 0ca6 0207     		.2byte	0x702
 4161 0ca8 D0030000 		.4byte	0x3d0
 4162 0cac 02       		.uleb128 0x2
 4163 0cad 91       		.byte	0x91
 4164 0cae 6C       		.sleb128 -20
 4165 0caf 1A       		.uleb128 0x1a
 4166 0cb0 0C000000 		.4byte	.LBB45
 4167 0cb4 42000000 		.4byte	.LBE45-.LBB45
 4168 0cb8 CC0C0000 		.4byte	0xccc
 4169 0cbc 15       		.uleb128 0x15
 4170 0cbd DC000000 		.4byte	.LASF56
 4171 0cc1 01       		.byte	0x1
 4172 0cc2 0C07     		.2byte	0x70c
 4173 0cc4 C4000000 		.4byte	0xc4
 4174 0cc8 02       		.uleb128 0x2
 4175 0cc9 91       		.byte	0x91
 4176 0cca 77       		.sleb128 -9
 4177 0ccb 00       		.byte	0
 4178 0ccc 18       		.uleb128 0x18
 4179 0ccd 56000000 		.4byte	.LBB46
 4180 0cd1 42000000 		.4byte	.LBE46-.LBB46
 4181 0cd5 15       		.uleb128 0x15
 4182 0cd6 D4070000 		.4byte	.LASF55
 4183 0cda 01       		.byte	0x1
 4184 0cdb 5D07     		.2byte	0x75d
 4185 0cdd C4000000 		.4byte	0xc4
 4186 0ce1 02       		.uleb128 0x2
 4187 0ce2 91       		.byte	0x91
 4188 0ce3 76       		.sleb128 -10
 4189 0ce4 00       		.byte	0
 4190 0ce5 00       		.byte	0
 4191 0ce6 1F       		.uleb128 0x1f
 4192 0ce7 75020000 		.4byte	.LASF114
 4193 0ceb 01       		.byte	0x1
 4194 0cec 7A07     		.2byte	0x77a
 4195 0cee FE000000 		.4byte	0xfe
 4196 0cf2 00000000 		.4byte	.LFB89
 4197 0cf6 2C000000 		.4byte	.LFE89-.LFB89
 4198 0cfa 01       		.uleb128 0x1
 4199 0cfb 9C       		.byte	0x9c
 4200 0cfc 1F0D0000 		.4byte	0xd1f
 4201 0d00 14       		.uleb128 0x14
 4202 0d01 B9060000 		.4byte	.LASF72
 4203 0d05 01       		.byte	0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 121


 4204 0d06 7A07     		.2byte	0x77a
 4205 0d08 1F0D0000 		.4byte	0xd1f
 4206 0d0c 02       		.uleb128 0x2
 4207 0d0d 91       		.byte	0x91
 4208 0d0e 6C       		.sleb128 -20
 4209 0d0f 15       		.uleb128 0x15
 4210 0d10 C1060000 		.4byte	.LASF83
 4211 0d14 01       		.byte	0x1
 4212 0d15 7C07     		.2byte	0x77c
 4213 0d17 FE000000 		.4byte	0xfe
 4214 0d1b 02       		.uleb128 0x2
 4215 0d1c 91       		.byte	0x91
 4216 0d1d 74       		.sleb128 -12
 4217 0d1e 00       		.byte	0
 4218 0d1f 06       		.uleb128 0x6
 4219 0d20 04       		.byte	0x4
 4220 0d21 250D0000 		.4byte	0xd25
 4221 0d25 07       		.uleb128 0x7
 4222 0d26 01030000 		.4byte	0x301
 4223 0d2a 1D       		.uleb128 0x1d
 4224 0d2b 83070000 		.4byte	.LASF115
 4225 0d2f 01       		.byte	0x1
 4226 0d30 8F07     		.2byte	0x78f
 4227 0d32 FE000000 		.4byte	0xfe
 4228 0d36 00000000 		.4byte	.LFB90
 4229 0d3a 28000000 		.4byte	.LFE90-.LFB90
 4230 0d3e 01       		.uleb128 0x1
 4231 0d3f 9C       		.byte	0x9c
 4232 0d40 630D0000 		.4byte	0xd63
 4233 0d44 14       		.uleb128 0x14
 4234 0d45 1A020000 		.4byte	.LASF66
 4235 0d49 01       		.byte	0x1
 4236 0d4a 8F07     		.2byte	0x78f
 4237 0d4c 340B0000 		.4byte	0xb34
 4238 0d50 02       		.uleb128 0x2
 4239 0d51 91       		.byte	0x91
 4240 0d52 6C       		.sleb128 -20
 4241 0d53 15       		.uleb128 0x15
 4242 0d54 C1060000 		.4byte	.LASF83
 4243 0d58 01       		.byte	0x1
 4244 0d59 9107     		.2byte	0x791
 4245 0d5b FE000000 		.4byte	0xfe
 4246 0d5f 02       		.uleb128 0x2
 4247 0d60 91       		.byte	0x91
 4248 0d61 74       		.sleb128 -12
 4249 0d62 00       		.byte	0
 4250 0d63 1F       		.uleb128 0x1f
 4251 0d64 79030000 		.4byte	.LASF116
 4252 0d68 01       		.byte	0x1
 4253 0d69 A107     		.2byte	0x7a1
 4254 0d6b FE000000 		.4byte	0xfe
 4255 0d6f 00000000 		.4byte	.LFB91
 4256 0d73 30000000 		.4byte	.LFE91-.LFB91
 4257 0d77 01       		.uleb128 0x1
 4258 0d78 9C       		.byte	0x9c
 4259 0d79 9C0D0000 		.4byte	0xd9c
 4260 0d7d 14       		.uleb128 0x14
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 122


 4261 0d7e B9060000 		.4byte	.LASF72
 4262 0d82 01       		.byte	0x1
 4263 0d83 A107     		.2byte	0x7a1
 4264 0d85 1F0D0000 		.4byte	0xd1f
 4265 0d89 02       		.uleb128 0x2
 4266 0d8a 91       		.byte	0x91
 4267 0d8b 6C       		.sleb128 -20
 4268 0d8c 15       		.uleb128 0x15
 4269 0d8d C1060000 		.4byte	.LASF83
 4270 0d91 01       		.byte	0x1
 4271 0d92 A307     		.2byte	0x7a3
 4272 0d94 FE000000 		.4byte	0xfe
 4273 0d98 02       		.uleb128 0x2
 4274 0d99 91       		.byte	0x91
 4275 0d9a 74       		.sleb128 -12
 4276 0d9b 00       		.byte	0
 4277 0d9c 1D       		.uleb128 0x1d
 4278 0d9d 78060000 		.4byte	.LASF117
 4279 0da1 01       		.byte	0x1
 4280 0da2 B607     		.2byte	0x7b6
 4281 0da4 FE000000 		.4byte	0xfe
 4282 0da8 00000000 		.4byte	.LFB92
 4283 0dac 2C000000 		.4byte	.LFE92-.LFB92
 4284 0db0 01       		.uleb128 0x1
 4285 0db1 9C       		.byte	0x9c
 4286 0db2 D50D0000 		.4byte	0xdd5
 4287 0db6 14       		.uleb128 0x14
 4288 0db7 1A020000 		.4byte	.LASF66
 4289 0dbb 01       		.byte	0x1
 4290 0dbc B607     		.2byte	0x7b6
 4291 0dbe 340B0000 		.4byte	0xb34
 4292 0dc2 02       		.uleb128 0x2
 4293 0dc3 91       		.byte	0x91
 4294 0dc4 6C       		.sleb128 -20
 4295 0dc5 15       		.uleb128 0x15
 4296 0dc6 C1060000 		.4byte	.LASF83
 4297 0dca 01       		.byte	0x1
 4298 0dcb B807     		.2byte	0x7b8
 4299 0dcd FE000000 		.4byte	0xfe
 4300 0dd1 02       		.uleb128 0x2
 4301 0dd2 91       		.byte	0x91
 4302 0dd3 74       		.sleb128 -12
 4303 0dd4 00       		.byte	0
 4304 0dd5 20       		.uleb128 0x20
 4305 0dd6 AD040000 		.4byte	.LASF119
 4306 0dda 01       		.byte	0x1
 4307 0ddb DD08     		.2byte	0x8dd
 4308 0ddd 00000000 		.4byte	.LFB93
 4309 0de1 50000000 		.4byte	.LFE93-.LFB93
 4310 0de5 01       		.uleb128 0x1
 4311 0de6 9C       		.byte	0x9c
 4312 0de7 180E0000 		.4byte	0xe18
 4313 0deb 14       		.uleb128 0x14
 4314 0dec 1A020000 		.4byte	.LASF66
 4315 0df0 01       		.byte	0x1
 4316 0df1 DD08     		.2byte	0x8dd
 4317 0df3 2D020000 		.4byte	0x22d
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 123


 4318 0df7 02       		.uleb128 0x2
 4319 0df8 91       		.byte	0x91
 4320 0df9 6C       		.sleb128 -20
 4321 0dfa 14       		.uleb128 0x14
 4322 0dfb D1020000 		.4byte	.LASF60
 4323 0dff 01       		.byte	0x1
 4324 0e00 DD08     		.2byte	0x8dd
 4325 0e02 B2000000 		.4byte	0xb2
 4326 0e06 02       		.uleb128 0x2
 4327 0e07 91       		.byte	0x91
 4328 0e08 68       		.sleb128 -24
 4329 0e09 21       		.uleb128 0x21
 4330 0e0a 757800   		.ascii	"ux\000"
 4331 0e0d 01       		.byte	0x1
 4332 0e0e DF08     		.2byte	0x8df
 4333 0e10 09010000 		.4byte	0x109
 4334 0e14 02       		.uleb128 0x2
 4335 0e15 91       		.byte	0x91
 4336 0e16 74       		.sleb128 -12
 4337 0e17 00       		.byte	0
 4338 0e18 1D       		.uleb128 0x1d
 4339 0e19 0C060000 		.4byte	.LASF120
 4340 0e1d 01       		.byte	0x1
 4341 0e1e FA08     		.2byte	0x8fa
 4342 0e20 B2000000 		.4byte	0xb2
 4343 0e24 00000000 		.4byte	.LFB94
 4344 0e28 4C000000 		.4byte	.LFE94-.LFB94
 4345 0e2c 01       		.uleb128 0x1
 4346 0e2d 9C       		.byte	0x9c
 4347 0e2e 5F0E0000 		.4byte	0xe5f
 4348 0e32 14       		.uleb128 0x14
 4349 0e33 1A020000 		.4byte	.LASF66
 4350 0e37 01       		.byte	0x1
 4351 0e38 FA08     		.2byte	0x8fa
 4352 0e3a 2D020000 		.4byte	0x22d
 4353 0e3e 02       		.uleb128 0x2
 4354 0e3f 91       		.byte	0x91
 4355 0e40 6C       		.sleb128 -20
 4356 0e41 21       		.uleb128 0x21
 4357 0e42 757800   		.ascii	"ux\000"
 4358 0e45 01       		.byte	0x1
 4359 0e46 FC08     		.2byte	0x8fc
 4360 0e48 09010000 		.4byte	0x109
 4361 0e4c 02       		.uleb128 0x2
 4362 0e4d 91       		.byte	0x91
 4363 0e4e 74       		.sleb128 -12
 4364 0e4f 15       		.uleb128 0x15
 4365 0e50 1B060000 		.4byte	.LASF121
 4366 0e54 01       		.byte	0x1
 4367 0e55 FD08     		.2byte	0x8fd
 4368 0e57 B2000000 		.4byte	0xb2
 4369 0e5b 02       		.uleb128 0x2
 4370 0e5c 91       		.byte	0x91
 4371 0e5d 70       		.sleb128 -16
 4372 0e5e 00       		.byte	0
 4373 0e5f 20       		.uleb128 0x20
 4374 0e60 9A010000 		.4byte	.LASF122
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 124


 4375 0e64 01       		.byte	0x1
 4376 0e65 1609     		.2byte	0x916
 4377 0e67 00000000 		.4byte	.LFB95
 4378 0e6b 50000000 		.4byte	.LFE95-.LFB95
 4379 0e6f 01       		.uleb128 0x1
 4380 0e70 9C       		.byte	0x9c
 4381 0e71 930E0000 		.4byte	0xe93
 4382 0e75 14       		.uleb128 0x14
 4383 0e76 1A020000 		.4byte	.LASF66
 4384 0e7a 01       		.byte	0x1
 4385 0e7b 1609     		.2byte	0x916
 4386 0e7d 2D020000 		.4byte	0x22d
 4387 0e81 02       		.uleb128 0x2
 4388 0e82 91       		.byte	0x91
 4389 0e83 6C       		.sleb128 -20
 4390 0e84 21       		.uleb128 0x21
 4391 0e85 757800   		.ascii	"ux\000"
 4392 0e88 01       		.byte	0x1
 4393 0e89 1809     		.2byte	0x918
 4394 0e8b 09010000 		.4byte	0x109
 4395 0e8f 02       		.uleb128 0x2
 4396 0e90 91       		.byte	0x91
 4397 0e91 74       		.sleb128 -12
 4398 0e92 00       		.byte	0
 4399 0e93 22       		.uleb128 0x22
 4400 0e94 4B060000 		.4byte	.LASF123
 4401 0e98 09       		.byte	0x9
 4402 0e99 9606     		.2byte	0x696
 4403 0e9b 9F0E0000 		.4byte	0xe9f
 4404 0e9f 0E       		.uleb128 0xe
 4405 0ea0 DA000000 		.4byte	0xda
 4406 0ea4 23       		.uleb128 0x23
 4407 0ea5 3C030000 		.4byte	0x33c
 4408 0ea9 B40E0000 		.4byte	0xeb4
 4409 0ead 24       		.uleb128 0x24
 4410 0eae A2000000 		.4byte	0xa2
 4411 0eb2 09       		.byte	0x9
 4412 0eb3 00       		.byte	0
 4413 0eb4 25       		.uleb128 0x25
 4414 0eb5 B3030000 		.4byte	.LASF124
 4415 0eb9 01       		.byte	0x1
 4416 0eba C4       		.byte	0xc4
 4417 0ebb A40E0000 		.4byte	0xea4
 4418 0ebf 05       		.uleb128 0x5
 4419 0ec0 03       		.byte	0x3
 4420 0ec1 00000000 		.4byte	xQueueRegistry
 4421 0ec5 00       		.byte	0
 4422              		.section	.debug_abbrev,"",%progbits
 4423              	.Ldebug_abbrev0:
 4424 0000 01       		.uleb128 0x1
 4425 0001 11       		.uleb128 0x11
 4426 0002 01       		.byte	0x1
 4427 0003 25       		.uleb128 0x25
 4428 0004 0E       		.uleb128 0xe
 4429 0005 13       		.uleb128 0x13
 4430 0006 0B       		.uleb128 0xb
 4431 0007 03       		.uleb128 0x3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 125


 4432 0008 0E       		.uleb128 0xe
 4433 0009 1B       		.uleb128 0x1b
 4434 000a 0E       		.uleb128 0xe
 4435 000b 55       		.uleb128 0x55
 4436 000c 17       		.uleb128 0x17
 4437 000d 11       		.uleb128 0x11
 4438 000e 01       		.uleb128 0x1
 4439 000f 10       		.uleb128 0x10
 4440 0010 17       		.uleb128 0x17
 4441 0011 00       		.byte	0
 4442 0012 00       		.byte	0
 4443 0013 02       		.uleb128 0x2
 4444 0014 16       		.uleb128 0x16
 4445 0015 00       		.byte	0
 4446 0016 03       		.uleb128 0x3
 4447 0017 0E       		.uleb128 0xe
 4448 0018 3A       		.uleb128 0x3a
 4449 0019 0B       		.uleb128 0xb
 4450 001a 3B       		.uleb128 0x3b
 4451 001b 0B       		.uleb128 0xb
 4452 001c 49       		.uleb128 0x49
 4453 001d 13       		.uleb128 0x13
 4454 001e 00       		.byte	0
 4455 001f 00       		.byte	0
 4456 0020 03       		.uleb128 0x3
 4457 0021 24       		.uleb128 0x24
 4458 0022 00       		.byte	0
 4459 0023 0B       		.uleb128 0xb
 4460 0024 0B       		.uleb128 0xb
 4461 0025 3E       		.uleb128 0x3e
 4462 0026 0B       		.uleb128 0xb
 4463 0027 03       		.uleb128 0x3
 4464 0028 0E       		.uleb128 0xe
 4465 0029 00       		.byte	0
 4466 002a 00       		.byte	0
 4467 002b 04       		.uleb128 0x4
 4468 002c 24       		.uleb128 0x24
 4469 002d 00       		.byte	0
 4470 002e 0B       		.uleb128 0xb
 4471 002f 0B       		.uleb128 0xb
 4472 0030 3E       		.uleb128 0x3e
 4473 0031 0B       		.uleb128 0xb
 4474 0032 03       		.uleb128 0x3
 4475 0033 08       		.uleb128 0x8
 4476 0034 00       		.byte	0
 4477 0035 00       		.byte	0
 4478 0036 05       		.uleb128 0x5
 4479 0037 0F       		.uleb128 0xf
 4480 0038 00       		.byte	0
 4481 0039 0B       		.uleb128 0xb
 4482 003a 0B       		.uleb128 0xb
 4483 003b 00       		.byte	0
 4484 003c 00       		.byte	0
 4485 003d 06       		.uleb128 0x6
 4486 003e 0F       		.uleb128 0xf
 4487 003f 00       		.byte	0
 4488 0040 0B       		.uleb128 0xb
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 126


 4489 0041 0B       		.uleb128 0xb
 4490 0042 49       		.uleb128 0x49
 4491 0043 13       		.uleb128 0x13
 4492 0044 00       		.byte	0
 4493 0045 00       		.byte	0
 4494 0046 07       		.uleb128 0x7
 4495 0047 26       		.uleb128 0x26
 4496 0048 00       		.byte	0
 4497 0049 49       		.uleb128 0x49
 4498 004a 13       		.uleb128 0x13
 4499 004b 00       		.byte	0
 4500 004c 00       		.byte	0
 4501 004d 08       		.uleb128 0x8
 4502 004e 26       		.uleb128 0x26
 4503 004f 00       		.byte	0
 4504 0050 00       		.byte	0
 4505 0051 00       		.byte	0
 4506 0052 09       		.uleb128 0x9
 4507 0053 13       		.uleb128 0x13
 4508 0054 01       		.byte	0x1
 4509 0055 03       		.uleb128 0x3
 4510 0056 0E       		.uleb128 0xe
 4511 0057 0B       		.uleb128 0xb
 4512 0058 0B       		.uleb128 0xb
 4513 0059 3A       		.uleb128 0x3a
 4514 005a 0B       		.uleb128 0xb
 4515 005b 3B       		.uleb128 0x3b
 4516 005c 0B       		.uleb128 0xb
 4517 005d 01       		.uleb128 0x1
 4518 005e 13       		.uleb128 0x13
 4519 005f 00       		.byte	0
 4520 0060 00       		.byte	0
 4521 0061 0A       		.uleb128 0xa
 4522 0062 0D       		.uleb128 0xd
 4523 0063 00       		.byte	0
 4524 0064 03       		.uleb128 0x3
 4525 0065 0E       		.uleb128 0xe
 4526 0066 3A       		.uleb128 0x3a
 4527 0067 0B       		.uleb128 0xb
 4528 0068 3B       		.uleb128 0x3b
 4529 0069 0B       		.uleb128 0xb
 4530 006a 49       		.uleb128 0x49
 4531 006b 13       		.uleb128 0x13
 4532 006c 38       		.uleb128 0x38
 4533 006d 0B       		.uleb128 0xb
 4534 006e 00       		.byte	0
 4535 006f 00       		.byte	0
 4536 0070 0B       		.uleb128 0xb
 4537 0071 17       		.uleb128 0x17
 4538 0072 01       		.byte	0x1
 4539 0073 0B       		.uleb128 0xb
 4540 0074 0B       		.uleb128 0xb
 4541 0075 3A       		.uleb128 0x3a
 4542 0076 0B       		.uleb128 0xb
 4543 0077 3B       		.uleb128 0x3b
 4544 0078 0B       		.uleb128 0xb
 4545 0079 01       		.uleb128 0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 127


 4546 007a 13       		.uleb128 0x13
 4547 007b 00       		.byte	0
 4548 007c 00       		.byte	0
 4549 007d 0C       		.uleb128 0xc
 4550 007e 0D       		.uleb128 0xd
 4551 007f 00       		.byte	0
 4552 0080 03       		.uleb128 0x3
 4553 0081 0E       		.uleb128 0xe
 4554 0082 3A       		.uleb128 0x3a
 4555 0083 0B       		.uleb128 0xb
 4556 0084 3B       		.uleb128 0x3b
 4557 0085 0B       		.uleb128 0xb
 4558 0086 49       		.uleb128 0x49
 4559 0087 13       		.uleb128 0x13
 4560 0088 00       		.byte	0
 4561 0089 00       		.byte	0
 4562 008a 0D       		.uleb128 0xd
 4563 008b 0D       		.uleb128 0xd
 4564 008c 00       		.byte	0
 4565 008d 03       		.uleb128 0x3
 4566 008e 08       		.uleb128 0x8
 4567 008f 3A       		.uleb128 0x3a
 4568 0090 0B       		.uleb128 0xb
 4569 0091 3B       		.uleb128 0x3b
 4570 0092 0B       		.uleb128 0xb
 4571 0093 49       		.uleb128 0x49
 4572 0094 13       		.uleb128 0x13
 4573 0095 38       		.uleb128 0x38
 4574 0096 0B       		.uleb128 0xb
 4575 0097 00       		.byte	0
 4576 0098 00       		.byte	0
 4577 0099 0E       		.uleb128 0xe
 4578 009a 35       		.uleb128 0x35
 4579 009b 00       		.byte	0
 4580 009c 49       		.uleb128 0x49
 4581 009d 13       		.uleb128 0x13
 4582 009e 00       		.byte	0
 4583 009f 00       		.byte	0
 4584 00a0 0F       		.uleb128 0xf
 4585 00a1 2E       		.uleb128 0x2e
 4586 00a2 01       		.byte	0x1
 4587 00a3 03       		.uleb128 0x3
 4588 00a4 0E       		.uleb128 0xe
 4589 00a5 3A       		.uleb128 0x3a
 4590 00a6 0B       		.uleb128 0xb
 4591 00a7 3B       		.uleb128 0x3b
 4592 00a8 0B       		.uleb128 0xb
 4593 00a9 27       		.uleb128 0x27
 4594 00aa 19       		.uleb128 0x19
 4595 00ab 49       		.uleb128 0x49
 4596 00ac 13       		.uleb128 0x13
 4597 00ad 20       		.uleb128 0x20
 4598 00ae 0B       		.uleb128 0xb
 4599 00af 01       		.uleb128 0x1
 4600 00b0 13       		.uleb128 0x13
 4601 00b1 00       		.byte	0
 4602 00b2 00       		.byte	0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 128


 4603 00b3 10       		.uleb128 0x10
 4604 00b4 34       		.uleb128 0x34
 4605 00b5 00       		.byte	0
 4606 00b6 03       		.uleb128 0x3
 4607 00b7 0E       		.uleb128 0xe
 4608 00b8 3A       		.uleb128 0x3a
 4609 00b9 0B       		.uleb128 0xb
 4610 00ba 3B       		.uleb128 0x3b
 4611 00bb 0B       		.uleb128 0xb
 4612 00bc 49       		.uleb128 0x49
 4613 00bd 13       		.uleb128 0x13
 4614 00be 00       		.byte	0
 4615 00bf 00       		.byte	0
 4616 00c0 11       		.uleb128 0x11
 4617 00c1 2E       		.uleb128 0x2e
 4618 00c2 01       		.byte	0x1
 4619 00c3 03       		.uleb128 0x3
 4620 00c4 0E       		.uleb128 0xe
 4621 00c5 3A       		.uleb128 0x3a
 4622 00c6 0B       		.uleb128 0xb
 4623 00c7 3B       		.uleb128 0x3b
 4624 00c8 05       		.uleb128 0x5
 4625 00c9 27       		.uleb128 0x27
 4626 00ca 19       		.uleb128 0x19
 4627 00cb 20       		.uleb128 0x20
 4628 00cc 0B       		.uleb128 0xb
 4629 00cd 01       		.uleb128 0x1
 4630 00ce 13       		.uleb128 0x13
 4631 00cf 00       		.byte	0
 4632 00d0 00       		.byte	0
 4633 00d1 12       		.uleb128 0x12
 4634 00d2 05       		.uleb128 0x5
 4635 00d3 00       		.byte	0
 4636 00d4 03       		.uleb128 0x3
 4637 00d5 0E       		.uleb128 0xe
 4638 00d6 3A       		.uleb128 0x3a
 4639 00d7 0B       		.uleb128 0xb
 4640 00d8 3B       		.uleb128 0x3b
 4641 00d9 05       		.uleb128 0x5
 4642 00da 49       		.uleb128 0x49
 4643 00db 13       		.uleb128 0x13
 4644 00dc 00       		.byte	0
 4645 00dd 00       		.byte	0
 4646 00de 13       		.uleb128 0x13
 4647 00df 2E       		.uleb128 0x2e
 4648 00e0 01       		.byte	0x1
 4649 00e1 3F       		.uleb128 0x3f
 4650 00e2 19       		.uleb128 0x19
 4651 00e3 03       		.uleb128 0x3
 4652 00e4 0E       		.uleb128 0xe
 4653 00e5 3A       		.uleb128 0x3a
 4654 00e6 0B       		.uleb128 0xb
 4655 00e7 3B       		.uleb128 0x3b
 4656 00e8 05       		.uleb128 0x5
 4657 00e9 27       		.uleb128 0x27
 4658 00ea 19       		.uleb128 0x19
 4659 00eb 49       		.uleb128 0x49
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 129


 4660 00ec 13       		.uleb128 0x13
 4661 00ed 11       		.uleb128 0x11
 4662 00ee 01       		.uleb128 0x1
 4663 00ef 12       		.uleb128 0x12
 4664 00f0 06       		.uleb128 0x6
 4665 00f1 40       		.uleb128 0x40
 4666 00f2 18       		.uleb128 0x18
 4667 00f3 9642     		.uleb128 0x2116
 4668 00f5 19       		.uleb128 0x19
 4669 00f6 01       		.uleb128 0x1
 4670 00f7 13       		.uleb128 0x13
 4671 00f8 00       		.byte	0
 4672 00f9 00       		.byte	0
 4673 00fa 14       		.uleb128 0x14
 4674 00fb 05       		.uleb128 0x5
 4675 00fc 00       		.byte	0
 4676 00fd 03       		.uleb128 0x3
 4677 00fe 0E       		.uleb128 0xe
 4678 00ff 3A       		.uleb128 0x3a
 4679 0100 0B       		.uleb128 0xb
 4680 0101 3B       		.uleb128 0x3b
 4681 0102 05       		.uleb128 0x5
 4682 0103 49       		.uleb128 0x49
 4683 0104 13       		.uleb128 0x13
 4684 0105 02       		.uleb128 0x2
 4685 0106 18       		.uleb128 0x18
 4686 0107 00       		.byte	0
 4687 0108 00       		.byte	0
 4688 0109 15       		.uleb128 0x15
 4689 010a 34       		.uleb128 0x34
 4690 010b 00       		.byte	0
 4691 010c 03       		.uleb128 0x3
 4692 010d 0E       		.uleb128 0xe
 4693 010e 3A       		.uleb128 0x3a
 4694 010f 0B       		.uleb128 0xb
 4695 0110 3B       		.uleb128 0x3b
 4696 0111 05       		.uleb128 0x5
 4697 0112 49       		.uleb128 0x49
 4698 0113 13       		.uleb128 0x13
 4699 0114 02       		.uleb128 0x2
 4700 0115 18       		.uleb128 0x18
 4701 0116 00       		.byte	0
 4702 0117 00       		.byte	0
 4703 0118 16       		.uleb128 0x16
 4704 0119 2E       		.uleb128 0x2e
 4705 011a 01       		.byte	0x1
 4706 011b 03       		.uleb128 0x3
 4707 011c 0E       		.uleb128 0xe
 4708 011d 3A       		.uleb128 0x3a
 4709 011e 0B       		.uleb128 0xb
 4710 011f 3B       		.uleb128 0x3b
 4711 0120 05       		.uleb128 0x5
 4712 0121 27       		.uleb128 0x27
 4713 0122 19       		.uleb128 0x19
 4714 0123 11       		.uleb128 0x11
 4715 0124 01       		.uleb128 0x1
 4716 0125 12       		.uleb128 0x12
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 130


 4717 0126 06       		.uleb128 0x6
 4718 0127 40       		.uleb128 0x40
 4719 0128 18       		.uleb128 0x18
 4720 0129 9642     		.uleb128 0x2116
 4721 012b 19       		.uleb128 0x19
 4722 012c 01       		.uleb128 0x1
 4723 012d 13       		.uleb128 0x13
 4724 012e 00       		.byte	0
 4725 012f 00       		.byte	0
 4726 0130 17       		.uleb128 0x17
 4727 0131 1D       		.uleb128 0x1d
 4728 0132 01       		.byte	0x1
 4729 0133 31       		.uleb128 0x31
 4730 0134 13       		.uleb128 0x13
 4731 0135 11       		.uleb128 0x11
 4732 0136 01       		.uleb128 0x1
 4733 0137 12       		.uleb128 0x12
 4734 0138 06       		.uleb128 0x6
 4735 0139 58       		.uleb128 0x58
 4736 013a 0B       		.uleb128 0xb
 4737 013b 59       		.uleb128 0x59
 4738 013c 05       		.uleb128 0x5
 4739 013d 01       		.uleb128 0x1
 4740 013e 13       		.uleb128 0x13
 4741 013f 00       		.byte	0
 4742 0140 00       		.byte	0
 4743 0141 18       		.uleb128 0x18
 4744 0142 0B       		.uleb128 0xb
 4745 0143 01       		.byte	0x1
 4746 0144 11       		.uleb128 0x11
 4747 0145 01       		.uleb128 0x1
 4748 0146 12       		.uleb128 0x12
 4749 0147 06       		.uleb128 0x6
 4750 0148 00       		.byte	0
 4751 0149 00       		.byte	0
 4752 014a 19       		.uleb128 0x19
 4753 014b 34       		.uleb128 0x34
 4754 014c 00       		.byte	0
 4755 014d 31       		.uleb128 0x31
 4756 014e 13       		.uleb128 0x13
 4757 014f 02       		.uleb128 0x2
 4758 0150 18       		.uleb128 0x18
 4759 0151 00       		.byte	0
 4760 0152 00       		.byte	0
 4761 0153 1A       		.uleb128 0x1a
 4762 0154 0B       		.uleb128 0xb
 4763 0155 01       		.byte	0x1
 4764 0156 11       		.uleb128 0x11
 4765 0157 01       		.uleb128 0x1
 4766 0158 12       		.uleb128 0x12
 4767 0159 06       		.uleb128 0x6
 4768 015a 01       		.uleb128 0x1
 4769 015b 13       		.uleb128 0x13
 4770 015c 00       		.byte	0
 4771 015d 00       		.byte	0
 4772 015e 1B       		.uleb128 0x1b
 4773 015f 1D       		.uleb128 0x1d
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 131


 4774 0160 01       		.byte	0x1
 4775 0161 31       		.uleb128 0x31
 4776 0162 13       		.uleb128 0x13
 4777 0163 11       		.uleb128 0x11
 4778 0164 01       		.uleb128 0x1
 4779 0165 12       		.uleb128 0x12
 4780 0166 06       		.uleb128 0x6
 4781 0167 58       		.uleb128 0x58
 4782 0168 0B       		.uleb128 0xb
 4783 0169 59       		.uleb128 0x59
 4784 016a 05       		.uleb128 0x5
 4785 016b 00       		.byte	0
 4786 016c 00       		.byte	0
 4787 016d 1C       		.uleb128 0x1c
 4788 016e 05       		.uleb128 0x5
 4789 016f 00       		.byte	0
 4790 0170 31       		.uleb128 0x31
 4791 0171 13       		.uleb128 0x13
 4792 0172 02       		.uleb128 0x2
 4793 0173 18       		.uleb128 0x18
 4794 0174 00       		.byte	0
 4795 0175 00       		.byte	0
 4796 0176 1D       		.uleb128 0x1d
 4797 0177 2E       		.uleb128 0x2e
 4798 0178 01       		.byte	0x1
 4799 0179 3F       		.uleb128 0x3f
 4800 017a 19       		.uleb128 0x19
 4801 017b 03       		.uleb128 0x3
 4802 017c 0E       		.uleb128 0xe
 4803 017d 3A       		.uleb128 0x3a
 4804 017e 0B       		.uleb128 0xb
 4805 017f 3B       		.uleb128 0x3b
 4806 0180 05       		.uleb128 0x5
 4807 0181 27       		.uleb128 0x27
 4808 0182 19       		.uleb128 0x19
 4809 0183 49       		.uleb128 0x49
 4810 0184 13       		.uleb128 0x13
 4811 0185 11       		.uleb128 0x11
 4812 0186 01       		.uleb128 0x1
 4813 0187 12       		.uleb128 0x12
 4814 0188 06       		.uleb128 0x6
 4815 0189 40       		.uleb128 0x40
 4816 018a 18       		.uleb128 0x18
 4817 018b 9742     		.uleb128 0x2117
 4818 018d 19       		.uleb128 0x19
 4819 018e 01       		.uleb128 0x1
 4820 018f 13       		.uleb128 0x13
 4821 0190 00       		.byte	0
 4822 0191 00       		.byte	0
 4823 0192 1E       		.uleb128 0x1e
 4824 0193 2E       		.uleb128 0x2e
 4825 0194 01       		.byte	0x1
 4826 0195 3F       		.uleb128 0x3f
 4827 0196 19       		.uleb128 0x19
 4828 0197 03       		.uleb128 0x3
 4829 0198 0E       		.uleb128 0xe
 4830 0199 3A       		.uleb128 0x3a
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 132


 4831 019a 0B       		.uleb128 0xb
 4832 019b 3B       		.uleb128 0x3b
 4833 019c 05       		.uleb128 0x5
 4834 019d 27       		.uleb128 0x27
 4835 019e 19       		.uleb128 0x19
 4836 019f 11       		.uleb128 0x11
 4837 01a0 01       		.uleb128 0x1
 4838 01a1 12       		.uleb128 0x12
 4839 01a2 06       		.uleb128 0x6
 4840 01a3 40       		.uleb128 0x40
 4841 01a4 18       		.uleb128 0x18
 4842 01a5 9642     		.uleb128 0x2116
 4843 01a7 19       		.uleb128 0x19
 4844 01a8 01       		.uleb128 0x1
 4845 01a9 13       		.uleb128 0x13
 4846 01aa 00       		.byte	0
 4847 01ab 00       		.byte	0
 4848 01ac 1F       		.uleb128 0x1f
 4849 01ad 2E       		.uleb128 0x2e
 4850 01ae 01       		.byte	0x1
 4851 01af 03       		.uleb128 0x3
 4852 01b0 0E       		.uleb128 0xe
 4853 01b1 3A       		.uleb128 0x3a
 4854 01b2 0B       		.uleb128 0xb
 4855 01b3 3B       		.uleb128 0x3b
 4856 01b4 05       		.uleb128 0x5
 4857 01b5 27       		.uleb128 0x27
 4858 01b6 19       		.uleb128 0x19
 4859 01b7 49       		.uleb128 0x49
 4860 01b8 13       		.uleb128 0x13
 4861 01b9 11       		.uleb128 0x11
 4862 01ba 01       		.uleb128 0x1
 4863 01bb 12       		.uleb128 0x12
 4864 01bc 06       		.uleb128 0x6
 4865 01bd 40       		.uleb128 0x40
 4866 01be 18       		.uleb128 0x18
 4867 01bf 9642     		.uleb128 0x2116
 4868 01c1 19       		.uleb128 0x19
 4869 01c2 01       		.uleb128 0x1
 4870 01c3 13       		.uleb128 0x13
 4871 01c4 00       		.byte	0
 4872 01c5 00       		.byte	0
 4873 01c6 20       		.uleb128 0x20
 4874 01c7 2E       		.uleb128 0x2e
 4875 01c8 01       		.byte	0x1
 4876 01c9 3F       		.uleb128 0x3f
 4877 01ca 19       		.uleb128 0x19
 4878 01cb 03       		.uleb128 0x3
 4879 01cc 0E       		.uleb128 0xe
 4880 01cd 3A       		.uleb128 0x3a
 4881 01ce 0B       		.uleb128 0xb
 4882 01cf 3B       		.uleb128 0x3b
 4883 01d0 05       		.uleb128 0x5
 4884 01d1 27       		.uleb128 0x27
 4885 01d2 19       		.uleb128 0x19
 4886 01d3 11       		.uleb128 0x11
 4887 01d4 01       		.uleb128 0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 133


 4888 01d5 12       		.uleb128 0x12
 4889 01d6 06       		.uleb128 0x6
 4890 01d7 40       		.uleb128 0x40
 4891 01d8 18       		.uleb128 0x18
 4892 01d9 9742     		.uleb128 0x2117
 4893 01db 19       		.uleb128 0x19
 4894 01dc 01       		.uleb128 0x1
 4895 01dd 13       		.uleb128 0x13
 4896 01de 00       		.byte	0
 4897 01df 00       		.byte	0
 4898 01e0 21       		.uleb128 0x21
 4899 01e1 34       		.uleb128 0x34
 4900 01e2 00       		.byte	0
 4901 01e3 03       		.uleb128 0x3
 4902 01e4 08       		.uleb128 0x8
 4903 01e5 3A       		.uleb128 0x3a
 4904 01e6 0B       		.uleb128 0xb
 4905 01e7 3B       		.uleb128 0x3b
 4906 01e8 05       		.uleb128 0x5
 4907 01e9 49       		.uleb128 0x49
 4908 01ea 13       		.uleb128 0x13
 4909 01eb 02       		.uleb128 0x2
 4910 01ec 18       		.uleb128 0x18
 4911 01ed 00       		.byte	0
 4912 01ee 00       		.byte	0
 4913 01ef 22       		.uleb128 0x22
 4914 01f0 34       		.uleb128 0x34
 4915 01f1 00       		.byte	0
 4916 01f2 03       		.uleb128 0x3
 4917 01f3 0E       		.uleb128 0xe
 4918 01f4 3A       		.uleb128 0x3a
 4919 01f5 0B       		.uleb128 0xb
 4920 01f6 3B       		.uleb128 0x3b
 4921 01f7 05       		.uleb128 0x5
 4922 01f8 49       		.uleb128 0x49
 4923 01f9 13       		.uleb128 0x13
 4924 01fa 3F       		.uleb128 0x3f
 4925 01fb 19       		.uleb128 0x19
 4926 01fc 3C       		.uleb128 0x3c
 4927 01fd 19       		.uleb128 0x19
 4928 01fe 00       		.byte	0
 4929 01ff 00       		.byte	0
 4930 0200 23       		.uleb128 0x23
 4931 0201 01       		.uleb128 0x1
 4932 0202 01       		.byte	0x1
 4933 0203 49       		.uleb128 0x49
 4934 0204 13       		.uleb128 0x13
 4935 0205 01       		.uleb128 0x1
 4936 0206 13       		.uleb128 0x13
 4937 0207 00       		.byte	0
 4938 0208 00       		.byte	0
 4939 0209 24       		.uleb128 0x24
 4940 020a 21       		.uleb128 0x21
 4941 020b 00       		.byte	0
 4942 020c 49       		.uleb128 0x49
 4943 020d 13       		.uleb128 0x13
 4944 020e 2F       		.uleb128 0x2f
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 134


 4945 020f 0B       		.uleb128 0xb
 4946 0210 00       		.byte	0
 4947 0211 00       		.byte	0
 4948 0212 25       		.uleb128 0x25
 4949 0213 34       		.uleb128 0x34
 4950 0214 00       		.byte	0
 4951 0215 03       		.uleb128 0x3
 4952 0216 0E       		.uleb128 0xe
 4953 0217 3A       		.uleb128 0x3a
 4954 0218 0B       		.uleb128 0xb
 4955 0219 3B       		.uleb128 0x3b
 4956 021a 0B       		.uleb128 0xb
 4957 021b 49       		.uleb128 0x49
 4958 021c 13       		.uleb128 0x13
 4959 021d 3F       		.uleb128 0x3f
 4960 021e 19       		.uleb128 0x19
 4961 021f 02       		.uleb128 0x2
 4962 0220 18       		.uleb128 0x18
 4963 0221 00       		.byte	0
 4964 0222 00       		.byte	0
 4965 0223 00       		.byte	0
 4966              		.section	.debug_aranges,"",%progbits
 4967 0000 F4000000 		.4byte	0xf4
 4968 0004 0200     		.2byte	0x2
 4969 0006 00000000 		.4byte	.Ldebug_info0
 4970 000a 04       		.byte	0x4
 4971 000b 00       		.byte	0
 4972 000c 0000     		.2byte	0
 4973 000e 0000     		.2byte	0
 4974 0010 00000000 		.4byte	.LFB68
 4975 0014 B4000000 		.4byte	.LFE68-.LFB68
 4976 0018 00000000 		.4byte	.LFB69
 4977 001c 58000000 		.4byte	.LFE69-.LFB69
 4978 0020 00000000 		.4byte	.LFB70
 4979 0024 3C000000 		.4byte	.LFE70-.LFB70
 4980 0028 00000000 		.4byte	.LFB71
 4981 002c 32000000 		.4byte	.LFE71-.LFB71
 4982 0030 00000000 		.4byte	.LFB72
 4983 0034 30000000 		.4byte	.LFE72-.LFB72
 4984 0038 00000000 		.4byte	.LFB73
 4985 003c 4C000000 		.4byte	.LFE73-.LFB73
 4986 0040 00000000 		.4byte	.LFB74
 4987 0044 54000000 		.4byte	.LFE74-.LFB74
 4988 0048 00000000 		.4byte	.LFB75
 4989 004c 2C000000 		.4byte	.LFE75-.LFB75
 4990 0050 00000000 		.4byte	.LFB76
 4991 0054 5C010000 		.4byte	.LFE76-.LFB76
 4992 0058 00000000 		.4byte	.LFB77
 4993 005c B2000000 		.4byte	.LFE77-.LFB77
 4994 0060 00000000 		.4byte	.LFB78
 4995 0064 A6000000 		.4byte	.LFE78-.LFB78
 4996 0068 00000000 		.4byte	.LFB79
 4997 006c B8010000 		.4byte	.LFE79-.LFB79
 4998 0070 00000000 		.4byte	.LFB80
 4999 0074 AC000000 		.4byte	.LFE80-.LFB80
 5000 0078 00000000 		.4byte	.LFB81
 5001 007c 64000000 		.4byte	.LFE81-.LFB81
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 135


 5002 0080 00000000 		.4byte	.LFB82
 5003 0084 20000000 		.4byte	.LFE82-.LFB82
 5004 0088 00000000 		.4byte	.LFB83
 5005 008c 2A000000 		.4byte	.LFE83-.LFB83
 5006 0090 00000000 		.4byte	.LFB84
 5007 0094 1C000000 		.4byte	.LFE84-.LFB84
 5008 0098 00000000 		.4byte	.LFB85
 5009 009c 1E000000 		.4byte	.LFE85-.LFB85
 5010 00a0 00000000 		.4byte	.LFB86
 5011 00a4 D8000000 		.4byte	.LFE86-.LFB86
 5012 00a8 00000000 		.4byte	.LFB87
 5013 00ac 4C000000 		.4byte	.LFE87-.LFB87
 5014 00b0 00000000 		.4byte	.LFB88
 5015 00b4 A2000000 		.4byte	.LFE88-.LFB88
 5016 00b8 00000000 		.4byte	.LFB89
 5017 00bc 2C000000 		.4byte	.LFE89-.LFB89
 5018 00c0 00000000 		.4byte	.LFB90
 5019 00c4 28000000 		.4byte	.LFE90-.LFB90
 5020 00c8 00000000 		.4byte	.LFB91
 5021 00cc 30000000 		.4byte	.LFE91-.LFB91
 5022 00d0 00000000 		.4byte	.LFB92
 5023 00d4 2C000000 		.4byte	.LFE92-.LFB92
 5024 00d8 00000000 		.4byte	.LFB93
 5025 00dc 50000000 		.4byte	.LFE93-.LFB93
 5026 00e0 00000000 		.4byte	.LFB94
 5027 00e4 4C000000 		.4byte	.LFE94-.LFB94
 5028 00e8 00000000 		.4byte	.LFB95
 5029 00ec 50000000 		.4byte	.LFE95-.LFB95
 5030 00f0 00000000 		.4byte	0
 5031 00f4 00000000 		.4byte	0
 5032              		.section	.debug_ranges,"",%progbits
 5033              	.Ldebug_ranges0:
 5034 0000 00000000 		.4byte	.LFB68
 5035 0004 B4000000 		.4byte	.LFE68
 5036 0008 00000000 		.4byte	.LFB69
 5037 000c 58000000 		.4byte	.LFE69
 5038 0010 00000000 		.4byte	.LFB70
 5039 0014 3C000000 		.4byte	.LFE70
 5040 0018 00000000 		.4byte	.LFB71
 5041 001c 32000000 		.4byte	.LFE71
 5042 0020 00000000 		.4byte	.LFB72
 5043 0024 30000000 		.4byte	.LFE72
 5044 0028 00000000 		.4byte	.LFB73
 5045 002c 4C000000 		.4byte	.LFE73
 5046 0030 00000000 		.4byte	.LFB74
 5047 0034 54000000 		.4byte	.LFE74
 5048 0038 00000000 		.4byte	.LFB75
 5049 003c 2C000000 		.4byte	.LFE75
 5050 0040 00000000 		.4byte	.LFB76
 5051 0044 5C010000 		.4byte	.LFE76
 5052 0048 00000000 		.4byte	.LFB77
 5053 004c B2000000 		.4byte	.LFE77
 5054 0050 00000000 		.4byte	.LFB78
 5055 0054 A6000000 		.4byte	.LFE78
 5056 0058 00000000 		.4byte	.LFB79
 5057 005c B8010000 		.4byte	.LFE79
 5058 0060 00000000 		.4byte	.LFB80
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 136


 5059 0064 AC000000 		.4byte	.LFE80
 5060 0068 00000000 		.4byte	.LFB81
 5061 006c 64000000 		.4byte	.LFE81
 5062 0070 00000000 		.4byte	.LFB82
 5063 0074 20000000 		.4byte	.LFE82
 5064 0078 00000000 		.4byte	.LFB83
 5065 007c 2A000000 		.4byte	.LFE83
 5066 0080 00000000 		.4byte	.LFB84
 5067 0084 1C000000 		.4byte	.LFE84
 5068 0088 00000000 		.4byte	.LFB85
 5069 008c 1E000000 		.4byte	.LFE85
 5070 0090 00000000 		.4byte	.LFB86
 5071 0094 D8000000 		.4byte	.LFE86
 5072 0098 00000000 		.4byte	.LFB87
 5073 009c 4C000000 		.4byte	.LFE87
 5074 00a0 00000000 		.4byte	.LFB88
 5075 00a4 A2000000 		.4byte	.LFE88
 5076 00a8 00000000 		.4byte	.LFB89
 5077 00ac 2C000000 		.4byte	.LFE89
 5078 00b0 00000000 		.4byte	.LFB90
 5079 00b4 28000000 		.4byte	.LFE90
 5080 00b8 00000000 		.4byte	.LFB91
 5081 00bc 30000000 		.4byte	.LFE91
 5082 00c0 00000000 		.4byte	.LFB92
 5083 00c4 2C000000 		.4byte	.LFE92
 5084 00c8 00000000 		.4byte	.LFB93
 5085 00cc 50000000 		.4byte	.LFE93
 5086 00d0 00000000 		.4byte	.LFB94
 5087 00d4 4C000000 		.4byte	.LFE94
 5088 00d8 00000000 		.4byte	.LFB95
 5089 00dc 50000000 		.4byte	.LFE95
 5090 00e0 00000000 		.4byte	0
 5091 00e4 00000000 		.4byte	0
 5092              		.section	.debug_line,"",%progbits
 5093              	.Ldebug_line0:
 5094 0000 5C060000 		.section	.debug_str,"MS",%progbits,1
 5094      02002602 
 5094      00000201 
 5094      FB0E0D00 
 5094      01010101 
 5095              	.LASF35:
 5096 0000 75784E75 		.ascii	"uxNumberOfItems\000"
 5096      6D626572 
 5096      4F664974 
 5096      656D7300 
 5097              	.LASF104:
 5098 0010 78517565 		.ascii	"xQueueReceiveFromISR\000"
 5098      75655265 
 5098      63656976 
 5098      6546726F 
 5098      6D495352 
 5099              	.LASF51:
 5100 0025 78546173 		.ascii	"xTasksWaitingToReceive\000"
 5100      6B735761 
 5100      6974696E 
 5100      67546F52 
 5100      65636569 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 137


 5101              	.LASF97:
 5102 003c 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 5102      67686572 
 5102      5072696F 
 5102      72697479 
 5102      5461736B 
 5103              	.LASF84:
 5104 0056 70784D75 		.ascii	"pxMutex\000"
 5104      74657800 
 5105              	.LASF0:
 5106 005e 756E7369 		.ascii	"unsigned int\000"
 5106      676E6564 
 5106      20696E74 
 5106      00
 5107              	.LASF36:
 5108 006b 7078496E 		.ascii	"pxIndex\000"
 5108      64657800 
 5109              	.LASF39:
 5110 0073 7854494D 		.ascii	"xTIME_OUT\000"
 5110      455F4F55 
 5110      5400
 5111              	.LASF73:
 5112 007d 70784E65 		.ascii	"pxNewQueue\000"
 5112      77517565 
 5112      756500
 5113              	.LASF8:
 5114 0088 5F5F696E 		.ascii	"__int32_t\000"
 5114      7433325F 
 5114      7400
 5115              	.LASF31:
 5116 0092 784C4953 		.ascii	"xLIST_ITEM\000"
 5116      545F4954 
 5116      454D00
 5117              	.LASF59:
 5118 009d 51554555 		.ascii	"QUEUE_REGISTRY_ITEM\000"
 5118      455F5245 
 5118      47495354 
 5118      52595F49 
 5118      54454D00 
 5119              	.LASF50:
 5120 00b1 78546173 		.ascii	"xTasksWaitingToSend\000"
 5120      6B735761 
 5120      6974696E 
 5120      67546F53 
 5120      656E6400 
 5121              	.LASF108:
 5122 00c5 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 5122      65756553 
 5122      70616365 
 5122      73417661 
 5122      696C6162 
 5123              	.LASF56:
 5124 00dc 6354784C 		.ascii	"cTxLock\000"
 5124      6F636B00 
 5125              	.LASF40:
 5126 00e4 784F7665 		.ascii	"xOverflowCount\000"
 5126      72666C6F 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 138


 5126      77436F75 
 5126      6E7400
 5127              	.LASF127:
 5128 00f3 433A5C55 		.ascii	"C:\\Users\\bmt\\Documents\\GitHub\\FreeRTOS_CY8CKIT"
 5128      73657273 
 5128      5C626D74 
 5128      5C446F63 
 5128      756D656E 
 5129 0121 5F303539 		.ascii	"_059\\FreeRTOS_Demo.cydsn\000"
 5129      5C467265 
 5129      6552544F 
 5129      535F4465 
 5129      6D6F2E63 
 5130              	.LASF45:
 5131 013a 75785265 		.ascii	"uxRecursiveCallCount\000"
 5131      63757273 
 5131      69766543 
 5131      616C6C43 
 5131      6F756E74 
 5132              	.LASF58:
 5133 014f 51756575 		.ascii	"Queue_t\000"
 5133      655F7400 
 5134              	.LASF92:
 5135 0157 78436F70 		.ascii	"xCopyPosition\000"
 5135      79506F73 
 5135      6974696F 
 5135      6E00
 5136              	.LASF107:
 5137 0165 75785265 		.ascii	"uxReturn\000"
 5137      7475726E 
 5137      00
 5138              	.LASF63:
 5139 016e 51756575 		.ascii	"QueueRegistryItem_t\000"
 5139      65526567 
 5139      69737472 
 5139      79497465 
 5139      6D5F7400 
 5140              	.LASF118:
 5141 0182 76517565 		.ascii	"vQueueDelete\000"
 5141      75654465 
 5141      6C657465 
 5141      00
 5142              	.LASF44:
 5143 018f 70635265 		.ascii	"pcReadFrom\000"
 5143      61644672 
 5143      6F6D00
 5144              	.LASF122:
 5145 019a 76517565 		.ascii	"vQueueUnregisterQueue\000"
 5145      7565556E 
 5145      72656769 
 5145      73746572 
 5145      51756575 
 5146              	.LASF98:
 5147 01b0 75785361 		.ascii	"uxSavedInterruptStatus\000"
 5147      76656449 
 5147      6E746572 
 5147      72757074 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 139


 5147      53746174 
 5148              	.LASF76:
 5149 01c7 70727649 		.ascii	"prvInitialiseNewQueue\000"
 5149      6E697469 
 5149      616C6973 
 5149      654E6577 
 5149      51756575 
 5150              	.LASF19:
 5151 01dd 75696E74 		.ascii	"uint32_t\000"
 5151      33325F74 
 5151      00
 5152              	.LASF16:
 5153 01e6 696E7438 		.ascii	"int8_t\000"
 5153      5F7400
 5154              	.LASF80:
 5155 01ed 75784D75 		.ascii	"uxMutexSize\000"
 5155      74657853 
 5155      697A6500 
 5156              	.LASF94:
 5157 01f9 78596965 		.ascii	"xYieldRequired\000"
 5157      6C645265 
 5157      71756972 
 5157      656400
 5158              	.LASF64:
 5159 0208 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 5159      6967696E 
 5159      616C4241 
 5159      53455052 
 5159      4900
 5160              	.LASF66:
 5161 021a 78517565 		.ascii	"xQueue\000"
 5161      756500
 5162              	.LASF20:
 5163 0221 666C6F61 		.ascii	"float\000"
 5163      7400
 5164              	.LASF46:
 5165 0227 51756575 		.ascii	"QueueDefinition\000"
 5165      65446566 
 5165      696E6974 
 5165      696F6E00 
 5166              	.LASF126:
 5167 0237 2E2E5C53 		.ascii	"..\\Source\\queue.c\000"
 5167      6F757263 
 5167      655C7175 
 5167      6575652E 
 5167      6300
 5168              	.LASF100:
 5169 0249 78517565 		.ascii	"xQueueGenericReceive\000"
 5169      75654765 
 5169      6E657269 
 5169      63526563 
 5169      65697665 
 5170              	.LASF13:
 5171 025e 6C6F6E67 		.ascii	"long long unsigned int\000"
 5171      206C6F6E 
 5171      6720756E 
 5171      7369676E 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 140


 5171      65642069 
 5172              	.LASF114:
 5173 0275 70727649 		.ascii	"prvIsQueueEmpty\000"
 5173      73517565 
 5173      7565456D 
 5173      70747900 
 5174              	.LASF101:
 5175 0285 70764275 		.ascii	"pvBuffer\000"
 5175      66666572 
 5175      00
 5176              	.LASF27:
 5177 028e 70785072 		.ascii	"pxPrevious\000"
 5177      6576696F 
 5177      757300
 5178              	.LASF52:
 5179 0299 75784D65 		.ascii	"uxMessagesWaiting\000"
 5179      73736167 
 5179      65735761 
 5179      6974696E 
 5179      6700
 5180              	.LASF93:
 5181 02ab 78456E74 		.ascii	"xEntryTimeSet\000"
 5181      72795469 
 5181      6D655365 
 5181      7400
 5182              	.LASF1:
 5183 02b9 73697A65 		.ascii	"size_t\000"
 5183      5F7400
 5184              	.LASF95:
 5185 02c0 7854696D 		.ascii	"xTimeOut\000"
 5185      654F7574 
 5185      00
 5186              	.LASF61:
 5187 02c9 7848616E 		.ascii	"xHandle\000"
 5187      646C6500 
 5188              	.LASF60:
 5189 02d1 70635175 		.ascii	"pcQueueName\000"
 5189      6575654E 
 5189      616D6500 
 5190              	.LASF32:
 5191 02dd 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 5191      495F4C49 
 5191      53545F49 
 5191      54454D00 
 5192              	.LASF34:
 5193 02ed 784C4953 		.ascii	"xLIST\000"
 5193      5400
 5194              	.LASF96:
 5195 02f3 78517565 		.ascii	"xQueueGenericSendFromISR\000"
 5195      75654765 
 5195      6E657269 
 5195      6353656E 
 5195      6446726F 
 5196              	.LASF129:
 5197 030c 76506F72 		.ascii	"vPortSetBASEPRI\000"
 5197      74536574 
 5197      42415345 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 141


 5197      50524900 
 5198              	.LASF113:
 5199 031c 70727643 		.ascii	"prvCopyDataToQueue\000"
 5199      6F707944 
 5199      61746154 
 5199      6F517565 
 5199      756500
 5200              	.LASF90:
 5201 032f 78517565 		.ascii	"xQueueGenericSend\000"
 5201      75654765 
 5201      6E657269 
 5201      6353656E 
 5201      6400
 5202              	.LASF54:
 5203 0341 75784974 		.ascii	"uxItemSize\000"
 5203      656D5369 
 5203      7A6500
 5204              	.LASF89:
 5205 034c 7578496E 		.ascii	"uxInitialCount\000"
 5205      69746961 
 5205      6C436F75 
 5205      6E7400
 5206              	.LASF79:
 5207 035b 75784D75 		.ascii	"uxMutexLength\000"
 5207      7465784C 
 5207      656E6774 
 5207      6800
 5208              	.LASF15:
 5209 0369 63686172 		.ascii	"char\000"
 5209      00
 5210              	.LASF30:
 5211 036e 4C697374 		.ascii	"ListItem_t\000"
 5211      4974656D 
 5211      5F7400
 5212              	.LASF116:
 5213 0379 70727649 		.ascii	"prvIsQueueFull\000"
 5213      73517565 
 5213      75654675 
 5213      6C6C00
 5214              	.LASF65:
 5215 0388 756C4E65 		.ascii	"ulNewBASEPRI\000"
 5215      77424153 
 5215      45505249 
 5215      00
 5216              	.LASF23:
 5217 0395 55426173 		.ascii	"UBaseType_t\000"
 5217      65547970 
 5217      655F7400 
 5218              	.LASF99:
 5219 03a1 78517565 		.ascii	"xQueueGiveFromISR\000"
 5219      75654769 
 5219      76654672 
 5219      6F6D4953 
 5219      5200
 5220              	.LASF124:
 5221 03b3 78517565 		.ascii	"xQueueRegistry\000"
 5221      75655265 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 142


 5221      67697374 
 5221      727900
 5222              	.LASF43:
 5223 03c2 51756575 		.ascii	"QueueHandle_t\000"
 5223      6548616E 
 5223      646C655F 
 5223      7400
 5224              	.LASF37:
 5225 03d0 784C6973 		.ascii	"xListEnd\000"
 5225      74456E64 
 5225      00
 5226              	.LASF109:
 5227 03d9 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
 5227      6575654D 
 5227      65737361 
 5227      67657357 
 5227      61697469 
 5228              	.LASF33:
 5229 03f7 4D696E69 		.ascii	"MiniListItem_t\000"
 5229      4C697374 
 5229      4974656D 
 5229      5F7400
 5230              	.LASF17:
 5231 0406 75696E74 		.ascii	"uint8_t\000"
 5231      385F7400 
 5232              	.LASF62:
 5233 040e 78517565 		.ascii	"xQueueRegistryItem\000"
 5233      75655265 
 5233      67697374 
 5233      72794974 
 5233      656D00
 5234              	.LASF69:
 5235 0421 78517565 		.ascii	"xQueueGenericCreate\000"
 5235      75654765 
 5235      6E657269 
 5235      63437265 
 5235      61746500 
 5236              	.LASF78:
 5237 0435 78517565 		.ascii	"xQueueCreateMutex\000"
 5237      75654372 
 5237      65617465 
 5237      4D757465 
 5237      7800
 5238              	.LASF128:
 5239 0447 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 5239      72745261 
 5239      69736542 
 5239      41534550 
 5239      524900
 5240              	.LASF12:
 5241 045a 6C6F6E67 		.ascii	"long long int\000"
 5241      206C6F6E 
 5241      6720696E 
 5241      7400
 5242              	.LASF77:
 5243 0468 70727649 		.ascii	"prvInitialiseMutex\000"
 5243      6E697469 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 143


 5243      616C6973 
 5243      654D7574 
 5243      657800
 5244              	.LASF22:
 5245 047b 42617365 		.ascii	"BaseType_t\000"
 5245      54797065 
 5245      5F7400
 5246              	.LASF75:
 5247 0486 70756351 		.ascii	"pucQueueStorage\000"
 5247      75657565 
 5247      53746F72 
 5247      61676500 
 5248              	.LASF82:
 5249 0496 784D7574 		.ascii	"xMutex\000"
 5249      657800
 5250              	.LASF41:
 5251 049d 7854696D 		.ascii	"xTimeOnEntering\000"
 5251      654F6E45 
 5251      6E746572 
 5251      696E6700 
 5252              	.LASF119:
 5253 04ad 76517565 		.ascii	"vQueueAddToRegistry\000"
 5253      75654164 
 5253      64546F52 
 5253      65676973 
 5253      74727900 
 5254              	.LASF26:
 5255 04c1 70784E65 		.ascii	"pxNext\000"
 5255      787400
 5256              	.LASF125:
 5257 04c8 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 5257      4320342E 
 5257      392E3320 
 5257      32303135 
 5257      30333033 
 5258 04fb 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 5258      20726576 
 5258      6973696F 
 5258      6E203232 
 5258      31323230 
 5259 052e 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 5259      66756E63 
 5259      74696F6E 
 5259      2D736563 
 5259      74696F6E 
 5260              	.LASF67:
 5261 0556 784E6577 		.ascii	"xNewQueue\000"
 5261      51756575 
 5261      6500
 5262              	.LASF88:
 5263 0560 75784D61 		.ascii	"uxMaxCount\000"
 5263      78436F75 
 5263      6E7400
 5264              	.LASF42:
 5265 056b 54696D65 		.ascii	"TimeOut_t\000"
 5265      4F75745F 
 5265      7400
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 144


 5266              	.LASF103:
 5267 0575 70634F72 		.ascii	"pcOriginalReadPosition\000"
 5267      6967696E 
 5267      616C5265 
 5267      6164506F 
 5267      73697469 
 5268              	.LASF130:
 5269 058c 756C4E65 		.ascii	"ulNewMaskValue\000"
 5269      774D6173 
 5269      6B56616C 
 5269      756500
 5270              	.LASF71:
 5271 059b 75635175 		.ascii	"ucQueueType\000"
 5271      65756554 
 5271      79706500 
 5272              	.LASF102:
 5273 05a7 784A7573 		.ascii	"xJustPeeking\000"
 5273      74506565 
 5273      6B696E67 
 5273      00
 5274              	.LASF38:
 5275 05b4 4C697374 		.ascii	"List_t\000"
 5275      5F7400
 5276              	.LASF49:
 5277 05bb 70635772 		.ascii	"pcWriteTo\000"
 5277      69746554 
 5277      6F00
 5278              	.LASF24:
 5279 05c5 5469636B 		.ascii	"TickType_t\000"
 5279      54797065 
 5279      5F7400
 5280              	.LASF2:
 5281 05d0 5F5F696E 		.ascii	"__int8_t\000"
 5281      74385F74 
 5281      00
 5282              	.LASF70:
 5283 05d9 75785175 		.ascii	"uxQueueLength\000"
 5283      6575654C 
 5283      656E6774 
 5283      6800
 5284              	.LASF85:
 5285 05e7 78517565 		.ascii	"xQueueTakeMutexRecursive\000"
 5285      75655461 
 5285      6B654D75 
 5285      74657852 
 5285      65637572 
 5286              	.LASF29:
 5287 0600 7076436F 		.ascii	"pvContainer\000"
 5287      6E746169 
 5287      6E657200 
 5288              	.LASF120:
 5289 060c 70635175 		.ascii	"pcQueueGetName\000"
 5289      65756547 
 5289      65744E61 
 5289      6D6500
 5290              	.LASF121:
 5291 061b 70635265 		.ascii	"pcReturn\000"
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 145


 5291      7475726E 
 5291      00
 5292              	.LASF53:
 5293 0624 75784C65 		.ascii	"uxLength\000"
 5293      6E677468 
 5293      00
 5294              	.LASF6:
 5295 062d 73686F72 		.ascii	"short int\000"
 5295      7420696E 
 5295      7400
 5296              	.LASF25:
 5297 0637 78497465 		.ascii	"xItemValue\000"
 5297      6D56616C 
 5297      756500
 5298              	.LASF9:
 5299 0642 6C6F6E67 		.ascii	"long int\000"
 5299      20696E74 
 5299      00
 5300              	.LASF123:
 5301 064b 49544D5F 		.ascii	"ITM_RxBuffer\000"
 5301      52784275 
 5301      66666572 
 5301      00
 5302              	.LASF74:
 5303 0658 78517565 		.ascii	"xQueueSizeInBytes\000"
 5303      75655369 
 5303      7A65496E 
 5303      42797465 
 5303      7300
 5304              	.LASF91:
 5305 066a 70764974 		.ascii	"pvItemToQueue\000"
 5305      656D546F 
 5305      51756575 
 5305      6500
 5306              	.LASF117:
 5307 0678 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 5307      75654973 
 5307      51756575 
 5307      6546756C 
 5307      6C46726F 
 5308              	.LASF106:
 5309 0691 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 5309      6575654D 
 5309      65737361 
 5309      67657357 
 5309      61697469 
 5310              	.LASF48:
 5311 06a8 70635461 		.ascii	"pcTail\000"
 5311      696C00
 5312              	.LASF4:
 5313 06af 5F5F7569 		.ascii	"__uint8_t\000"
 5313      6E74385F 
 5313      7400
 5314              	.LASF72:
 5315 06b9 70785175 		.ascii	"pxQueue\000"
 5315      65756500 
 5316              	.LASF83:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 146


 5317 06c1 78526574 		.ascii	"xReturn\000"
 5317      75726E00 
 5318              	.LASF14:
 5319 06c9 73697A65 		.ascii	"sizetype\000"
 5319      74797065 
 5319      00
 5320              	.LASF11:
 5321 06d2 6C6F6E67 		.ascii	"long unsigned int\000"
 5321      20756E73 
 5321      69676E65 
 5321      6420696E 
 5321      7400
 5322              	.LASF18:
 5323 06e4 696E7433 		.ascii	"int32_t\000"
 5323      325F7400 
 5324              	.LASF105:
 5325 06ec 78517565 		.ascii	"xQueuePeekFromISR\000"
 5325      75655065 
 5325      656B4672 
 5325      6F6D4953 
 5325      5200
 5326              	.LASF5:
 5327 06fe 756E7369 		.ascii	"unsigned char\000"
 5327      676E6564 
 5327      20636861 
 5327      7200
 5328              	.LASF10:
 5329 070c 5F5F7569 		.ascii	"__uint32_t\000"
 5329      6E743332 
 5329      5F7400
 5330              	.LASF111:
 5331 0717 70727643 		.ascii	"prvCopyDataFromQueue\000"
 5331      6F707944 
 5331      61746146 
 5331      726F6D51 
 5331      75657565 
 5332              	.LASF86:
 5333 072c 78546963 		.ascii	"xTicksToWait\000"
 5333      6B73546F 
 5333      57616974 
 5333      00
 5334              	.LASF28:
 5335 0739 70764F77 		.ascii	"pvOwner\000"
 5335      6E657200 
 5336              	.LASF47:
 5337 0741 70634865 		.ascii	"pcHead\000"
 5337      616400
 5338              	.LASF81:
 5339 0748 78517565 		.ascii	"xQueueGiveMutexRecursive\000"
 5339      75654769 
 5339      76654D75 
 5339      74657852 
 5339      65637572 
 5340              	.LASF112:
 5341 0761 70727655 		.ascii	"prvUnlockQueue\000"
 5341      6E6C6F63 
 5341      6B517565 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\cc98IX3d.s 			page 147


 5341      756500
 5342              	.LASF68:
 5343 0770 78517565 		.ascii	"xQueueGenericReset\000"
 5343      75654765 
 5343      6E657269 
 5343      63526573 
 5343      657400
 5344              	.LASF115:
 5345 0783 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 5345      75654973 
 5345      51756575 
 5345      65456D70 
 5345      74794672 
 5346              	.LASF3:
 5347 079d 7369676E 		.ascii	"signed char\000"
 5347      65642063 
 5347      68617200 
 5348              	.LASF7:
 5349 07a9 73686F72 		.ascii	"short unsigned int\000"
 5349      7420756E 
 5349      7369676E 
 5349      65642069 
 5349      6E7400
 5350              	.LASF57:
 5351 07bc 78515545 		.ascii	"xQUEUE\000"
 5351      554500
 5352              	.LASF21:
 5353 07c3 646F7562 		.ascii	"double\000"
 5353      6C6500
 5354              	.LASF110:
 5355 07ca 78506F73 		.ascii	"xPosition\000"
 5355      6974696F 
 5355      6E00
 5356              	.LASF55:
 5357 07d4 6352784C 		.ascii	"cRxLock\000"
 5357      6F636B00 
 5358              	.LASF87:
 5359 07dc 78517565 		.ascii	"xQueueCreateCountingSemaphore\000"
 5359      75654372 
 5359      65617465 
 5359      436F756E 
 5359      74696E67 
 5360              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
