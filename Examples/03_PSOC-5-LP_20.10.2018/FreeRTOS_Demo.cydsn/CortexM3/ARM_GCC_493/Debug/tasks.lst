ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"tasks.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.global	pxCurrentTCB
  19              		.bss
  20              		.align	2
  21              		.type	pxCurrentTCB, %object
  22              		.size	pxCurrentTCB, 4
  23              	pxCurrentTCB:
  24 0000 00000000 		.space	4
  25              		.align	2
  26              	pxReadyTasksLists:
  27 0004 00000000 		.space	100
  27      00000000 
  27      00000000 
  27      00000000 
  27      00000000 
  28              		.align	2
  29              	xDelayedTaskList1:
  30 0068 00000000 		.space	20
  30      00000000 
  30      00000000 
  30      00000000 
  30      00000000 
  31              		.align	2
  32              	xDelayedTaskList2:
  33 007c 00000000 		.space	20
  33      00000000 
  33      00000000 
  33      00000000 
  33      00000000 
  34              		.align	2
  35              	pxDelayedTaskList:
  36 0090 00000000 		.space	4
  37              		.align	2
  38              	pxOverflowDelayedTaskList:
  39 0094 00000000 		.space	4
  40              		.align	2
  41              	xPendingReadyList:
  42 0098 00000000 		.space	20
  42      00000000 
  42      00000000 
  42      00000000 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 2


  42      00000000 
  43              		.align	2
  44              	xTasksWaitingTermination:
  45 00ac 00000000 		.space	20
  45      00000000 
  45      00000000 
  45      00000000 
  45      00000000 
  46              		.align	2
  47              	uxDeletedTasksWaitingCleanUp:
  48 00c0 00000000 		.space	4
  49              		.align	2
  50              	xSuspendedTaskList:
  51 00c4 00000000 		.space	20
  51      00000000 
  51      00000000 
  51      00000000 
  51      00000000 
  52              		.align	2
  53              	uxCurrentNumberOfTasks:
  54 00d8 00000000 		.space	4
  55              		.align	2
  56              	xTickCount:
  57 00dc 00000000 		.space	4
  58              		.align	2
  59              	uxTopReadyPriority:
  60 00e0 00000000 		.space	4
  61              		.align	2
  62              	xSchedulerRunning:
  63 00e4 00000000 		.space	4
  64              		.align	2
  65              	uxPendedTicks:
  66 00e8 00000000 		.space	4
  67              		.align	2
  68              	xYieldPending:
  69 00ec 00000000 		.space	4
  70              		.align	2
  71              	xNumOfOverflows:
  72 00f0 00000000 		.space	4
  73              		.align	2
  74              	uxTaskNumber:
  75 00f4 00000000 		.space	4
  76              		.align	2
  77              	xNextTaskUnblockTime:
  78 00f8 00000000 		.space	4
  79              		.align	2
  80              	xIdleTaskHandle:
  81 00fc 00000000 		.space	4
  82              		.align	2
  83              	uxSchedulerSuspended:
  84 0100 00000000 		.space	4
  85              		.section	.text.xTaskCreate,"ax",%progbits
  86              		.align	2
  87              		.global	xTaskCreate
  88              		.thumb
  89              		.thumb_func
  90              		.type	xTaskCreate, %function
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 3


  91              	xTaskCreate:
  92              	.LFB68:
  93              		.file 1 "..\\Source\\tasks.c"
   1:..\Source/tasks.c **** /*
   2:..\Source/tasks.c ****     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:..\Source/tasks.c ****     All rights reserved
   4:..\Source/tasks.c **** 
   5:..\Source/tasks.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:..\Source/tasks.c **** 
   7:..\Source/tasks.c ****     This file is part of the FreeRTOS distribution.
   8:..\Source/tasks.c **** 
   9:..\Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:..\Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:..\Source/tasks.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:..\Source/tasks.c **** 
  13:..\Source/tasks.c ****     ***************************************************************************
  14:..\Source/tasks.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:..\Source/tasks.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:..\Source/tasks.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:..\Source/tasks.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:..\Source/tasks.c ****     ***************************************************************************
  19:..\Source/tasks.c **** 
  20:..\Source/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:..\Source/tasks.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:..\Source/tasks.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:..\Source/tasks.c ****     link: http://www.freertos.org/a00114.html
  24:..\Source/tasks.c **** 
  25:..\Source/tasks.c ****     ***************************************************************************
  26:..\Source/tasks.c ****      *                                                                       *
  27:..\Source/tasks.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:..\Source/tasks.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:..\Source/tasks.c ****      *    platform software that is more than just the market leader, it     *
  30:..\Source/tasks.c ****      *    is the industry's de facto standard.                               *
  31:..\Source/tasks.c ****      *                                                                       *
  32:..\Source/tasks.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:..\Source/tasks.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:..\Source/tasks.c ****      *    tutorial book, reference manual, or both:                          *
  35:..\Source/tasks.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:..\Source/tasks.c ****      *                                                                       *
  37:..\Source/tasks.c ****     ***************************************************************************
  38:..\Source/tasks.c **** 
  39:..\Source/tasks.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:..\Source/tasks.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:..\Source/tasks.c ****     defined configASSERT()?
  42:..\Source/tasks.c **** 
  43:..\Source/tasks.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:..\Source/tasks.c ****     embedded software for free we request you assist our global community by
  45:..\Source/tasks.c ****     participating in the support forum.
  46:..\Source/tasks.c **** 
  47:..\Source/tasks.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:..\Source/tasks.c ****     be as productive as possible as early as possible.  Now you can receive
  49:..\Source/tasks.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:..\Source/tasks.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:..\Source/tasks.c **** 
  52:..\Source/tasks.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:..\Source/tasks.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:..\Source/tasks.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 4


  55:..\Source/tasks.c **** 
  56:..\Source/tasks.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:..\Source/tasks.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:..\Source/tasks.c **** 
  59:..\Source/tasks.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:..\Source/tasks.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:..\Source/tasks.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:..\Source/tasks.c **** 
  63:..\Source/tasks.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:..\Source/tasks.c ****     engineered and independently SIL3 certified version for use in safety and
  65:..\Source/tasks.c ****     mission critical applications that require provable dependability.
  66:..\Source/tasks.c **** 
  67:..\Source/tasks.c ****     1 tab == 4 spaces!
  68:..\Source/tasks.c **** */
  69:..\Source/tasks.c **** 
  70:..\Source/tasks.c **** /* Standard includes. */
  71:..\Source/tasks.c **** #include <stdlib.h>
  72:..\Source/tasks.c **** #include <string.h>
  73:..\Source/tasks.c **** 
  74:..\Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  75:..\Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  76:..\Source/tasks.c **** task.h is included from an application file. */
  77:..\Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  78:..\Source/tasks.c **** 
  79:..\Source/tasks.c **** /* FreeRTOS includes. */
  80:..\Source/tasks.c **** #include "FreeRTOS.h"
  81:..\Source/tasks.c **** #include "task.h"
  82:..\Source/tasks.c **** #include "timers.h"
  83:..\Source/tasks.c **** #include "StackMacros.h"
  84:..\Source/tasks.c **** 
  85:..\Source/tasks.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  86:..\Source/tasks.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  87:..\Source/tasks.c **** header files above, but not in this file, in order to generate the correct
  88:..\Source/tasks.c **** privileged Vs unprivileged linkage and placement. */
  89:..\Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  90:..\Source/tasks.c **** 
  91:..\Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  92:..\Source/tasks.c **** functions but without including stdio.h here. */
  93:..\Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  94:..\Source/tasks.c **** 	/* At the bottom of this file are two optional functions that can be used
  95:..\Source/tasks.c **** 	to generate human readable text from the raw data generated by the
  96:..\Source/tasks.c **** 	uxTaskGetSystemState() function.  Note the formatting functions are provided
  97:..\Source/tasks.c **** 	for convenience only, and are NOT considered part of the kernel. */
  98:..\Source/tasks.c **** 	#include <stdio.h>
  99:..\Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
 100:..\Source/tasks.c **** 
 101:..\Source/tasks.c **** #if( configUSE_PREEMPTION == 0 )
 102:..\Source/tasks.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 103:..\Source/tasks.c **** 	performed just because a higher priority task has been woken. */
 104:..\Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION()
 105:..\Source/tasks.c **** #else
 106:..\Source/tasks.c **** 	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 107:..\Source/tasks.c **** #endif
 108:..\Source/tasks.c **** 
 109:..\Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
 110:..\Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION	( ( uint8_t ) 0 )
 111:..\Source/tasks.c **** #define taskWAITING_NOTIFICATION		( ( uint8_t ) 1 )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 5


 112:..\Source/tasks.c **** #define taskNOTIFICATION_RECEIVED		( ( uint8_t ) 2 )
 113:..\Source/tasks.c **** 
 114:..\Source/tasks.c **** /*
 115:..\Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 116:..\Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 117:..\Source/tasks.c ****  */
 118:..\Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 119:..\Source/tasks.c **** 
 120:..\Source/tasks.c **** /* Sometimes the FreeRTOSConfig.h settings only allow a task to be created using
 121:..\Source/tasks.c **** dynamically allocated RAM, in which case when any task is deleted it is known
 122:..\Source/tasks.c **** that both the task's stack and TCB need to be freed.  Sometimes the
 123:..\Source/tasks.c **** FreeRTOSConfig.h settings only allow a task to be created using statically
 124:..\Source/tasks.c **** allocated RAM, in which case when any task is deleted it is known that neither
 125:..\Source/tasks.c **** the task's stack or TCB should be freed.  Sometimes the FreeRTOSConfig.h
 126:..\Source/tasks.c **** settings allow a task to be created using either statically or dynamically
 127:..\Source/tasks.c **** allocated RAM, in which case a member of the TCB is used to record whether the
 128:..\Source/tasks.c **** stack and/or TCB were allocated statically or dynamically, so when a task is
 129:..\Source/tasks.c **** deleted the RAM that was allocated dynamically is freed again and no attempt is
 130:..\Source/tasks.c **** made to free the RAM that was allocated statically.
 131:..\Source/tasks.c **** tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE is only true if it is possible for a
 132:..\Source/tasks.c **** task to be created using either statically or dynamically allocated RAM.  Note
 133:..\Source/tasks.c **** that if portUSING_MPU_WRAPPERS is 1 then a protected task can be created with
 134:..\Source/tasks.c **** a statically allocated stack and a dynamically allocated TCB. */
 135:..\Source/tasks.c **** #define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && (
 136:..\Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB 		( ( uint8_t ) 0 )
 137:..\Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY 			( ( uint8_t ) 1 )
 138:..\Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB		( ( uint8_t ) 2 )
 139:..\Source/tasks.c **** 
 140:..\Source/tasks.c **** /*
 141:..\Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 142:..\Source/tasks.c ****  */
 143:..\Source/tasks.c **** #define tskBLOCKED_CHAR		( 'B' )
 144:..\Source/tasks.c **** #define tskREADY_CHAR		( 'R' )
 145:..\Source/tasks.c **** #define tskDELETED_CHAR		( 'D' )
 146:..\Source/tasks.c **** #define tskSUSPENDED_CHAR	( 'S' )
 147:..\Source/tasks.c **** 
 148:..\Source/tasks.c **** /*
 149:..\Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to be
 150:..\Source/tasks.c ****  * global, rather than file scope.
 151:..\Source/tasks.c ****  */
 152:..\Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 153:..\Source/tasks.c **** 	#define static
 154:..\Source/tasks.c **** #endif
 155:..\Source/tasks.c **** 
 156:..\Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 157:..\Source/tasks.c **** 
 158:..\Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
 159:..\Source/tasks.c **** 	performed in a generic way that is not optimised to any particular
 160:..\Source/tasks.c **** 	microcontroller architecture. */
 161:..\Source/tasks.c **** 
 162:..\Source/tasks.c **** 	/* uxTopReadyPriority holds the priority of the highest priority ready
 163:..\Source/tasks.c **** 	state task. */
 164:..\Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )														\
 165:..\Source/tasks.c **** 	{																									\
 166:..\Source/tasks.c **** 		if( ( uxPriority ) > uxTopReadyPriority )														\
 167:..\Source/tasks.c **** 		{																								\
 168:..\Source/tasks.c **** 			uxTopReadyPriority = ( uxPriority );														\
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 6


 169:..\Source/tasks.c **** 		}																								\
 170:..\Source/tasks.c **** 	} /* taskRECORD_READY_PRIORITY */
 171:..\Source/tasks.c **** 
 172:..\Source/tasks.c **** 	/*-----------------------------------------------------------*/
 173:..\Source/tasks.c **** 
 174:..\Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
 175:..\Source/tasks.c **** 	{																									\
 176:..\Source/tasks.c **** 	UBaseType_t uxTopPriority = uxTopReadyPriority;														\
 177:..\Source/tasks.c **** 																										\
 178:..\Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */								\
 179:..\Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )							\
 180:..\Source/tasks.c **** 		{																								\
 181:..\Source/tasks.c **** 			configASSERT( uxTopPriority );																\
 182:..\Source/tasks.c **** 			--uxTopPriority;																			\
 183:..\Source/tasks.c **** 		}																								\
 184:..\Source/tasks.c **** 																										\
 185:..\Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
 186:..\Source/tasks.c **** 		the	same priority get an equal share of the processor time. */									\
 187:..\Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );			\
 188:..\Source/tasks.c **** 		uxTopReadyPriority = uxTopPriority;																\
 189:..\Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
 190:..\Source/tasks.c **** 
 191:..\Source/tasks.c **** 	/*-----------------------------------------------------------*/
 192:..\Source/tasks.c **** 
 193:..\Source/tasks.c **** 	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 194:..\Source/tasks.c **** 	they are only required when a port optimised method of task selection is
 195:..\Source/tasks.c **** 	being used. */
 196:..\Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )
 197:..\Source/tasks.c **** 	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 198:..\Source/tasks.c **** 
 199:..\Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 200:..\Source/tasks.c **** 
 201:..\Source/tasks.c **** 	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 202:..\Source/tasks.c **** 	performed in a way that is tailored to the particular microcontroller
 203:..\Source/tasks.c **** 	architecture being used. */
 204:..\Source/tasks.c **** 
 205:..\Source/tasks.c **** 	/* A port optimised version is provided.  Call the port defined macros. */
 206:..\Source/tasks.c **** 	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyP
 207:..\Source/tasks.c **** 
 208:..\Source/tasks.c **** 	/*-----------------------------------------------------------*/
 209:..\Source/tasks.c **** 
 210:..\Source/tasks.c **** 	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
 211:..\Source/tasks.c **** 	{																								\
 212:..\Source/tasks.c **** 	UBaseType_t uxTopPriority;																		\
 213:..\Source/tasks.c **** 																									\
 214:..\Source/tasks.c **** 		/* Find the highest priority list that contains ready tasks. */								\
 215:..\Source/tasks.c **** 		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
 216:..\Source/tasks.c **** 		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
 217:..\Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
 218:..\Source/tasks.c **** 	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
 219:..\Source/tasks.c **** 
 220:..\Source/tasks.c **** 	/*-----------------------------------------------------------*/
 221:..\Source/tasks.c **** 
 222:..\Source/tasks.c **** 	/* A port optimised version is provided, call it only if the TCB being reset
 223:..\Source/tasks.c **** 	is being referenced from a ready list.  If it is referenced from a delayed
 224:..\Source/tasks.c **** 	or suspended list then it won't be in a ready list. */
 225:..\Source/tasks.c **** 	#define taskRESET_READY_PRIORITY( uxPriority )														\
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 7


 226:..\Source/tasks.c **** 	{																									\
 227:..\Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
 228:..\Source/tasks.c **** 		{																								\
 229:..\Source/tasks.c **** 			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
 230:..\Source/tasks.c **** 		}																								\
 231:..\Source/tasks.c **** 	}
 232:..\Source/tasks.c **** 
 233:..\Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 234:..\Source/tasks.c **** 
 235:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 236:..\Source/tasks.c **** 
 237:..\Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 238:..\Source/tasks.c **** count overflows. */
 239:..\Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()																	\
 240:..\Source/tasks.c **** {																									\
 241:..\Source/tasks.c **** 	List_t *pxTemp;																					\
 242:..\Source/tasks.c **** 																									\
 243:..\Source/tasks.c **** 	/* The delayed tasks list should be empty when the lists are switched. */						\
 244:..\Source/tasks.c **** 	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
 245:..\Source/tasks.c **** 																									\
 246:..\Source/tasks.c **** 	pxTemp = pxDelayedTaskList;																		\
 247:..\Source/tasks.c **** 	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
 248:..\Source/tasks.c **** 	pxOverflowDelayedTaskList = pxTemp;																\
 249:..\Source/tasks.c **** 	xNumOfOverflows++;																				\
 250:..\Source/tasks.c **** 	prvResetNextTaskUnblockTime();																	\
 251:..\Source/tasks.c **** }
 252:..\Source/tasks.c **** 
 253:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 254:..\Source/tasks.c **** 
 255:..\Source/tasks.c **** /*
 256:..\Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 257:..\Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 258:..\Source/tasks.c ****  */
 259:..\Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )																\
 260:..\Source/tasks.c **** 	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
 261:..\Source/tasks.c **** 	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
 262:..\Source/tasks.c **** 	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListItem ) );
 263:..\Source/tasks.c **** 	tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
 264:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 265:..\Source/tasks.c **** 
 266:..\Source/tasks.c **** /*
 267:..\Source/tasks.c ****  * Several functions take an TaskHandle_t parameter that can optionally be NULL,
 268:..\Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 269:..\Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 270:..\Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 271:..\Source/tasks.c ****  */
 272:..\Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( T
 273:..\Source/tasks.c **** 
 274:..\Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 275:..\Source/tasks.c **** of the task to which it belongs (coded to allow it to be held in reverse
 276:..\Source/tasks.c **** priority order).  However, it is occasionally borrowed for other purposes.  It
 277:..\Source/tasks.c **** is important its value is not updated due to a task priority change while it is
 278:..\Source/tasks.c **** being used for another purpose.  The following bit definition is used to inform
 279:..\Source/tasks.c **** the scheduler that the value should not be changed - in which case it is the
 280:..\Source/tasks.c **** responsibility of whichever module is using the value to ensure it gets set back
 281:..\Source/tasks.c **** to its original value when it is released. */
 282:..\Source/tasks.c **** #if( configUSE_16_BIT_TICKS == 1 )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 8


 283:..\Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
 284:..\Source/tasks.c **** #else
 285:..\Source/tasks.c **** 	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
 286:..\Source/tasks.c **** #endif
 287:..\Source/tasks.c **** 
 288:..\Source/tasks.c **** /*
 289:..\Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 290:..\Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 291:..\Source/tasks.c ****  * (the task's run time environment, including register values)
 292:..\Source/tasks.c ****  */
 293:..\Source/tasks.c **** typedef struct tskTaskControlBlock
 294:..\Source/tasks.c **** {
 295:..\Source/tasks.c **** 	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the task
 296:..\Source/tasks.c **** 
 297:..\Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 298:..\Source/tasks.c **** 		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MU
 299:..\Source/tasks.c **** 	#endif
 300:..\Source/tasks.c **** 
 301:..\Source/tasks.c **** 	ListItem_t			xStateListItem;	/*< The list that the state list item of a task is reference from den
 302:..\Source/tasks.c **** 	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
 303:..\Source/tasks.c **** 	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
 304:..\Source/tasks.c **** 	StackType_t			*pxStack;			/*< Points to the start of the stack. */
 305:..\Source/tasks.c **** 	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.
 306:..\Source/tasks.c **** 
 307:..\Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
 308:..\Source/tasks.c **** 		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack 
 309:..\Source/tasks.c **** 	#endif
 310:..\Source/tasks.c **** 
 311:..\Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 312:..\Source/tasks.c **** 		UBaseType_t		uxCriticalNesting;	/*< Holds the critical section nesting depth for ports that do no
 313:..\Source/tasks.c **** 	#endif
 314:..\Source/tasks.c **** 
 315:..\Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 316:..\Source/tasks.c **** 		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It al
 317:..\Source/tasks.c **** 		UBaseType_t		uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. *
 318:..\Source/tasks.c **** 	#endif
 319:..\Source/tasks.c **** 
 320:..\Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 321:..\Source/tasks.c **** 		UBaseType_t		uxBasePriority;		/*< The priority last assigned to the task - used by the priority i
 322:..\Source/tasks.c **** 		UBaseType_t		uxMutexesHeld;
 323:..\Source/tasks.c **** 	#endif
 324:..\Source/tasks.c **** 
 325:..\Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 326:..\Source/tasks.c **** 		TaskHookFunction_t pxTaskTag;
 327:..\Source/tasks.c **** 	#endif
 328:..\Source/tasks.c **** 
 329:..\Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 330:..\Source/tasks.c **** 		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 331:..\Source/tasks.c **** 	#endif
 332:..\Source/tasks.c **** 
 333:..\Source/tasks.c **** 	#if( configGENERATE_RUN_TIME_STATS == 1 )
 334:..\Source/tasks.c **** 		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state
 335:..\Source/tasks.c **** 	#endif
 336:..\Source/tasks.c **** 
 337:..\Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 338:..\Source/tasks.c **** 		/* Allocate a Newlib reent structure that is specific to this task.
 339:..\Source/tasks.c **** 		Note Newlib support has been included by popular demand, but is not
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 9


 340:..\Source/tasks.c **** 		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
 341:..\Source/tasks.c **** 		responsible for resulting newlib operation.  User must be familiar with
 342:..\Source/tasks.c **** 		newlib and must provide system-wide implementations of the necessary
 343:..\Source/tasks.c **** 		stubs. Be warned that (at the time of writing) the current newlib design
 344:..\Source/tasks.c **** 		implements a system-wide malloc() that must be provided with locks. */
 345:..\Source/tasks.c **** 		struct	_reent xNewLib_reent;
 346:..\Source/tasks.c **** 	#endif
 347:..\Source/tasks.c **** 
 348:..\Source/tasks.c **** 	#if( configUSE_TASK_NOTIFICATIONS == 1 )
 349:..\Source/tasks.c **** 		volatile uint32_t ulNotifiedValue;
 350:..\Source/tasks.c **** 		volatile uint8_t ucNotifyState;
 351:..\Source/tasks.c **** 	#endif
 352:..\Source/tasks.c **** 
 353:..\Source/tasks.c **** 	/* See the comments above the definition of
 354:..\Source/tasks.c **** 	tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 355:..\Source/tasks.c **** 	#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 356:..\Source/tasks.c **** 		uint8_t	ucStaticallyAllocated; 		/*< Set to pdTRUE if the task is a statically allocated to ensur
 357:..\Source/tasks.c **** 	#endif
 358:..\Source/tasks.c **** 
 359:..\Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 360:..\Source/tasks.c **** 		uint8_t ucDelayAborted;
 361:..\Source/tasks.c **** 	#endif
 362:..\Source/tasks.c **** 
 363:..\Source/tasks.c **** } tskTCB;
 364:..\Source/tasks.c **** 
 365:..\Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 366:..\Source/tasks.c **** below to enable the use of older kernel aware debuggers. */
 367:..\Source/tasks.c **** typedef tskTCB TCB_t;
 368:..\Source/tasks.c **** 
 369:..\Source/tasks.c **** /*lint -e956 A manual analysis and inspection has been used to determine which
 370:..\Source/tasks.c **** static variables must be declared volatile. */
 371:..\Source/tasks.c **** 
 372:..\Source/tasks.c **** PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 373:..\Source/tasks.c **** 
 374:..\Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 375:..\Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks
 376:..\Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
 377:..\Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one f
 378:..\Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list 
 379:..\Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task
 380:..\Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the sc
 381:..\Source/tasks.c **** 
 382:..\Source/tasks.c **** #if( INCLUDE_vTaskDelete == 1 )
 383:..\Source/tasks.c **** 
 384:..\Source/tasks.c **** 	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but 
 385:..\Source/tasks.c **** 	PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 386:..\Source/tasks.c **** 
 387:..\Source/tasks.c **** #endif
 388:..\Source/tasks.c **** 
 389:..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 390:..\Source/tasks.c **** 
 391:..\Source/tasks.c **** 	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 392:..\Source/tasks.c **** 
 393:..\Source/tasks.c **** #endif
 394:..\Source/tasks.c **** 
 395:..\Source/tasks.c **** /* Other file private variables. --------------------------------*/
 396:..\Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 10


 397:..\Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
 398:..\Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
 399:..\Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
 400:..\Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
 401:..\Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
 402:..\Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
 403:..\Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
 404:..\Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= ( TickType_t ) 0U; /* Initialise
 405:..\Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle					= NULL;			/*< Holds the handle of the idle 
 406:..\Source/tasks.c **** 
 407:..\Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 408:..\Source/tasks.c **** interrupts must not manipulate the xStateListItem of a TCB, or any of the
 409:..\Source/tasks.c **** lists the xStateListItem can be referenced from, if the scheduler is suspended.
 410:..\Source/tasks.c **** If an interrupt needs to unblock a task while the scheduler is suspended then it
 411:..\Source/tasks.c **** moves the task's event list item into the xPendingReadyList, ready for the
 412:..\Source/tasks.c **** kernel to move the task from the pending ready list into the real ready list
 413:..\Source/tasks.c **** when the scheduler is unsuspended.  The pending ready list itself can only be
 414:..\Source/tasks.c **** accessed from a critical section. */
 415:..\Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
 416:..\Source/tasks.c **** 
 417:..\Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 418:..\Source/tasks.c **** 
 419:..\Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter
 420:..\Source/tasks.c **** 	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution tim
 421:..\Source/tasks.c **** 
 422:..\Source/tasks.c **** #endif
 423:..\Source/tasks.c **** 
 424:..\Source/tasks.c **** /*lint +e956 */
 425:..\Source/tasks.c **** 
 426:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 427:..\Source/tasks.c **** 
 428:..\Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 429:..\Source/tasks.c **** #if(  configCHECK_FOR_STACK_OVERFLOW > 0 )
 430:..\Source/tasks.c **** 	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
 431:..\Source/tasks.c **** #endif
 432:..\Source/tasks.c **** 
 433:..\Source/tasks.c **** #if( configUSE_TICK_HOOK > 0 )
 434:..\Source/tasks.c **** 	extern void vApplicationTickHook( void );
 435:..\Source/tasks.c **** #endif
 436:..\Source/tasks.c **** 
 437:..\Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 438:..\Source/tasks.c **** 	extern void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxI
 439:..\Source/tasks.c **** #endif
 440:..\Source/tasks.c **** 
 441:..\Source/tasks.c **** /* File private functions. --------------------------------*/
 442:..\Source/tasks.c **** 
 443:..\Source/tasks.c **** /**
 444:..\Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 445:..\Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 446:..\Source/tasks.c ****  * is in any other state.
 447:..\Source/tasks.c ****  */
 448:..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 449:..\Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 450:..\Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 451:..\Source/tasks.c **** 
 452:..\Source/tasks.c **** /*
 453:..\Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 11


 454:..\Source/tasks.c ****  * automatically upon the creation of the first task.
 455:..\Source/tasks.c ****  */
 456:..\Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 457:..\Source/tasks.c **** 
 458:..\Source/tasks.c **** /*
 459:..\Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 460:..\Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 461:..\Source/tasks.c ****  * creation of the first user task.
 462:..\Source/tasks.c ****  *
 463:..\Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 464:..\Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 465:..\Source/tasks.c ****  *
 466:..\Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 467:..\Source/tasks.c ****  *
 468:..\Source/tasks.c ****  */
 469:..\Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 470:..\Source/tasks.c **** 
 471:..\Source/tasks.c **** /*
 472:..\Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 473:..\Source/tasks.c ****  * including the stack pointed to by the TCB.
 474:..\Source/tasks.c ****  *
 475:..\Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 476:..\Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 477:..\Source/tasks.c ****  */
 478:..\Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 479:..\Source/tasks.c **** 
 480:..\Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
 481:..\Source/tasks.c **** 
 482:..\Source/tasks.c **** #endif
 483:..\Source/tasks.c **** 
 484:..\Source/tasks.c **** /*
 485:..\Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 486:..\Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 487:..\Source/tasks.c ****  * and its TCB deleted.
 488:..\Source/tasks.c ****  */
 489:..\Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 490:..\Source/tasks.c **** 
 491:..\Source/tasks.c **** /*
 492:..\Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 493:..\Source/tasks.c ****  * either the current or the overflow delayed task list.
 494:..\Source/tasks.c ****  */
 495:..\Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
 496:..\Source/tasks.c **** 
 497:..\Source/tasks.c **** /*
 498:..\Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 499:..\Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 500:..\Source/tasks.c ****  * a suspended list, etc.).
 501:..\Source/tasks.c ****  *
 502:..\Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 503:..\Source/tasks.c ****  * NORMAL APPLICATION CODE.
 504:..\Source/tasks.c ****  */
 505:..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 506:..\Source/tasks.c **** 
 507:..\Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
 508:..\Source/tasks.c **** 
 509:..\Source/tasks.c **** #endif
 510:..\Source/tasks.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 12


 511:..\Source/tasks.c **** /*
 512:..\Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 513:..\Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 514:..\Source/tasks.c ****  */
 515:..\Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 516:..\Source/tasks.c **** 
 517:..\Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] ) PRIVI
 518:..\Source/tasks.c **** 
 519:..\Source/tasks.c **** #endif
 520:..\Source/tasks.c **** 
 521:..\Source/tasks.c **** /*
 522:..\Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 523:..\Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 524:..\Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 525:..\Source/tasks.c ****  */
 526:..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 527:..\Source/tasks.c **** 
 528:..\Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
 529:..\Source/tasks.c **** 
 530:..\Source/tasks.c **** #endif
 531:..\Source/tasks.c **** 
 532:..\Source/tasks.c **** /*
 533:..\Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 534:..\Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 535:..\Source/tasks.c ****  *
 536:..\Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 537:..\Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 538:..\Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 539:..\Source/tasks.c ****  * set to a value other than 1.
 540:..\Source/tasks.c ****  */
 541:..\Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 542:..\Source/tasks.c **** 
 543:..\Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 544:..\Source/tasks.c **** 
 545:..\Source/tasks.c **** #endif
 546:..\Source/tasks.c **** 
 547:..\Source/tasks.c **** /*
 548:..\Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 549:..\Source/tasks.c ****  * will exit the Blocked state.
 550:..\Source/tasks.c ****  */
 551:..\Source/tasks.c **** static void prvResetNextTaskUnblockTime( void );
 552:..\Source/tasks.c **** 
 553:..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
 554:..\Source/tasks.c **** 
 555:..\Source/tasks.c **** 	/*
 556:..\Source/tasks.c **** 	 * Helper function used to pad task names with spaces when printing out
 557:..\Source/tasks.c **** 	 * human readable tables of task information.
 558:..\Source/tasks.c **** 	 */
 559:..\Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName ) PRIVILEGED_FUNCTION;
 560:..\Source/tasks.c **** 
 561:..\Source/tasks.c **** #endif
 562:..\Source/tasks.c **** 
 563:..\Source/tasks.c **** /*
 564:..\Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 565:..\Source/tasks.c ****  * dynamically to fill in the structure's members.
 566:..\Source/tasks.c ****  */
 567:..\Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 13


 568:..\Source/tasks.c **** 									const char * const pcName,
 569:..\Source/tasks.c **** 									const uint32_t ulStackDepth,
 570:..\Source/tasks.c **** 									void * const pvParameters,
 571:..\Source/tasks.c **** 									UBaseType_t uxPriority,
 572:..\Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 573:..\Source/tasks.c **** 									TCB_t *pxNewTCB,
 574:..\Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char
 575:..\Source/tasks.c **** 
 576:..\Source/tasks.c **** /*
 577:..\Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 578:..\Source/tasks.c ****  * under the control of the scheduler.
 579:..\Source/tasks.c ****  */
 580:..\Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) PRIVILEGED_FUNCTION;
 581:..\Source/tasks.c **** 
 582:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 583:..\Source/tasks.c **** 
 584:..\Source/tasks.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 585:..\Source/tasks.c **** 
 586:..\Source/tasks.c **** 	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
 587:..\Source/tasks.c **** 									const char * const pcName,
 588:..\Source/tasks.c **** 									const uint32_t ulStackDepth,
 589:..\Source/tasks.c **** 									void * const pvParameters,
 590:..\Source/tasks.c **** 									UBaseType_t uxPriority,
 591:..\Source/tasks.c **** 									StackType_t * const puxStackBuffer,
 592:..\Source/tasks.c **** 									StaticTask_t * const pxTaskBuffer ) /*lint !e971 Unqualified char types are allowed for st
 593:..\Source/tasks.c **** 	{
 594:..\Source/tasks.c **** 	TCB_t *pxNewTCB;
 595:..\Source/tasks.c **** 	TaskHandle_t xReturn;
 596:..\Source/tasks.c **** 
 597:..\Source/tasks.c **** 		configASSERT( puxStackBuffer != NULL );
 598:..\Source/tasks.c **** 		configASSERT( pxTaskBuffer != NULL );
 599:..\Source/tasks.c **** 
 600:..\Source/tasks.c **** 		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 601:..\Source/tasks.c **** 		{
 602:..\Source/tasks.c **** 			/* The memory used for the task's TCB and stack are passed into this
 603:..\Source/tasks.c **** 			function - use them. */
 604:..\Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are desig
 605:..\Source/tasks.c **** 			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 606:..\Source/tasks.c **** 
 607:..\Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 608:..\Source/tasks.c **** 			{
 609:..\Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 610:..\Source/tasks.c **** 				task was created statically in case the task is later deleted. */
 611:..\Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 612:..\Source/tasks.c **** 			}
 613:..\Source/tasks.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 614:..\Source/tasks.c **** 
 615:..\Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNe
 616:..\Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 617:..\Source/tasks.c **** 		}
 618:..\Source/tasks.c **** 		else
 619:..\Source/tasks.c **** 		{
 620:..\Source/tasks.c **** 			xReturn = NULL;
 621:..\Source/tasks.c **** 		}
 622:..\Source/tasks.c **** 
 623:..\Source/tasks.c **** 		return xReturn;
 624:..\Source/tasks.c **** 	}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 14


 625:..\Source/tasks.c **** 
 626:..\Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
 627:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 628:..\Source/tasks.c **** 
 629:..\Source/tasks.c **** #if( portUSING_MPU_WRAPPERS == 1 )
 630:..\Source/tasks.c **** 
 631:..\Source/tasks.c **** 	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *p
 632:..\Source/tasks.c **** 	{
 633:..\Source/tasks.c **** 	TCB_t *pxNewTCB;
 634:..\Source/tasks.c **** 	BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 635:..\Source/tasks.c **** 
 636:..\Source/tasks.c **** 		configASSERT( pxTaskDefinition->puxStackBuffer );
 637:..\Source/tasks.c **** 
 638:..\Source/tasks.c **** 		if( pxTaskDefinition->puxStackBuffer != NULL )
 639:..\Source/tasks.c **** 		{
 640:..\Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends
 641:..\Source/tasks.c **** 			on the implementation of the port malloc function and whether or
 642:..\Source/tasks.c **** 			not static allocation is being used. */
 643:..\Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 644:..\Source/tasks.c **** 
 645:..\Source/tasks.c **** 			if( pxNewTCB != NULL )
 646:..\Source/tasks.c **** 			{
 647:..\Source/tasks.c **** 				/* Store the stack location in the TCB. */
 648:..\Source/tasks.c **** 				pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 649:..\Source/tasks.c **** 
 650:..\Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note
 651:..\Source/tasks.c **** 				this task had a statically allocated stack in case it is
 652:..\Source/tasks.c **** 				later deleted.  The TCB was allocated dynamically. */
 653:..\Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 654:..\Source/tasks.c **** 
 655:..\Source/tasks.c **** 				prvInitialiseNewTask(	pxTaskDefinition->pvTaskCode,
 656:..\Source/tasks.c **** 										pxTaskDefinition->pcName,
 657:..\Source/tasks.c **** 										( uint32_t ) pxTaskDefinition->usStackDepth,
 658:..\Source/tasks.c **** 										pxTaskDefinition->pvParameters,
 659:..\Source/tasks.c **** 										pxTaskDefinition->uxPriority,
 660:..\Source/tasks.c **** 										pxCreatedTask, pxNewTCB,
 661:..\Source/tasks.c **** 										pxTaskDefinition->xRegions );
 662:..\Source/tasks.c **** 
 663:..\Source/tasks.c **** 				prvAddNewTaskToReadyList( pxNewTCB );
 664:..\Source/tasks.c **** 				xReturn = pdPASS;
 665:..\Source/tasks.c **** 			}
 666:..\Source/tasks.c **** 		}
 667:..\Source/tasks.c **** 
 668:..\Source/tasks.c **** 		return xReturn;
 669:..\Source/tasks.c **** 	}
 670:..\Source/tasks.c **** 
 671:..\Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 672:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 673:..\Source/tasks.c **** 
 674:..\Source/tasks.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 675:..\Source/tasks.c **** 
 676:..\Source/tasks.c **** 	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
 677:..\Source/tasks.c **** 							const char * const pcName,
 678:..\Source/tasks.c **** 							const uint16_t usStackDepth,
 679:..\Source/tasks.c **** 							void * const pvParameters,
 680:..\Source/tasks.c **** 							UBaseType_t uxPriority,
 681:..\Source/tasks.c **** 							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for str
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 15


 682:..\Source/tasks.c **** 	{
  94              		.loc 1 682 0
  95              		.cfi_startproc
  96              		@ args = 8, pretend = 0, frame = 32
  97              		@ frame_needed = 1, uses_anonymous_args = 0
  98 0000 80B5     		push	{r7, lr}
  99              		.cfi_def_cfa_offset 8
 100              		.cfi_offset 7, -8
 101              		.cfi_offset 14, -4
 102 0002 8CB0     		sub	sp, sp, #48
 103              		.cfi_def_cfa_offset 56
 104 0004 04AF     		add	r7, sp, #16
 105              		.cfi_def_cfa 7, 40
 106 0006 F860     		str	r0, [r7, #12]
 107 0008 B960     		str	r1, [r7, #8]
 108 000a 3B60     		str	r3, [r7]
 109 000c 1346     		mov	r3, r2	@ movhi
 110 000e FB80     		strh	r3, [r7, #6]	@ movhi
 111              	.LBB27:
 683:..\Source/tasks.c **** 	TCB_t *pxNewTCB;
 684:..\Source/tasks.c **** 	BaseType_t xReturn;
 685:..\Source/tasks.c **** 
 686:..\Source/tasks.c **** 		/* If the stack grows down then allocate the stack then the TCB so the stack
 687:..\Source/tasks.c **** 		does not grow into the TCB.  Likewise if the stack grows up then allocate
 688:..\Source/tasks.c **** 		the TCB then the stack. */
 689:..\Source/tasks.c **** 		#if( portSTACK_GROWTH > 0 )
 690:..\Source/tasks.c **** 		{
 691:..\Source/tasks.c **** 			/* Allocate space for the TCB.  Where the memory comes from depends on
 692:..\Source/tasks.c **** 			the implementation of the port malloc function and whether or not static
 693:..\Source/tasks.c **** 			allocation is being used. */
 694:..\Source/tasks.c **** 			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 695:..\Source/tasks.c **** 
 696:..\Source/tasks.c **** 			if( pxNewTCB != NULL )
 697:..\Source/tasks.c **** 			{
 698:..\Source/tasks.c **** 				/* Allocate space for the stack used by the task being created.
 699:..\Source/tasks.c **** 				The base of the stack memory stored in the TCB so the task can
 700:..\Source/tasks.c **** 				be deleted later if required. */
 701:..\Source/tasks.c **** 				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( Sta
 702:..\Source/tasks.c **** 
 703:..\Source/tasks.c **** 				if( pxNewTCB->pxStack == NULL )
 704:..\Source/tasks.c **** 				{
 705:..\Source/tasks.c **** 					/* Could not allocate the stack.  Delete the allocated TCB. */
 706:..\Source/tasks.c **** 					vPortFree( pxNewTCB );
 707:..\Source/tasks.c **** 					pxNewTCB = NULL;
 708:..\Source/tasks.c **** 				}
 709:..\Source/tasks.c **** 			}
 710:..\Source/tasks.c **** 		}
 711:..\Source/tasks.c **** 		#else /* portSTACK_GROWTH */
 712:..\Source/tasks.c **** 		{
 713:..\Source/tasks.c **** 		StackType_t *pxStack;
 714:..\Source/tasks.c **** 
 715:..\Source/tasks.c **** 			/* Allocate space for the stack used by the task being created. */
 716:..\Source/tasks.c **** 			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) 
 112              		.loc 1 716 0
 113 0010 FB88     		ldrh	r3, [r7, #6]
 114 0012 9B00     		lsls	r3, r3, #2
 115 0014 1846     		mov	r0, r3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 16


 116 0016 FFF7FEFF 		bl	pvPortMalloc
 117 001a 7861     		str	r0, [r7, #20]
 717:..\Source/tasks.c **** 
 718:..\Source/tasks.c **** 			if( pxStack != NULL )
 118              		.loc 1 718 0
 119 001c 7B69     		ldr	r3, [r7, #20]
 120 001e 002B     		cmp	r3, #0
 121 0020 0ED0     		beq	.L2
 719:..\Source/tasks.c **** 			{
 720:..\Source/tasks.c **** 				/* Allocate space for the TCB. */
 721:..\Source/tasks.c **** 				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the cas
 122              		.loc 1 721 0
 123 0022 5020     		movs	r0, #80
 124 0024 FFF7FEFF 		bl	pvPortMalloc
 125 0028 F861     		str	r0, [r7, #28]
 722:..\Source/tasks.c **** 
 723:..\Source/tasks.c **** 				if( pxNewTCB != NULL )
 126              		.loc 1 723 0
 127 002a FB69     		ldr	r3, [r7, #28]
 128 002c 002B     		cmp	r3, #0
 129 002e 03D0     		beq	.L3
 724:..\Source/tasks.c **** 				{
 725:..\Source/tasks.c **** 					/* Store the stack location in the TCB. */
 726:..\Source/tasks.c **** 					pxNewTCB->pxStack = pxStack;
 130              		.loc 1 726 0
 131 0030 FB69     		ldr	r3, [r7, #28]
 132 0032 7A69     		ldr	r2, [r7, #20]
 133 0034 1A63     		str	r2, [r3, #48]
 134 0036 05E0     		b	.L5
 135              	.L3:
 727:..\Source/tasks.c **** 				}
 728:..\Source/tasks.c **** 				else
 729:..\Source/tasks.c **** 				{
 730:..\Source/tasks.c **** 					/* The stack cannot be used as the TCB was not created.  Free
 731:..\Source/tasks.c **** 					it again. */
 732:..\Source/tasks.c **** 					vPortFree( pxStack );
 136              		.loc 1 732 0
 137 0038 7869     		ldr	r0, [r7, #20]
 138 003a FFF7FEFF 		bl	vPortFree
 139 003e 01E0     		b	.L5
 140              	.L2:
 733:..\Source/tasks.c **** 				}
 734:..\Source/tasks.c **** 			}
 735:..\Source/tasks.c **** 			else
 736:..\Source/tasks.c **** 			{
 737:..\Source/tasks.c **** 				pxNewTCB = NULL;
 141              		.loc 1 737 0
 142 0040 0023     		movs	r3, #0
 143 0042 FB61     		str	r3, [r7, #28]
 144              	.L5:
 145              	.LBE27:
 738:..\Source/tasks.c **** 			}
 739:..\Source/tasks.c **** 		}
 740:..\Source/tasks.c **** 		#endif /* portSTACK_GROWTH */
 741:..\Source/tasks.c **** 
 742:..\Source/tasks.c **** 		if( pxNewTCB != NULL )
 146              		.loc 1 742 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 17


 147 0044 FB69     		ldr	r3, [r7, #28]
 148 0046 002B     		cmp	r3, #0
 149 0048 13D0     		beq	.L6
 743:..\Source/tasks.c **** 		{
 744:..\Source/tasks.c **** 			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 745:..\Source/tasks.c **** 			{
 746:..\Source/tasks.c **** 				/* Tasks can be created statically or dynamically, so note this
 747:..\Source/tasks.c **** 				task was created dynamically in case it is later deleted. */
 748:..\Source/tasks.c **** 				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 749:..\Source/tasks.c **** 			}
 750:..\Source/tasks.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 751:..\Source/tasks.c **** 
 752:..\Source/tasks.c **** 			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, p
 150              		.loc 1 752 0
 151 004a FA88     		ldrh	r2, [r7, #6]
 152 004c BB6A     		ldr	r3, [r7, #40]
 153 004e 0093     		str	r3, [sp]
 154 0050 FB6A     		ldr	r3, [r7, #44]
 155 0052 0193     		str	r3, [sp, #4]
 156 0054 FB69     		ldr	r3, [r7, #28]
 157 0056 0293     		str	r3, [sp, #8]
 158 0058 0023     		movs	r3, #0
 159 005a 0393     		str	r3, [sp, #12]
 160 005c F868     		ldr	r0, [r7, #12]
 161 005e B968     		ldr	r1, [r7, #8]
 162 0060 3B68     		ldr	r3, [r7]
 163 0062 FFF7FEFF 		bl	prvInitialiseNewTask
 753:..\Source/tasks.c **** 			prvAddNewTaskToReadyList( pxNewTCB );
 164              		.loc 1 753 0
 165 0066 F869     		ldr	r0, [r7, #28]
 166 0068 FFF7FEFF 		bl	prvAddNewTaskToReadyList
 754:..\Source/tasks.c **** 			xReturn = pdPASS;
 167              		.loc 1 754 0
 168 006c 0123     		movs	r3, #1
 169 006e BB61     		str	r3, [r7, #24]
 170 0070 02E0     		b	.L7
 171              	.L6:
 755:..\Source/tasks.c **** 		}
 756:..\Source/tasks.c **** 		else
 757:..\Source/tasks.c **** 		{
 758:..\Source/tasks.c **** 			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 172              		.loc 1 758 0
 173 0072 4FF0FF33 		mov	r3, #-1
 174 0076 BB61     		str	r3, [r7, #24]
 175              	.L7:
 759:..\Source/tasks.c **** 		}
 760:..\Source/tasks.c **** 
 761:..\Source/tasks.c **** 		return xReturn;
 176              		.loc 1 761 0
 177 0078 BB69     		ldr	r3, [r7, #24]
 762:..\Source/tasks.c **** 	}
 178              		.loc 1 762 0
 179 007a 1846     		mov	r0, r3
 180 007c 2037     		adds	r7, r7, #32
 181              		.cfi_def_cfa_offset 8
 182 007e BD46     		mov	sp, r7
 183              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 18


 184              		@ sp needed
 185 0080 80BD     		pop	{r7, pc}
 186              		.cfi_endproc
 187              	.LFE68:
 188              		.size	xTaskCreate, .-xTaskCreate
 189 0082 00BF     		.section	.text.prvInitialiseNewTask,"ax",%progbits
 190              		.align	2
 191              		.thumb
 192              		.thumb_func
 193              		.type	prvInitialiseNewTask, %function
 194              	prvInitialiseNewTask:
 195              	.LFB69:
 763:..\Source/tasks.c **** 
 764:..\Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 765:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 766:..\Source/tasks.c **** 
 767:..\Source/tasks.c **** static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 768:..\Source/tasks.c **** 									const char * const pcName,
 769:..\Source/tasks.c **** 									const uint32_t ulStackDepth,
 770:..\Source/tasks.c **** 									void * const pvParameters,
 771:..\Source/tasks.c **** 									UBaseType_t uxPriority,
 772:..\Source/tasks.c **** 									TaskHandle_t * const pxCreatedTask,
 773:..\Source/tasks.c **** 									TCB_t *pxNewTCB,
 774:..\Source/tasks.c **** 									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed fo
 775:..\Source/tasks.c **** {
 196              		.loc 1 775 0
 197              		.cfi_startproc
 198              		@ args = 16, pretend = 0, frame = 24
 199              		@ frame_needed = 1, uses_anonymous_args = 0
 200 0000 80B5     		push	{r7, lr}
 201              		.cfi_def_cfa_offset 8
 202              		.cfi_offset 7, -8
 203              		.cfi_offset 14, -4
 204 0002 86B0     		sub	sp, sp, #24
 205              		.cfi_def_cfa_offset 32
 206 0004 00AF     		add	r7, sp, #0
 207              		.cfi_def_cfa_register 7
 208 0006 F860     		str	r0, [r7, #12]
 209 0008 B960     		str	r1, [r7, #8]
 210 000a 7A60     		str	r2, [r7, #4]
 211 000c 3B60     		str	r3, [r7]
 776:..\Source/tasks.c **** StackType_t *pxTopOfStack;
 777:..\Source/tasks.c **** UBaseType_t x;
 778:..\Source/tasks.c **** 
 779:..\Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 780:..\Source/tasks.c **** 		/* Should the task be created in privileged mode? */
 781:..\Source/tasks.c **** 		BaseType_t xRunPrivileged;
 782:..\Source/tasks.c **** 		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 783:..\Source/tasks.c **** 		{
 784:..\Source/tasks.c **** 			xRunPrivileged = pdTRUE;
 785:..\Source/tasks.c **** 		}
 786:..\Source/tasks.c **** 		else
 787:..\Source/tasks.c **** 		{
 788:..\Source/tasks.c **** 			xRunPrivileged = pdFALSE;
 789:..\Source/tasks.c **** 		}
 790:..\Source/tasks.c **** 		uxPriority &= ~portPRIVILEGE_BIT;
 791:..\Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS == 1 */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 19


 792:..\Source/tasks.c **** 
 793:..\Source/tasks.c **** 	/* Avoid dependency on memset() if it is not required. */
 794:..\Source/tasks.c **** 	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTa
 795:..\Source/tasks.c **** 	{
 796:..\Source/tasks.c **** 		/* Fill the stack with a known value to assist debugging. */
 797:..\Source/tasks.c **** 		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof(
 212              		.loc 1 797 0
 213 000e BB6A     		ldr	r3, [r7, #40]
 214 0010 1A6B     		ldr	r2, [r3, #48]
 215 0012 7B68     		ldr	r3, [r7, #4]
 216 0014 9B00     		lsls	r3, r3, #2
 217 0016 1046     		mov	r0, r2
 218 0018 A521     		movs	r1, #165
 219 001a 1A46     		mov	r2, r3
 220 001c FFF7FEFF 		bl	memset
 798:..\Source/tasks.c **** 	}
 799:..\Source/tasks.c **** 	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INC
 800:..\Source/tasks.c **** 
 801:..\Source/tasks.c **** 	/* Calculate the top of stack address.  This depends on whether the stack
 802:..\Source/tasks.c **** 	grows from high memory to low (as per the 80x86) or vice versa.
 803:..\Source/tasks.c **** 	portSTACK_GROWTH is used to make the result positive or negative as required
 804:..\Source/tasks.c **** 	by the port. */
 805:..\Source/tasks.c **** 	#if( portSTACK_GROWTH < 0 )
 806:..\Source/tasks.c **** 	{
 807:..\Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 221              		.loc 1 807 0
 222 0020 BB6A     		ldr	r3, [r7, #40]
 223 0022 1A6B     		ldr	r2, [r3, #48]
 224 0024 7B68     		ldr	r3, [r7, #4]
 225 0026 03F18043 		add	r3, r3, #1073741824
 226 002a 013B     		subs	r3, r3, #1
 227 002c 9B00     		lsls	r3, r3, #2
 228 002e 1344     		add	r3, r3, r2
 229 0030 3B61     		str	r3, [r7, #16]
 808:..\Source/tasks.c **** 		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTE
 230              		.loc 1 808 0
 231 0032 3B69     		ldr	r3, [r7, #16]
 232 0034 23F00703 		bic	r3, r3, #7
 233 0038 3B61     		str	r3, [r7, #16]
 809:..\Source/tasks.c **** 
 810:..\Source/tasks.c **** 		/* Check the alignment of the calculated top of stack is correct. */
 811:..\Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALI
 812:..\Source/tasks.c **** 	}
 813:..\Source/tasks.c **** 	#else /* portSTACK_GROWTH */
 814:..\Source/tasks.c **** 	{
 815:..\Source/tasks.c **** 		pxTopOfStack = pxNewTCB->pxStack;
 816:..\Source/tasks.c **** 
 817:..\Source/tasks.c **** 		/* Check the alignment of the stack buffer is correct. */
 818:..\Source/tasks.c **** 		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYT
 819:..\Source/tasks.c **** 
 820:..\Source/tasks.c **** 		/* The other extreme of the stack space is required if stack checking is
 821:..\Source/tasks.c **** 		performed. */
 822:..\Source/tasks.c **** 		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 823:..\Source/tasks.c **** 	}
 824:..\Source/tasks.c **** 	#endif /* portSTACK_GROWTH */
 825:..\Source/tasks.c **** 
 826:..\Source/tasks.c **** 	/* Store the task name in the TCB. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 20


 827:..\Source/tasks.c **** 	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 234              		.loc 1 827 0
 235 003a 0023     		movs	r3, #0
 236 003c 7B61     		str	r3, [r7, #20]
 237 003e 13E0     		b	.L10
 238              	.L13:
 828:..\Source/tasks.c **** 	{
 829:..\Source/tasks.c **** 		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 239              		.loc 1 829 0
 240 0040 BA68     		ldr	r2, [r7, #8]
 241 0042 7B69     		ldr	r3, [r7, #20]
 242 0044 1344     		add	r3, r3, r2
 243 0046 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 244 0048 BA6A     		ldr	r2, [r7, #40]
 245 004a 7B69     		ldr	r3, [r7, #20]
 246 004c 1344     		add	r3, r3, r2
 247 004e 3033     		adds	r3, r3, #48
 248 0050 0A46     		mov	r2, r1
 249 0052 1A71     		strb	r2, [r3, #4]
 830:..\Source/tasks.c **** 
 831:..\Source/tasks.c **** 		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 832:..\Source/tasks.c **** 		configMAX_TASK_NAME_LEN characters just in case the memory after the
 833:..\Source/tasks.c **** 		string is not accessible (extremely unlikely). */
 834:..\Source/tasks.c **** 		if( pcName[ x ] == 0x00 )
 250              		.loc 1 834 0
 251 0054 BA68     		ldr	r2, [r7, #8]
 252 0056 7B69     		ldr	r3, [r7, #20]
 253 0058 1344     		add	r3, r3, r2
 254 005a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 255 005c 002B     		cmp	r3, #0
 256 005e 00D1     		bne	.L11
 835:..\Source/tasks.c **** 		{
 836:..\Source/tasks.c **** 			break;
 257              		.loc 1 836 0
 258 0060 05E0     		b	.L12
 259              	.L11:
 827:..\Source/tasks.c **** 	{
 260              		.loc 1 827 0 discriminator 2
 261 0062 7B69     		ldr	r3, [r7, #20]
 262 0064 0133     		adds	r3, r3, #1
 263 0066 7B61     		str	r3, [r7, #20]
 264              	.L10:
 827:..\Source/tasks.c **** 	{
 265              		.loc 1 827 0 is_stmt 0 discriminator 1
 266 0068 7B69     		ldr	r3, [r7, #20]
 267 006a 0B2B     		cmp	r3, #11
 268 006c E8D9     		bls	.L13
 269              	.L12:
 837:..\Source/tasks.c **** 		}
 838:..\Source/tasks.c **** 		else
 839:..\Source/tasks.c **** 		{
 840:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
 841:..\Source/tasks.c **** 		}
 842:..\Source/tasks.c **** 	}
 843:..\Source/tasks.c **** 
 844:..\Source/tasks.c **** 	/* Ensure the name string is terminated in the case that the string length
 845:..\Source/tasks.c **** 	was greater or equal to configMAX_TASK_NAME_LEN. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 21


 846:..\Source/tasks.c **** 	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 270              		.loc 1 846 0 is_stmt 1
 271 006e BB6A     		ldr	r3, [r7, #40]
 272 0070 0022     		movs	r2, #0
 273 0072 83F83F20 		strb	r2, [r3, #63]
 847:..\Source/tasks.c **** 
 848:..\Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
 849:..\Source/tasks.c **** 	remove the privilege bit if one is present. */
 850:..\Source/tasks.c **** 	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 274              		.loc 1 850 0
 275 0076 3B6A     		ldr	r3, [r7, #32]
 276 0078 042B     		cmp	r3, #4
 277 007a 01D9     		bls	.L14
 851:..\Source/tasks.c **** 	{
 852:..\Source/tasks.c **** 		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 278              		.loc 1 852 0
 279 007c 0423     		movs	r3, #4
 280 007e 3B62     		str	r3, [r7, #32]
 281              	.L14:
 853:..\Source/tasks.c **** 	}
 854:..\Source/tasks.c **** 	else
 855:..\Source/tasks.c **** 	{
 856:..\Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 857:..\Source/tasks.c **** 	}
 858:..\Source/tasks.c **** 
 859:..\Source/tasks.c **** 	pxNewTCB->uxPriority = uxPriority;
 282              		.loc 1 859 0
 283 0080 BB6A     		ldr	r3, [r7, #40]
 284 0082 3A6A     		ldr	r2, [r7, #32]
 285 0084 DA62     		str	r2, [r3, #44]
 860:..\Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 861:..\Source/tasks.c **** 	{
 862:..\Source/tasks.c **** 		pxNewTCB->uxBasePriority = uxPriority;
 286              		.loc 1 862 0
 287 0086 BB6A     		ldr	r3, [r7, #40]
 288 0088 3A6A     		ldr	r2, [r7, #32]
 289 008a 1A64     		str	r2, [r3, #64]
 863:..\Source/tasks.c **** 		pxNewTCB->uxMutexesHeld = 0;
 290              		.loc 1 863 0
 291 008c BB6A     		ldr	r3, [r7, #40]
 292 008e 0022     		movs	r2, #0
 293 0090 5A64     		str	r2, [r3, #68]
 864:..\Source/tasks.c **** 	}
 865:..\Source/tasks.c **** 	#endif /* configUSE_MUTEXES */
 866:..\Source/tasks.c **** 
 867:..\Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 294              		.loc 1 867 0
 295 0092 BB6A     		ldr	r3, [r7, #40]
 296 0094 0433     		adds	r3, r3, #4
 297 0096 1846     		mov	r0, r3
 298 0098 FFF7FEFF 		bl	vListInitialiseItem
 868:..\Source/tasks.c **** 	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 299              		.loc 1 868 0
 300 009c BB6A     		ldr	r3, [r7, #40]
 301 009e 1833     		adds	r3, r3, #24
 302 00a0 1846     		mov	r0, r3
 303 00a2 FFF7FEFF 		bl	vListInitialiseItem
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 22


 869:..\Source/tasks.c **** 
 870:..\Source/tasks.c **** 	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 871:..\Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
 872:..\Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 304              		.loc 1 872 0
 305 00a6 BB6A     		ldr	r3, [r7, #40]
 306 00a8 BA6A     		ldr	r2, [r7, #40]
 307 00aa 1A61     		str	r2, [r3, #16]
 873:..\Source/tasks.c **** 
 874:..\Source/tasks.c **** 	/* Event lists are always in priority order. */
 875:..\Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( Ti
 308              		.loc 1 875 0
 309 00ac 3B6A     		ldr	r3, [r7, #32]
 310 00ae C3F10502 		rsb	r2, r3, #5
 311 00b2 BB6A     		ldr	r3, [r7, #40]
 312 00b4 9A61     		str	r2, [r3, #24]
 876:..\Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 313              		.loc 1 876 0
 314 00b6 BB6A     		ldr	r3, [r7, #40]
 315 00b8 BA6A     		ldr	r2, [r7, #40]
 316 00ba 5A62     		str	r2, [r3, #36]
 877:..\Source/tasks.c **** 
 878:..\Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 879:..\Source/tasks.c **** 	{
 880:..\Source/tasks.c **** 		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 881:..\Source/tasks.c **** 	}
 882:..\Source/tasks.c **** 	#endif /* portCRITICAL_NESTING_IN_TCB */
 883:..\Source/tasks.c **** 
 884:..\Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 885:..\Source/tasks.c **** 	{
 886:..\Source/tasks.c **** 		pxNewTCB->pxTaskTag = NULL;
 887:..\Source/tasks.c **** 	}
 888:..\Source/tasks.c **** 	#endif /* configUSE_APPLICATION_TASK_TAG */
 889:..\Source/tasks.c **** 
 890:..\Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 891:..\Source/tasks.c **** 	{
 892:..\Source/tasks.c **** 		pxNewTCB->ulRunTimeCounter = 0UL;
 893:..\Source/tasks.c **** 	}
 894:..\Source/tasks.c **** 	#endif /* configGENERATE_RUN_TIME_STATS */
 895:..\Source/tasks.c **** 
 896:..\Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
 897:..\Source/tasks.c **** 	{
 898:..\Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth
 899:..\Source/tasks.c **** 	}
 900:..\Source/tasks.c **** 	#else
 901:..\Source/tasks.c **** 	{
 902:..\Source/tasks.c **** 		/* Avoid compiler warning about unreferenced parameter. */
 903:..\Source/tasks.c **** 		( void ) xRegions;
 904:..\Source/tasks.c **** 	}
 905:..\Source/tasks.c **** 	#endif
 906:..\Source/tasks.c **** 
 907:..\Source/tasks.c **** 	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
 908:..\Source/tasks.c **** 	{
 909:..\Source/tasks.c **** 		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 910:..\Source/tasks.c **** 		{
 911:..\Source/tasks.c **** 			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 912:..\Source/tasks.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 23


 913:..\Source/tasks.c **** 	}
 914:..\Source/tasks.c **** 	#endif
 915:..\Source/tasks.c **** 
 916:..\Source/tasks.c **** 	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
 917:..\Source/tasks.c **** 	{
 918:..\Source/tasks.c **** 		pxNewTCB->ulNotifiedValue = 0;
 317              		.loc 1 918 0
 318 00bc BB6A     		ldr	r3, [r7, #40]
 319 00be 0022     		movs	r2, #0
 320 00c0 9A64     		str	r2, [r3, #72]
 919:..\Source/tasks.c **** 		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 321              		.loc 1 919 0
 322 00c2 BB6A     		ldr	r3, [r7, #40]
 323 00c4 0022     		movs	r2, #0
 324 00c6 83F84C20 		strb	r2, [r3, #76]
 920:..\Source/tasks.c **** 	}
 921:..\Source/tasks.c **** 	#endif
 922:..\Source/tasks.c **** 
 923:..\Source/tasks.c **** 	#if ( configUSE_NEWLIB_REENTRANT == 1 )
 924:..\Source/tasks.c **** 	{
 925:..\Source/tasks.c **** 		/* Initialise this task's Newlib reent structure. */
 926:..\Source/tasks.c **** 		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 927:..\Source/tasks.c **** 	}
 928:..\Source/tasks.c **** 	#endif
 929:..\Source/tasks.c **** 
 930:..\Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
 931:..\Source/tasks.c **** 	{
 932:..\Source/tasks.c **** 		pxNewTCB->ucDelayAborted = pdFALSE;
 933:..\Source/tasks.c **** 	}
 934:..\Source/tasks.c **** 	#endif
 935:..\Source/tasks.c **** 
 936:..\Source/tasks.c **** 	/* Initialize the TCB stack to look as if the task was already running,
 937:..\Source/tasks.c **** 	but had been interrupted by the scheduler.  The return address is set
 938:..\Source/tasks.c **** 	to the start of the task function. Once the stack has been initialised
 939:..\Source/tasks.c **** 	the	top of stack variable is updated. */
 940:..\Source/tasks.c **** 	#if( portUSING_MPU_WRAPPERS == 1 )
 941:..\Source/tasks.c **** 	{
 942:..\Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivi
 943:..\Source/tasks.c **** 	}
 944:..\Source/tasks.c **** 	#else /* portUSING_MPU_WRAPPERS */
 945:..\Source/tasks.c **** 	{
 946:..\Source/tasks.c **** 		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 325              		.loc 1 946 0
 326 00ca 3869     		ldr	r0, [r7, #16]
 327 00cc F968     		ldr	r1, [r7, #12]
 328 00ce 3A68     		ldr	r2, [r7]
 329 00d0 FFF7FEFF 		bl	pxPortInitialiseStack
 330 00d4 0246     		mov	r2, r0
 331 00d6 BB6A     		ldr	r3, [r7, #40]
 332 00d8 1A60     		str	r2, [r3]
 947:..\Source/tasks.c **** 	}
 948:..\Source/tasks.c **** 	#endif /* portUSING_MPU_WRAPPERS */
 949:..\Source/tasks.c **** 
 950:..\Source/tasks.c **** 	if( ( void * ) pxCreatedTask != NULL )
 333              		.loc 1 950 0
 334 00da 7B6A     		ldr	r3, [r7, #36]
 335 00dc 002B     		cmp	r3, #0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 24


 336 00de 02D0     		beq	.L9
 951:..\Source/tasks.c **** 	{
 952:..\Source/tasks.c **** 		/* Pass the handle out in an anonymous way.  The handle can be used to
 953:..\Source/tasks.c **** 		change the created task's priority, delete the created task, etc.*/
 954:..\Source/tasks.c **** 		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 337              		.loc 1 954 0
 338 00e0 7B6A     		ldr	r3, [r7, #36]
 339 00e2 BA6A     		ldr	r2, [r7, #40]
 340 00e4 1A60     		str	r2, [r3]
 341              	.L9:
 955:..\Source/tasks.c **** 	}
 956:..\Source/tasks.c **** 	else
 957:..\Source/tasks.c **** 	{
 958:..\Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
 959:..\Source/tasks.c **** 	}
 960:..\Source/tasks.c **** }
 342              		.loc 1 960 0
 343 00e6 1837     		adds	r7, r7, #24
 344              		.cfi_def_cfa_offset 8
 345 00e8 BD46     		mov	sp, r7
 346              		.cfi_def_cfa_register 13
 347              		@ sp needed
 348 00ea 80BD     		pop	{r7, pc}
 349              		.cfi_endproc
 350              	.LFE69:
 351              		.size	prvInitialiseNewTask, .-prvInitialiseNewTask
 352              		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 353              		.align	2
 354              		.thumb
 355              		.thumb_func
 356              		.type	prvAddNewTaskToReadyList, %function
 357              	prvAddNewTaskToReadyList:
 358              	.LFB70:
 961:..\Source/tasks.c **** /*-----------------------------------------------------------*/
 962:..\Source/tasks.c **** 
 963:..\Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
 964:..\Source/tasks.c **** {
 359              		.loc 1 964 0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 8
 362              		@ frame_needed = 1, uses_anonymous_args = 0
 363 0000 80B5     		push	{r7, lr}
 364              		.cfi_def_cfa_offset 8
 365              		.cfi_offset 7, -8
 366              		.cfi_offset 14, -4
 367 0002 82B0     		sub	sp, sp, #8
 368              		.cfi_def_cfa_offset 16
 369 0004 00AF     		add	r7, sp, #0
 370              		.cfi_def_cfa_register 7
 371 0006 7860     		str	r0, [r7, #4]
 965:..\Source/tasks.c **** 	/* Ensure interrupts don't access the task lists while the lists are being
 966:..\Source/tasks.c **** 	updated. */
 967:..\Source/tasks.c **** 	taskENTER_CRITICAL();
 372              		.loc 1 967 0
 373 0008 FFF7FEFF 		bl	vPortEnterCritical
 968:..\Source/tasks.c **** 	{
 969:..\Source/tasks.c **** 		uxCurrentNumberOfTasks++;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 25


 374              		.loc 1 969 0
 375 000c 2B4B     		ldr	r3, .L20
 376 000e 1B68     		ldr	r3, [r3]
 377 0010 0133     		adds	r3, r3, #1
 378 0012 2A4A     		ldr	r2, .L20
 379 0014 1360     		str	r3, [r2]
 970:..\Source/tasks.c **** 		if( pxCurrentTCB == NULL )
 380              		.loc 1 970 0
 381 0016 2A4B     		ldr	r3, .L20+4
 382 0018 1B68     		ldr	r3, [r3]
 383 001a 002B     		cmp	r3, #0
 384 001c 09D1     		bne	.L17
 971:..\Source/tasks.c **** 		{
 972:..\Source/tasks.c **** 			/* There are no other tasks, or all the other tasks are in
 973:..\Source/tasks.c **** 			the suspended state - make this the current task. */
 974:..\Source/tasks.c **** 			pxCurrentTCB = pxNewTCB;
 385              		.loc 1 974 0
 386 001e 284A     		ldr	r2, .L20+4
 387 0020 7B68     		ldr	r3, [r7, #4]
 388 0022 1360     		str	r3, [r2]
 975:..\Source/tasks.c **** 
 976:..\Source/tasks.c **** 			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 389              		.loc 1 976 0
 390 0024 254B     		ldr	r3, .L20
 391 0026 1B68     		ldr	r3, [r3]
 392 0028 012B     		cmp	r3, #1
 393 002a 10D1     		bne	.L18
 977:..\Source/tasks.c **** 			{
 978:..\Source/tasks.c **** 				/* This is the first task to be created so do the preliminary
 979:..\Source/tasks.c **** 				initialisation required.  We will not recover if this call
 980:..\Source/tasks.c **** 				fails, but we will report the failure. */
 981:..\Source/tasks.c **** 				prvInitialiseTaskLists();
 394              		.loc 1 981 0
 395 002c FFF7FEFF 		bl	prvInitialiseTaskLists
 396 0030 0DE0     		b	.L18
 397              	.L17:
 982:..\Source/tasks.c **** 			}
 983:..\Source/tasks.c **** 			else
 984:..\Source/tasks.c **** 			{
 985:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
 986:..\Source/tasks.c **** 			}
 987:..\Source/tasks.c **** 		}
 988:..\Source/tasks.c **** 		else
 989:..\Source/tasks.c **** 		{
 990:..\Source/tasks.c **** 			/* If the scheduler is not already running, make this task the
 991:..\Source/tasks.c **** 			current task if it is the highest priority task to be created
 992:..\Source/tasks.c **** 			so far. */
 993:..\Source/tasks.c **** 			if( xSchedulerRunning == pdFALSE )
 398              		.loc 1 993 0
 399 0032 244B     		ldr	r3, .L20+8
 400 0034 1B68     		ldr	r3, [r3]
 401 0036 002B     		cmp	r3, #0
 402 0038 09D1     		bne	.L18
 994:..\Source/tasks.c **** 			{
 995:..\Source/tasks.c **** 				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 403              		.loc 1 995 0
 404 003a 214B     		ldr	r3, .L20+4
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 26


 405 003c 1B68     		ldr	r3, [r3]
 406 003e DA6A     		ldr	r2, [r3, #44]
 407 0040 7B68     		ldr	r3, [r7, #4]
 408 0042 DB6A     		ldr	r3, [r3, #44]
 409 0044 9A42     		cmp	r2, r3
 410 0046 02D8     		bhi	.L18
 996:..\Source/tasks.c **** 				{
 997:..\Source/tasks.c **** 					pxCurrentTCB = pxNewTCB;
 411              		.loc 1 997 0
 412 0048 1D4A     		ldr	r2, .L20+4
 413 004a 7B68     		ldr	r3, [r7, #4]
 414 004c 1360     		str	r3, [r2]
 415              	.L18:
 998:..\Source/tasks.c **** 				}
 999:..\Source/tasks.c **** 				else
1000:..\Source/tasks.c **** 				{
1001:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1002:..\Source/tasks.c **** 				}
1003:..\Source/tasks.c **** 			}
1004:..\Source/tasks.c **** 			else
1005:..\Source/tasks.c **** 			{
1006:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1007:..\Source/tasks.c **** 			}
1008:..\Source/tasks.c **** 		}
1009:..\Source/tasks.c **** 
1010:..\Source/tasks.c **** 		uxTaskNumber++;
 416              		.loc 1 1010 0
 417 004e 1E4B     		ldr	r3, .L20+12
 418 0050 1B68     		ldr	r3, [r3]
 419 0052 0133     		adds	r3, r3, #1
 420 0054 1C4A     		ldr	r2, .L20+12
 421 0056 1360     		str	r3, [r2]
1011:..\Source/tasks.c **** 
1012:..\Source/tasks.c **** 		#if ( configUSE_TRACE_FACILITY == 1 )
1013:..\Source/tasks.c **** 		{
1014:..\Source/tasks.c **** 			/* Add a counter into the TCB for tracing only. */
1015:..\Source/tasks.c **** 			pxNewTCB->uxTCBNumber = uxTaskNumber;
1016:..\Source/tasks.c **** 		}
1017:..\Source/tasks.c **** 		#endif /* configUSE_TRACE_FACILITY */
1018:..\Source/tasks.c **** 		traceTASK_CREATE( pxNewTCB );
1019:..\Source/tasks.c **** 
1020:..\Source/tasks.c **** 		prvAddTaskToReadyList( pxNewTCB );
 422              		.loc 1 1020 0
 423 0058 7B68     		ldr	r3, [r7, #4]
 424 005a DB6A     		ldr	r3, [r3, #44]
 425 005c 1A46     		mov	r2, r3
 426 005e 0123     		movs	r3, #1
 427 0060 03FA02F2 		lsl	r2, r3, r2
 428 0064 194B     		ldr	r3, .L20+16
 429 0066 1B68     		ldr	r3, [r3]
 430 0068 1343     		orrs	r3, r3, r2
 431 006a 184A     		ldr	r2, .L20+16
 432 006c 1360     		str	r3, [r2]
 433 006e 7B68     		ldr	r3, [r7, #4]
 434 0070 DA6A     		ldr	r2, [r3, #44]
 435 0072 1346     		mov	r3, r2
 436 0074 9B00     		lsls	r3, r3, #2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 27


 437 0076 1344     		add	r3, r3, r2
 438 0078 9B00     		lsls	r3, r3, #2
 439 007a 154A     		ldr	r2, .L20+20
 440 007c 1A44     		add	r2, r2, r3
 441 007e 7B68     		ldr	r3, [r7, #4]
 442 0080 0433     		adds	r3, r3, #4
 443 0082 1046     		mov	r0, r2
 444 0084 1946     		mov	r1, r3
 445 0086 FFF7FEFF 		bl	vListInsertEnd
1021:..\Source/tasks.c **** 
1022:..\Source/tasks.c **** 		portSETUP_TCB( pxNewTCB );
1023:..\Source/tasks.c **** 	}
1024:..\Source/tasks.c **** 	taskEXIT_CRITICAL();
 446              		.loc 1 1024 0
 447 008a FFF7FEFF 		bl	vPortExitCritical
1025:..\Source/tasks.c **** 
1026:..\Source/tasks.c **** 	if( xSchedulerRunning != pdFALSE )
 448              		.loc 1 1026 0
 449 008e 0D4B     		ldr	r3, .L20+8
 450 0090 1B68     		ldr	r3, [r3]
 451 0092 002B     		cmp	r3, #0
 452 0094 0ED0     		beq	.L16
1027:..\Source/tasks.c **** 	{
1028:..\Source/tasks.c **** 		/* If the created task is of a higher priority than the current task
1029:..\Source/tasks.c **** 		then it should run now. */
1030:..\Source/tasks.c **** 		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 453              		.loc 1 1030 0
 454 0096 0A4B     		ldr	r3, .L20+4
 455 0098 1B68     		ldr	r3, [r3]
 456 009a DA6A     		ldr	r2, [r3, #44]
 457 009c 7B68     		ldr	r3, [r7, #4]
 458 009e DB6A     		ldr	r3, [r3, #44]
 459 00a0 9A42     		cmp	r2, r3
 460 00a2 07D2     		bcs	.L16
1031:..\Source/tasks.c **** 		{
1032:..\Source/tasks.c **** 			taskYIELD_IF_USING_PREEMPTION();
 461              		.loc 1 1032 0
 462 00a4 0B4B     		ldr	r3, .L20+24
 463 00a6 4FF08052 		mov	r2, #268435456
 464 00aa 1A60     		str	r2, [r3]
 465              	@ 1032 "..\Source\tasks.c" 1
 466 00ac BFF34F8F 		dsb
 467              	@ 0 "" 2
 468              	@ 1032 "..\Source\tasks.c" 1
 469 00b0 BFF36F8F 		isb
 470              	@ 0 "" 2
 471              		.thumb
 472              	.L16:
1033:..\Source/tasks.c **** 		}
1034:..\Source/tasks.c **** 		else
1035:..\Source/tasks.c **** 		{
1036:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1037:..\Source/tasks.c **** 		}
1038:..\Source/tasks.c **** 	}
1039:..\Source/tasks.c **** 	else
1040:..\Source/tasks.c **** 	{
1041:..\Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 28


1042:..\Source/tasks.c **** 	}
1043:..\Source/tasks.c **** }
 473              		.loc 1 1043 0
 474 00b4 0837     		adds	r7, r7, #8
 475              		.cfi_def_cfa_offset 8
 476 00b6 BD46     		mov	sp, r7
 477              		.cfi_def_cfa_register 13
 478              		@ sp needed
 479 00b8 80BD     		pop	{r7, pc}
 480              	.L21:
 481 00ba 00BF     		.align	2
 482              	.L20:
 483 00bc D8000000 		.word	uxCurrentNumberOfTasks
 484 00c0 00000000 		.word	pxCurrentTCB
 485 00c4 E4000000 		.word	xSchedulerRunning
 486 00c8 F4000000 		.word	uxTaskNumber
 487 00cc E0000000 		.word	uxTopReadyPriority
 488 00d0 04000000 		.word	pxReadyTasksLists
 489 00d4 04ED00E0 		.word	-536810236
 490              		.cfi_endproc
 491              	.LFE70:
 492              		.size	prvAddNewTaskToReadyList, .-prvAddNewTaskToReadyList
 493              		.section	.text.vTaskDelete,"ax",%progbits
 494              		.align	2
 495              		.global	vTaskDelete
 496              		.thumb
 497              		.thumb_func
 498              		.type	vTaskDelete, %function
 499              	vTaskDelete:
 500              	.LFB71:
1044:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1045:..\Source/tasks.c **** 
1046:..\Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1047:..\Source/tasks.c **** 
1048:..\Source/tasks.c **** 	void vTaskDelete( TaskHandle_t xTaskToDelete )
1049:..\Source/tasks.c **** 	{
 501              		.loc 1 1049 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 16
 504              		@ frame_needed = 1, uses_anonymous_args = 0
 505 0000 80B5     		push	{r7, lr}
 506              		.cfi_def_cfa_offset 8
 507              		.cfi_offset 7, -8
 508              		.cfi_offset 14, -4
 509 0002 84B0     		sub	sp, sp, #16
 510              		.cfi_def_cfa_offset 24
 511 0004 00AF     		add	r7, sp, #0
 512              		.cfi_def_cfa_register 7
 513 0006 7860     		str	r0, [r7, #4]
1050:..\Source/tasks.c **** 	TCB_t *pxTCB;
1051:..\Source/tasks.c **** 
1052:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 514              		.loc 1 1052 0
 515 0008 FFF7FEFF 		bl	vPortEnterCritical
1053:..\Source/tasks.c **** 		{
1054:..\Source/tasks.c **** 			/* If null is passed in here then it is the calling task that is
1055:..\Source/tasks.c **** 			being deleted. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 29


1056:..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 516              		.loc 1 1056 0
 517 000c 7B68     		ldr	r3, [r7, #4]
 518 000e 002B     		cmp	r3, #0
 519 0010 02D1     		bne	.L23
 520              		.loc 1 1056 0 is_stmt 0 discriminator 1
 521 0012 314B     		ldr	r3, .L31
 522 0014 1B68     		ldr	r3, [r3]
 523 0016 00E0     		b	.L24
 524              	.L23:
 525              		.loc 1 1056 0 discriminator 2
 526 0018 7B68     		ldr	r3, [r7, #4]
 527              	.L24:
 528              		.loc 1 1056 0 discriminator 4
 529 001a FB60     		str	r3, [r7, #12]
1057:..\Source/tasks.c **** 
1058:..\Source/tasks.c **** 			/* Remove task from the ready list. */
1059:..\Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 530              		.loc 1 1059 0 is_stmt 1 discriminator 4
 531 001c FB68     		ldr	r3, [r7, #12]
 532 001e 0433     		adds	r3, r3, #4
 533 0020 1846     		mov	r0, r3
 534 0022 FFF7FEFF 		bl	uxListRemove
 535 0026 0346     		mov	r3, r0
 536 0028 002B     		cmp	r3, #0
 537 002a 15D1     		bne	.L25
1060:..\Source/tasks.c **** 			{
1061:..\Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 538              		.loc 1 1061 0
 539 002c FB68     		ldr	r3, [r7, #12]
 540 002e DA6A     		ldr	r2, [r3, #44]
 541 0030 2A49     		ldr	r1, .L31+4
 542 0032 1346     		mov	r3, r2
 543 0034 9B00     		lsls	r3, r3, #2
 544 0036 1344     		add	r3, r3, r2
 545 0038 9B00     		lsls	r3, r3, #2
 546 003a 0B44     		add	r3, r3, r1
 547 003c 1B68     		ldr	r3, [r3]
 548 003e 002B     		cmp	r3, #0
 549 0040 0AD1     		bne	.L25
 550              		.loc 1 1061 0 is_stmt 0 discriminator 1
 551 0042 FB68     		ldr	r3, [r7, #12]
 552 0044 DB6A     		ldr	r3, [r3, #44]
 553 0046 1A46     		mov	r2, r3
 554 0048 0123     		movs	r3, #1
 555 004a 9340     		lsls	r3, r3, r2
 556 004c DA43     		mvns	r2, r3
 557 004e 244B     		ldr	r3, .L31+8
 558 0050 1B68     		ldr	r3, [r3]
 559 0052 1340     		ands	r3, r3, r2
 560 0054 224A     		ldr	r2, .L31+8
 561 0056 1360     		str	r3, [r2]
 562              	.L25:
1062:..\Source/tasks.c **** 			}
1063:..\Source/tasks.c **** 			else
1064:..\Source/tasks.c **** 			{
1065:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 30


1066:..\Source/tasks.c **** 			}
1067:..\Source/tasks.c **** 
1068:..\Source/tasks.c **** 			/* Is the task waiting on an event also? */
1069:..\Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 563              		.loc 1 1069 0 is_stmt 1
 564 0058 FB68     		ldr	r3, [r7, #12]
 565 005a 9B6A     		ldr	r3, [r3, #40]
 566 005c 002B     		cmp	r3, #0
 567 005e 04D0     		beq	.L27
1070:..\Source/tasks.c **** 			{
1071:..\Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 568              		.loc 1 1071 0
 569 0060 FB68     		ldr	r3, [r7, #12]
 570 0062 1833     		adds	r3, r3, #24
 571 0064 1846     		mov	r0, r3
 572 0066 FFF7FEFF 		bl	uxListRemove
 573              	.L27:
1072:..\Source/tasks.c **** 			}
1073:..\Source/tasks.c **** 			else
1074:..\Source/tasks.c **** 			{
1075:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1076:..\Source/tasks.c **** 			}
1077:..\Source/tasks.c **** 
1078:..\Source/tasks.c **** 			/* Increment the uxTaskNumber also so kernel aware debuggers can
1079:..\Source/tasks.c **** 			detect that the task lists need re-generating.  This is done before
1080:..\Source/tasks.c **** 			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1081:..\Source/tasks.c **** 			not return. */
1082:..\Source/tasks.c **** 			uxTaskNumber++;
 574              		.loc 1 1082 0
 575 006a 1E4B     		ldr	r3, .L31+12
 576 006c 1B68     		ldr	r3, [r3]
 577 006e 0133     		adds	r3, r3, #1
 578 0070 1C4A     		ldr	r2, .L31+12
 579 0072 1360     		str	r3, [r2]
1083:..\Source/tasks.c **** 
1084:..\Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
 580              		.loc 1 1084 0
 581 0074 184B     		ldr	r3, .L31
 582 0076 1B68     		ldr	r3, [r3]
 583 0078 FA68     		ldr	r2, [r7, #12]
 584 007a 9A42     		cmp	r2, r3
 585 007c 0BD1     		bne	.L28
1085:..\Source/tasks.c **** 			{
1086:..\Source/tasks.c **** 				/* A task is deleting itself.  This cannot complete within the
1087:..\Source/tasks.c **** 				task itself, as a context switch to another task is required.
1088:..\Source/tasks.c **** 				Place the task in the termination list.  The idle task will
1089:..\Source/tasks.c **** 				check the termination list and free up any memory allocated by
1090:..\Source/tasks.c **** 				the scheduler for the TCB and stack of the deleted task. */
1091:..\Source/tasks.c **** 				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 586              		.loc 1 1091 0
 587 007e FB68     		ldr	r3, [r7, #12]
 588 0080 0433     		adds	r3, r3, #4
 589 0082 1948     		ldr	r0, .L31+16
 590 0084 1946     		mov	r1, r3
 591 0086 FFF7FEFF 		bl	vListInsertEnd
1092:..\Source/tasks.c **** 
1093:..\Source/tasks.c **** 				/* Increment the ucTasksDeleted variable so the idle task knows
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 31


1094:..\Source/tasks.c **** 				there is a task that has been deleted and that it should therefore
1095:..\Source/tasks.c **** 				check the xTasksWaitingTermination list. */
1096:..\Source/tasks.c **** 				++uxDeletedTasksWaitingCleanUp;
 592              		.loc 1 1096 0
 593 008a 184B     		ldr	r3, .L31+20
 594 008c 1B68     		ldr	r3, [r3]
 595 008e 0133     		adds	r3, r3, #1
 596 0090 164A     		ldr	r2, .L31+20
 597 0092 1360     		str	r3, [r2]
 598 0094 09E0     		b	.L29
 599              	.L28:
1097:..\Source/tasks.c **** 
1098:..\Source/tasks.c **** 				/* The pre-delete hook is primarily for the Windows simulator,
1099:..\Source/tasks.c **** 				in which Windows specific clean up operations are performed,
1100:..\Source/tasks.c **** 				after which it is not possible to yield away from this task -
1101:..\Source/tasks.c **** 				hence xYieldPending is used to latch that a context switch is
1102:..\Source/tasks.c **** 				required. */
1103:..\Source/tasks.c **** 				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1104:..\Source/tasks.c **** 			}
1105:..\Source/tasks.c **** 			else
1106:..\Source/tasks.c **** 			{
1107:..\Source/tasks.c **** 				--uxCurrentNumberOfTasks;
 600              		.loc 1 1107 0
 601 0096 164B     		ldr	r3, .L31+24
 602 0098 1B68     		ldr	r3, [r3]
 603 009a 013B     		subs	r3, r3, #1
 604 009c 144A     		ldr	r2, .L31+24
 605 009e 1360     		str	r3, [r2]
1108:..\Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 606              		.loc 1 1108 0
 607 00a0 F868     		ldr	r0, [r7, #12]
 608 00a2 FFF7FEFF 		bl	prvDeleteTCB
1109:..\Source/tasks.c **** 
1110:..\Source/tasks.c **** 				/* Reset the next expected unblock time in case it referred to
1111:..\Source/tasks.c **** 				the task that has just been deleted. */
1112:..\Source/tasks.c **** 				prvResetNextTaskUnblockTime();
 609              		.loc 1 1112 0
 610 00a6 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 611              	.L29:
1113:..\Source/tasks.c **** 			}
1114:..\Source/tasks.c **** 
1115:..\Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
1116:..\Source/tasks.c **** 		}
1117:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 612              		.loc 1 1117 0
 613 00aa FFF7FEFF 		bl	vPortExitCritical
1118:..\Source/tasks.c **** 
1119:..\Source/tasks.c **** 		/* Force a reschedule if it is the currently running task that has just
1120:..\Source/tasks.c **** 		been deleted. */
1121:..\Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 614              		.loc 1 1121 0
 615 00ae 114B     		ldr	r3, .L31+28
 616 00b0 1B68     		ldr	r3, [r3]
 617 00b2 002B     		cmp	r3, #0
 618 00b4 0CD0     		beq	.L22
1122:..\Source/tasks.c **** 		{
1123:..\Source/tasks.c **** 			if( pxTCB == pxCurrentTCB )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 32


 619              		.loc 1 1123 0
 620 00b6 084B     		ldr	r3, .L31
 621 00b8 1B68     		ldr	r3, [r3]
 622 00ba FA68     		ldr	r2, [r7, #12]
 623 00bc 9A42     		cmp	r2, r3
 624 00be 07D1     		bne	.L22
1124:..\Source/tasks.c **** 			{
1125:..\Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1126:..\Source/tasks.c **** 				portYIELD_WITHIN_API();
 625              		.loc 1 1126 0
 626 00c0 0D4B     		ldr	r3, .L31+32
 627 00c2 4FF08052 		mov	r2, #268435456
 628 00c6 1A60     		str	r2, [r3]
 629              	@ 1126 "..\Source\tasks.c" 1
 630 00c8 BFF34F8F 		dsb
 631              	@ 0 "" 2
 632              	@ 1126 "..\Source\tasks.c" 1
 633 00cc BFF36F8F 		isb
 634              	@ 0 "" 2
 635              		.thumb
 636              	.L22:
1127:..\Source/tasks.c **** 			}
1128:..\Source/tasks.c **** 			else
1129:..\Source/tasks.c **** 			{
1130:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1131:..\Source/tasks.c **** 			}
1132:..\Source/tasks.c **** 		}
1133:..\Source/tasks.c **** 	}
 637              		.loc 1 1133 0
 638 00d0 1037     		adds	r7, r7, #16
 639              		.cfi_def_cfa_offset 8
 640 00d2 BD46     		mov	sp, r7
 641              		.cfi_def_cfa_register 13
 642              		@ sp needed
 643 00d4 80BD     		pop	{r7, pc}
 644              	.L32:
 645 00d6 00BF     		.align	2
 646              	.L31:
 647 00d8 00000000 		.word	pxCurrentTCB
 648 00dc 04000000 		.word	pxReadyTasksLists
 649 00e0 E0000000 		.word	uxTopReadyPriority
 650 00e4 F4000000 		.word	uxTaskNumber
 651 00e8 AC000000 		.word	xTasksWaitingTermination
 652 00ec C0000000 		.word	uxDeletedTasksWaitingCleanUp
 653 00f0 D8000000 		.word	uxCurrentNumberOfTasks
 654 00f4 E4000000 		.word	xSchedulerRunning
 655 00f8 04ED00E0 		.word	-536810236
 656              		.cfi_endproc
 657              	.LFE71:
 658              		.size	vTaskDelete, .-vTaskDelete
 659              		.section	.text.vTaskDelayUntil,"ax",%progbits
 660              		.align	2
 661              		.global	vTaskDelayUntil
 662              		.thumb
 663              		.thumb_func
 664              		.type	vTaskDelayUntil, %function
 665              	vTaskDelayUntil:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 33


 666              	.LFB72:
1134:..\Source/tasks.c **** 
1135:..\Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1136:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1137:..\Source/tasks.c **** 
1138:..\Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
1139:..\Source/tasks.c **** 
1140:..\Source/tasks.c **** 	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
1141:..\Source/tasks.c **** 	{
 667              		.loc 1 1141 0
 668              		.cfi_startproc
 669              		@ args = 0, pretend = 0, frame = 24
 670              		@ frame_needed = 1, uses_anonymous_args = 0
 671 0000 80B5     		push	{r7, lr}
 672              		.cfi_def_cfa_offset 8
 673              		.cfi_offset 7, -8
 674              		.cfi_offset 14, -4
 675 0002 86B0     		sub	sp, sp, #24
 676              		.cfi_def_cfa_offset 32
 677 0004 00AF     		add	r7, sp, #0
 678              		.cfi_def_cfa_register 7
 679 0006 7860     		str	r0, [r7, #4]
 680 0008 3960     		str	r1, [r7]
1142:..\Source/tasks.c **** 	TickType_t xTimeToWake;
1143:..\Source/tasks.c **** 	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 681              		.loc 1 1143 0
 682 000a 0023     		movs	r3, #0
 683 000c 7B61     		str	r3, [r7, #20]
1144:..\Source/tasks.c **** 
1145:..\Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
1146:..\Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
1147:..\Source/tasks.c **** 		configASSERT( uxSchedulerSuspended == 0 );
1148:..\Source/tasks.c **** 
1149:..\Source/tasks.c **** 		vTaskSuspendAll();
 684              		.loc 1 1149 0
 685 000e FFF7FEFF 		bl	vTaskSuspendAll
 686              	.LBB28:
1150:..\Source/tasks.c **** 		{
1151:..\Source/tasks.c **** 			/* Minor optimisation.  The tick count cannot change in this
1152:..\Source/tasks.c **** 			block. */
1153:..\Source/tasks.c **** 			const TickType_t xConstTickCount = xTickCount;
 687              		.loc 1 1153 0
 688 0012 214B     		ldr	r3, .L39
 689 0014 1B68     		ldr	r3, [r3]
 690 0016 3B61     		str	r3, [r7, #16]
1154:..\Source/tasks.c **** 
1155:..\Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
1156:..\Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 691              		.loc 1 1156 0
 692 0018 7B68     		ldr	r3, [r7, #4]
 693 001a 1A68     		ldr	r2, [r3]
 694 001c 3B68     		ldr	r3, [r7]
 695 001e 1344     		add	r3, r3, r2
 696 0020 FB60     		str	r3, [r7, #12]
1157:..\Source/tasks.c **** 
1158:..\Source/tasks.c **** 			if( xConstTickCount < *pxPreviousWakeTime )
 697              		.loc 1 1158 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 34


 698 0022 7B68     		ldr	r3, [r7, #4]
 699 0024 1A68     		ldr	r2, [r3]
 700 0026 3B69     		ldr	r3, [r7, #16]
 701 0028 9A42     		cmp	r2, r3
 702 002a 0BD9     		bls	.L34
1159:..\Source/tasks.c **** 			{
1160:..\Source/tasks.c **** 				/* The tick count has overflowed since this function was
1161:..\Source/tasks.c **** 				lasted called.  In this case the only time we should ever
1162:..\Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
1163:..\Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
1164:..\Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
1165:..\Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 703              		.loc 1 1165 0
 704 002c 7B68     		ldr	r3, [r7, #4]
 705 002e 1A68     		ldr	r2, [r3]
 706 0030 FB68     		ldr	r3, [r7, #12]
 707 0032 9A42     		cmp	r2, r3
 708 0034 11D9     		bls	.L35
 709              		.loc 1 1165 0 is_stmt 0 discriminator 1
 710 0036 FA68     		ldr	r2, [r7, #12]
 711 0038 3B69     		ldr	r3, [r7, #16]
 712 003a 9A42     		cmp	r2, r3
 713 003c 0DD9     		bls	.L35
1166:..\Source/tasks.c **** 				{
1167:..\Source/tasks.c **** 					xShouldDelay = pdTRUE;
 714              		.loc 1 1167 0 is_stmt 1
 715 003e 0123     		movs	r3, #1
 716 0040 7B61     		str	r3, [r7, #20]
 717 0042 0AE0     		b	.L35
 718              	.L34:
1168:..\Source/tasks.c **** 				}
1169:..\Source/tasks.c **** 				else
1170:..\Source/tasks.c **** 				{
1171:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1172:..\Source/tasks.c **** 				}
1173:..\Source/tasks.c **** 			}
1174:..\Source/tasks.c **** 			else
1175:..\Source/tasks.c **** 			{
1176:..\Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
1177:..\Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
1178:..\Source/tasks.c **** 				tick time is less than the wake time. */
1179:..\Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 719              		.loc 1 1179 0
 720 0044 7B68     		ldr	r3, [r7, #4]
 721 0046 1A68     		ldr	r2, [r3]
 722 0048 FB68     		ldr	r3, [r7, #12]
 723 004a 9A42     		cmp	r2, r3
 724 004c 03D8     		bhi	.L36
 725              		.loc 1 1179 0 is_stmt 0 discriminator 1
 726 004e FA68     		ldr	r2, [r7, #12]
 727 0050 3B69     		ldr	r3, [r7, #16]
 728 0052 9A42     		cmp	r2, r3
 729 0054 01D9     		bls	.L35
 730              	.L36:
1180:..\Source/tasks.c **** 				{
1181:..\Source/tasks.c **** 					xShouldDelay = pdTRUE;
 731              		.loc 1 1181 0 is_stmt 1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 35


 732 0056 0123     		movs	r3, #1
 733 0058 7B61     		str	r3, [r7, #20]
 734              	.L35:
1182:..\Source/tasks.c **** 				}
1183:..\Source/tasks.c **** 				else
1184:..\Source/tasks.c **** 				{
1185:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1186:..\Source/tasks.c **** 				}
1187:..\Source/tasks.c **** 			}
1188:..\Source/tasks.c **** 
1189:..\Source/tasks.c **** 			/* Update the wake time ready for the next call. */
1190:..\Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 735              		.loc 1 1190 0
 736 005a 7B68     		ldr	r3, [r7, #4]
 737 005c FA68     		ldr	r2, [r7, #12]
 738 005e 1A60     		str	r2, [r3]
1191:..\Source/tasks.c **** 
1192:..\Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 739              		.loc 1 1192 0
 740 0060 7B69     		ldr	r3, [r7, #20]
 741 0062 002B     		cmp	r3, #0
 742 0064 06D0     		beq	.L37
1193:..\Source/tasks.c **** 			{
1194:..\Source/tasks.c **** 				traceTASK_DELAY_UNTIL( xTimeToWake );
1195:..\Source/tasks.c **** 
1196:..\Source/tasks.c **** 				/* prvAddCurrentTaskToDelayedList() needs the block time, not
1197:..\Source/tasks.c **** 				the time to wake, so subtract the current tick count. */
1198:..\Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 743              		.loc 1 1198 0
 744 0066 FA68     		ldr	r2, [r7, #12]
 745 0068 3B69     		ldr	r3, [r7, #16]
 746 006a D31A     		subs	r3, r2, r3
 747 006c 1846     		mov	r0, r3
 748 006e 0021     		movs	r1, #0
 749 0070 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 750              	.L37:
 751              	.LBE28:
1199:..\Source/tasks.c **** 			}
1200:..\Source/tasks.c **** 			else
1201:..\Source/tasks.c **** 			{
1202:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1203:..\Source/tasks.c **** 			}
1204:..\Source/tasks.c **** 		}
1205:..\Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 752              		.loc 1 1205 0
 753 0074 FFF7FEFF 		bl	xTaskResumeAll
 754 0078 B860     		str	r0, [r7, #8]
1206:..\Source/tasks.c **** 
1207:..\Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1208:..\Source/tasks.c **** 		have put ourselves to sleep. */
1209:..\Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 755              		.loc 1 1209 0
 756 007a BB68     		ldr	r3, [r7, #8]
 757 007c 002B     		cmp	r3, #0
 758 007e 07D1     		bne	.L33
1210:..\Source/tasks.c **** 		{
1211:..\Source/tasks.c **** 			portYIELD_WITHIN_API();
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 36


 759              		.loc 1 1211 0
 760 0080 064B     		ldr	r3, .L39+4
 761 0082 4FF08052 		mov	r2, #268435456
 762 0086 1A60     		str	r2, [r3]
 763              	@ 1211 "..\Source\tasks.c" 1
 764 0088 BFF34F8F 		dsb
 765              	@ 0 "" 2
 766              	@ 1211 "..\Source\tasks.c" 1
 767 008c BFF36F8F 		isb
 768              	@ 0 "" 2
 769              		.thumb
 770              	.L33:
1212:..\Source/tasks.c **** 		}
1213:..\Source/tasks.c **** 		else
1214:..\Source/tasks.c **** 		{
1215:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1216:..\Source/tasks.c **** 		}
1217:..\Source/tasks.c **** 	}
 771              		.loc 1 1217 0
 772 0090 1837     		adds	r7, r7, #24
 773              		.cfi_def_cfa_offset 8
 774 0092 BD46     		mov	sp, r7
 775              		.cfi_def_cfa_register 13
 776              		@ sp needed
 777 0094 80BD     		pop	{r7, pc}
 778              	.L40:
 779 0096 00BF     		.align	2
 780              	.L39:
 781 0098 DC000000 		.word	xTickCount
 782 009c 04ED00E0 		.word	-536810236
 783              		.cfi_endproc
 784              	.LFE72:
 785              		.size	vTaskDelayUntil, .-vTaskDelayUntil
 786              		.section	.text.vTaskDelay,"ax",%progbits
 787              		.align	2
 788              		.global	vTaskDelay
 789              		.thumb
 790              		.thumb_func
 791              		.type	vTaskDelay, %function
 792              	vTaskDelay:
 793              	.LFB73:
1218:..\Source/tasks.c **** 
1219:..\Source/tasks.c **** #endif /* INCLUDE_vTaskDelayUntil */
1220:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1221:..\Source/tasks.c **** 
1222:..\Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1223:..\Source/tasks.c **** 
1224:..\Source/tasks.c **** 	void vTaskDelay( const TickType_t xTicksToDelay )
1225:..\Source/tasks.c **** 	{
 794              		.loc 1 1225 0
 795              		.cfi_startproc
 796              		@ args = 0, pretend = 0, frame = 16
 797              		@ frame_needed = 1, uses_anonymous_args = 0
 798 0000 80B5     		push	{r7, lr}
 799              		.cfi_def_cfa_offset 8
 800              		.cfi_offset 7, -8
 801              		.cfi_offset 14, -4
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 37


 802 0002 84B0     		sub	sp, sp, #16
 803              		.cfi_def_cfa_offset 24
 804 0004 00AF     		add	r7, sp, #0
 805              		.cfi_def_cfa_register 7
 806 0006 7860     		str	r0, [r7, #4]
1226:..\Source/tasks.c **** 	BaseType_t xAlreadyYielded = pdFALSE;
 807              		.loc 1 1226 0
 808 0008 0023     		movs	r3, #0
 809 000a FB60     		str	r3, [r7, #12]
1227:..\Source/tasks.c **** 
1228:..\Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
1229:..\Source/tasks.c **** 		if( xTicksToDelay > ( TickType_t ) 0U )
 810              		.loc 1 1229 0
 811 000c 7B68     		ldr	r3, [r7, #4]
 812 000e 002B     		cmp	r3, #0
 813 0010 08D0     		beq	.L42
1230:..\Source/tasks.c **** 		{
1231:..\Source/tasks.c **** 			configASSERT( uxSchedulerSuspended == 0 );
1232:..\Source/tasks.c **** 			vTaskSuspendAll();
 814              		.loc 1 1232 0
 815 0012 FFF7FEFF 		bl	vTaskSuspendAll
1233:..\Source/tasks.c **** 			{
1234:..\Source/tasks.c **** 				traceTASK_DELAY();
1235:..\Source/tasks.c **** 
1236:..\Source/tasks.c **** 				/* A task that is removed from the event list while the
1237:..\Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
1238:..\Source/tasks.c **** 				list or removed from the blocked list until the scheduler
1239:..\Source/tasks.c **** 				is resumed.
1240:..\Source/tasks.c **** 
1241:..\Source/tasks.c **** 				This task cannot be in an event list as it is the currently
1242:..\Source/tasks.c **** 				executing task. */
1243:..\Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 816              		.loc 1 1243 0
 817 0016 7868     		ldr	r0, [r7, #4]
 818 0018 0021     		movs	r1, #0
 819 001a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1244:..\Source/tasks.c **** 			}
1245:..\Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 820              		.loc 1 1245 0
 821 001e FFF7FEFF 		bl	xTaskResumeAll
 822 0022 F860     		str	r0, [r7, #12]
 823              	.L42:
1246:..\Source/tasks.c **** 		}
1247:..\Source/tasks.c **** 		else
1248:..\Source/tasks.c **** 		{
1249:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1250:..\Source/tasks.c **** 		}
1251:..\Source/tasks.c **** 
1252:..\Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
1253:..\Source/tasks.c **** 		have put ourselves to sleep. */
1254:..\Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 824              		.loc 1 1254 0
 825 0024 FB68     		ldr	r3, [r7, #12]
 826 0026 002B     		cmp	r3, #0
 827 0028 07D1     		bne	.L41
1255:..\Source/tasks.c **** 		{
1256:..\Source/tasks.c **** 			portYIELD_WITHIN_API();
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 38


 828              		.loc 1 1256 0
 829 002a 054B     		ldr	r3, .L44
 830 002c 4FF08052 		mov	r2, #268435456
 831 0030 1A60     		str	r2, [r3]
 832              	@ 1256 "..\Source\tasks.c" 1
 833 0032 BFF34F8F 		dsb
 834              	@ 0 "" 2
 835              	@ 1256 "..\Source\tasks.c" 1
 836 0036 BFF36F8F 		isb
 837              	@ 0 "" 2
 838              		.thumb
 839              	.L41:
1257:..\Source/tasks.c **** 		}
1258:..\Source/tasks.c **** 		else
1259:..\Source/tasks.c **** 		{
1260:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1261:..\Source/tasks.c **** 		}
1262:..\Source/tasks.c **** 	}
 840              		.loc 1 1262 0
 841 003a 1037     		adds	r7, r7, #16
 842              		.cfi_def_cfa_offset 8
 843 003c BD46     		mov	sp, r7
 844              		.cfi_def_cfa_register 13
 845              		@ sp needed
 846 003e 80BD     		pop	{r7, pc}
 847              	.L45:
 848              		.align	2
 849              	.L44:
 850 0040 04ED00E0 		.word	-536810236
 851              		.cfi_endproc
 852              	.LFE73:
 853              		.size	vTaskDelay, .-vTaskDelay
 854              		.section	.text.eTaskGetState,"ax",%progbits
 855              		.align	2
 856              		.global	eTaskGetState
 857              		.thumb
 858              		.thumb_func
 859              		.type	eTaskGetState, %function
 860              	eTaskGetState:
 861              	.LFB74:
1263:..\Source/tasks.c **** 
1264:..\Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1265:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1266:..\Source/tasks.c **** 
1267:..\Source/tasks.c **** #if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )
1268:..\Source/tasks.c **** 
1269:..\Source/tasks.c **** 	eTaskState eTaskGetState( TaskHandle_t xTask )
1270:..\Source/tasks.c **** 	{
 862              		.loc 1 1270 0
 863              		.cfi_startproc
 864              		@ args = 0, pretend = 0, frame = 24
 865              		@ frame_needed = 1, uses_anonymous_args = 0
 866 0000 80B5     		push	{r7, lr}
 867              		.cfi_def_cfa_offset 8
 868              		.cfi_offset 7, -8
 869              		.cfi_offset 14, -4
 870 0002 86B0     		sub	sp, sp, #24
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 39


 871              		.cfi_def_cfa_offset 32
 872 0004 00AF     		add	r7, sp, #0
 873              		.cfi_def_cfa_register 7
 874 0006 7860     		str	r0, [r7, #4]
1271:..\Source/tasks.c **** 	eTaskState eReturn;
1272:..\Source/tasks.c **** 	List_t *pxStateList;
1273:..\Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 875              		.loc 1 1273 0
 876 0008 7B68     		ldr	r3, [r7, #4]
 877 000a 3B61     		str	r3, [r7, #16]
1274:..\Source/tasks.c **** 
1275:..\Source/tasks.c **** 		configASSERT( pxTCB );
1276:..\Source/tasks.c **** 
1277:..\Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 878              		.loc 1 1277 0
 879 000c 1D4B     		ldr	r3, .L57
 880 000e 1B68     		ldr	r3, [r3]
 881 0010 3A69     		ldr	r2, [r7, #16]
 882 0012 9A42     		cmp	r2, r3
 883 0014 02D1     		bne	.L47
1278:..\Source/tasks.c **** 		{
1279:..\Source/tasks.c **** 			/* The task calling this function is querying its own state. */
1280:..\Source/tasks.c **** 			eReturn = eRunning;
 884              		.loc 1 1280 0
 885 0016 0023     		movs	r3, #0
 886 0018 FB75     		strb	r3, [r7, #23]
 887 001a 2DE0     		b	.L48
 888              	.L47:
1281:..\Source/tasks.c **** 		}
1282:..\Source/tasks.c **** 		else
1283:..\Source/tasks.c **** 		{
1284:..\Source/tasks.c **** 			taskENTER_CRITICAL();
 889              		.loc 1 1284 0
 890 001c FFF7FEFF 		bl	vPortEnterCritical
1285:..\Source/tasks.c **** 			{
1286:..\Source/tasks.c **** 				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 891              		.loc 1 1286 0
 892 0020 3B69     		ldr	r3, [r7, #16]
 893 0022 5B69     		ldr	r3, [r3, #20]
 894 0024 FB60     		str	r3, [r7, #12]
1287:..\Source/tasks.c **** 			}
1288:..\Source/tasks.c **** 			taskEXIT_CRITICAL();
 895              		.loc 1 1288 0
 896 0026 FFF7FEFF 		bl	vPortExitCritical
1289:..\Source/tasks.c **** 
1290:..\Source/tasks.c **** 			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
 897              		.loc 1 1290 0
 898 002a 174B     		ldr	r3, .L57+4
 899 002c 1B68     		ldr	r3, [r3]
 900 002e FA68     		ldr	r2, [r7, #12]
 901 0030 9A42     		cmp	r2, r3
 902 0032 04D0     		beq	.L49
 903              		.loc 1 1290 0 is_stmt 0 discriminator 1
 904 0034 154B     		ldr	r3, .L57+8
 905 0036 1B68     		ldr	r3, [r3]
 906 0038 FA68     		ldr	r2, [r7, #12]
 907 003a 9A42     		cmp	r2, r3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 40


 908 003c 02D1     		bne	.L50
 909              	.L49:
1291:..\Source/tasks.c **** 			{
1292:..\Source/tasks.c **** 				/* The task being queried is referenced from one of the Blocked
1293:..\Source/tasks.c **** 				lists. */
1294:..\Source/tasks.c **** 				eReturn = eBlocked;
 910              		.loc 1 1294 0 is_stmt 1
 911 003e 0223     		movs	r3, #2
 912 0040 FB75     		strb	r3, [r7, #23]
 913 0042 19E0     		b	.L48
 914              	.L50:
1295:..\Source/tasks.c **** 			}
1296:..\Source/tasks.c **** 
1297:..\Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1298:..\Source/tasks.c **** 				else if( pxStateList == &xSuspendedTaskList )
 915              		.loc 1 1298 0
 916 0044 FB68     		ldr	r3, [r7, #12]
 917 0046 124A     		ldr	r2, .L57+12
 918 0048 9342     		cmp	r3, r2
 919 004a 09D1     		bne	.L51
1299:..\Source/tasks.c **** 				{
1300:..\Source/tasks.c **** 					/* The task being queried is referenced from the suspended
1301:..\Source/tasks.c **** 					list.  Is it genuinely suspended or is it block
1302:..\Source/tasks.c **** 					indefinitely? */
1303:..\Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 920              		.loc 1 1303 0
 921 004c 3B69     		ldr	r3, [r7, #16]
 922 004e 9B6A     		ldr	r3, [r3, #40]
 923 0050 002B     		cmp	r3, #0
 924 0052 02D1     		bne	.L52
1304:..\Source/tasks.c **** 					{
1305:..\Source/tasks.c **** 						eReturn = eSuspended;
 925              		.loc 1 1305 0
 926 0054 0323     		movs	r3, #3
 927 0056 FB75     		strb	r3, [r7, #23]
 928 0058 0EE0     		b	.L48
 929              	.L52:
1306:..\Source/tasks.c **** 					}
1307:..\Source/tasks.c **** 					else
1308:..\Source/tasks.c **** 					{
1309:..\Source/tasks.c **** 						eReturn = eBlocked;
 930              		.loc 1 1309 0
 931 005a 0223     		movs	r3, #2
 932 005c FB75     		strb	r3, [r7, #23]
 933 005e 0BE0     		b	.L48
 934              	.L51:
1310:..\Source/tasks.c **** 					}
1311:..\Source/tasks.c **** 				}
1312:..\Source/tasks.c **** 			#endif
1313:..\Source/tasks.c **** 
1314:..\Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1315:..\Source/tasks.c **** 				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 935              		.loc 1 1315 0
 936 0060 FB68     		ldr	r3, [r7, #12]
 937 0062 0C4A     		ldr	r2, .L57+16
 938 0064 9342     		cmp	r3, r2
 939 0066 02D0     		beq	.L54
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 41


 940              		.loc 1 1315 0 is_stmt 0 discriminator 1
 941 0068 FB68     		ldr	r3, [r7, #12]
 942 006a 002B     		cmp	r3, #0
 943 006c 02D1     		bne	.L55
 944              	.L54:
1316:..\Source/tasks.c **** 				{
1317:..\Source/tasks.c **** 					/* The task being queried is referenced from the deleted
1318:..\Source/tasks.c **** 					tasks list, or it is not referenced from any lists at
1319:..\Source/tasks.c **** 					all. */
1320:..\Source/tasks.c **** 					eReturn = eDeleted;
 945              		.loc 1 1320 0 is_stmt 1
 946 006e 0423     		movs	r3, #4
 947 0070 FB75     		strb	r3, [r7, #23]
 948 0072 01E0     		b	.L48
 949              	.L55:
1321:..\Source/tasks.c **** 				}
1322:..\Source/tasks.c **** 			#endif
1323:..\Source/tasks.c **** 
1324:..\Source/tasks.c **** 			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
1325:..\Source/tasks.c **** 			{
1326:..\Source/tasks.c **** 				/* If the task is not in any other state, it must be in the
1327:..\Source/tasks.c **** 				Ready (including pending ready) state. */
1328:..\Source/tasks.c **** 				eReturn = eReady;
 950              		.loc 1 1328 0
 951 0074 0123     		movs	r3, #1
 952 0076 FB75     		strb	r3, [r7, #23]
 953              	.L48:
1329:..\Source/tasks.c **** 			}
1330:..\Source/tasks.c **** 		}
1331:..\Source/tasks.c **** 
1332:..\Source/tasks.c **** 		return eReturn;
 954              		.loc 1 1332 0
 955 0078 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1333:..\Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 956              		.loc 1 1333 0
 957 007a 1846     		mov	r0, r3
 958 007c 1837     		adds	r7, r7, #24
 959              		.cfi_def_cfa_offset 8
 960 007e BD46     		mov	sp, r7
 961              		.cfi_def_cfa_register 13
 962              		@ sp needed
 963 0080 80BD     		pop	{r7, pc}
 964              	.L58:
 965 0082 00BF     		.align	2
 966              	.L57:
 967 0084 00000000 		.word	pxCurrentTCB
 968 0088 90000000 		.word	pxDelayedTaskList
 969 008c 94000000 		.word	pxOverflowDelayedTaskList
 970 0090 C4000000 		.word	xSuspendedTaskList
 971 0094 AC000000 		.word	xTasksWaitingTermination
 972              		.cfi_endproc
 973              	.LFE74:
 974              		.size	eTaskGetState, .-eTaskGetState
 975              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 976              		.align	2
 977              		.global	uxTaskPriorityGet
 978              		.thumb
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 42


 979              		.thumb_func
 980              		.type	uxTaskPriorityGet, %function
 981              	uxTaskPriorityGet:
 982              	.LFB75:
1334:..\Source/tasks.c **** 
1335:..\Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1336:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1337:..\Source/tasks.c **** 
1338:..\Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1339:..\Source/tasks.c **** 
1340:..\Source/tasks.c **** 	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1341:..\Source/tasks.c **** 	{
 983              		.loc 1 1341 0
 984              		.cfi_startproc
 985              		@ args = 0, pretend = 0, frame = 16
 986              		@ frame_needed = 1, uses_anonymous_args = 0
 987 0000 80B5     		push	{r7, lr}
 988              		.cfi_def_cfa_offset 8
 989              		.cfi_offset 7, -8
 990              		.cfi_offset 14, -4
 991 0002 84B0     		sub	sp, sp, #16
 992              		.cfi_def_cfa_offset 24
 993 0004 00AF     		add	r7, sp, #0
 994              		.cfi_def_cfa_register 7
 995 0006 7860     		str	r0, [r7, #4]
1342:..\Source/tasks.c **** 	TCB_t *pxTCB;
1343:..\Source/tasks.c **** 	UBaseType_t uxReturn;
1344:..\Source/tasks.c **** 
1345:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 996              		.loc 1 1345 0
 997 0008 FFF7FEFF 		bl	vPortEnterCritical
1346:..\Source/tasks.c **** 		{
1347:..\Source/tasks.c **** 			/* If null is passed in here then it is the priority of the that
1348:..\Source/tasks.c **** 			called uxTaskPriorityGet() that is being queried. */
1349:..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 998              		.loc 1 1349 0
 999 000c 7B68     		ldr	r3, [r7, #4]
 1000 000e 002B     		cmp	r3, #0
 1001 0010 02D1     		bne	.L60
 1002              		.loc 1 1349 0 is_stmt 0 discriminator 1
 1003 0012 074B     		ldr	r3, .L63
 1004 0014 1B68     		ldr	r3, [r3]
 1005 0016 00E0     		b	.L61
 1006              	.L60:
 1007              		.loc 1 1349 0 discriminator 2
 1008 0018 7B68     		ldr	r3, [r7, #4]
 1009              	.L61:
 1010              		.loc 1 1349 0 discriminator 4
 1011 001a FB60     		str	r3, [r7, #12]
1350:..\Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1012              		.loc 1 1350 0 is_stmt 1 discriminator 4
 1013 001c FB68     		ldr	r3, [r7, #12]
 1014 001e DB6A     		ldr	r3, [r3, #44]
 1015 0020 BB60     		str	r3, [r7, #8]
1351:..\Source/tasks.c **** 		}
1352:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 1016              		.loc 1 1352 0 discriminator 4
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 43


 1017 0022 FFF7FEFF 		bl	vPortExitCritical
1353:..\Source/tasks.c **** 
1354:..\Source/tasks.c **** 		return uxReturn;
 1018              		.loc 1 1354 0 discriminator 4
 1019 0026 BB68     		ldr	r3, [r7, #8]
1355:..\Source/tasks.c **** 	}
 1020              		.loc 1 1355 0 discriminator 4
 1021 0028 1846     		mov	r0, r3
 1022 002a 1037     		adds	r7, r7, #16
 1023              		.cfi_def_cfa_offset 8
 1024 002c BD46     		mov	sp, r7
 1025              		.cfi_def_cfa_register 13
 1026              		@ sp needed
 1027 002e 80BD     		pop	{r7, pc}
 1028              	.L64:
 1029              		.align	2
 1030              	.L63:
 1031 0030 00000000 		.word	pxCurrentTCB
 1032              		.cfi_endproc
 1033              	.LFE75:
 1034              		.size	uxTaskPriorityGet, .-uxTaskPriorityGet
 1035              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 1036              		.align	2
 1037              		.global	uxTaskPriorityGetFromISR
 1038              		.thumb
 1039              		.thumb_func
 1040              		.type	uxTaskPriorityGetFromISR, %function
 1041              	uxTaskPriorityGetFromISR:
 1042              	.LFB76:
1356:..\Source/tasks.c **** 
1357:..\Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1358:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1359:..\Source/tasks.c **** 
1360:..\Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1361:..\Source/tasks.c **** 
1362:..\Source/tasks.c **** 	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
1363:..\Source/tasks.c **** 	{
 1043              		.loc 1 1363 0
 1044              		.cfi_startproc
 1045              		@ args = 0, pretend = 0, frame = 32
 1046              		@ frame_needed = 1, uses_anonymous_args = 0
 1047              		@ link register save eliminated.
 1048 0000 80B4     		push	{r7}
 1049              		.cfi_def_cfa_offset 4
 1050              		.cfi_offset 7, -4
 1051 0002 89B0     		sub	sp, sp, #36
 1052              		.cfi_def_cfa_offset 40
 1053 0004 00AF     		add	r7, sp, #0
 1054              		.cfi_def_cfa_register 7
 1055 0006 7860     		str	r0, [r7, #4]
 1056              	.LBB29:
 1057              	.LBB30:
 1058              		.file 2 "..\\Source\\portable\\GCC\\ARM_CM3/portmacro.h"
   1:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*
   2:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     All rights reserved
   4:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 44


   5:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
   7:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     This file is part of the FreeRTOS distribution.
   8:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
   9:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     the terms of the GNU General Public License (version 2) as published by the
  11:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  13:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  14:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  19:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  20:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     link: http://www.freertos.org/a00114.html
  24:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  25:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  26:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  27:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    robust, strictly quality controlled, supported, and cross          *
  29:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    platform software that is more than just the market leader, it     *
  30:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    is the industry's de facto standard.                               *
  31:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  32:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    Help yourself get started quickly while simultaneously helping     *
  33:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    tutorial book, reference manual, or both:                          *
  35:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  37:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  38:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  39:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     defined configASSERT()?
  42:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  43:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     embedded software for free we request you assist our global community by
  45:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     participating in the support forum.
  46:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  47:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     be as productive as possible as early as possible.  Now you can receive
  49:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  52:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  56:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  59:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     licenses offer ticketed support, indemnification and commercial middleware.
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 45


  62:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  63:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     engineered and independently SIL3 certified version for use in safety and
  65:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     mission critical applications that require provable dependability.
  66:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  67:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     1 tab == 4 spaces!
  68:..\Source\portable\GCC\ARM_CM3/portmacro.h **** */
  69:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  70:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  71:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  72:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define PORTMACRO_H
  73:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  74:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef __cplusplus
  75:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern "C" {
  76:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  77:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  78:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  79:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Port specific definitions.
  80:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  81:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  82:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * given hardware and compiler.
  83:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  84:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * These settings should not be altered.
  85:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  86:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  87:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  88:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Type definitions. */
  89:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCHAR		char
  90:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portFLOAT		float
  91:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDOUBLE		double
  92:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portLONG		long
  93:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSHORT		short
  94:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  95:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  96:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  97:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
  98:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef long BaseType_t;
  99:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
 100:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 101:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
 102:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
 103:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
 104:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #else
 105:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
 106:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
 107:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 108:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
 109:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
 110:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
 111:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 112:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 113:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 114:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specifics. */
 115:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
 116:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
 117:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
 118:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 46


 119:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 120:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Scheduler utilities. */
 121:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD() 															\
 122:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {																				\
 123:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
 124:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
 125:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 																				\
 126:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
 127:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
 128:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" );													\
 129:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
 130:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 131:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 132:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
 133:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
 134:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
 135:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
 136:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 137:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 138:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Critical section management. */
 139:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
 140:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
 141:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 142:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 143:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 144:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 145:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 146:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 147:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 148:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 149:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 150:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 151:..\Source\portable\GCC\ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 152:..\Source\portable\GCC\ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 153:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 154:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
 155:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 156:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 157:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 158:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 159:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 160:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 161:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 162:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 163:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 164:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 165:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 166:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 167:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 168:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 169:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 170:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 171:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 172:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 173:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 174:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 175:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 47


 176:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 177:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		return ucReturn;
 178:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 179:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 180:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 181:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 182:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 183:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#endif
 184:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 185:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 186:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 187:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 188:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 189:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 190:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 191:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 192:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 193:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 194:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 195:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 196:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 197:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef configASSERT
 198:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 199:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 200:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 201:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 202:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 203:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNOP()
 204:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 205:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portINLINE	__inline
 206:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 207:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 208:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 209:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 210:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 211:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
 212:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 213:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 214:..\Source\portable\GCC\ARM_CM3/portmacro.h **** BaseType_t xReturn;
 215:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 216:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 217:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 218:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 219:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 220:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 221:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 222:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 223:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	else
 224:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 225:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 226:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 227:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 228:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return xReturn;
 229:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 230:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 231:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 232:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 48


 233:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 234:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 235:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 236:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 237:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 238:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 239:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n"	\
 240:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 241:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 242:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 243:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 244:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 245:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 246:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 247:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 248:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 249:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 250:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 251:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 252:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 1059              		.loc 2 253 0
 1060              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1061 0008 EFF31182 			mrs r2, basepri											
 1062 000c 4FF0A003 		mov r3, #160												
 1063 0010 83F31188 		msr basepri, r3											
 1064 0014 BFF36F8F 		isb														
 1065 0018 BFF34F8F 		dsb														
 1066              	
 1067              	@ 0 "" 2
 1068              		.thumb
 1069 001c 3A61     		str	r2, [r7, #16]
 1070 001e FB60     		str	r3, [r7, #12]
 254:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 255:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 256:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n"	\
 257:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 258:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 259:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 260:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 261:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 262:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 263:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 264:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	warnings. */
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 1071              		.loc 2 265 0
 1072 0020 3B69     		ldr	r3, [r7, #16]
 1073              	.LBE30:
 1074              	.LBE29:
1364:..\Source/tasks.c **** 	TCB_t *pxTCB;
1365:..\Source/tasks.c **** 	UBaseType_t uxReturn, uxSavedInterruptState;
1366:..\Source/tasks.c **** 
1367:..\Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1368:..\Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1369:..\Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
1370:..\Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1371:..\Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 49


1372:..\Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1373:..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1374:..\Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1375:..\Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1376:..\Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1377:..\Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1378:..\Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1379:..\Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1380:..\Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1381:..\Source/tasks.c **** 		provided on the following link:
1382:..\Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1383:..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1384:..\Source/tasks.c **** 
1385:..\Source/tasks.c **** 		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1075              		.loc 1 1385 0
 1076 0022 FB61     		str	r3, [r7, #28]
1386:..\Source/tasks.c **** 		{
1387:..\Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1388:..\Source/tasks.c **** 			task that is being queried. */
1389:..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1077              		.loc 1 1389 0
 1078 0024 7B68     		ldr	r3, [r7, #4]
 1079 0026 002B     		cmp	r3, #0
 1080 0028 02D1     		bne	.L67
 1081              		.loc 1 1389 0 is_stmt 0 discriminator 1
 1082 002a 0A4B     		ldr	r3, .L70
 1083 002c 1B68     		ldr	r3, [r3]
 1084 002e 00E0     		b	.L68
 1085              	.L67:
 1086              		.loc 1 1389 0 discriminator 2
 1087 0030 7B68     		ldr	r3, [r7, #4]
 1088              	.L68:
 1089              		.loc 1 1389 0 discriminator 4
 1090 0032 BB61     		str	r3, [r7, #24]
1390:..\Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 1091              		.loc 1 1390 0 is_stmt 1 discriminator 4
 1092 0034 BB69     		ldr	r3, [r7, #24]
 1093 0036 DB6A     		ldr	r3, [r3, #44]
 1094 0038 7B61     		str	r3, [r7, #20]
 1095 003a FB69     		ldr	r3, [r7, #28]
 1096 003c BB60     		str	r3, [r7, #8]
 1097              	.LBB31:
 1098              	.LBB32:
 266:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 267:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 268:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 269:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 270:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 271:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 1099              		.loc 2 271 0 discriminator 4
 1100 003e BB68     		ldr	r3, [r7, #8]
 1101              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1102 0040 83F31188 			msr basepri, r3	
 1103              	@ 0 "" 2
 1104              		.thumb
 1105              	.LBE32:
 1106              	.LBE31:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 50


1391:..\Source/tasks.c **** 		}
1392:..\Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
1393:..\Source/tasks.c **** 
1394:..\Source/tasks.c **** 		return uxReturn;
 1107              		.loc 1 1394 0 discriminator 4
 1108 0044 7B69     		ldr	r3, [r7, #20]
1395:..\Source/tasks.c **** 	}
 1109              		.loc 1 1395 0 discriminator 4
 1110 0046 1846     		mov	r0, r3
 1111 0048 2437     		adds	r7, r7, #36
 1112              		.cfi_def_cfa_offset 4
 1113 004a BD46     		mov	sp, r7
 1114              		.cfi_def_cfa_register 13
 1115              		@ sp needed
 1116 004c 5DF8047B 		ldr	r7, [sp], #4
 1117              		.cfi_restore 7
 1118              		.cfi_def_cfa_offset 0
 1119 0050 7047     		bx	lr
 1120              	.L71:
 1121 0052 00BF     		.align	2
 1122              	.L70:
 1123 0054 00000000 		.word	pxCurrentTCB
 1124              		.cfi_endproc
 1125              	.LFE76:
 1126              		.size	uxTaskPriorityGetFromISR, .-uxTaskPriorityGetFromISR
 1127              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1128              		.align	2
 1129              		.global	vTaskPrioritySet
 1130              		.thumb
 1131              		.thumb_func
 1132              		.type	vTaskPrioritySet, %function
 1133              	vTaskPrioritySet:
 1134              	.LFB77:
1396:..\Source/tasks.c **** 
1397:..\Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1398:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1399:..\Source/tasks.c **** 
1400:..\Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1401:..\Source/tasks.c **** 
1402:..\Source/tasks.c **** 	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1403:..\Source/tasks.c **** 	{
 1135              		.loc 1 1403 0
 1136              		.cfi_startproc
 1137              		@ args = 0, pretend = 0, frame = 24
 1138              		@ frame_needed = 1, uses_anonymous_args = 0
 1139 0000 80B5     		push	{r7, lr}
 1140              		.cfi_def_cfa_offset 8
 1141              		.cfi_offset 7, -8
 1142              		.cfi_offset 14, -4
 1143 0002 86B0     		sub	sp, sp, #24
 1144              		.cfi_def_cfa_offset 32
 1145 0004 00AF     		add	r7, sp, #0
 1146              		.cfi_def_cfa_register 7
 1147 0006 7860     		str	r0, [r7, #4]
 1148 0008 3960     		str	r1, [r7]
1404:..\Source/tasks.c **** 	TCB_t *pxTCB;
1405:..\Source/tasks.c **** 	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 51


1406:..\Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1149              		.loc 1 1406 0
 1150 000a 0023     		movs	r3, #0
 1151 000c 7B61     		str	r3, [r7, #20]
1407:..\Source/tasks.c **** 
1408:..\Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1409:..\Source/tasks.c **** 
1410:..\Source/tasks.c **** 		/* Ensure the new priority is valid. */
1411:..\Source/tasks.c **** 		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1152              		.loc 1 1411 0
 1153 000e 3B68     		ldr	r3, [r7]
 1154 0010 042B     		cmp	r3, #4
 1155 0012 01D9     		bls	.L73
1412:..\Source/tasks.c **** 		{
1413:..\Source/tasks.c **** 			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1156              		.loc 1 1413 0
 1157 0014 0423     		movs	r3, #4
 1158 0016 3B60     		str	r3, [r7]
 1159              	.L73:
1414:..\Source/tasks.c **** 		}
1415:..\Source/tasks.c **** 		else
1416:..\Source/tasks.c **** 		{
1417:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1418:..\Source/tasks.c **** 		}
1419:..\Source/tasks.c **** 
1420:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 1160              		.loc 1 1420 0
 1161 0018 FFF7FEFF 		bl	vPortEnterCritical
1421:..\Source/tasks.c **** 		{
1422:..\Source/tasks.c **** 			/* If null is passed in here then it is the priority of the calling
1423:..\Source/tasks.c **** 			task that is being changed. */
1424:..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTask );
 1162              		.loc 1 1424 0
 1163 001c 7B68     		ldr	r3, [r7, #4]
 1164 001e 002B     		cmp	r3, #0
 1165 0020 02D1     		bne	.L74
 1166              		.loc 1 1424 0 is_stmt 0 discriminator 1
 1167 0022 444B     		ldr	r3, .L85
 1168 0024 1B68     		ldr	r3, [r3]
 1169 0026 00E0     		b	.L75
 1170              	.L74:
 1171              		.loc 1 1424 0 discriminator 2
 1172 0028 7B68     		ldr	r3, [r7, #4]
 1173              	.L75:
 1174              		.loc 1 1424 0 discriminator 4
 1175 002a 3B61     		str	r3, [r7, #16]
1425:..\Source/tasks.c **** 
1426:..\Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1427:..\Source/tasks.c **** 
1428:..\Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
1429:..\Source/tasks.c **** 			{
1430:..\Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxBasePriority;
 1176              		.loc 1 1430 0 is_stmt 1 discriminator 4
 1177 002c 3B69     		ldr	r3, [r7, #16]
 1178 002e 1B6C     		ldr	r3, [r3, #64]
 1179 0030 FB60     		str	r3, [r7, #12]
1431:..\Source/tasks.c **** 			}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 52


1432:..\Source/tasks.c **** 			#else
1433:..\Source/tasks.c **** 			{
1434:..\Source/tasks.c **** 				uxCurrentBasePriority = pxTCB->uxPriority;
1435:..\Source/tasks.c **** 			}
1436:..\Source/tasks.c **** 			#endif
1437:..\Source/tasks.c **** 
1438:..\Source/tasks.c **** 			if( uxCurrentBasePriority != uxNewPriority )
 1180              		.loc 1 1438 0 discriminator 4
 1181 0032 FA68     		ldr	r2, [r7, #12]
 1182 0034 3B68     		ldr	r3, [r7]
 1183 0036 9A42     		cmp	r2, r3
 1184 0038 76D0     		beq	.L76
1439:..\Source/tasks.c **** 			{
1440:..\Source/tasks.c **** 				/* The priority change may have readied a task of higher
1441:..\Source/tasks.c **** 				priority than the calling task. */
1442:..\Source/tasks.c **** 				if( uxNewPriority > uxCurrentBasePriority )
 1185              		.loc 1 1442 0
 1186 003a 3A68     		ldr	r2, [r7]
 1187 003c FB68     		ldr	r3, [r7, #12]
 1188 003e 9A42     		cmp	r2, r3
 1189 0040 0DD9     		bls	.L77
1443:..\Source/tasks.c **** 				{
1444:..\Source/tasks.c **** 					if( pxTCB != pxCurrentTCB )
 1190              		.loc 1 1444 0
 1191 0042 3C4B     		ldr	r3, .L85
 1192 0044 1B68     		ldr	r3, [r3]
 1193 0046 3A69     		ldr	r2, [r7, #16]
 1194 0048 9A42     		cmp	r2, r3
 1195 004a 0FD0     		beq	.L78
1445:..\Source/tasks.c **** 					{
1446:..\Source/tasks.c **** 						/* The priority of a task other than the currently
1447:..\Source/tasks.c **** 						running task is being raised.  Is the priority being
1448:..\Source/tasks.c **** 						raised above that of the running task? */
1449:..\Source/tasks.c **** 						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1196              		.loc 1 1449 0
 1197 004c 394B     		ldr	r3, .L85
 1198 004e 1B68     		ldr	r3, [r3]
 1199 0050 DA6A     		ldr	r2, [r3, #44]
 1200 0052 3B68     		ldr	r3, [r7]
 1201 0054 9A42     		cmp	r2, r3
 1202 0056 09D8     		bhi	.L78
1450:..\Source/tasks.c **** 						{
1451:..\Source/tasks.c **** 							xYieldRequired = pdTRUE;
 1203              		.loc 1 1451 0
 1204 0058 0123     		movs	r3, #1
 1205 005a 7B61     		str	r3, [r7, #20]
 1206 005c 06E0     		b	.L78
 1207              	.L77:
1452:..\Source/tasks.c **** 						}
1453:..\Source/tasks.c **** 						else
1454:..\Source/tasks.c **** 						{
1455:..\Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
1456:..\Source/tasks.c **** 						}
1457:..\Source/tasks.c **** 					}
1458:..\Source/tasks.c **** 					else
1459:..\Source/tasks.c **** 					{
1460:..\Source/tasks.c **** 						/* The priority of the running task is being raised,
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 53


1461:..\Source/tasks.c **** 						but the running task must already be the highest
1462:..\Source/tasks.c **** 						priority task able to run so no yield is required. */
1463:..\Source/tasks.c **** 					}
1464:..\Source/tasks.c **** 				}
1465:..\Source/tasks.c **** 				else if( pxTCB == pxCurrentTCB )
 1208              		.loc 1 1465 0
 1209 005e 354B     		ldr	r3, .L85
 1210 0060 1B68     		ldr	r3, [r3]
 1211 0062 3A69     		ldr	r2, [r7, #16]
 1212 0064 9A42     		cmp	r2, r3
 1213 0066 01D1     		bne	.L78
1466:..\Source/tasks.c **** 				{
1467:..\Source/tasks.c **** 					/* Setting the priority of the running task down means
1468:..\Source/tasks.c **** 					there may now be another task of higher priority that
1469:..\Source/tasks.c **** 					is ready to execute. */
1470:..\Source/tasks.c **** 					xYieldRequired = pdTRUE;
 1214              		.loc 1 1470 0
 1215 0068 0123     		movs	r3, #1
 1216 006a 7B61     		str	r3, [r7, #20]
 1217              	.L78:
1471:..\Source/tasks.c **** 				}
1472:..\Source/tasks.c **** 				else
1473:..\Source/tasks.c **** 				{
1474:..\Source/tasks.c **** 					/* Setting the priority of any other task down does not
1475:..\Source/tasks.c **** 					require a yield as the running task must be above the
1476:..\Source/tasks.c **** 					new priority of the task being modified. */
1477:..\Source/tasks.c **** 				}
1478:..\Source/tasks.c **** 
1479:..\Source/tasks.c **** 				/* Remember the ready list the task might be referenced from
1480:..\Source/tasks.c **** 				before its uxPriority member is changed so the
1481:..\Source/tasks.c **** 				taskRESET_READY_PRIORITY() macro can function correctly. */
1482:..\Source/tasks.c **** 				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1218              		.loc 1 1482 0
 1219 006c 3B69     		ldr	r3, [r7, #16]
 1220 006e DB6A     		ldr	r3, [r3, #44]
 1221 0070 BB60     		str	r3, [r7, #8]
1483:..\Source/tasks.c **** 
1484:..\Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
1485:..\Source/tasks.c **** 				{
1486:..\Source/tasks.c **** 					/* Only change the priority being used if the task is not
1487:..\Source/tasks.c **** 					currently using an inherited priority. */
1488:..\Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1222              		.loc 1 1488 0
 1223 0072 3B69     		ldr	r3, [r7, #16]
 1224 0074 1A6C     		ldr	r2, [r3, #64]
 1225 0076 3B69     		ldr	r3, [r7, #16]
 1226 0078 DB6A     		ldr	r3, [r3, #44]
 1227 007a 9A42     		cmp	r2, r3
 1228 007c 02D1     		bne	.L79
1489:..\Source/tasks.c **** 					{
1490:..\Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 1229              		.loc 1 1490 0
 1230 007e 3B69     		ldr	r3, [r7, #16]
 1231 0080 3A68     		ldr	r2, [r7]
 1232 0082 DA62     		str	r2, [r3, #44]
 1233              	.L79:
1491:..\Source/tasks.c **** 					}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 54


1492:..\Source/tasks.c **** 					else
1493:..\Source/tasks.c **** 					{
1494:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1495:..\Source/tasks.c **** 					}
1496:..\Source/tasks.c **** 
1497:..\Source/tasks.c **** 					/* The base priority gets set whatever. */
1498:..\Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 1234              		.loc 1 1498 0
 1235 0084 3B69     		ldr	r3, [r7, #16]
 1236 0086 3A68     		ldr	r2, [r7]
 1237 0088 1A64     		str	r2, [r3, #64]
1499:..\Source/tasks.c **** 				}
1500:..\Source/tasks.c **** 				#else
1501:..\Source/tasks.c **** 				{
1502:..\Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
1503:..\Source/tasks.c **** 				}
1504:..\Source/tasks.c **** 				#endif
1505:..\Source/tasks.c **** 
1506:..\Source/tasks.c **** 				/* Only reset the event list item value if the value is not
1507:..\Source/tasks.c **** 				being used for anything else. */
1508:..\Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 1238              		.loc 1 1508 0
 1239 008a 3B69     		ldr	r3, [r7, #16]
 1240 008c 9B69     		ldr	r3, [r3, #24]
 1241 008e 002B     		cmp	r3, #0
 1242 0090 04DB     		blt	.L80
1509:..\Source/tasks.c **** 				{
1510:..\Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - (
 1243              		.loc 1 1510 0
 1244 0092 3B68     		ldr	r3, [r7]
 1245 0094 C3F10502 		rsb	r2, r3, #5
 1246 0098 3B69     		ldr	r3, [r7, #16]
 1247 009a 9A61     		str	r2, [r3, #24]
 1248              	.L80:
1511:..\Source/tasks.c **** 				}
1512:..\Source/tasks.c **** 				else
1513:..\Source/tasks.c **** 				{
1514:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1515:..\Source/tasks.c **** 				}
1516:..\Source/tasks.c **** 
1517:..\Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
1518:..\Source/tasks.c **** 				nothing more than change it's priority variable. However, if
1519:..\Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
1520:..\Source/tasks.c **** 				in the list appropriate to its new priority. */
1521:..\Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateL
 1249              		.loc 1 1521 0
 1250 009c 3B69     		ldr	r3, [r7, #16]
 1251 009e 5969     		ldr	r1, [r3, #20]
 1252 00a0 BA68     		ldr	r2, [r7, #8]
 1253 00a2 1346     		mov	r3, r2
 1254 00a4 9B00     		lsls	r3, r3, #2
 1255 00a6 1344     		add	r3, r3, r2
 1256 00a8 9B00     		lsls	r3, r3, #2
 1257 00aa 234A     		ldr	r2, .L85+4
 1258 00ac 1344     		add	r3, r3, r2
 1259 00ae 9942     		cmp	r1, r3
 1260 00b0 01D1     		bne	.L81
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 55


 1261              		.loc 1 1521 0 is_stmt 0 discriminator 1
 1262 00b2 0123     		movs	r3, #1
 1263 00b4 00E0     		b	.L82
 1264              	.L81:
 1265              		.loc 1 1521 0 discriminator 2
 1266 00b6 0023     		movs	r3, #0
 1267              	.L82:
 1268              		.loc 1 1521 0 discriminator 4
 1269 00b8 002B     		cmp	r3, #0
 1270 00ba 2AD0     		beq	.L83
1522:..\Source/tasks.c **** 				{
1523:..\Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
1524:..\Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
1525:..\Source/tasks.c **** 					can do this even if the scheduler is suspended. */
1526:..\Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1271              		.loc 1 1526 0 is_stmt 1
 1272 00bc 3B69     		ldr	r3, [r7, #16]
 1273 00be 0433     		adds	r3, r3, #4
 1274 00c0 1846     		mov	r0, r3
 1275 00c2 FFF7FEFF 		bl	uxListRemove
 1276 00c6 0346     		mov	r3, r0
 1277 00c8 002B     		cmp	r3, #0
 1278 00ca 09D1     		bne	.L84
1527:..\Source/tasks.c **** 					{
1528:..\Source/tasks.c **** 						/* It is known that the task is in its ready list so
1529:..\Source/tasks.c **** 						there is no need to check again and the port level
1530:..\Source/tasks.c **** 						reset macro can be called directly. */
1531:..\Source/tasks.c **** 						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 1279              		.loc 1 1531 0
 1280 00cc BB68     		ldr	r3, [r7, #8]
 1281 00ce 0122     		movs	r2, #1
 1282 00d0 02FA03F3 		lsl	r3, r2, r3
 1283 00d4 DA43     		mvns	r2, r3
 1284 00d6 194B     		ldr	r3, .L85+8
 1285 00d8 1B68     		ldr	r3, [r3]
 1286 00da 1340     		ands	r3, r3, r2
 1287 00dc 174A     		ldr	r2, .L85+8
 1288 00de 1360     		str	r3, [r2]
 1289              	.L84:
1532:..\Source/tasks.c **** 					}
1533:..\Source/tasks.c **** 					else
1534:..\Source/tasks.c **** 					{
1535:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1536:..\Source/tasks.c **** 					}
1537:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1290              		.loc 1 1537 0
 1291 00e0 3B69     		ldr	r3, [r7, #16]
 1292 00e2 DB6A     		ldr	r3, [r3, #44]
 1293 00e4 1A46     		mov	r2, r3
 1294 00e6 0123     		movs	r3, #1
 1295 00e8 03FA02F2 		lsl	r2, r3, r2
 1296 00ec 134B     		ldr	r3, .L85+8
 1297 00ee 1B68     		ldr	r3, [r3]
 1298 00f0 1343     		orrs	r3, r3, r2
 1299 00f2 124A     		ldr	r2, .L85+8
 1300 00f4 1360     		str	r3, [r2]
 1301 00f6 3B69     		ldr	r3, [r7, #16]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 56


 1302 00f8 DA6A     		ldr	r2, [r3, #44]
 1303 00fa 1346     		mov	r3, r2
 1304 00fc 9B00     		lsls	r3, r3, #2
 1305 00fe 1344     		add	r3, r3, r2
 1306 0100 9B00     		lsls	r3, r3, #2
 1307 0102 0D4A     		ldr	r2, .L85+4
 1308 0104 1A44     		add	r2, r2, r3
 1309 0106 3B69     		ldr	r3, [r7, #16]
 1310 0108 0433     		adds	r3, r3, #4
 1311 010a 1046     		mov	r0, r2
 1312 010c 1946     		mov	r1, r3
 1313 010e FFF7FEFF 		bl	vListInsertEnd
 1314              	.L83:
1538:..\Source/tasks.c **** 				}
1539:..\Source/tasks.c **** 				else
1540:..\Source/tasks.c **** 				{
1541:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1542:..\Source/tasks.c **** 				}
1543:..\Source/tasks.c **** 
1544:..\Source/tasks.c **** 				if( xYieldRequired != pdFALSE )
 1315              		.loc 1 1544 0
 1316 0112 7B69     		ldr	r3, [r7, #20]
 1317 0114 002B     		cmp	r3, #0
 1318 0116 07D0     		beq	.L76
1545:..\Source/tasks.c **** 				{
1546:..\Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 1319              		.loc 1 1546 0
 1320 0118 094B     		ldr	r3, .L85+12
 1321 011a 4FF08052 		mov	r2, #268435456
 1322 011e 1A60     		str	r2, [r3]
 1323              	@ 1546 "..\Source\tasks.c" 1
 1324 0120 BFF34F8F 		dsb
 1325              	@ 0 "" 2
 1326              	@ 1546 "..\Source\tasks.c" 1
 1327 0124 BFF36F8F 		isb
 1328              	@ 0 "" 2
 1329              		.thumb
 1330              	.L76:
1547:..\Source/tasks.c **** 				}
1548:..\Source/tasks.c **** 				else
1549:..\Source/tasks.c **** 				{
1550:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1551:..\Source/tasks.c **** 				}
1552:..\Source/tasks.c **** 
1553:..\Source/tasks.c **** 				/* Remove compiler warning about unused variables when the port
1554:..\Source/tasks.c **** 				optimised task selection is not being used. */
1555:..\Source/tasks.c **** 				( void ) uxPriorityUsedOnEntry;
1556:..\Source/tasks.c **** 			}
1557:..\Source/tasks.c **** 		}
1558:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 1331              		.loc 1 1558 0
 1332 0128 FFF7FEFF 		bl	vPortExitCritical
1559:..\Source/tasks.c **** 	}
 1333              		.loc 1 1559 0
 1334 012c 1837     		adds	r7, r7, #24
 1335              		.cfi_def_cfa_offset 8
 1336 012e BD46     		mov	sp, r7
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 57


 1337              		.cfi_def_cfa_register 13
 1338              		@ sp needed
 1339 0130 80BD     		pop	{r7, pc}
 1340              	.L86:
 1341 0132 00BF     		.align	2
 1342              	.L85:
 1343 0134 00000000 		.word	pxCurrentTCB
 1344 0138 04000000 		.word	pxReadyTasksLists
 1345 013c E0000000 		.word	uxTopReadyPriority
 1346 0140 04ED00E0 		.word	-536810236
 1347              		.cfi_endproc
 1348              	.LFE77:
 1349              		.size	vTaskPrioritySet, .-vTaskPrioritySet
 1350              		.section	.text.vTaskSuspend,"ax",%progbits
 1351              		.align	2
 1352              		.global	vTaskSuspend
 1353              		.thumb
 1354              		.thumb_func
 1355              		.type	vTaskSuspend, %function
 1356              	vTaskSuspend:
 1357              	.LFB78:
1560:..\Source/tasks.c **** 
1561:..\Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1562:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1563:..\Source/tasks.c **** 
1564:..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1565:..\Source/tasks.c **** 
1566:..\Source/tasks.c **** 	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1567:..\Source/tasks.c **** 	{
 1358              		.loc 1 1567 0
 1359              		.cfi_startproc
 1360              		@ args = 0, pretend = 0, frame = 16
 1361              		@ frame_needed = 1, uses_anonymous_args = 0
 1362 0000 80B5     		push	{r7, lr}
 1363              		.cfi_def_cfa_offset 8
 1364              		.cfi_offset 7, -8
 1365              		.cfi_offset 14, -4
 1366 0002 84B0     		sub	sp, sp, #16
 1367              		.cfi_def_cfa_offset 24
 1368 0004 00AF     		add	r7, sp, #0
 1369              		.cfi_def_cfa_register 7
 1370 0006 7860     		str	r0, [r7, #4]
1568:..\Source/tasks.c **** 	TCB_t *pxTCB;
1569:..\Source/tasks.c **** 
1570:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 1371              		.loc 1 1570 0
 1372 0008 FFF7FEFF 		bl	vPortEnterCritical
1571:..\Source/tasks.c **** 		{
1572:..\Source/tasks.c **** 			/* If null is passed in here then it is the running task that is
1573:..\Source/tasks.c **** 			being suspended. */
1574:..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1373              		.loc 1 1574 0
 1374 000c 7B68     		ldr	r3, [r7, #4]
 1375 000e 002B     		cmp	r3, #0
 1376 0010 02D1     		bne	.L88
 1377              		.loc 1 1574 0 is_stmt 0 discriminator 1
 1378 0012 2F4B     		ldr	r3, .L98
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 58


 1379 0014 1B68     		ldr	r3, [r3]
 1380 0016 00E0     		b	.L89
 1381              	.L88:
 1382              		.loc 1 1574 0 discriminator 2
 1383 0018 7B68     		ldr	r3, [r7, #4]
 1384              	.L89:
 1385              		.loc 1 1574 0 discriminator 4
 1386 001a FB60     		str	r3, [r7, #12]
1575:..\Source/tasks.c **** 
1576:..\Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
1577:..\Source/tasks.c **** 
1578:..\Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the
1579:..\Source/tasks.c **** 			suspended list. */
1580:..\Source/tasks.c **** 			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1387              		.loc 1 1580 0 is_stmt 1 discriminator 4
 1388 001c FB68     		ldr	r3, [r7, #12]
 1389 001e 0433     		adds	r3, r3, #4
 1390 0020 1846     		mov	r0, r3
 1391 0022 FFF7FEFF 		bl	uxListRemove
 1392 0026 0346     		mov	r3, r0
 1393 0028 002B     		cmp	r3, #0
 1394 002a 15D1     		bne	.L90
1581:..\Source/tasks.c **** 			{
1582:..\Source/tasks.c **** 				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 1395              		.loc 1 1582 0
 1396 002c FB68     		ldr	r3, [r7, #12]
 1397 002e DA6A     		ldr	r2, [r3, #44]
 1398 0030 2849     		ldr	r1, .L98+4
 1399 0032 1346     		mov	r3, r2
 1400 0034 9B00     		lsls	r3, r3, #2
 1401 0036 1344     		add	r3, r3, r2
 1402 0038 9B00     		lsls	r3, r3, #2
 1403 003a 0B44     		add	r3, r3, r1
 1404 003c 1B68     		ldr	r3, [r3]
 1405 003e 002B     		cmp	r3, #0
 1406 0040 0AD1     		bne	.L90
 1407              		.loc 1 1582 0 is_stmt 0 discriminator 1
 1408 0042 FB68     		ldr	r3, [r7, #12]
 1409 0044 DB6A     		ldr	r3, [r3, #44]
 1410 0046 1A46     		mov	r2, r3
 1411 0048 0123     		movs	r3, #1
 1412 004a 9340     		lsls	r3, r3, r2
 1413 004c DA43     		mvns	r2, r3
 1414 004e 224B     		ldr	r3, .L98+8
 1415 0050 1B68     		ldr	r3, [r3]
 1416 0052 1340     		ands	r3, r3, r2
 1417 0054 204A     		ldr	r2, .L98+8
 1418 0056 1360     		str	r3, [r2]
 1419              	.L90:
1583:..\Source/tasks.c **** 			}
1584:..\Source/tasks.c **** 			else
1585:..\Source/tasks.c **** 			{
1586:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1587:..\Source/tasks.c **** 			}
1588:..\Source/tasks.c **** 
1589:..\Source/tasks.c **** 			/* Is the task waiting on an event also? */
1590:..\Source/tasks.c **** 			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 59


 1420              		.loc 1 1590 0 is_stmt 1
 1421 0058 FB68     		ldr	r3, [r7, #12]
 1422 005a 9B6A     		ldr	r3, [r3, #40]
 1423 005c 002B     		cmp	r3, #0
 1424 005e 04D0     		beq	.L92
1591:..\Source/tasks.c **** 			{
1592:..\Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1425              		.loc 1 1592 0
 1426 0060 FB68     		ldr	r3, [r7, #12]
 1427 0062 1833     		adds	r3, r3, #24
 1428 0064 1846     		mov	r0, r3
 1429 0066 FFF7FEFF 		bl	uxListRemove
 1430              	.L92:
1593:..\Source/tasks.c **** 			}
1594:..\Source/tasks.c **** 			else
1595:..\Source/tasks.c **** 			{
1596:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1597:..\Source/tasks.c **** 			}
1598:..\Source/tasks.c **** 
1599:..\Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1431              		.loc 1 1599 0
 1432 006a FB68     		ldr	r3, [r7, #12]
 1433 006c 0433     		adds	r3, r3, #4
 1434 006e 1B48     		ldr	r0, .L98+12
 1435 0070 1946     		mov	r1, r3
 1436 0072 FFF7FEFF 		bl	vListInsertEnd
1600:..\Source/tasks.c **** 		}
1601:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 1437              		.loc 1 1601 0
 1438 0076 FFF7FEFF 		bl	vPortExitCritical
1602:..\Source/tasks.c **** 
1603:..\Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 1439              		.loc 1 1603 0
 1440 007a 194B     		ldr	r3, .L98+16
 1441 007c 1B68     		ldr	r3, [r3]
 1442 007e 002B     		cmp	r3, #0
 1443 0080 05D0     		beq	.L93
1604:..\Source/tasks.c **** 		{
1605:..\Source/tasks.c **** 			/* Reset the next expected unblock time in case it referred to the
1606:..\Source/tasks.c **** 			task that is now in the Suspended state. */
1607:..\Source/tasks.c **** 			taskENTER_CRITICAL();
 1444              		.loc 1 1607 0
 1445 0082 FFF7FEFF 		bl	vPortEnterCritical
1608:..\Source/tasks.c **** 			{
1609:..\Source/tasks.c **** 				prvResetNextTaskUnblockTime();
 1446              		.loc 1 1609 0
 1447 0086 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
1610:..\Source/tasks.c **** 			}
1611:..\Source/tasks.c **** 			taskEXIT_CRITICAL();
 1448              		.loc 1 1611 0
 1449 008a FFF7FEFF 		bl	vPortExitCritical
 1450              	.L93:
1612:..\Source/tasks.c **** 		}
1613:..\Source/tasks.c **** 		else
1614:..\Source/tasks.c **** 		{
1615:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1616:..\Source/tasks.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 60


1617:..\Source/tasks.c **** 
1618:..\Source/tasks.c **** 		if( pxTCB == pxCurrentTCB )
 1451              		.loc 1 1618 0
 1452 008e 104B     		ldr	r3, .L98
 1453 0090 1B68     		ldr	r3, [r3]
 1454 0092 FA68     		ldr	r2, [r7, #12]
 1455 0094 9A42     		cmp	r2, r3
 1456 0096 18D1     		bne	.L87
1619:..\Source/tasks.c **** 		{
1620:..\Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 1457              		.loc 1 1620 0
 1458 0098 114B     		ldr	r3, .L98+16
 1459 009a 1B68     		ldr	r3, [r3]
 1460 009c 002B     		cmp	r3, #0
 1461 009e 08D0     		beq	.L95
1621:..\Source/tasks.c **** 			{
1622:..\Source/tasks.c **** 				/* The current task has just been suspended. */
1623:..\Source/tasks.c **** 				configASSERT( uxSchedulerSuspended == 0 );
1624:..\Source/tasks.c **** 				portYIELD_WITHIN_API();
 1462              		.loc 1 1624 0
 1463 00a0 104B     		ldr	r3, .L98+20
 1464 00a2 4FF08052 		mov	r2, #268435456
 1465 00a6 1A60     		str	r2, [r3]
 1466              	@ 1624 "..\Source\tasks.c" 1
 1467 00a8 BFF34F8F 		dsb
 1468              	@ 0 "" 2
 1469              	@ 1624 "..\Source\tasks.c" 1
 1470 00ac BFF36F8F 		isb
 1471              	@ 0 "" 2
 1472              		.thumb
 1473 00b0 0BE0     		b	.L87
 1474              	.L95:
1625:..\Source/tasks.c **** 			}
1626:..\Source/tasks.c **** 			else
1627:..\Source/tasks.c **** 			{
1628:..\Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
1629:..\Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1630:..\Source/tasks.c **** 				must be adjusted to point to a different task. */
1631:..\Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1475              		.loc 1 1631 0
 1476 00b2 0A4B     		ldr	r3, .L98+12
 1477 00b4 1A68     		ldr	r2, [r3]
 1478 00b6 0C4B     		ldr	r3, .L98+24
 1479 00b8 1B68     		ldr	r3, [r3]
 1480 00ba 9A42     		cmp	r2, r3
 1481 00bc 03D1     		bne	.L97
1632:..\Source/tasks.c **** 				{
1633:..\Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
1634:..\Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
1635:..\Source/tasks.c **** 					be set to point to it no matter what its relative priority
1636:..\Source/tasks.c **** 					is. */
1637:..\Source/tasks.c **** 					pxCurrentTCB = NULL;
 1482              		.loc 1 1637 0
 1483 00be 044B     		ldr	r3, .L98
 1484 00c0 0022     		movs	r2, #0
 1485 00c2 1A60     		str	r2, [r3]
 1486 00c4 01E0     		b	.L87
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 61


 1487              	.L97:
1638:..\Source/tasks.c **** 				}
1639:..\Source/tasks.c **** 				else
1640:..\Source/tasks.c **** 				{
1641:..\Source/tasks.c **** 					vTaskSwitchContext();
 1488              		.loc 1 1641 0
 1489 00c6 FFF7FEFF 		bl	vTaskSwitchContext
 1490              	.L87:
1642:..\Source/tasks.c **** 				}
1643:..\Source/tasks.c **** 			}
1644:..\Source/tasks.c **** 		}
1645:..\Source/tasks.c **** 		else
1646:..\Source/tasks.c **** 		{
1647:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1648:..\Source/tasks.c **** 		}
1649:..\Source/tasks.c **** 	}
 1491              		.loc 1 1649 0
 1492 00ca 1037     		adds	r7, r7, #16
 1493              		.cfi_def_cfa_offset 8
 1494 00cc BD46     		mov	sp, r7
 1495              		.cfi_def_cfa_register 13
 1496              		@ sp needed
 1497 00ce 80BD     		pop	{r7, pc}
 1498              	.L99:
 1499              		.align	2
 1500              	.L98:
 1501 00d0 00000000 		.word	pxCurrentTCB
 1502 00d4 04000000 		.word	pxReadyTasksLists
 1503 00d8 E0000000 		.word	uxTopReadyPriority
 1504 00dc C4000000 		.word	xSuspendedTaskList
 1505 00e0 E4000000 		.word	xSchedulerRunning
 1506 00e4 04ED00E0 		.word	-536810236
 1507 00e8 D8000000 		.word	uxCurrentNumberOfTasks
 1508              		.cfi_endproc
 1509              	.LFE78:
 1510              		.size	vTaskSuspend, .-vTaskSuspend
 1511              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 1512              		.align	2
 1513              		.thumb
 1514              		.thumb_func
 1515              		.type	prvTaskIsTaskSuspended, %function
 1516              	prvTaskIsTaskSuspended:
 1517              	.LFB79:
1650:..\Source/tasks.c **** 
1651:..\Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1652:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1653:..\Source/tasks.c **** 
1654:..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1655:..\Source/tasks.c **** 
1656:..\Source/tasks.c **** 	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1657:..\Source/tasks.c **** 	{
 1518              		.loc 1 1657 0
 1519              		.cfi_startproc
 1520              		@ args = 0, pretend = 0, frame = 16
 1521              		@ frame_needed = 1, uses_anonymous_args = 0
 1522              		@ link register save eliminated.
 1523 0000 80B4     		push	{r7}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 62


 1524              		.cfi_def_cfa_offset 4
 1525              		.cfi_offset 7, -4
 1526 0002 85B0     		sub	sp, sp, #20
 1527              		.cfi_def_cfa_offset 24
 1528 0004 00AF     		add	r7, sp, #0
 1529              		.cfi_def_cfa_register 7
 1530 0006 7860     		str	r0, [r7, #4]
1658:..\Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 1531              		.loc 1 1658 0
 1532 0008 0023     		movs	r3, #0
 1533 000a FB60     		str	r3, [r7, #12]
1659:..\Source/tasks.c **** 	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 1534              		.loc 1 1659 0
 1535 000c 7B68     		ldr	r3, [r7, #4]
 1536 000e BB60     		str	r3, [r7, #8]
1660:..\Source/tasks.c **** 
1661:..\Source/tasks.c **** 		/* Accesses xPendingReadyList so must be called from a critical
1662:..\Source/tasks.c **** 		section. */
1663:..\Source/tasks.c **** 
1664:..\Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
1665:..\Source/tasks.c **** 		configASSERT( xTask );
1666:..\Source/tasks.c **** 
1667:..\Source/tasks.c **** 		/* Is the task being resumed actually in the suspended list? */
1668:..\Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1537              		.loc 1 1668 0
 1538 0010 BB68     		ldr	r3, [r7, #8]
 1539 0012 5B69     		ldr	r3, [r3, #20]
 1540 0014 0F4A     		ldr	r2, .L107
 1541 0016 9342     		cmp	r3, r2
 1542 0018 01D1     		bne	.L101
 1543              		.loc 1 1668 0 is_stmt 0 discriminator 1
 1544 001a 0123     		movs	r3, #1
 1545 001c 00E0     		b	.L102
 1546              	.L101:
 1547              		.loc 1 1668 0 discriminator 2
 1548 001e 0023     		movs	r3, #0
 1549              	.L102:
 1550              		.loc 1 1668 0 discriminator 4
 1551 0020 002B     		cmp	r3, #0
 1552 0022 0FD0     		beq	.L103
1669:..\Source/tasks.c **** 		{
1670:..\Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
1671:..\Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1553              		.loc 1 1671 0 is_stmt 1
 1554 0024 BB68     		ldr	r3, [r7, #8]
 1555 0026 9B6A     		ldr	r3, [r3, #40]
 1556 0028 0B4A     		ldr	r2, .L107+4
 1557 002a 9342     		cmp	r3, r2
 1558 002c 0AD0     		beq	.L103
1672:..\Source/tasks.c **** 			{
1673:..\Source/tasks.c **** 				/* Is it in the suspended list because it is in the	Suspended
1674:..\Source/tasks.c **** 				state, or because is is blocked with no timeout? */
1675:..\Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1559              		.loc 1 1675 0
 1560 002e BB68     		ldr	r3, [r7, #8]
 1561 0030 9B6A     		ldr	r3, [r3, #40]
 1562 0032 002B     		cmp	r3, #0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 63


 1563 0034 01D1     		bne	.L104
 1564              		.loc 1 1675 0 is_stmt 0 discriminator 1
 1565 0036 0123     		movs	r3, #1
 1566 0038 00E0     		b	.L105
 1567              	.L104:
 1568              		.loc 1 1675 0 discriminator 2
 1569 003a 0023     		movs	r3, #0
 1570              	.L105:
 1571              		.loc 1 1675 0 discriminator 4
 1572 003c 002B     		cmp	r3, #0
 1573 003e 01D0     		beq	.L103
1676:..\Source/tasks.c **** 				{
1677:..\Source/tasks.c **** 					xReturn = pdTRUE;
 1574              		.loc 1 1677 0 is_stmt 1
 1575 0040 0123     		movs	r3, #1
 1576 0042 FB60     		str	r3, [r7, #12]
 1577              	.L103:
1678:..\Source/tasks.c **** 				}
1679:..\Source/tasks.c **** 				else
1680:..\Source/tasks.c **** 				{
1681:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1682:..\Source/tasks.c **** 				}
1683:..\Source/tasks.c **** 			}
1684:..\Source/tasks.c **** 			else
1685:..\Source/tasks.c **** 			{
1686:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1687:..\Source/tasks.c **** 			}
1688:..\Source/tasks.c **** 		}
1689:..\Source/tasks.c **** 		else
1690:..\Source/tasks.c **** 		{
1691:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1692:..\Source/tasks.c **** 		}
1693:..\Source/tasks.c **** 
1694:..\Source/tasks.c **** 		return xReturn;
 1578              		.loc 1 1694 0
 1579 0044 FB68     		ldr	r3, [r7, #12]
1695:..\Source/tasks.c **** 	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1580              		.loc 1 1695 0
 1581 0046 1846     		mov	r0, r3
 1582 0048 1437     		adds	r7, r7, #20
 1583              		.cfi_def_cfa_offset 4
 1584 004a BD46     		mov	sp, r7
 1585              		.cfi_def_cfa_register 13
 1586              		@ sp needed
 1587 004c 5DF8047B 		ldr	r7, [sp], #4
 1588              		.cfi_restore 7
 1589              		.cfi_def_cfa_offset 0
 1590 0050 7047     		bx	lr
 1591              	.L108:
 1592 0052 00BF     		.align	2
 1593              	.L107:
 1594 0054 C4000000 		.word	xSuspendedTaskList
 1595 0058 98000000 		.word	xPendingReadyList
 1596              		.cfi_endproc
 1597              	.LFE79:
 1598              		.size	prvTaskIsTaskSuspended, .-prvTaskIsTaskSuspended
 1599              		.section	.text.vTaskResume,"ax",%progbits
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 64


 1600              		.align	2
 1601              		.global	vTaskResume
 1602              		.thumb
 1603              		.thumb_func
 1604              		.type	vTaskResume, %function
 1605              	vTaskResume:
 1606              	.LFB80:
1696:..\Source/tasks.c **** 
1697:..\Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1698:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1699:..\Source/tasks.c **** 
1700:..\Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1701:..\Source/tasks.c **** 
1702:..\Source/tasks.c **** 	void vTaskResume( TaskHandle_t xTaskToResume )
1703:..\Source/tasks.c **** 	{
 1607              		.loc 1 1703 0
 1608              		.cfi_startproc
 1609              		@ args = 0, pretend = 0, frame = 16
 1610              		@ frame_needed = 1, uses_anonymous_args = 0
 1611 0000 80B5     		push	{r7, lr}
 1612              		.cfi_def_cfa_offset 8
 1613              		.cfi_offset 7, -8
 1614              		.cfi_offset 14, -4
 1615 0002 84B0     		sub	sp, sp, #16
 1616              		.cfi_def_cfa_offset 24
 1617 0004 00AF     		add	r7, sp, #0
 1618              		.cfi_def_cfa_register 7
 1619 0006 7860     		str	r0, [r7, #4]
1704:..\Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1620              		.loc 1 1704 0
 1621 0008 7B68     		ldr	r3, [r7, #4]
 1622 000a FB60     		str	r3, [r7, #12]
1705:..\Source/tasks.c **** 
1706:..\Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1707:..\Source/tasks.c **** 		configASSERT( xTaskToResume );
1708:..\Source/tasks.c **** 
1709:..\Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1710:..\Source/tasks.c **** 		currently executing task. */
1711:..\Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1623              		.loc 1 1711 0
 1624 000c FB68     		ldr	r3, [r7, #12]
 1625 000e 002B     		cmp	r3, #0
 1626 0010 3BD0     		beq	.L109
 1627              		.loc 1 1711 0 is_stmt 0 discriminator 1
 1628 0012 1F4B     		ldr	r3, .L112
 1629 0014 1B68     		ldr	r3, [r3]
 1630 0016 FA68     		ldr	r2, [r7, #12]
 1631 0018 9A42     		cmp	r2, r3
 1632 001a 36D0     		beq	.L109
1712:..\Source/tasks.c **** 		{
1713:..\Source/tasks.c **** 			taskENTER_CRITICAL();
 1633              		.loc 1 1713 0 is_stmt 1
 1634 001c FFF7FEFF 		bl	vPortEnterCritical
1714:..\Source/tasks.c **** 			{
1715:..\Source/tasks.c **** 				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1635              		.loc 1 1715 0
 1636 0020 F868     		ldr	r0, [r7, #12]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 65


 1637 0022 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1638 0026 0346     		mov	r3, r0
 1639 0028 002B     		cmp	r3, #0
 1640 002a 2CD0     		beq	.L111
1716:..\Source/tasks.c **** 				{
1717:..\Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1718:..\Source/tasks.c **** 
1719:..\Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1720:..\Source/tasks.c **** 					lists even if the scheduler is suspended. */
1721:..\Source/tasks.c **** 					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1641              		.loc 1 1721 0
 1642 002c FB68     		ldr	r3, [r7, #12]
 1643 002e 0433     		adds	r3, r3, #4
 1644 0030 1846     		mov	r0, r3
 1645 0032 FFF7FEFF 		bl	uxListRemove
1722:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1646              		.loc 1 1722 0
 1647 0036 FB68     		ldr	r3, [r7, #12]
 1648 0038 DB6A     		ldr	r3, [r3, #44]
 1649 003a 1A46     		mov	r2, r3
 1650 003c 0123     		movs	r3, #1
 1651 003e 03FA02F2 		lsl	r2, r3, r2
 1652 0042 144B     		ldr	r3, .L112+4
 1653 0044 1B68     		ldr	r3, [r3]
 1654 0046 1343     		orrs	r3, r3, r2
 1655 0048 124A     		ldr	r2, .L112+4
 1656 004a 1360     		str	r3, [r2]
 1657 004c FB68     		ldr	r3, [r7, #12]
 1658 004e DA6A     		ldr	r2, [r3, #44]
 1659 0050 1346     		mov	r3, r2
 1660 0052 9B00     		lsls	r3, r3, #2
 1661 0054 1344     		add	r3, r3, r2
 1662 0056 9B00     		lsls	r3, r3, #2
 1663 0058 0F4A     		ldr	r2, .L112+8
 1664 005a 1A44     		add	r2, r2, r3
 1665 005c FB68     		ldr	r3, [r7, #12]
 1666 005e 0433     		adds	r3, r3, #4
 1667 0060 1046     		mov	r0, r2
 1668 0062 1946     		mov	r1, r3
 1669 0064 FFF7FEFF 		bl	vListInsertEnd
1723:..\Source/tasks.c **** 
1724:..\Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1725:..\Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1670              		.loc 1 1725 0
 1671 0068 FB68     		ldr	r3, [r7, #12]
 1672 006a DA6A     		ldr	r2, [r3, #44]
 1673 006c 084B     		ldr	r3, .L112
 1674 006e 1B68     		ldr	r3, [r3]
 1675 0070 DB6A     		ldr	r3, [r3, #44]
 1676 0072 9A42     		cmp	r2, r3
 1677 0074 07D3     		bcc	.L111
1726:..\Source/tasks.c **** 					{
1727:..\Source/tasks.c **** 						/* This yield may not cause the task just resumed to run,
1728:..\Source/tasks.c **** 						but will leave the lists in the correct state for the
1729:..\Source/tasks.c **** 						next yield. */
1730:..\Source/tasks.c **** 						taskYIELD_IF_USING_PREEMPTION();
 1678              		.loc 1 1730 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 66


 1679 0076 094B     		ldr	r3, .L112+12
 1680 0078 4FF08052 		mov	r2, #268435456
 1681 007c 1A60     		str	r2, [r3]
 1682              	@ 1730 "..\Source\tasks.c" 1
 1683 007e BFF34F8F 		dsb
 1684              	@ 0 "" 2
 1685              	@ 1730 "..\Source\tasks.c" 1
 1686 0082 BFF36F8F 		isb
 1687              	@ 0 "" 2
 1688              		.thumb
 1689              	.L111:
1731:..\Source/tasks.c **** 					}
1732:..\Source/tasks.c **** 					else
1733:..\Source/tasks.c **** 					{
1734:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1735:..\Source/tasks.c **** 					}
1736:..\Source/tasks.c **** 				}
1737:..\Source/tasks.c **** 				else
1738:..\Source/tasks.c **** 				{
1739:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
1740:..\Source/tasks.c **** 				}
1741:..\Source/tasks.c **** 			}
1742:..\Source/tasks.c **** 			taskEXIT_CRITICAL();
 1690              		.loc 1 1742 0
 1691 0086 FFF7FEFF 		bl	vPortExitCritical
 1692              	.L109:
1743:..\Source/tasks.c **** 		}
1744:..\Source/tasks.c **** 		else
1745:..\Source/tasks.c **** 		{
1746:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1747:..\Source/tasks.c **** 		}
1748:..\Source/tasks.c **** 	}
 1693              		.loc 1 1748 0
 1694 008a 1037     		adds	r7, r7, #16
 1695              		.cfi_def_cfa_offset 8
 1696 008c BD46     		mov	sp, r7
 1697              		.cfi_def_cfa_register 13
 1698              		@ sp needed
 1699 008e 80BD     		pop	{r7, pc}
 1700              	.L113:
 1701              		.align	2
 1702              	.L112:
 1703 0090 00000000 		.word	pxCurrentTCB
 1704 0094 E0000000 		.word	uxTopReadyPriority
 1705 0098 04000000 		.word	pxReadyTasksLists
 1706 009c 04ED00E0 		.word	-536810236
 1707              		.cfi_endproc
 1708              	.LFE80:
 1709              		.size	vTaskResume, .-vTaskResume
 1710              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1711              		.align	2
 1712              		.global	xTaskResumeFromISR
 1713              		.thumb
 1714              		.thumb_func
 1715              		.type	xTaskResumeFromISR, %function
 1716              	xTaskResumeFromISR:
 1717              	.LFB81:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 67


1749:..\Source/tasks.c **** 
1750:..\Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1751:..\Source/tasks.c **** 
1752:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1753:..\Source/tasks.c **** 
1754:..\Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1755:..\Source/tasks.c **** 
1756:..\Source/tasks.c **** 	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1757:..\Source/tasks.c **** 	{
 1718              		.loc 1 1757 0
 1719              		.cfi_startproc
 1720              		@ args = 0, pretend = 0, frame = 32
 1721              		@ frame_needed = 1, uses_anonymous_args = 0
 1722 0000 80B5     		push	{r7, lr}
 1723              		.cfi_def_cfa_offset 8
 1724              		.cfi_offset 7, -8
 1725              		.cfi_offset 14, -4
 1726 0002 88B0     		sub	sp, sp, #32
 1727              		.cfi_def_cfa_offset 40
 1728 0004 00AF     		add	r7, sp, #0
 1729              		.cfi_def_cfa_register 7
 1730 0006 7860     		str	r0, [r7, #4]
1758:..\Source/tasks.c **** 	BaseType_t xYieldRequired = pdFALSE;
 1731              		.loc 1 1758 0
 1732 0008 0023     		movs	r3, #0
 1733 000a FB61     		str	r3, [r7, #28]
1759:..\Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1734              		.loc 1 1759 0
 1735 000c 7B68     		ldr	r3, [r7, #4]
 1736 000e BB61     		str	r3, [r7, #24]
 1737              	.LBB33:
 1738              	.LBB34:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1739              		.loc 2 253 0
 1740              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1741 0010 EFF31182 			mrs r2, basepri											
 1742 0014 4FF0A003 		mov r3, #160												
 1743 0018 83F31188 		msr basepri, r3											
 1744 001c BFF36F8F 		isb														
 1745 0020 BFF34F8F 		dsb														
 1746              	
 1747              	@ 0 "" 2
 1748              		.thumb
 1749 0024 3A61     		str	r2, [r7, #16]
 1750 0026 FB60     		str	r3, [r7, #12]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1751              		.loc 2 265 0
 1752 0028 3B69     		ldr	r3, [r7, #16]
 1753              	.LBE34:
 1754              	.LBE33:
1760:..\Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
1761:..\Source/tasks.c **** 
1762:..\Source/tasks.c **** 		configASSERT( xTaskToResume );
1763:..\Source/tasks.c **** 
1764:..\Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
1765:..\Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
1766:..\Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 68


1767:..\Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
1768:..\Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1769:..\Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
1770:..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1771:..\Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
1772:..\Source/tasks.c **** 		been assigned a priority above the configured maximum system call
1773:..\Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
1774:..\Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
1775:..\Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
1776:..\Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
1777:..\Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
1778:..\Source/tasks.c **** 		provided on the following link:
1779:..\Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1780:..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1781:..\Source/tasks.c **** 
1782:..\Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1755              		.loc 1 1782 0
 1756 002a 7B61     		str	r3, [r7, #20]
1783:..\Source/tasks.c **** 		{
1784:..\Source/tasks.c **** 			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1757              		.loc 1 1784 0
 1758 002c B869     		ldr	r0, [r7, #24]
 1759 002e FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1760 0032 0346     		mov	r3, r0
 1761 0034 002B     		cmp	r3, #0
 1762 0036 31D0     		beq	.L116
1785:..\Source/tasks.c **** 			{
1786:..\Source/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1787:..\Source/tasks.c **** 
1788:..\Source/tasks.c **** 				/* Check the ready lists can be accessed. */
1789:..\Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1763              		.loc 1 1789 0
 1764 0038 1D4B     		ldr	r3, .L121
 1765 003a 1B68     		ldr	r3, [r3]
 1766 003c 002B     		cmp	r3, #0
 1767 003e 27D1     		bne	.L117
1790:..\Source/tasks.c **** 				{
1791:..\Source/tasks.c **** 					/* Ready lists can be accessed so move the task from the
1792:..\Source/tasks.c **** 					suspended list to the ready list directly. */
1793:..\Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1768              		.loc 1 1793 0
 1769 0040 BB69     		ldr	r3, [r7, #24]
 1770 0042 DA6A     		ldr	r2, [r3, #44]
 1771 0044 1B4B     		ldr	r3, .L121+4
 1772 0046 1B68     		ldr	r3, [r3]
 1773 0048 DB6A     		ldr	r3, [r3, #44]
 1774 004a 9A42     		cmp	r2, r3
 1775 004c 01D3     		bcc	.L118
1794:..\Source/tasks.c **** 					{
1795:..\Source/tasks.c **** 						xYieldRequired = pdTRUE;
 1776              		.loc 1 1795 0
 1777 004e 0123     		movs	r3, #1
 1778 0050 FB61     		str	r3, [r7, #28]
 1779              	.L118:
1796:..\Source/tasks.c **** 					}
1797:..\Source/tasks.c **** 					else
1798:..\Source/tasks.c **** 					{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 69


1799:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
1800:..\Source/tasks.c **** 					}
1801:..\Source/tasks.c **** 
1802:..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1780              		.loc 1 1802 0
 1781 0052 BB69     		ldr	r3, [r7, #24]
 1782 0054 0433     		adds	r3, r3, #4
 1783 0056 1846     		mov	r0, r3
 1784 0058 FFF7FEFF 		bl	uxListRemove
1803:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 1785              		.loc 1 1803 0
 1786 005c BB69     		ldr	r3, [r7, #24]
 1787 005e DB6A     		ldr	r3, [r3, #44]
 1788 0060 1A46     		mov	r2, r3
 1789 0062 0123     		movs	r3, #1
 1790 0064 03FA02F2 		lsl	r2, r3, r2
 1791 0068 134B     		ldr	r3, .L121+8
 1792 006a 1B68     		ldr	r3, [r3]
 1793 006c 1343     		orrs	r3, r3, r2
 1794 006e 124A     		ldr	r2, .L121+8
 1795 0070 1360     		str	r3, [r2]
 1796 0072 BB69     		ldr	r3, [r7, #24]
 1797 0074 DA6A     		ldr	r2, [r3, #44]
 1798 0076 1346     		mov	r3, r2
 1799 0078 9B00     		lsls	r3, r3, #2
 1800 007a 1344     		add	r3, r3, r2
 1801 007c 9B00     		lsls	r3, r3, #2
 1802 007e 0F4A     		ldr	r2, .L121+12
 1803 0080 1A44     		add	r2, r2, r3
 1804 0082 BB69     		ldr	r3, [r7, #24]
 1805 0084 0433     		adds	r3, r3, #4
 1806 0086 1046     		mov	r0, r2
 1807 0088 1946     		mov	r1, r3
 1808 008a FFF7FEFF 		bl	vListInsertEnd
 1809 008e 05E0     		b	.L116
 1810              	.L117:
1804:..\Source/tasks.c **** 				}
1805:..\Source/tasks.c **** 				else
1806:..\Source/tasks.c **** 				{
1807:..\Source/tasks.c **** 					/* The delayed or ready lists cannot be accessed so the task
1808:..\Source/tasks.c **** 					is held in the pending ready list until the scheduler is
1809:..\Source/tasks.c **** 					unsuspended. */
1810:..\Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1811              		.loc 1 1810 0
 1812 0090 BB69     		ldr	r3, [r7, #24]
 1813 0092 1833     		adds	r3, r3, #24
 1814 0094 0A48     		ldr	r0, .L121+16
 1815 0096 1946     		mov	r1, r3
 1816 0098 FFF7FEFF 		bl	vListInsertEnd
 1817              	.L116:
 1818 009c 7B69     		ldr	r3, [r7, #20]
 1819 009e BB60     		str	r3, [r7, #8]
 1820              	.LBB35:
 1821              	.LBB36:
 1822              		.loc 2 271 0
 1823 00a0 BB68     		ldr	r3, [r7, #8]
 1824              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 70


 1825 00a2 83F31188 			msr basepri, r3	
 1826              	@ 0 "" 2
 1827              		.thumb
 1828              	.LBE36:
 1829              	.LBE35:
1811:..\Source/tasks.c **** 				}
1812:..\Source/tasks.c **** 			}
1813:..\Source/tasks.c **** 			else
1814:..\Source/tasks.c **** 			{
1815:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
1816:..\Source/tasks.c **** 			}
1817:..\Source/tasks.c **** 		}
1818:..\Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1819:..\Source/tasks.c **** 
1820:..\Source/tasks.c **** 		return xYieldRequired;
 1830              		.loc 1 1820 0
 1831 00a6 FB69     		ldr	r3, [r7, #28]
1821:..\Source/tasks.c **** 	}
 1832              		.loc 1 1821 0
 1833 00a8 1846     		mov	r0, r3
 1834 00aa 2037     		adds	r7, r7, #32
 1835              		.cfi_def_cfa_offset 8
 1836 00ac BD46     		mov	sp, r7
 1837              		.cfi_def_cfa_register 13
 1838              		@ sp needed
 1839 00ae 80BD     		pop	{r7, pc}
 1840              	.L122:
 1841              		.align	2
 1842              	.L121:
 1843 00b0 00010000 		.word	uxSchedulerSuspended
 1844 00b4 00000000 		.word	pxCurrentTCB
 1845 00b8 E0000000 		.word	uxTopReadyPriority
 1846 00bc 04000000 		.word	pxReadyTasksLists
 1847 00c0 98000000 		.word	xPendingReadyList
 1848              		.cfi_endproc
 1849              	.LFE81:
 1850              		.size	xTaskResumeFromISR, .-xTaskResumeFromISR
 1851              		.section	.rodata
 1852              		.align	2
 1853              	.LC0:
 1854 0000 49444C45 		.ascii	"IDLE\000"
 1854      00
 1855 0005 000000   		.section	.text.vTaskStartScheduler,"ax",%progbits
 1856              		.align	2
 1857              		.global	vTaskStartScheduler
 1858              		.thumb
 1859              		.thumb_func
 1860              		.type	vTaskStartScheduler, %function
 1861              	vTaskStartScheduler:
 1862              	.LFB82:
1822:..\Source/tasks.c **** 
1823:..\Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1824:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1825:..\Source/tasks.c **** 
1826:..\Source/tasks.c **** void vTaskStartScheduler( void )
1827:..\Source/tasks.c **** {
 1863              		.loc 1 1827 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 71


 1864              		.cfi_startproc
 1865              		@ args = 0, pretend = 0, frame = 8
 1866              		@ frame_needed = 1, uses_anonymous_args = 0
 1867 0000 80B5     		push	{r7, lr}
 1868              		.cfi_def_cfa_offset 8
 1869              		.cfi_offset 7, -8
 1870              		.cfi_offset 14, -4
 1871 0002 84B0     		sub	sp, sp, #16
 1872              		.cfi_def_cfa_offset 24
 1873 0004 02AF     		add	r7, sp, #8
 1874              		.cfi_def_cfa 7, 16
1828:..\Source/tasks.c **** BaseType_t xReturn;
1829:..\Source/tasks.c **** 
1830:..\Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1831:..\Source/tasks.c **** 	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
1832:..\Source/tasks.c **** 	{
1833:..\Source/tasks.c **** 		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
1834:..\Source/tasks.c **** 		StackType_t *pxIdleTaskStackBuffer = NULL;
1835:..\Source/tasks.c **** 		uint32_t ulIdleTaskStackSize;
1836:..\Source/tasks.c **** 
1837:..\Source/tasks.c **** 		/* The Idle task is created using user provided RAM - obtain the
1838:..\Source/tasks.c **** 		address of the RAM then create the idle task. */
1839:..\Source/tasks.c **** 		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize
1840:..\Source/tasks.c **** 		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
1841:..\Source/tasks.c **** 												"IDLE",
1842:..\Source/tasks.c **** 												ulIdleTaskStackSize,
1843:..\Source/tasks.c **** 												( void * ) NULL,
1844:..\Source/tasks.c **** 												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1845:..\Source/tasks.c **** 												pxIdleTaskStackBuffer,
1846:..\Source/tasks.c **** 												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant
1847:..\Source/tasks.c **** 
1848:..\Source/tasks.c **** 		if( xIdleTaskHandle != NULL )
1849:..\Source/tasks.c **** 		{
1850:..\Source/tasks.c **** 			xReturn = pdPASS;
1851:..\Source/tasks.c **** 		}
1852:..\Source/tasks.c **** 		else
1853:..\Source/tasks.c **** 		{
1854:..\Source/tasks.c **** 			xReturn = pdFAIL;
1855:..\Source/tasks.c **** 		}
1856:..\Source/tasks.c **** 	}
1857:..\Source/tasks.c **** 	#else
1858:..\Source/tasks.c **** 	{
1859:..\Source/tasks.c **** 		/* The Idle task is being created using dynamically allocated RAM. */
1860:..\Source/tasks.c **** 		xReturn = xTaskCreate(	prvIdleTask,
 1875              		.loc 1 1860 0
 1876 0006 0023     		movs	r3, #0
 1877 0008 0093     		str	r3, [sp]
 1878 000a 124B     		ldr	r3, .L125
 1879 000c 0193     		str	r3, [sp, #4]
 1880 000e 1248     		ldr	r0, .L125+4
 1881 0010 1249     		ldr	r1, .L125+8
 1882 0012 6422     		movs	r2, #100
 1883 0014 0023     		movs	r3, #0
 1884 0016 FFF7FEFF 		bl	xTaskCreate
 1885 001a 7860     		str	r0, [r7, #4]
1861:..\Source/tasks.c **** 								"IDLE", configMINIMAL_STACK_SIZE,
1862:..\Source/tasks.c **** 								( void * ) NULL,
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 72


1863:..\Source/tasks.c **** 								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
1864:..\Source/tasks.c **** 								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explic
1865:..\Source/tasks.c **** 	}
1866:..\Source/tasks.c **** 	#endif /* configSUPPORT_STATIC_ALLOCATION */
1867:..\Source/tasks.c **** 
1868:..\Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1869:..\Source/tasks.c **** 	{
1870:..\Source/tasks.c **** 		if( xReturn == pdPASS )
1871:..\Source/tasks.c **** 		{
1872:..\Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1873:..\Source/tasks.c **** 		}
1874:..\Source/tasks.c **** 		else
1875:..\Source/tasks.c **** 		{
1876:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
1877:..\Source/tasks.c **** 		}
1878:..\Source/tasks.c **** 	}
1879:..\Source/tasks.c **** 	#endif /* configUSE_TIMERS */
1880:..\Source/tasks.c **** 
1881:..\Source/tasks.c **** 	if( xReturn == pdPASS )
 1886              		.loc 1 1881 0
 1887 001c 7B68     		ldr	r3, [r7, #4]
 1888 001e 012B     		cmp	r3, #1
 1889 0020 14D1     		bne	.L123
 1890              	.LBB37:
 1891              	.LBB38:
 237:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1892              		.loc 2 237 0
 1893              	@ 237 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1894 0022 4FF0A003 			mov r3, #160												
 1895 0026 83F31188 		msr basepri, r3											
 1896 002a BFF36F8F 		isb														
 1897 002e BFF34F8F 		dsb														
 1898              	
 1899              	@ 0 "" 2
 1900              		.thumb
 1901 0032 3B60     		str	r3, [r7]
 1902              	.LBE38:
 1903              	.LBE37:
1882:..\Source/tasks.c **** 	{
1883:..\Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1884:..\Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1885:..\Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1886:..\Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1887:..\Source/tasks.c **** 		starts to run. */
1888:..\Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1889:..\Source/tasks.c **** 
1890:..\Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1891:..\Source/tasks.c **** 		{
1892:..\Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
1893:..\Source/tasks.c **** 			structure specific to the task that will run first. */
1894:..\Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1895:..\Source/tasks.c **** 		}
1896:..\Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
1897:..\Source/tasks.c **** 
1898:..\Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 1904              		.loc 1 1898 0
 1905 0034 0A4B     		ldr	r3, .L125+12
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 73


 1906 0036 4FF0FF32 		mov	r2, #-1
 1907 003a 1A60     		str	r2, [r3]
1899:..\Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1908              		.loc 1 1899 0
 1909 003c 094B     		ldr	r3, .L125+16
 1910 003e 0122     		movs	r2, #1
 1911 0040 1A60     		str	r2, [r3]
1900:..\Source/tasks.c **** 		xTickCount = ( TickType_t ) 0U;
 1912              		.loc 1 1900 0
 1913 0042 094B     		ldr	r3, .L125+20
 1914 0044 0022     		movs	r2, #0
 1915 0046 1A60     		str	r2, [r3]
1901:..\Source/tasks.c **** 
1902:..\Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1903:..\Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1904:..\Source/tasks.c **** 		the run time counter time base. */
1905:..\Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1906:..\Source/tasks.c **** 
1907:..\Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1908:..\Source/tasks.c **** 		portable interface. */
1909:..\Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 1916              		.loc 1 1909 0
 1917 0048 FFF7FEFF 		bl	xPortStartScheduler
 1918              	.L123:
1910:..\Source/tasks.c **** 		{
1911:..\Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1912:..\Source/tasks.c **** 			function will not return. */
1913:..\Source/tasks.c **** 		}
1914:..\Source/tasks.c **** 		else
1915:..\Source/tasks.c **** 		{
1916:..\Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1917:..\Source/tasks.c **** 		}
1918:..\Source/tasks.c **** 	}
1919:..\Source/tasks.c **** 	else
1920:..\Source/tasks.c **** 	{
1921:..\Source/tasks.c **** 		/* This line will only be reached if the kernel could not be started,
1922:..\Source/tasks.c **** 		because there was not enough FreeRTOS heap to create the idle task
1923:..\Source/tasks.c **** 		or the timer task. */
1924:..\Source/tasks.c **** 		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
1925:..\Source/tasks.c **** 	}
1926:..\Source/tasks.c **** 
1927:..\Source/tasks.c **** 	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
1928:..\Source/tasks.c **** 	meaning xIdleTaskHandle is not used anywhere else. */
1929:..\Source/tasks.c **** 	( void ) xIdleTaskHandle;
1930:..\Source/tasks.c **** }
 1919              		.loc 1 1930 0
 1920 004c 0837     		adds	r7, r7, #8
 1921              		.cfi_def_cfa_offset 8
 1922 004e BD46     		mov	sp, r7
 1923              		.cfi_def_cfa_register 13
 1924              		@ sp needed
 1925 0050 80BD     		pop	{r7, pc}
 1926              	.L126:
 1927 0052 00BF     		.align	2
 1928              	.L125:
 1929 0054 FC000000 		.word	xIdleTaskHandle
 1930 0058 00000000 		.word	prvIdleTask
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 74


 1931 005c 00000000 		.word	.LC0
 1932 0060 F8000000 		.word	xNextTaskUnblockTime
 1933 0064 E4000000 		.word	xSchedulerRunning
 1934 0068 DC000000 		.word	xTickCount
 1935              		.cfi_endproc
 1936              	.LFE82:
 1937              		.size	vTaskStartScheduler, .-vTaskStartScheduler
 1938              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1939              		.align	2
 1940              		.global	vTaskEndScheduler
 1941              		.thumb
 1942              		.thumb_func
 1943              		.type	vTaskEndScheduler, %function
 1944              	vTaskEndScheduler:
 1945              	.LFB83:
1931:..\Source/tasks.c **** /*-----------------------------------------------------------*/
1932:..\Source/tasks.c **** 
1933:..\Source/tasks.c **** void vTaskEndScheduler( void )
1934:..\Source/tasks.c **** {
 1946              		.loc 1 1934 0
 1947              		.cfi_startproc
 1948              		@ args = 0, pretend = 0, frame = 8
 1949              		@ frame_needed = 1, uses_anonymous_args = 0
 1950 0000 80B5     		push	{r7, lr}
 1951              		.cfi_def_cfa_offset 8
 1952              		.cfi_offset 7, -8
 1953              		.cfi_offset 14, -4
 1954 0002 82B0     		sub	sp, sp, #8
 1955              		.cfi_def_cfa_offset 16
 1956 0004 00AF     		add	r7, sp, #0
 1957              		.cfi_def_cfa_register 7
 1958              	.LBB39:
 1959              	.LBB40:
 237:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1960              		.loc 2 237 0
 1961              	@ 237 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1962 0006 4FF0A003 			mov r3, #160												
 1963 000a 83F31188 		msr basepri, r3											
 1964 000e BFF36F8F 		isb														
 1965 0012 BFF34F8F 		dsb														
 1966              	
 1967              	@ 0 "" 2
 1968              		.thumb
 1969 0016 7B60     		str	r3, [r7, #4]
 1970              	.LBE40:
 1971              	.LBE39:
1935:..\Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1936:..\Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1937:..\Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1938:..\Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1939:..\Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1972              		.loc 1 1939 0
 1973 0018 034B     		ldr	r3, .L128
 1974 001a 0022     		movs	r2, #0
 1975 001c 1A60     		str	r2, [r3]
1940:..\Source/tasks.c **** 	vPortEndScheduler();
 1976              		.loc 1 1940 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 75


 1977 001e FFF7FEFF 		bl	vPortEndScheduler
1941:..\Source/tasks.c **** }
 1978              		.loc 1 1941 0
 1979 0022 0837     		adds	r7, r7, #8
 1980              		.cfi_def_cfa_offset 8
 1981 0024 BD46     		mov	sp, r7
 1982              		.cfi_def_cfa_register 13
 1983              		@ sp needed
 1984 0026 80BD     		pop	{r7, pc}
 1985              	.L129:
 1986              		.align	2
 1987              	.L128:
 1988 0028 E4000000 		.word	xSchedulerRunning
 1989              		.cfi_endproc
 1990              	.LFE83:
 1991              		.size	vTaskEndScheduler, .-vTaskEndScheduler
 1992              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1993              		.align	2
 1994              		.global	vTaskSuspendAll
 1995              		.thumb
 1996              		.thumb_func
 1997              		.type	vTaskSuspendAll, %function
 1998              	vTaskSuspendAll:
 1999              	.LFB84:
1942:..\Source/tasks.c **** /*----------------------------------------------------------*/
1943:..\Source/tasks.c **** 
1944:..\Source/tasks.c **** void vTaskSuspendAll( void )
1945:..\Source/tasks.c **** {
 2000              		.loc 1 1945 0
 2001              		.cfi_startproc
 2002              		@ args = 0, pretend = 0, frame = 0
 2003              		@ frame_needed = 1, uses_anonymous_args = 0
 2004              		@ link register save eliminated.
 2005 0000 80B4     		push	{r7}
 2006              		.cfi_def_cfa_offset 4
 2007              		.cfi_offset 7, -4
 2008 0002 00AF     		add	r7, sp, #0
 2009              		.cfi_def_cfa_register 7
1946:..\Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1947:..\Source/tasks.c **** 	BaseType_t.  Please read Richard Barry's reply in the following link to a
1948:..\Source/tasks.c **** 	post in the FreeRTOS support forum before reporting this as a bug! -
1949:..\Source/tasks.c **** 	http://goo.gl/wu4acr */
1950:..\Source/tasks.c **** 	++uxSchedulerSuspended;
 2010              		.loc 1 1950 0
 2011 0004 044B     		ldr	r3, .L131
 2012 0006 1B68     		ldr	r3, [r3]
 2013 0008 0133     		adds	r3, r3, #1
 2014 000a 034A     		ldr	r2, .L131
 2015 000c 1360     		str	r3, [r2]
1951:..\Source/tasks.c **** }
 2016              		.loc 1 1951 0
 2017 000e BD46     		mov	sp, r7
 2018              		.cfi_def_cfa_register 13
 2019              		@ sp needed
 2020 0010 5DF8047B 		ldr	r7, [sp], #4
 2021              		.cfi_restore 7
 2022              		.cfi_def_cfa_offset 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 76


 2023 0014 7047     		bx	lr
 2024              	.L132:
 2025 0016 00BF     		.align	2
 2026              	.L131:
 2027 0018 00010000 		.word	uxSchedulerSuspended
 2028              		.cfi_endproc
 2029              	.LFE84:
 2030              		.size	vTaskSuspendAll, .-vTaskSuspendAll
 2031              		.section	.text.xTaskResumeAll,"ax",%progbits
 2032              		.align	2
 2033              		.global	xTaskResumeAll
 2034              		.thumb
 2035              		.thumb_func
 2036              		.type	xTaskResumeAll, %function
 2037              	xTaskResumeAll:
 2038              	.LFB85:
1952:..\Source/tasks.c **** /*----------------------------------------------------------*/
1953:..\Source/tasks.c **** 
1954:..\Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
1955:..\Source/tasks.c **** 
1956:..\Source/tasks.c **** 	static TickType_t prvGetExpectedIdleTime( void )
1957:..\Source/tasks.c **** 	{
1958:..\Source/tasks.c **** 	TickType_t xReturn;
1959:..\Source/tasks.c **** 	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
1960:..\Source/tasks.c **** 
1961:..\Source/tasks.c **** 		/* uxHigherPriorityReadyTasks takes care of the case where
1962:..\Source/tasks.c **** 		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
1963:..\Source/tasks.c **** 		task that are in the Ready state, even though the idle task is
1964:..\Source/tasks.c **** 		running. */
1965:..\Source/tasks.c **** 		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
1966:..\Source/tasks.c **** 		{
1967:..\Source/tasks.c **** 			if( uxTopReadyPriority > tskIDLE_PRIORITY )
1968:..\Source/tasks.c **** 			{
1969:..\Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
1970:..\Source/tasks.c **** 			}
1971:..\Source/tasks.c **** 		}
1972:..\Source/tasks.c **** 		#else
1973:..\Source/tasks.c **** 		{
1974:..\Source/tasks.c **** 			const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
1975:..\Source/tasks.c **** 
1976:..\Source/tasks.c **** 			/* When port optimised task selection is used the uxTopReadyPriority
1977:..\Source/tasks.c **** 			variable is used as a bit map.  If bits other than the least
1978:..\Source/tasks.c **** 			significant bit are set then there are tasks that have a priority
1979:..\Source/tasks.c **** 			above the idle priority that are in the Ready state.  This takes
1980:..\Source/tasks.c **** 			care of the case where the co-operative scheduler is in use. */
1981:..\Source/tasks.c **** 			if( uxTopReadyPriority > uxLeastSignificantBit )
1982:..\Source/tasks.c **** 			{
1983:..\Source/tasks.c **** 				uxHigherPriorityReadyTasks = pdTRUE;
1984:..\Source/tasks.c **** 			}
1985:..\Source/tasks.c **** 		}
1986:..\Source/tasks.c **** 		#endif
1987:..\Source/tasks.c **** 
1988:..\Source/tasks.c **** 		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1989:..\Source/tasks.c **** 		{
1990:..\Source/tasks.c **** 			xReturn = 0;
1991:..\Source/tasks.c **** 		}
1992:..\Source/tasks.c **** 		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 77


1993:..\Source/tasks.c **** 		{
1994:..\Source/tasks.c **** 			/* There are other idle priority tasks in the ready state.  If
1995:..\Source/tasks.c **** 			time slicing is used then the very next tick interrupt must be
1996:..\Source/tasks.c **** 			processed. */
1997:..\Source/tasks.c **** 			xReturn = 0;
1998:..\Source/tasks.c **** 		}
1999:..\Source/tasks.c **** 		else if( uxHigherPriorityReadyTasks != pdFALSE )
2000:..\Source/tasks.c **** 		{
2001:..\Source/tasks.c **** 			/* There are tasks in the Ready state that have a priority above the
2002:..\Source/tasks.c **** 			idle priority.  This path can only be reached if
2003:..\Source/tasks.c **** 			configUSE_PREEMPTION is 0. */
2004:..\Source/tasks.c **** 			xReturn = 0;
2005:..\Source/tasks.c **** 		}
2006:..\Source/tasks.c **** 		else
2007:..\Source/tasks.c **** 		{
2008:..\Source/tasks.c **** 			xReturn = xNextTaskUnblockTime - xTickCount;
2009:..\Source/tasks.c **** 		}
2010:..\Source/tasks.c **** 
2011:..\Source/tasks.c **** 		return xReturn;
2012:..\Source/tasks.c **** 	}
2013:..\Source/tasks.c **** 
2014:..\Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2015:..\Source/tasks.c **** /*----------------------------------------------------------*/
2016:..\Source/tasks.c **** 
2017:..\Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2018:..\Source/tasks.c **** {
 2039              		.loc 1 2018 0
 2040              		.cfi_startproc
 2041              		@ args = 0, pretend = 0, frame = 16
 2042              		@ frame_needed = 1, uses_anonymous_args = 0
 2043 0000 80B5     		push	{r7, lr}
 2044              		.cfi_def_cfa_offset 8
 2045              		.cfi_offset 7, -8
 2046              		.cfi_offset 14, -4
 2047 0002 84B0     		sub	sp, sp, #16
 2048              		.cfi_def_cfa_offset 24
 2049 0004 00AF     		add	r7, sp, #0
 2050              		.cfi_def_cfa_register 7
2019:..\Source/tasks.c **** TCB_t *pxTCB = NULL;
 2051              		.loc 1 2019 0
 2052 0006 0023     		movs	r3, #0
 2053 0008 FB60     		str	r3, [r7, #12]
2020:..\Source/tasks.c **** BaseType_t xAlreadyYielded = pdFALSE;
 2054              		.loc 1 2020 0
 2055 000a 0023     		movs	r3, #0
 2056 000c BB60     		str	r3, [r7, #8]
2021:..\Source/tasks.c **** 
2022:..\Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
2023:..\Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
2024:..\Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
2025:..\Source/tasks.c **** 
2026:..\Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
2027:..\Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
2028:..\Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
2029:..\Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
2030:..\Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
2031:..\Source/tasks.c **** 	taskENTER_CRITICAL();
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 78


 2057              		.loc 1 2031 0
 2058 000e FFF7FEFF 		bl	vPortEnterCritical
2032:..\Source/tasks.c **** 	{
2033:..\Source/tasks.c **** 		--uxSchedulerSuspended;
 2059              		.loc 1 2033 0
 2060 0012 3A4B     		ldr	r3, .L142
 2061 0014 1B68     		ldr	r3, [r3]
 2062 0016 013B     		subs	r3, r3, #1
 2063 0018 384A     		ldr	r2, .L142
 2064 001a 1360     		str	r3, [r2]
2034:..\Source/tasks.c **** 
2035:..\Source/tasks.c **** 		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2065              		.loc 1 2035 0
 2066 001c 374B     		ldr	r3, .L142
 2067 001e 1B68     		ldr	r3, [r3]
 2068 0020 002B     		cmp	r3, #0
 2069 0022 63D1     		bne	.L134
2036:..\Source/tasks.c **** 		{
2037:..\Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 2070              		.loc 1 2037 0
 2071 0024 364B     		ldr	r3, .L142+4
 2072 0026 1B68     		ldr	r3, [r3]
 2073 0028 002B     		cmp	r3, #0
 2074 002a 5FD0     		beq	.L134
2038:..\Source/tasks.c **** 			{
2039:..\Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
2040:..\Source/tasks.c **** 				appropriate ready list. */
2041:..\Source/tasks.c **** 				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2075              		.loc 1 2041 0
 2076 002c 30E0     		b	.L135
 2077              	.L136:
2042:..\Source/tasks.c **** 				{
2043:..\Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 2078              		.loc 1 2043 0
 2079 002e 354B     		ldr	r3, .L142+8
 2080 0030 DB68     		ldr	r3, [r3, #12]
 2081 0032 DB68     		ldr	r3, [r3, #12]
 2082 0034 FB60     		str	r3, [r7, #12]
2044:..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2083              		.loc 1 2044 0
 2084 0036 FB68     		ldr	r3, [r7, #12]
 2085 0038 1833     		adds	r3, r3, #24
 2086 003a 1846     		mov	r0, r3
 2087 003c FFF7FEFF 		bl	uxListRemove
2045:..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2088              		.loc 1 2045 0
 2089 0040 FB68     		ldr	r3, [r7, #12]
 2090 0042 0433     		adds	r3, r3, #4
 2091 0044 1846     		mov	r0, r3
 2092 0046 FFF7FEFF 		bl	uxListRemove
2046:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2093              		.loc 1 2046 0
 2094 004a FB68     		ldr	r3, [r7, #12]
 2095 004c DB6A     		ldr	r3, [r3, #44]
 2096 004e 1A46     		mov	r2, r3
 2097 0050 0123     		movs	r3, #1
 2098 0052 03FA02F2 		lsl	r2, r3, r2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 79


 2099 0056 2C4B     		ldr	r3, .L142+12
 2100 0058 1B68     		ldr	r3, [r3]
 2101 005a 1343     		orrs	r3, r3, r2
 2102 005c 2A4A     		ldr	r2, .L142+12
 2103 005e 1360     		str	r3, [r2]
 2104 0060 FB68     		ldr	r3, [r7, #12]
 2105 0062 DA6A     		ldr	r2, [r3, #44]
 2106 0064 1346     		mov	r3, r2
 2107 0066 9B00     		lsls	r3, r3, #2
 2108 0068 1344     		add	r3, r3, r2
 2109 006a 9B00     		lsls	r3, r3, #2
 2110 006c 274A     		ldr	r2, .L142+16
 2111 006e 1A44     		add	r2, r2, r3
 2112 0070 FB68     		ldr	r3, [r7, #12]
 2113 0072 0433     		adds	r3, r3, #4
 2114 0074 1046     		mov	r0, r2
 2115 0076 1946     		mov	r1, r3
 2116 0078 FFF7FEFF 		bl	vListInsertEnd
2047:..\Source/tasks.c **** 
2048:..\Source/tasks.c **** 					/* If the moved task has a priority higher than the current
2049:..\Source/tasks.c **** 					task then a yield must be performed. */
2050:..\Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2117              		.loc 1 2050 0
 2118 007c FB68     		ldr	r3, [r7, #12]
 2119 007e DA6A     		ldr	r2, [r3, #44]
 2120 0080 234B     		ldr	r3, .L142+20
 2121 0082 1B68     		ldr	r3, [r3]
 2122 0084 DB6A     		ldr	r3, [r3, #44]
 2123 0086 9A42     		cmp	r2, r3
 2124 0088 02D3     		bcc	.L135
2051:..\Source/tasks.c **** 					{
2052:..\Source/tasks.c **** 						xYieldPending = pdTRUE;
 2125              		.loc 1 2052 0
 2126 008a 224B     		ldr	r3, .L142+24
 2127 008c 0122     		movs	r2, #1
 2128 008e 1A60     		str	r2, [r3]
 2129              	.L135:
2041:..\Source/tasks.c **** 				{
 2130              		.loc 1 2041 0
 2131 0090 1C4B     		ldr	r3, .L142+8
 2132 0092 1B68     		ldr	r3, [r3]
 2133 0094 002B     		cmp	r3, #0
 2134 0096 CAD1     		bne	.L136
2053:..\Source/tasks.c **** 					}
2054:..\Source/tasks.c **** 					else
2055:..\Source/tasks.c **** 					{
2056:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2057:..\Source/tasks.c **** 					}
2058:..\Source/tasks.c **** 				}
2059:..\Source/tasks.c **** 
2060:..\Source/tasks.c **** 				if( pxTCB != NULL )
 2135              		.loc 1 2060 0
 2136 0098 FB68     		ldr	r3, [r7, #12]
 2137 009a 002B     		cmp	r3, #0
 2138 009c 01D0     		beq	.L137
2061:..\Source/tasks.c **** 				{
2062:..\Source/tasks.c **** 					/* A task was unblocked while the scheduler was suspended,
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 80


2063:..\Source/tasks.c **** 					which may have prevented the next unblock time from being
2064:..\Source/tasks.c **** 					re-calculated, in which case re-calculate it now.  Mainly
2065:..\Source/tasks.c **** 					important for low power tickless implementations, where
2066:..\Source/tasks.c **** 					this can prevent an unnecessary exit from low power
2067:..\Source/tasks.c **** 					state. */
2068:..\Source/tasks.c **** 					prvResetNextTaskUnblockTime();
 2139              		.loc 1 2068 0
 2140 009e FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2141              	.L137:
 2142              	.LBB41:
2069:..\Source/tasks.c **** 				}
2070:..\Source/tasks.c **** 
2071:..\Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
2072:..\Source/tasks.c **** 				they should be processed now.  This ensures the tick count does
2073:..\Source/tasks.c **** 				not	slip, and that any delayed tasks are resumed at the correct
2074:..\Source/tasks.c **** 				time. */
2075:..\Source/tasks.c **** 				{
2076:..\Source/tasks.c **** 					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 2143              		.loc 1 2076 0
 2144 00a2 1D4B     		ldr	r3, .L142+28
 2145 00a4 1B68     		ldr	r3, [r3]
 2146 00a6 7B60     		str	r3, [r7, #4]
2077:..\Source/tasks.c **** 
2078:..\Source/tasks.c **** 					if( uxPendedCounts > ( UBaseType_t ) 0U )
 2147              		.loc 1 2078 0
 2148 00a8 7B68     		ldr	r3, [r7, #4]
 2149 00aa 002B     		cmp	r3, #0
 2150 00ac 10D0     		beq	.L138
 2151              	.L140:
2079:..\Source/tasks.c **** 					{
2080:..\Source/tasks.c **** 						do
2081:..\Source/tasks.c **** 						{
2082:..\Source/tasks.c **** 							if( xTaskIncrementTick() != pdFALSE )
 2152              		.loc 1 2082 0
 2153 00ae FFF7FEFF 		bl	xTaskIncrementTick
 2154 00b2 0346     		mov	r3, r0
 2155 00b4 002B     		cmp	r3, #0
 2156 00b6 02D0     		beq	.L139
2083:..\Source/tasks.c **** 							{
2084:..\Source/tasks.c **** 								xYieldPending = pdTRUE;
 2157              		.loc 1 2084 0
 2158 00b8 164B     		ldr	r3, .L142+24
 2159 00ba 0122     		movs	r2, #1
 2160 00bc 1A60     		str	r2, [r3]
 2161              	.L139:
2085:..\Source/tasks.c **** 							}
2086:..\Source/tasks.c **** 							else
2087:..\Source/tasks.c **** 							{
2088:..\Source/tasks.c **** 								mtCOVERAGE_TEST_MARKER();
2089:..\Source/tasks.c **** 							}
2090:..\Source/tasks.c **** 							--uxPendedCounts;
 2162              		.loc 1 2090 0
 2163 00be 7B68     		ldr	r3, [r7, #4]
 2164 00c0 013B     		subs	r3, r3, #1
 2165 00c2 7B60     		str	r3, [r7, #4]
2091:..\Source/tasks.c **** 						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 2166              		.loc 1 2091 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 81


 2167 00c4 7B68     		ldr	r3, [r7, #4]
 2168 00c6 002B     		cmp	r3, #0
 2169 00c8 F1D1     		bne	.L140
2092:..\Source/tasks.c **** 
2093:..\Source/tasks.c **** 						uxPendedTicks = 0;
 2170              		.loc 1 2093 0
 2171 00ca 134B     		ldr	r3, .L142+28
 2172 00cc 0022     		movs	r2, #0
 2173 00ce 1A60     		str	r2, [r3]
 2174              	.L138:
 2175              	.LBE41:
2094:..\Source/tasks.c **** 					}
2095:..\Source/tasks.c **** 					else
2096:..\Source/tasks.c **** 					{
2097:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2098:..\Source/tasks.c **** 					}
2099:..\Source/tasks.c **** 				}
2100:..\Source/tasks.c **** 
2101:..\Source/tasks.c **** 				if( xYieldPending != pdFALSE )
 2176              		.loc 1 2101 0
 2177 00d0 104B     		ldr	r3, .L142+24
 2178 00d2 1B68     		ldr	r3, [r3]
 2179 00d4 002B     		cmp	r3, #0
 2180 00d6 09D0     		beq	.L134
2102:..\Source/tasks.c **** 				{
2103:..\Source/tasks.c **** 					#if( configUSE_PREEMPTION != 0 )
2104:..\Source/tasks.c **** 					{
2105:..\Source/tasks.c **** 						xAlreadyYielded = pdTRUE;
 2181              		.loc 1 2105 0
 2182 00d8 0123     		movs	r3, #1
 2183 00da BB60     		str	r3, [r7, #8]
2106:..\Source/tasks.c **** 					}
2107:..\Source/tasks.c **** 					#endif
2108:..\Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 2184              		.loc 1 2108 0
 2185 00dc 0F4B     		ldr	r3, .L142+32
 2186 00de 4FF08052 		mov	r2, #268435456
 2187 00e2 1A60     		str	r2, [r3]
 2188              	@ 2108 "..\Source\tasks.c" 1
 2189 00e4 BFF34F8F 		dsb
 2190              	@ 0 "" 2
 2191              	@ 2108 "..\Source\tasks.c" 1
 2192 00e8 BFF36F8F 		isb
 2193              	@ 0 "" 2
 2194              		.thumb
 2195              	.L134:
2109:..\Source/tasks.c **** 				}
2110:..\Source/tasks.c **** 				else
2111:..\Source/tasks.c **** 				{
2112:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2113:..\Source/tasks.c **** 				}
2114:..\Source/tasks.c **** 			}
2115:..\Source/tasks.c **** 		}
2116:..\Source/tasks.c **** 		else
2117:..\Source/tasks.c **** 		{
2118:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2119:..\Source/tasks.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 82


2120:..\Source/tasks.c **** 	}
2121:..\Source/tasks.c **** 	taskEXIT_CRITICAL();
 2196              		.loc 1 2121 0
 2197 00ec FFF7FEFF 		bl	vPortExitCritical
2122:..\Source/tasks.c **** 
2123:..\Source/tasks.c **** 	return xAlreadyYielded;
 2198              		.loc 1 2123 0
 2199 00f0 BB68     		ldr	r3, [r7, #8]
2124:..\Source/tasks.c **** }
 2200              		.loc 1 2124 0
 2201 00f2 1846     		mov	r0, r3
 2202 00f4 1037     		adds	r7, r7, #16
 2203              		.cfi_def_cfa_offset 8
 2204 00f6 BD46     		mov	sp, r7
 2205              		.cfi_def_cfa_register 13
 2206              		@ sp needed
 2207 00f8 80BD     		pop	{r7, pc}
 2208              	.L143:
 2209 00fa 00BF     		.align	2
 2210              	.L142:
 2211 00fc 00010000 		.word	uxSchedulerSuspended
 2212 0100 D8000000 		.word	uxCurrentNumberOfTasks
 2213 0104 98000000 		.word	xPendingReadyList
 2214 0108 E0000000 		.word	uxTopReadyPriority
 2215 010c 04000000 		.word	pxReadyTasksLists
 2216 0110 00000000 		.word	pxCurrentTCB
 2217 0114 EC000000 		.word	xYieldPending
 2218 0118 E8000000 		.word	uxPendedTicks
 2219 011c 04ED00E0 		.word	-536810236
 2220              		.cfi_endproc
 2221              	.LFE85:
 2222              		.size	xTaskResumeAll, .-xTaskResumeAll
 2223              		.section	.text.xTaskGetTickCount,"ax",%progbits
 2224              		.align	2
 2225              		.global	xTaskGetTickCount
 2226              		.thumb
 2227              		.thumb_func
 2228              		.type	xTaskGetTickCount, %function
 2229              	xTaskGetTickCount:
 2230              	.LFB86:
2125:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2126:..\Source/tasks.c **** 
2127:..\Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2128:..\Source/tasks.c **** {
 2231              		.loc 1 2128 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 8
 2234              		@ frame_needed = 1, uses_anonymous_args = 0
 2235              		@ link register save eliminated.
 2236 0000 80B4     		push	{r7}
 2237              		.cfi_def_cfa_offset 4
 2238              		.cfi_offset 7, -4
 2239 0002 83B0     		sub	sp, sp, #12
 2240              		.cfi_def_cfa_offset 16
 2241 0004 00AF     		add	r7, sp, #0
 2242              		.cfi_def_cfa_register 7
2129:..\Source/tasks.c **** TickType_t xTicks;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 83


2130:..\Source/tasks.c **** 
2131:..\Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
2132:..\Source/tasks.c **** 	portTICK_TYPE_ENTER_CRITICAL();
2133:..\Source/tasks.c **** 	{
2134:..\Source/tasks.c **** 		xTicks = xTickCount;
 2243              		.loc 1 2134 0
 2244 0006 054B     		ldr	r3, .L146
 2245 0008 1B68     		ldr	r3, [r3]
 2246 000a 7B60     		str	r3, [r7, #4]
2135:..\Source/tasks.c **** 	}
2136:..\Source/tasks.c **** 	portTICK_TYPE_EXIT_CRITICAL();
2137:..\Source/tasks.c **** 
2138:..\Source/tasks.c **** 	return xTicks;
 2247              		.loc 1 2138 0
 2248 000c 7B68     		ldr	r3, [r7, #4]
2139:..\Source/tasks.c **** }
 2249              		.loc 1 2139 0
 2250 000e 1846     		mov	r0, r3
 2251 0010 0C37     		adds	r7, r7, #12
 2252              		.cfi_def_cfa_offset 4
 2253 0012 BD46     		mov	sp, r7
 2254              		.cfi_def_cfa_register 13
 2255              		@ sp needed
 2256 0014 5DF8047B 		ldr	r7, [sp], #4
 2257              		.cfi_restore 7
 2258              		.cfi_def_cfa_offset 0
 2259 0018 7047     		bx	lr
 2260              	.L147:
 2261 001a 00BF     		.align	2
 2262              	.L146:
 2263 001c DC000000 		.word	xTickCount
 2264              		.cfi_endproc
 2265              	.LFE86:
 2266              		.size	xTaskGetTickCount, .-xTaskGetTickCount
 2267              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 2268              		.align	2
 2269              		.global	xTaskGetTickCountFromISR
 2270              		.thumb
 2271              		.thumb_func
 2272              		.type	xTaskGetTickCountFromISR, %function
 2273              	xTaskGetTickCountFromISR:
 2274              	.LFB87:
2140:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2141:..\Source/tasks.c **** 
2142:..\Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2143:..\Source/tasks.c **** {
 2275              		.loc 1 2143 0
 2276              		.cfi_startproc
 2277              		@ args = 0, pretend = 0, frame = 8
 2278              		@ frame_needed = 1, uses_anonymous_args = 0
 2279              		@ link register save eliminated.
 2280 0000 80B4     		push	{r7}
 2281              		.cfi_def_cfa_offset 4
 2282              		.cfi_offset 7, -4
 2283 0002 83B0     		sub	sp, sp, #12
 2284              		.cfi_def_cfa_offset 16
 2285 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 84


 2286              		.cfi_def_cfa_register 7
2144:..\Source/tasks.c **** TickType_t xReturn;
2145:..\Source/tasks.c **** UBaseType_t uxSavedInterruptStatus;
2146:..\Source/tasks.c **** 
2147:..\Source/tasks.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
2148:..\Source/tasks.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
2149:..\Source/tasks.c **** 	above the maximum system call priority are kept permanently enabled, even
2150:..\Source/tasks.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
2151:..\Source/tasks.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2152:..\Source/tasks.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2153:..\Source/tasks.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
2154:..\Source/tasks.c **** 	assigned a priority above the configured maximum system call priority.
2155:..\Source/tasks.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
2156:..\Source/tasks.c **** 	that have been assigned a priority at or (logically) below the maximum
2157:..\Source/tasks.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
2158:..\Source/tasks.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
2159:..\Source/tasks.c **** 	More information (albeit Cortex-M specific) is provided on the following
2160:..\Source/tasks.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
2161:..\Source/tasks.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
2162:..\Source/tasks.c **** 
2163:..\Source/tasks.c **** 	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2287              		.loc 1 2163 0
 2288 0006 0023     		movs	r3, #0
 2289 0008 7B60     		str	r3, [r7, #4]
2164:..\Source/tasks.c **** 	{
2165:..\Source/tasks.c **** 		xReturn = xTickCount;
 2290              		.loc 1 2165 0
 2291 000a 054B     		ldr	r3, .L150
 2292 000c 1B68     		ldr	r3, [r3]
 2293 000e 3B60     		str	r3, [r7]
2166:..\Source/tasks.c **** 	}
2167:..\Source/tasks.c **** 	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2168:..\Source/tasks.c **** 
2169:..\Source/tasks.c **** 	return xReturn;
 2294              		.loc 1 2169 0
 2295 0010 3B68     		ldr	r3, [r7]
2170:..\Source/tasks.c **** }
 2296              		.loc 1 2170 0
 2297 0012 1846     		mov	r0, r3
 2298 0014 0C37     		adds	r7, r7, #12
 2299              		.cfi_def_cfa_offset 4
 2300 0016 BD46     		mov	sp, r7
 2301              		.cfi_def_cfa_register 13
 2302              		@ sp needed
 2303 0018 5DF8047B 		ldr	r7, [sp], #4
 2304              		.cfi_restore 7
 2305              		.cfi_def_cfa_offset 0
 2306 001c 7047     		bx	lr
 2307              	.L151:
 2308 001e 00BF     		.align	2
 2309              	.L150:
 2310 0020 DC000000 		.word	xTickCount
 2311              		.cfi_endproc
 2312              	.LFE87:
 2313              		.size	xTaskGetTickCountFromISR, .-xTaskGetTickCountFromISR
 2314              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2315              		.align	2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 85


 2316              		.global	uxTaskGetNumberOfTasks
 2317              		.thumb
 2318              		.thumb_func
 2319              		.type	uxTaskGetNumberOfTasks, %function
 2320              	uxTaskGetNumberOfTasks:
 2321              	.LFB88:
2171:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2172:..\Source/tasks.c **** 
2173:..\Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2174:..\Source/tasks.c **** {
 2322              		.loc 1 2174 0
 2323              		.cfi_startproc
 2324              		@ args = 0, pretend = 0, frame = 0
 2325              		@ frame_needed = 1, uses_anonymous_args = 0
 2326              		@ link register save eliminated.
 2327 0000 80B4     		push	{r7}
 2328              		.cfi_def_cfa_offset 4
 2329              		.cfi_offset 7, -4
 2330 0002 00AF     		add	r7, sp, #0
 2331              		.cfi_def_cfa_register 7
2175:..\Source/tasks.c **** 	/* A critical section is not required because the variables are of type
2176:..\Source/tasks.c **** 	BaseType_t. */
2177:..\Source/tasks.c **** 	return uxCurrentNumberOfTasks;
 2332              		.loc 1 2177 0
 2333 0004 034B     		ldr	r3, .L154
 2334 0006 1B68     		ldr	r3, [r3]
2178:..\Source/tasks.c **** }
 2335              		.loc 1 2178 0
 2336 0008 1846     		mov	r0, r3
 2337 000a BD46     		mov	sp, r7
 2338              		.cfi_def_cfa_register 13
 2339              		@ sp needed
 2340 000c 5DF8047B 		ldr	r7, [sp], #4
 2341              		.cfi_restore 7
 2342              		.cfi_def_cfa_offset 0
 2343 0010 7047     		bx	lr
 2344              	.L155:
 2345 0012 00BF     		.align	2
 2346              	.L154:
 2347 0014 D8000000 		.word	uxCurrentNumberOfTasks
 2348              		.cfi_endproc
 2349              	.LFE88:
 2350              		.size	uxTaskGetNumberOfTasks, .-uxTaskGetNumberOfTasks
 2351              		.section	.text.pcTaskGetName,"ax",%progbits
 2352              		.align	2
 2353              		.global	pcTaskGetName
 2354              		.thumb
 2355              		.thumb_func
 2356              		.type	pcTaskGetName, %function
 2357              	pcTaskGetName:
 2358              	.LFB89:
2179:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2180:..\Source/tasks.c **** 
2181:..\Source/tasks.c **** char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed fo
2182:..\Source/tasks.c **** {
 2359              		.loc 1 2182 0
 2360              		.cfi_startproc
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 86


 2361              		@ args = 0, pretend = 0, frame = 16
 2362              		@ frame_needed = 1, uses_anonymous_args = 0
 2363              		@ link register save eliminated.
 2364 0000 80B4     		push	{r7}
 2365              		.cfi_def_cfa_offset 4
 2366              		.cfi_offset 7, -4
 2367 0002 85B0     		sub	sp, sp, #20
 2368              		.cfi_def_cfa_offset 24
 2369 0004 00AF     		add	r7, sp, #0
 2370              		.cfi_def_cfa_register 7
 2371 0006 7860     		str	r0, [r7, #4]
2183:..\Source/tasks.c **** TCB_t *pxTCB;
2184:..\Source/tasks.c **** 
2185:..\Source/tasks.c **** 	/* If null is passed in here then the name of the calling task is being
2186:..\Source/tasks.c **** 	queried. */
2187:..\Source/tasks.c **** 	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2372              		.loc 1 2187 0
 2373 0008 7B68     		ldr	r3, [r7, #4]
 2374 000a 002B     		cmp	r3, #0
 2375 000c 02D1     		bne	.L157
 2376              		.loc 1 2187 0 is_stmt 0 discriminator 1
 2377 000e 064B     		ldr	r3, .L160
 2378 0010 1B68     		ldr	r3, [r3]
 2379 0012 00E0     		b	.L158
 2380              	.L157:
 2381              		.loc 1 2187 0 discriminator 2
 2382 0014 7B68     		ldr	r3, [r7, #4]
 2383              	.L158:
 2384              		.loc 1 2187 0 discriminator 4
 2385 0016 FB60     		str	r3, [r7, #12]
2188:..\Source/tasks.c **** 	configASSERT( pxTCB );
2189:..\Source/tasks.c **** 	return &( pxTCB->pcTaskName[ 0 ] );
 2386              		.loc 1 2189 0 is_stmt 1 discriminator 4
 2387 0018 FB68     		ldr	r3, [r7, #12]
 2388 001a 3433     		adds	r3, r3, #52
2190:..\Source/tasks.c **** }
 2389              		.loc 1 2190 0 discriminator 4
 2390 001c 1846     		mov	r0, r3
 2391 001e 1437     		adds	r7, r7, #20
 2392              		.cfi_def_cfa_offset 4
 2393 0020 BD46     		mov	sp, r7
 2394              		.cfi_def_cfa_register 13
 2395              		@ sp needed
 2396 0022 5DF8047B 		ldr	r7, [sp], #4
 2397              		.cfi_restore 7
 2398              		.cfi_def_cfa_offset 0
 2399 0026 7047     		bx	lr
 2400              	.L161:
 2401              		.align	2
 2402              	.L160:
 2403 0028 00000000 		.word	pxCurrentTCB
 2404              		.cfi_endproc
 2405              	.LFE89:
 2406              		.size	pcTaskGetName, .-pcTaskGetName
 2407              		.section	.text.xTaskIncrementTick,"ax",%progbits
 2408              		.align	2
 2409              		.global	xTaskIncrementTick
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 87


 2410              		.thumb
 2411              		.thumb_func
 2412              		.type	xTaskIncrementTick, %function
 2413              	xTaskIncrementTick:
 2414              	.LFB90:
2191:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2192:..\Source/tasks.c **** 
2193:..\Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2194:..\Source/tasks.c **** 
2195:..\Source/tasks.c **** 	static TCB_t *prvSearchForNameWithinSingleList( List_t *pxList, const char pcNameToQuery[] )
2196:..\Source/tasks.c **** 	{
2197:..\Source/tasks.c **** 	TCB_t *pxNextTCB, *pxFirstTCB, *pxReturn = NULL;
2198:..\Source/tasks.c **** 	UBaseType_t x;
2199:..\Source/tasks.c **** 	char cNextChar;
2200:..\Source/tasks.c **** 
2201:..\Source/tasks.c **** 		/* This function is called with the scheduler suspended. */
2202:..\Source/tasks.c **** 
2203:..\Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2204:..\Source/tasks.c **** 		{
2205:..\Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2206:..\Source/tasks.c **** 
2207:..\Source/tasks.c **** 			do
2208:..\Source/tasks.c **** 			{
2209:..\Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2210:..\Source/tasks.c **** 
2211:..\Source/tasks.c **** 				/* Check each character in the name looking for a match or
2212:..\Source/tasks.c **** 				mismatch. */
2213:..\Source/tasks.c **** 				for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2214:..\Source/tasks.c **** 				{
2215:..\Source/tasks.c **** 					cNextChar = pxNextTCB->pcTaskName[ x ];
2216:..\Source/tasks.c **** 
2217:..\Source/tasks.c **** 					if( cNextChar != pcNameToQuery[ x ] )
2218:..\Source/tasks.c **** 					{
2219:..\Source/tasks.c **** 						/* Characters didn't match. */
2220:..\Source/tasks.c **** 						break;
2221:..\Source/tasks.c **** 					}
2222:..\Source/tasks.c **** 					else if( cNextChar == 0x00 )
2223:..\Source/tasks.c **** 					{
2224:..\Source/tasks.c **** 						/* Both strings terminated, a match must have been
2225:..\Source/tasks.c **** 						found. */
2226:..\Source/tasks.c **** 						pxReturn = pxNextTCB;
2227:..\Source/tasks.c **** 						break;
2228:..\Source/tasks.c **** 					}
2229:..\Source/tasks.c **** 					else
2230:..\Source/tasks.c **** 					{
2231:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2232:..\Source/tasks.c **** 					}
2233:..\Source/tasks.c **** 				}
2234:..\Source/tasks.c **** 
2235:..\Source/tasks.c **** 				if( pxReturn != NULL )
2236:..\Source/tasks.c **** 				{
2237:..\Source/tasks.c **** 					/* The handle has been found. */
2238:..\Source/tasks.c **** 					break;
2239:..\Source/tasks.c **** 				}
2240:..\Source/tasks.c **** 
2241:..\Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
2242:..\Source/tasks.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 88


2243:..\Source/tasks.c **** 		else
2244:..\Source/tasks.c **** 		{
2245:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2246:..\Source/tasks.c **** 		}
2247:..\Source/tasks.c **** 
2248:..\Source/tasks.c **** 		return pxReturn;
2249:..\Source/tasks.c **** 	}
2250:..\Source/tasks.c **** 
2251:..\Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2252:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2253:..\Source/tasks.c **** 
2254:..\Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2255:..\Source/tasks.c **** 
2256:..\Source/tasks.c **** 	TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) /*lint !e971 Unqualified char types are a
2257:..\Source/tasks.c **** 	{
2258:..\Source/tasks.c **** 	UBaseType_t uxQueue = configMAX_PRIORITIES;
2259:..\Source/tasks.c **** 	TCB_t* pxTCB;
2260:..\Source/tasks.c **** 
2261:..\Source/tasks.c **** 		/* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2262:..\Source/tasks.c **** 		configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2263:..\Source/tasks.c **** 
2264:..\Source/tasks.c **** 		vTaskSuspendAll();
2265:..\Source/tasks.c **** 		{
2266:..\Source/tasks.c **** 			/* Search the ready lists. */
2267:..\Source/tasks.c **** 			do
2268:..\Source/tasks.c **** 			{
2269:..\Source/tasks.c **** 				uxQueue--;
2270:..\Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNam
2271:..\Source/tasks.c **** 
2272:..\Source/tasks.c **** 				if( pxTCB != NULL )
2273:..\Source/tasks.c **** 				{
2274:..\Source/tasks.c **** 					/* Found the handle. */
2275:..\Source/tasks.c **** 					break;
2276:..\Source/tasks.c **** 				}
2277:..\Source/tasks.c **** 
2278:..\Source/tasks.c **** 			} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts
2279:..\Source/tasks.c **** 
2280:..\Source/tasks.c **** 			/* Search the delayed lists. */
2281:..\Source/tasks.c **** 			if( pxTCB == NULL )
2282:..\Source/tasks.c **** 			{
2283:..\Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
2284:..\Source/tasks.c **** 			}
2285:..\Source/tasks.c **** 
2286:..\Source/tasks.c **** 			if( pxTCB == NULL )
2287:..\Source/tasks.c **** 			{
2288:..\Source/tasks.c **** 				pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery
2289:..\Source/tasks.c **** 			}
2290:..\Source/tasks.c **** 
2291:..\Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
2292:..\Source/tasks.c **** 			{
2293:..\Source/tasks.c **** 				if( pxTCB == NULL )
2294:..\Source/tasks.c **** 				{
2295:..\Source/tasks.c **** 					/* Search the suspended list. */
2296:..\Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2297:..\Source/tasks.c **** 				}
2298:..\Source/tasks.c **** 			}
2299:..\Source/tasks.c **** 			#endif
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 89


2300:..\Source/tasks.c **** 
2301:..\Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
2302:..\Source/tasks.c **** 			{
2303:..\Source/tasks.c **** 				if( pxTCB == NULL )
2304:..\Source/tasks.c **** 				{
2305:..\Source/tasks.c **** 					/* Search the deleted list. */
2306:..\Source/tasks.c **** 					pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
2307:..\Source/tasks.c **** 				}
2308:..\Source/tasks.c **** 			}
2309:..\Source/tasks.c **** 			#endif
2310:..\Source/tasks.c **** 		}
2311:..\Source/tasks.c **** 		( void ) xTaskResumeAll();
2312:..\Source/tasks.c **** 
2313:..\Source/tasks.c **** 		return ( TaskHandle_t ) pxTCB;
2314:..\Source/tasks.c **** 	}
2315:..\Source/tasks.c **** 
2316:..\Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2317:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2318:..\Source/tasks.c **** 
2319:..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2320:..\Source/tasks.c **** 
2321:..\Source/tasks.c **** 	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArra
2322:..\Source/tasks.c **** 	{
2323:..\Source/tasks.c **** 	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
2324:..\Source/tasks.c **** 
2325:..\Source/tasks.c **** 		vTaskSuspendAll();
2326:..\Source/tasks.c **** 		{
2327:..\Source/tasks.c **** 			/* Is there a space in the array for each task in the system? */
2328:..\Source/tasks.c **** 			if( uxArraySize >= uxCurrentNumberOfTasks )
2329:..\Source/tasks.c **** 			{
2330:..\Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2331:..\Source/tasks.c **** 				task in the Ready state. */
2332:..\Source/tasks.c **** 				do
2333:..\Source/tasks.c **** 				{
2334:..\Source/tasks.c **** 					uxQueue--;
2335:..\Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists
2336:..\Source/tasks.c **** 
2337:..\Source/tasks.c **** 				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the cast
2338:..\Source/tasks.c **** 
2339:..\Source/tasks.c **** 				/* Fill in an TaskStatus_t structure with information on each
2340:..\Source/tasks.c **** 				task in the Blocked state. */
2341:..\Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelaye
2342:..\Source/tasks.c **** 				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverfl
2343:..\Source/tasks.c **** 
2344:..\Source/tasks.c **** 				#if( INCLUDE_vTaskDelete == 1 )
2345:..\Source/tasks.c **** 				{
2346:..\Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2347:..\Source/tasks.c **** 					each task that has been deleted but not yet cleaned up. */
2348:..\Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermin
2349:..\Source/tasks.c **** 				}
2350:..\Source/tasks.c **** 				#endif
2351:..\Source/tasks.c **** 
2352:..\Source/tasks.c **** 				#if ( INCLUDE_vTaskSuspend == 1 )
2353:..\Source/tasks.c **** 				{
2354:..\Source/tasks.c **** 					/* Fill in an TaskStatus_t structure with information on
2355:..\Source/tasks.c **** 					each task in the Suspended state. */
2356:..\Source/tasks.c **** 					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList,
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 90


2357:..\Source/tasks.c **** 				}
2358:..\Source/tasks.c **** 				#endif
2359:..\Source/tasks.c **** 
2360:..\Source/tasks.c **** 				#if ( configGENERATE_RUN_TIME_STATS == 1)
2361:..\Source/tasks.c **** 				{
2362:..\Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2363:..\Source/tasks.c **** 					{
2364:..\Source/tasks.c **** 						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2365:..\Source/tasks.c **** 							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2366:..\Source/tasks.c **** 						#else
2367:..\Source/tasks.c **** 							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2368:..\Source/tasks.c **** 						#endif
2369:..\Source/tasks.c **** 					}
2370:..\Source/tasks.c **** 				}
2371:..\Source/tasks.c **** 				#else
2372:..\Source/tasks.c **** 				{
2373:..\Source/tasks.c **** 					if( pulTotalRunTime != NULL )
2374:..\Source/tasks.c **** 					{
2375:..\Source/tasks.c **** 						*pulTotalRunTime = 0;
2376:..\Source/tasks.c **** 					}
2377:..\Source/tasks.c **** 				}
2378:..\Source/tasks.c **** 				#endif
2379:..\Source/tasks.c **** 			}
2380:..\Source/tasks.c **** 			else
2381:..\Source/tasks.c **** 			{
2382:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2383:..\Source/tasks.c **** 			}
2384:..\Source/tasks.c **** 		}
2385:..\Source/tasks.c **** 		( void ) xTaskResumeAll();
2386:..\Source/tasks.c **** 
2387:..\Source/tasks.c **** 		return uxTask;
2388:..\Source/tasks.c **** 	}
2389:..\Source/tasks.c **** 
2390:..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2391:..\Source/tasks.c **** /*----------------------------------------------------------*/
2392:..\Source/tasks.c **** 
2393:..\Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2394:..\Source/tasks.c **** 
2395:..\Source/tasks.c **** 	TaskHandle_t xTaskGetIdleTaskHandle( void )
2396:..\Source/tasks.c **** 	{
2397:..\Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2398:..\Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
2399:..\Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
2400:..\Source/tasks.c **** 		return xIdleTaskHandle;
2401:..\Source/tasks.c **** 	}
2402:..\Source/tasks.c **** 
2403:..\Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2404:..\Source/tasks.c **** /*----------------------------------------------------------*/
2405:..\Source/tasks.c **** 
2406:..\Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2407:..\Source/tasks.c **** This is to ensure vTaskStepTick() is available when user defined low power mode
2408:..\Source/tasks.c **** implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2409:..\Source/tasks.c **** 1. */
2410:..\Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2411:..\Source/tasks.c **** 
2412:..\Source/tasks.c **** 	void vTaskStepTick( const TickType_t xTicksToJump )
2413:..\Source/tasks.c **** 	{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 91


2414:..\Source/tasks.c **** 		/* Correct the tick count value after a period during which the tick
2415:..\Source/tasks.c **** 		was suppressed.  Note this does *not* call the tick hook function for
2416:..\Source/tasks.c **** 		each stepped tick. */
2417:..\Source/tasks.c **** 		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2418:..\Source/tasks.c **** 		xTickCount += xTicksToJump;
2419:..\Source/tasks.c **** 		traceINCREASE_TICK_COUNT( xTicksToJump );
2420:..\Source/tasks.c **** 	}
2421:..\Source/tasks.c **** 
2422:..\Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2423:..\Source/tasks.c **** /*----------------------------------------------------------*/
2424:..\Source/tasks.c **** 
2425:..\Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2426:..\Source/tasks.c **** 
2427:..\Source/tasks.c **** 	BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
2428:..\Source/tasks.c **** 	{
2429:..\Source/tasks.c **** 	TCB_t *pxTCB = ( TCB_t * ) xTask;
2430:..\Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
2431:..\Source/tasks.c **** 
2432:..\Source/tasks.c **** 		configASSERT( pxTCB );
2433:..\Source/tasks.c **** 
2434:..\Source/tasks.c **** 		vTaskSuspendAll();
2435:..\Source/tasks.c **** 		{
2436:..\Source/tasks.c **** 			/* A task can only be prematurely removed from the Blocked state if
2437:..\Source/tasks.c **** 			it is actually in the Blocked state. */
2438:..\Source/tasks.c **** 			if( eTaskGetState( xTask ) == eBlocked )
2439:..\Source/tasks.c **** 			{
2440:..\Source/tasks.c **** 				/* Remove the reference to the task from the blocked list.  An
2441:..\Source/tasks.c **** 				interrupt won't touch the xStateListItem because the
2442:..\Source/tasks.c **** 				scheduler is suspended. */
2443:..\Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2444:..\Source/tasks.c **** 
2445:..\Source/tasks.c **** 				/* Is the task waiting on an event also?  If so remove it from
2446:..\Source/tasks.c **** 				the event list too.  Interrupts can touch the event list item,
2447:..\Source/tasks.c **** 				even though the scheduler is suspended, so a critical section
2448:..\Source/tasks.c **** 				is used. */
2449:..\Source/tasks.c **** 				taskENTER_CRITICAL();
2450:..\Source/tasks.c **** 				{
2451:..\Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2452:..\Source/tasks.c **** 					{
2453:..\Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2454:..\Source/tasks.c **** 						pxTCB->ucDelayAborted = pdTRUE;
2455:..\Source/tasks.c **** 					}
2456:..\Source/tasks.c **** 					else
2457:..\Source/tasks.c **** 					{
2458:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2459:..\Source/tasks.c **** 					}
2460:..\Source/tasks.c **** 				}
2461:..\Source/tasks.c **** 				taskEXIT_CRITICAL();
2462:..\Source/tasks.c **** 
2463:..\Source/tasks.c **** 				/* Place the unblocked task into the appropriate ready list. */
2464:..\Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
2465:..\Source/tasks.c **** 
2466:..\Source/tasks.c **** 				/* A task being unblocked cannot cause an immediate context
2467:..\Source/tasks.c **** 				switch if preemption is turned off. */
2468:..\Source/tasks.c **** 				#if (  configUSE_PREEMPTION == 1 )
2469:..\Source/tasks.c **** 				{
2470:..\Source/tasks.c **** 					/* Preemption is on, but a context switch should only be
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 92


2471:..\Source/tasks.c **** 					performed if the unblocked task has a priority that is
2472:..\Source/tasks.c **** 					equal to or higher than the currently executing task. */
2473:..\Source/tasks.c **** 					if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2474:..\Source/tasks.c **** 					{
2475:..\Source/tasks.c **** 						/* Pend the yield to be performed when the scheduler
2476:..\Source/tasks.c **** 						is unsuspended. */
2477:..\Source/tasks.c **** 						xYieldPending = pdTRUE;
2478:..\Source/tasks.c **** 					}
2479:..\Source/tasks.c **** 					else
2480:..\Source/tasks.c **** 					{
2481:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2482:..\Source/tasks.c **** 					}
2483:..\Source/tasks.c **** 				}
2484:..\Source/tasks.c **** 				#endif /* configUSE_PREEMPTION */
2485:..\Source/tasks.c **** 			}
2486:..\Source/tasks.c **** 			else
2487:..\Source/tasks.c **** 			{
2488:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2489:..\Source/tasks.c **** 			}
2490:..\Source/tasks.c **** 		}
2491:..\Source/tasks.c **** 		xTaskResumeAll();
2492:..\Source/tasks.c **** 
2493:..\Source/tasks.c **** 		return xReturn;
2494:..\Source/tasks.c **** 	}
2495:..\Source/tasks.c **** 
2496:..\Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2497:..\Source/tasks.c **** /*----------------------------------------------------------*/
2498:..\Source/tasks.c **** 
2499:..\Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2500:..\Source/tasks.c **** {
 2415              		.loc 1 2500 0
 2416              		.cfi_startproc
 2417              		@ args = 0, pretend = 0, frame = 24
 2418              		@ frame_needed = 1, uses_anonymous_args = 0
 2419 0000 80B5     		push	{r7, lr}
 2420              		.cfi_def_cfa_offset 8
 2421              		.cfi_offset 7, -8
 2422              		.cfi_offset 14, -4
 2423 0002 86B0     		sub	sp, sp, #24
 2424              		.cfi_def_cfa_offset 32
 2425 0004 00AF     		add	r7, sp, #0
 2426              		.cfi_def_cfa_register 7
2501:..\Source/tasks.c **** TCB_t * pxTCB;
2502:..\Source/tasks.c **** TickType_t xItemValue;
2503:..\Source/tasks.c **** BaseType_t xSwitchRequired = pdFALSE;
 2427              		.loc 1 2503 0
 2428 0006 0023     		movs	r3, #0
 2429 0008 7B61     		str	r3, [r7, #20]
2504:..\Source/tasks.c **** 
2505:..\Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
2506:..\Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
2507:..\Source/tasks.c **** 	tasks to be unblocked. */
2508:..\Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
2509:..\Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2430              		.loc 1 2509 0
 2431 000a 494B     		ldr	r3, .L177
 2432 000c 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 93


 2433 000e 002B     		cmp	r3, #0
 2434 0010 7ED1     		bne	.L163
 2435              	.LBB42:
2510:..\Source/tasks.c **** 	{
2511:..\Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this
2512:..\Source/tasks.c **** 		block. */
2513:..\Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount + 1;
 2436              		.loc 1 2513 0
 2437 0012 484B     		ldr	r3, .L177+4
 2438 0014 1B68     		ldr	r3, [r3]
 2439 0016 0133     		adds	r3, r3, #1
 2440 0018 3B61     		str	r3, [r7, #16]
2514:..\Source/tasks.c **** 
2515:..\Source/tasks.c **** 		/* Increment the RTOS tick, switching the delayed and overflowed
2516:..\Source/tasks.c **** 		delayed lists if it wraps to 0. */
2517:..\Source/tasks.c **** 		xTickCount = xConstTickCount;
 2441              		.loc 1 2517 0
 2442 001a 464A     		ldr	r2, .L177+4
 2443 001c 3B69     		ldr	r3, [r7, #16]
 2444 001e 1360     		str	r3, [r2]
2518:..\Source/tasks.c **** 
2519:..\Source/tasks.c **** 		if( xConstTickCount == ( TickType_t ) 0U )
 2445              		.loc 1 2519 0
 2446 0020 3B69     		ldr	r3, [r7, #16]
 2447 0022 002B     		cmp	r3, #0
 2448 0024 10D1     		bne	.L164
 2449              	.LBB43:
2520:..\Source/tasks.c **** 		{
2521:..\Source/tasks.c **** 			taskSWITCH_DELAYED_LISTS();
 2450              		.loc 1 2521 0
 2451 0026 444B     		ldr	r3, .L177+8
 2452 0028 1B68     		ldr	r3, [r3]
 2453 002a FB60     		str	r3, [r7, #12]
 2454 002c 434B     		ldr	r3, .L177+12
 2455 002e 1B68     		ldr	r3, [r3]
 2456 0030 414A     		ldr	r2, .L177+8
 2457 0032 1360     		str	r3, [r2]
 2458 0034 414A     		ldr	r2, .L177+12
 2459 0036 FB68     		ldr	r3, [r7, #12]
 2460 0038 1360     		str	r3, [r2]
 2461 003a 414B     		ldr	r3, .L177+16
 2462 003c 1B68     		ldr	r3, [r3]
 2463 003e 0133     		adds	r3, r3, #1
 2464 0040 3F4A     		ldr	r2, .L177+16
 2465 0042 1360     		str	r3, [r2]
 2466 0044 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2467              	.L164:
 2468              	.LBE43:
2522:..\Source/tasks.c **** 		}
2523:..\Source/tasks.c **** 		else
2524:..\Source/tasks.c **** 		{
2525:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2526:..\Source/tasks.c **** 		}
2527:..\Source/tasks.c **** 
2528:..\Source/tasks.c **** 		/* See if this tick has made a timeout expire.  Tasks are stored in
2529:..\Source/tasks.c **** 		the	queue in the order of their wake time - meaning once one task
2530:..\Source/tasks.c **** 		has been found whose block time has not expired there is no need to
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 94


2531:..\Source/tasks.c **** 		look any further down the list. */
2532:..\Source/tasks.c **** 		if( xConstTickCount >= xNextTaskUnblockTime )
 2469              		.loc 1 2532 0
 2470 0048 3E4B     		ldr	r3, .L177+20
 2471 004a 1B68     		ldr	r3, [r3]
 2472 004c 3A69     		ldr	r2, [r7, #16]
 2473 004e 9A42     		cmp	r2, r3
 2474 0050 4FD3     		bcc	.L165
 2475              	.L172:
2533:..\Source/tasks.c **** 		{
2534:..\Source/tasks.c **** 			for( ;; )
2535:..\Source/tasks.c **** 			{
2536:..\Source/tasks.c **** 				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2476              		.loc 1 2536 0
 2477 0052 394B     		ldr	r3, .L177+8
 2478 0054 1B68     		ldr	r3, [r3]
 2479 0056 1B68     		ldr	r3, [r3]
 2480 0058 002B     		cmp	r3, #0
 2481 005a 01D1     		bne	.L166
 2482              		.loc 1 2536 0 is_stmt 0 discriminator 1
 2483 005c 0123     		movs	r3, #1
 2484 005e 00E0     		b	.L167
 2485              	.L166:
 2486              		.loc 1 2536 0 discriminator 2
 2487 0060 0023     		movs	r3, #0
 2488              	.L167:
 2489              		.loc 1 2536 0 discriminator 4
 2490 0062 002B     		cmp	r3, #0
 2491 0064 04D0     		beq	.L168
2537:..\Source/tasks.c **** 				{
2538:..\Source/tasks.c **** 					/* The delayed list is empty.  Set xNextTaskUnblockTime
2539:..\Source/tasks.c **** 					to the maximum possible value so it is extremely
2540:..\Source/tasks.c **** 					unlikely that the
2541:..\Source/tasks.c **** 					if( xTickCount >= xNextTaskUnblockTime ) test will pass
2542:..\Source/tasks.c **** 					next time through. */
2543:..\Source/tasks.c **** 					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redun
 2492              		.loc 1 2543 0 is_stmt 1
 2493 0066 374B     		ldr	r3, .L177+20
 2494 0068 4FF0FF32 		mov	r2, #-1
 2495 006c 1A60     		str	r2, [r3]
2544:..\Source/tasks.c **** 					break;
 2496              		.loc 1 2544 0
 2497 006e 40E0     		b	.L165
 2498              	.L168:
2545:..\Source/tasks.c **** 				}
2546:..\Source/tasks.c **** 				else
2547:..\Source/tasks.c **** 				{
2548:..\Source/tasks.c **** 					/* The delayed list is not empty, get the value of the
2549:..\Source/tasks.c **** 					item at the head of the delayed list.  This is the time
2550:..\Source/tasks.c **** 					at which the task at the head of the delayed list must
2551:..\Source/tasks.c **** 					be removed from the Blocked state. */
2552:..\Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 2499              		.loc 1 2552 0
 2500 0070 314B     		ldr	r3, .L177+8
 2501 0072 1B68     		ldr	r3, [r3]
 2502 0074 DB68     		ldr	r3, [r3, #12]
 2503 0076 DB68     		ldr	r3, [r3, #12]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 95


 2504 0078 BB60     		str	r3, [r7, #8]
2553:..\Source/tasks.c **** 					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 2505              		.loc 1 2553 0
 2506 007a BB68     		ldr	r3, [r7, #8]
 2507 007c 5B68     		ldr	r3, [r3, #4]
 2508 007e 7B60     		str	r3, [r7, #4]
2554:..\Source/tasks.c **** 
2555:..\Source/tasks.c **** 					if( xConstTickCount < xItemValue )
 2509              		.loc 1 2555 0
 2510 0080 3A69     		ldr	r2, [r7, #16]
 2511 0082 7B68     		ldr	r3, [r7, #4]
 2512 0084 9A42     		cmp	r2, r3
 2513 0086 03D2     		bcs	.L169
2556:..\Source/tasks.c **** 					{
2557:..\Source/tasks.c **** 						/* It is not time to unblock this item yet, but the
2558:..\Source/tasks.c **** 						item value is the time at which the task at the head
2559:..\Source/tasks.c **** 						of the blocked list must be removed from the Blocked
2560:..\Source/tasks.c **** 						state -	so record the item value in
2561:..\Source/tasks.c **** 						xNextTaskUnblockTime. */
2562:..\Source/tasks.c **** 						xNextTaskUnblockTime = xItemValue;
 2514              		.loc 1 2562 0
 2515 0088 2E4A     		ldr	r2, .L177+20
 2516 008a 7B68     		ldr	r3, [r7, #4]
 2517 008c 1360     		str	r3, [r2]
2563:..\Source/tasks.c **** 						break;
 2518              		.loc 1 2563 0
 2519 008e 30E0     		b	.L165
 2520              	.L169:
2564:..\Source/tasks.c **** 					}
2565:..\Source/tasks.c **** 					else
2566:..\Source/tasks.c **** 					{
2567:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2568:..\Source/tasks.c **** 					}
2569:..\Source/tasks.c **** 
2570:..\Source/tasks.c **** 					/* It is time to remove the item from the Blocked state. */
2571:..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2521              		.loc 1 2571 0
 2522 0090 BB68     		ldr	r3, [r7, #8]
 2523 0092 0433     		adds	r3, r3, #4
 2524 0094 1846     		mov	r0, r3
 2525 0096 FFF7FEFF 		bl	uxListRemove
2572:..\Source/tasks.c **** 
2573:..\Source/tasks.c **** 					/* Is the task waiting on an event also?  If so remove
2574:..\Source/tasks.c **** 					it from the event list. */
2575:..\Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2526              		.loc 1 2575 0
 2527 009a BB68     		ldr	r3, [r7, #8]
 2528 009c 9B6A     		ldr	r3, [r3, #40]
 2529 009e 002B     		cmp	r3, #0
 2530 00a0 04D0     		beq	.L170
2576:..\Source/tasks.c **** 					{
2577:..\Source/tasks.c **** 						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 2531              		.loc 1 2577 0
 2532 00a2 BB68     		ldr	r3, [r7, #8]
 2533 00a4 1833     		adds	r3, r3, #24
 2534 00a6 1846     		mov	r0, r3
 2535 00a8 FFF7FEFF 		bl	uxListRemove
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 96


 2536              	.L170:
2578:..\Source/tasks.c **** 					}
2579:..\Source/tasks.c **** 					else
2580:..\Source/tasks.c **** 					{
2581:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
2582:..\Source/tasks.c **** 					}
2583:..\Source/tasks.c **** 
2584:..\Source/tasks.c **** 					/* Place the unblocked task into the appropriate ready
2585:..\Source/tasks.c **** 					list. */
2586:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 2537              		.loc 1 2586 0
 2538 00ac BB68     		ldr	r3, [r7, #8]
 2539 00ae DB6A     		ldr	r3, [r3, #44]
 2540 00b0 1A46     		mov	r2, r3
 2541 00b2 0123     		movs	r3, #1
 2542 00b4 03FA02F2 		lsl	r2, r3, r2
 2543 00b8 234B     		ldr	r3, .L177+24
 2544 00ba 1B68     		ldr	r3, [r3]
 2545 00bc 1343     		orrs	r3, r3, r2
 2546 00be 224A     		ldr	r2, .L177+24
 2547 00c0 1360     		str	r3, [r2]
 2548 00c2 BB68     		ldr	r3, [r7, #8]
 2549 00c4 DA6A     		ldr	r2, [r3, #44]
 2550 00c6 1346     		mov	r3, r2
 2551 00c8 9B00     		lsls	r3, r3, #2
 2552 00ca 1344     		add	r3, r3, r2
 2553 00cc 9B00     		lsls	r3, r3, #2
 2554 00ce 1F4A     		ldr	r2, .L177+28
 2555 00d0 1A44     		add	r2, r2, r3
 2556 00d2 BB68     		ldr	r3, [r7, #8]
 2557 00d4 0433     		adds	r3, r3, #4
 2558 00d6 1046     		mov	r0, r2
 2559 00d8 1946     		mov	r1, r3
 2560 00da FFF7FEFF 		bl	vListInsertEnd
2587:..\Source/tasks.c **** 
2588:..\Source/tasks.c **** 					/* A task being unblocked cannot cause an immediate
2589:..\Source/tasks.c **** 					context switch if preemption is turned off. */
2590:..\Source/tasks.c **** 					#if (  configUSE_PREEMPTION == 1 )
2591:..\Source/tasks.c **** 					{
2592:..\Source/tasks.c **** 						/* Preemption is on, but a context switch should
2593:..\Source/tasks.c **** 						only be performed if the unblocked task has a
2594:..\Source/tasks.c **** 						priority that is equal to or higher than the
2595:..\Source/tasks.c **** 						currently executing task. */
2596:..\Source/tasks.c **** 						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2561              		.loc 1 2596 0
 2562 00de BB68     		ldr	r3, [r7, #8]
 2563 00e0 DA6A     		ldr	r2, [r3, #44]
 2564 00e2 1B4B     		ldr	r3, .L177+32
 2565 00e4 1B68     		ldr	r3, [r3]
 2566 00e6 DB6A     		ldr	r3, [r3, #44]
 2567 00e8 9A42     		cmp	r2, r3
 2568 00ea 01D3     		bcc	.L171
2597:..\Source/tasks.c **** 						{
2598:..\Source/tasks.c **** 							xSwitchRequired = pdTRUE;
 2569              		.loc 1 2598 0
 2570 00ec 0123     		movs	r3, #1
 2571 00ee 7B61     		str	r3, [r7, #20]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 97


 2572              	.L171:
2599:..\Source/tasks.c **** 						}
2600:..\Source/tasks.c **** 						else
2601:..\Source/tasks.c **** 						{
2602:..\Source/tasks.c **** 							mtCOVERAGE_TEST_MARKER();
2603:..\Source/tasks.c **** 						}
2604:..\Source/tasks.c **** 					}
2605:..\Source/tasks.c **** 					#endif /* configUSE_PREEMPTION */
2606:..\Source/tasks.c **** 				}
2607:..\Source/tasks.c **** 			}
 2573              		.loc 1 2607 0
 2574 00f0 AFE7     		b	.L172
 2575              	.L165:
2608:..\Source/tasks.c **** 		}
2609:..\Source/tasks.c **** 
2610:..\Source/tasks.c **** 		/* Tasks of equal priority to the currently running task will share
2611:..\Source/tasks.c **** 		processing time (time slice) if preemption is on, and the application
2612:..\Source/tasks.c **** 		writer has not explicitly turned time slicing off. */
2613:..\Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2614:..\Source/tasks.c **** 		{
2615:..\Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_
 2576              		.loc 1 2615 0
 2577 00f2 174B     		ldr	r3, .L177+32
 2578 00f4 1B68     		ldr	r3, [r3]
 2579 00f6 DA6A     		ldr	r2, [r3, #44]
 2580 00f8 1449     		ldr	r1, .L177+28
 2581 00fa 1346     		mov	r3, r2
 2582 00fc 9B00     		lsls	r3, r3, #2
 2583 00fe 1344     		add	r3, r3, r2
 2584 0100 9B00     		lsls	r3, r3, #2
 2585 0102 0B44     		add	r3, r3, r1
 2586 0104 1B68     		ldr	r3, [r3]
 2587 0106 012B     		cmp	r3, #1
 2588 0108 01D9     		bls	.L173
2616:..\Source/tasks.c **** 			{
2617:..\Source/tasks.c **** 				xSwitchRequired = pdTRUE;
 2589              		.loc 1 2617 0
 2590 010a 0123     		movs	r3, #1
 2591 010c 7B61     		str	r3, [r7, #20]
 2592              	.L173:
 2593              	.LBE42:
 2594 010e 04E0     		b	.L174
 2595              	.L163:
2618:..\Source/tasks.c **** 			}
2619:..\Source/tasks.c **** 			else
2620:..\Source/tasks.c **** 			{
2621:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2622:..\Source/tasks.c **** 			}
2623:..\Source/tasks.c **** 		}
2624:..\Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2625:..\Source/tasks.c **** 
2626:..\Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2627:..\Source/tasks.c **** 		{
2628:..\Source/tasks.c **** 			/* Guard against the tick hook being called when the pended tick
2629:..\Source/tasks.c **** 			count is being unwound (when the scheduler is being unlocked). */
2630:..\Source/tasks.c **** 			if( uxPendedTicks == ( UBaseType_t ) 0U )
2631:..\Source/tasks.c **** 			{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 98


2632:..\Source/tasks.c **** 				vApplicationTickHook();
2633:..\Source/tasks.c **** 			}
2634:..\Source/tasks.c **** 			else
2635:..\Source/tasks.c **** 			{
2636:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
2637:..\Source/tasks.c **** 			}
2638:..\Source/tasks.c **** 		}
2639:..\Source/tasks.c **** 		#endif /* configUSE_TICK_HOOK */
2640:..\Source/tasks.c **** 	}
2641:..\Source/tasks.c **** 	else
2642:..\Source/tasks.c **** 	{
2643:..\Source/tasks.c **** 		++uxPendedTicks;
 2596              		.loc 1 2643 0
 2597 0110 104B     		ldr	r3, .L177+36
 2598 0112 1B68     		ldr	r3, [r3]
 2599 0114 0133     		adds	r3, r3, #1
 2600 0116 0F4A     		ldr	r2, .L177+36
 2601 0118 1360     		str	r3, [r2]
 2602              	.L174:
2644:..\Source/tasks.c **** 
2645:..\Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
2646:..\Source/tasks.c **** 		scheduler is locked. */
2647:..\Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
2648:..\Source/tasks.c **** 		{
2649:..\Source/tasks.c **** 			vApplicationTickHook();
2650:..\Source/tasks.c **** 		}
2651:..\Source/tasks.c **** 		#endif
2652:..\Source/tasks.c **** 	}
2653:..\Source/tasks.c **** 
2654:..\Source/tasks.c **** 	#if ( configUSE_PREEMPTION == 1 )
2655:..\Source/tasks.c **** 	{
2656:..\Source/tasks.c **** 		if( xYieldPending != pdFALSE )
 2603              		.loc 1 2656 0
 2604 011a 0F4B     		ldr	r3, .L177+40
 2605 011c 1B68     		ldr	r3, [r3]
 2606 011e 002B     		cmp	r3, #0
 2607 0120 01D0     		beq	.L175
2657:..\Source/tasks.c **** 		{
2658:..\Source/tasks.c **** 			xSwitchRequired = pdTRUE;
 2608              		.loc 1 2658 0
 2609 0122 0123     		movs	r3, #1
 2610 0124 7B61     		str	r3, [r7, #20]
 2611              	.L175:
2659:..\Source/tasks.c **** 		}
2660:..\Source/tasks.c **** 		else
2661:..\Source/tasks.c **** 		{
2662:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
2663:..\Source/tasks.c **** 		}
2664:..\Source/tasks.c **** 	}
2665:..\Source/tasks.c **** 	#endif /* configUSE_PREEMPTION */
2666:..\Source/tasks.c **** 
2667:..\Source/tasks.c **** 	return xSwitchRequired;
 2612              		.loc 1 2667 0
 2613 0126 7B69     		ldr	r3, [r7, #20]
2668:..\Source/tasks.c **** }
 2614              		.loc 1 2668 0
 2615 0128 1846     		mov	r0, r3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 99


 2616 012a 1837     		adds	r7, r7, #24
 2617              		.cfi_def_cfa_offset 8
 2618 012c BD46     		mov	sp, r7
 2619              		.cfi_def_cfa_register 13
 2620              		@ sp needed
 2621 012e 80BD     		pop	{r7, pc}
 2622              	.L178:
 2623              		.align	2
 2624              	.L177:
 2625 0130 00010000 		.word	uxSchedulerSuspended
 2626 0134 DC000000 		.word	xTickCount
 2627 0138 90000000 		.word	pxDelayedTaskList
 2628 013c 94000000 		.word	pxOverflowDelayedTaskList
 2629 0140 F0000000 		.word	xNumOfOverflows
 2630 0144 F8000000 		.word	xNextTaskUnblockTime
 2631 0148 E0000000 		.word	uxTopReadyPriority
 2632 014c 04000000 		.word	pxReadyTasksLists
 2633 0150 00000000 		.word	pxCurrentTCB
 2634 0154 E8000000 		.word	uxPendedTicks
 2635 0158 EC000000 		.word	xYieldPending
 2636              		.cfi_endproc
 2637              	.LFE90:
 2638              		.size	xTaskIncrementTick, .-xTaskIncrementTick
 2639              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2640              		.align	2
 2641              		.global	vTaskSwitchContext
 2642              		.thumb
 2643              		.thumb_func
 2644              		.type	vTaskSwitchContext, %function
 2645              	vTaskSwitchContext:
 2646              	.LFB91:
2669:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2670:..\Source/tasks.c **** 
2671:..\Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2672:..\Source/tasks.c **** 
2673:..\Source/tasks.c **** 	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2674:..\Source/tasks.c **** 	{
2675:..\Source/tasks.c **** 	TCB_t *xTCB;
2676:..\Source/tasks.c **** 
2677:..\Source/tasks.c **** 		/* If xTask is NULL then it is the task hook of the calling task that is
2678:..\Source/tasks.c **** 		getting set. */
2679:..\Source/tasks.c **** 		if( xTask == NULL )
2680:..\Source/tasks.c **** 		{
2681:..\Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2682:..\Source/tasks.c **** 		}
2683:..\Source/tasks.c **** 		else
2684:..\Source/tasks.c **** 		{
2685:..\Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2686:..\Source/tasks.c **** 		}
2687:..\Source/tasks.c **** 
2688:..\Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2689:..\Source/tasks.c **** 		the value can be accessed from an interrupt. */
2690:..\Source/tasks.c **** 		taskENTER_CRITICAL();
2691:..\Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
2692:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
2693:..\Source/tasks.c **** 	}
2694:..\Source/tasks.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 100


2695:..\Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2696:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2697:..\Source/tasks.c **** 
2698:..\Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2699:..\Source/tasks.c **** 
2700:..\Source/tasks.c **** 	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2701:..\Source/tasks.c **** 	{
2702:..\Source/tasks.c **** 	TCB_t *xTCB;
2703:..\Source/tasks.c **** 	TaskHookFunction_t xReturn;
2704:..\Source/tasks.c **** 
2705:..\Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
2706:..\Source/tasks.c **** 		if( xTask == NULL )
2707:..\Source/tasks.c **** 		{
2708:..\Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2709:..\Source/tasks.c **** 		}
2710:..\Source/tasks.c **** 		else
2711:..\Source/tasks.c **** 		{
2712:..\Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2713:..\Source/tasks.c **** 		}
2714:..\Source/tasks.c **** 
2715:..\Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
2716:..\Source/tasks.c **** 		the value can be accessed from an interrupt. */
2717:..\Source/tasks.c **** 		taskENTER_CRITICAL();
2718:..\Source/tasks.c **** 		{
2719:..\Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
2720:..\Source/tasks.c **** 		}
2721:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
2722:..\Source/tasks.c **** 
2723:..\Source/tasks.c **** 		return xReturn;
2724:..\Source/tasks.c **** 	}
2725:..\Source/tasks.c **** 
2726:..\Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2727:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2728:..\Source/tasks.c **** 
2729:..\Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2730:..\Source/tasks.c **** 
2731:..\Source/tasks.c **** 	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2732:..\Source/tasks.c **** 	{
2733:..\Source/tasks.c **** 	TCB_t *xTCB;
2734:..\Source/tasks.c **** 	BaseType_t xReturn;
2735:..\Source/tasks.c **** 
2736:..\Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
2737:..\Source/tasks.c **** 		if( xTask == NULL )
2738:..\Source/tasks.c **** 		{
2739:..\Source/tasks.c **** 			xTCB = ( TCB_t * ) pxCurrentTCB;
2740:..\Source/tasks.c **** 		}
2741:..\Source/tasks.c **** 		else
2742:..\Source/tasks.c **** 		{
2743:..\Source/tasks.c **** 			xTCB = ( TCB_t * ) xTask;
2744:..\Source/tasks.c **** 		}
2745:..\Source/tasks.c **** 
2746:..\Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
2747:..\Source/tasks.c **** 		{
2748:..\Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
2749:..\Source/tasks.c **** 		}
2750:..\Source/tasks.c **** 		else
2751:..\Source/tasks.c **** 		{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 101


2752:..\Source/tasks.c **** 			xReturn = pdFAIL;
2753:..\Source/tasks.c **** 		}
2754:..\Source/tasks.c **** 
2755:..\Source/tasks.c **** 		return xReturn;
2756:..\Source/tasks.c **** 	}
2757:..\Source/tasks.c **** 
2758:..\Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2759:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2760:..\Source/tasks.c **** 
2761:..\Source/tasks.c **** void vTaskSwitchContext( void )
2762:..\Source/tasks.c **** {
 2647              		.loc 1 2762 0
 2648              		.cfi_startproc
 2649              		@ args = 0, pretend = 0, frame = 24
 2650              		@ frame_needed = 1, uses_anonymous_args = 0
 2651 0000 80B5     		push	{r7, lr}
 2652              		.cfi_def_cfa_offset 8
 2653              		.cfi_offset 7, -8
 2654              		.cfi_offset 14, -4
 2655 0002 86B0     		sub	sp, sp, #24
 2656              		.cfi_def_cfa_offset 32
 2657 0004 00AF     		add	r7, sp, #0
 2658              		.cfi_def_cfa_register 7
2763:..\Source/tasks.c **** 	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2659              		.loc 1 2763 0
 2660 0006 2E4B     		ldr	r3, .L186
 2661 0008 1B68     		ldr	r3, [r3]
 2662 000a 002B     		cmp	r3, #0
 2663 000c 03D0     		beq	.L180
2764:..\Source/tasks.c **** 	{
2765:..\Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
2766:..\Source/tasks.c **** 		switch. */
2767:..\Source/tasks.c **** 		xYieldPending = pdTRUE;
 2664              		.loc 1 2767 0
 2665 000e 2D4B     		ldr	r3, .L186+4
 2666 0010 0122     		movs	r2, #1
 2667 0012 1A60     		str	r2, [r3]
 2668 0014 51E0     		b	.L179
 2669              	.L180:
2768:..\Source/tasks.c **** 	}
2769:..\Source/tasks.c **** 	else
2770:..\Source/tasks.c **** 	{
2771:..\Source/tasks.c **** 		xYieldPending = pdFALSE;
 2670              		.loc 1 2771 0
 2671 0016 2B4B     		ldr	r3, .L186+4
 2672 0018 0022     		movs	r2, #0
 2673 001a 1A60     		str	r2, [r3]
 2674              	.LBB44:
2772:..\Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
2773:..\Source/tasks.c **** 
2774:..\Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2775:..\Source/tasks.c **** 		{
2776:..\Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2777:..\Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2778:..\Source/tasks.c **** 				#else
2779:..\Source/tasks.c **** 					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2780:..\Source/tasks.c **** 				#endif
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 102


2781:..\Source/tasks.c **** 
2782:..\Source/tasks.c **** 				/* Add the amount of time the task has been running to the
2783:..\Source/tasks.c **** 				accumulated time so far.  The time the task started running was
2784:..\Source/tasks.c **** 				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2785:..\Source/tasks.c **** 				protection here so count values are only valid until the timer
2786:..\Source/tasks.c **** 				overflows.  The guard against negative values is to protect
2787:..\Source/tasks.c **** 				against suspect run time stat counter implementations - which
2788:..\Source/tasks.c **** 				are provided by the application, not the kernel. */
2789:..\Source/tasks.c **** 				if( ulTotalRunTime > ulTaskSwitchedInTime )
2790:..\Source/tasks.c **** 				{
2791:..\Source/tasks.c **** 					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2792:..\Source/tasks.c **** 				}
2793:..\Source/tasks.c **** 				else
2794:..\Source/tasks.c **** 				{
2795:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
2796:..\Source/tasks.c **** 				}
2797:..\Source/tasks.c **** 				ulTaskSwitchedInTime = ulTotalRunTime;
2798:..\Source/tasks.c **** 		}
2799:..\Source/tasks.c **** 		#endif /* configGENERATE_RUN_TIME_STATS */
2800:..\Source/tasks.c **** 
2801:..\Source/tasks.c **** 		/* Check for stack overflow, if configured. */
2802:..\Source/tasks.c **** 		taskCHECK_FOR_STACK_OVERFLOW();
 2675              		.loc 1 2802 0
 2676 001c 2A4B     		ldr	r3, .L186+8
 2677 001e 1B68     		ldr	r3, [r3]
 2678 0020 1B6B     		ldr	r3, [r3, #48]
 2679 0022 7B61     		str	r3, [r7, #20]
 2680 0024 4FF0A533 		mov	r3, #-1515870811
 2681 0028 3B61     		str	r3, [r7, #16]
 2682 002a 7B69     		ldr	r3, [r7, #20]
 2683 002c 1A68     		ldr	r2, [r3]
 2684 002e 3B69     		ldr	r3, [r7, #16]
 2685 0030 9A42     		cmp	r2, r3
 2686 0032 11D1     		bne	.L182
 2687              		.loc 1 2802 0 is_stmt 0 discriminator 2
 2688 0034 7B69     		ldr	r3, [r7, #20]
 2689 0036 0433     		adds	r3, r3, #4
 2690 0038 1A68     		ldr	r2, [r3]
 2691 003a 3B69     		ldr	r3, [r7, #16]
 2692 003c 9A42     		cmp	r2, r3
 2693 003e 0BD1     		bne	.L182
 2694              		.loc 1 2802 0 discriminator 4
 2695 0040 7B69     		ldr	r3, [r7, #20]
 2696 0042 0833     		adds	r3, r3, #8
 2697 0044 1A68     		ldr	r2, [r3]
 2698 0046 3B69     		ldr	r3, [r7, #16]
 2699 0048 9A42     		cmp	r2, r3
 2700 004a 05D1     		bne	.L182
 2701              		.loc 1 2802 0 discriminator 6
 2702 004c 7B69     		ldr	r3, [r7, #20]
 2703 004e 0C33     		adds	r3, r3, #12
 2704 0050 1A68     		ldr	r2, [r3]
 2705 0052 3B69     		ldr	r3, [r7, #16]
 2706 0054 9A42     		cmp	r2, r3
 2707 0056 08D0     		beq	.L183
 2708              	.L182:
 2709              		.loc 1 2802 0 discriminator 7
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 103


 2710 0058 1B4B     		ldr	r3, .L186+8
 2711 005a 1A68     		ldr	r2, [r3]
 2712 005c 1A4B     		ldr	r3, .L186+8
 2713 005e 1B68     		ldr	r3, [r3]
 2714 0060 3433     		adds	r3, r3, #52
 2715 0062 1046     		mov	r0, r2
 2716 0064 1946     		mov	r1, r3
 2717 0066 FFF7FEFF 		bl	vApplicationStackOverflowHook
 2718              	.L183:
 2719              	.LBE44:
 2720              	.LBB45:
2803:..\Source/tasks.c **** 
2804:..\Source/tasks.c **** 		/* Select a new task to run using either the generic C or port
2805:..\Source/tasks.c **** 		optimised asm code. */
2806:..\Source/tasks.c **** 		taskSELECT_HIGHEST_PRIORITY_TASK();
 2721              		.loc 1 2806 0 is_stmt 1
 2722 006a 184B     		ldr	r3, .L186+12
 2723 006c 1B68     		ldr	r3, [r3]
 2724 006e 7B60     		str	r3, [r7, #4]
 2725              	.LBB46:
 2726              	.LBB47:
 176:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		return ucReturn;
 2727              		.loc 2 176 0
 2728 0070 7B68     		ldr	r3, [r7, #4]
 2729              	@ 176 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 2730 0072 B3FA83F3 		clz r3, r3
 2731              	@ 0 "" 2
 2732              		.thumb
 2733 0076 FB70     		strb	r3, [r7, #3]
 177:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 2734              		.loc 2 177 0
 2735 0078 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2736              	.LBE47:
 2737              	.LBE46:
 2738              		.loc 1 2806 0
 2739 007a C3F11F03 		rsb	r3, r3, #31
 2740 007e FB60     		str	r3, [r7, #12]
 2741              	.LBB48:
 2742 0080 FA68     		ldr	r2, [r7, #12]
 2743 0082 1346     		mov	r3, r2
 2744 0084 9B00     		lsls	r3, r3, #2
 2745 0086 1344     		add	r3, r3, r2
 2746 0088 9B00     		lsls	r3, r3, #2
 2747 008a 114A     		ldr	r2, .L186+16
 2748 008c 1344     		add	r3, r3, r2
 2749 008e BB60     		str	r3, [r7, #8]
 2750 0090 BB68     		ldr	r3, [r7, #8]
 2751 0092 5B68     		ldr	r3, [r3, #4]
 2752 0094 5A68     		ldr	r2, [r3, #4]
 2753 0096 BB68     		ldr	r3, [r7, #8]
 2754 0098 5A60     		str	r2, [r3, #4]
 2755 009a BB68     		ldr	r3, [r7, #8]
 2756 009c 5A68     		ldr	r2, [r3, #4]
 2757 009e BB68     		ldr	r3, [r7, #8]
 2758 00a0 0833     		adds	r3, r3, #8
 2759 00a2 9A42     		cmp	r2, r3
 2760 00a4 04D1     		bne	.L185
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 104


 2761              		.loc 1 2806 0 is_stmt 0 discriminator 1
 2762 00a6 BB68     		ldr	r3, [r7, #8]
 2763 00a8 5B68     		ldr	r3, [r3, #4]
 2764 00aa 5A68     		ldr	r2, [r3, #4]
 2765 00ac BB68     		ldr	r3, [r7, #8]
 2766 00ae 5A60     		str	r2, [r3, #4]
 2767              	.L185:
 2768              		.loc 1 2806 0 discriminator 3
 2769 00b0 BB68     		ldr	r3, [r7, #8]
 2770 00b2 5B68     		ldr	r3, [r3, #4]
 2771 00b4 DB68     		ldr	r3, [r3, #12]
 2772 00b6 044A     		ldr	r2, .L186+8
 2773 00b8 1360     		str	r3, [r2]
 2774              	.L179:
 2775              	.LBE48:
 2776              	.LBE45:
2807:..\Source/tasks.c **** 		traceTASK_SWITCHED_IN();
2808:..\Source/tasks.c **** 
2809:..\Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2810:..\Source/tasks.c **** 		{
2811:..\Source/tasks.c **** 			/* Switch Newlib's _impure_ptr variable to point to the _reent
2812:..\Source/tasks.c **** 			structure specific to this task. */
2813:..\Source/tasks.c **** 			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2814:..\Source/tasks.c **** 		}
2815:..\Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
2816:..\Source/tasks.c **** 	}
2817:..\Source/tasks.c **** }
 2777              		.loc 1 2817 0 is_stmt 1
 2778 00ba 1837     		adds	r7, r7, #24
 2779              		.cfi_def_cfa_offset 8
 2780 00bc BD46     		mov	sp, r7
 2781              		.cfi_def_cfa_register 13
 2782              		@ sp needed
 2783 00be 80BD     		pop	{r7, pc}
 2784              	.L187:
 2785              		.align	2
 2786              	.L186:
 2787 00c0 00010000 		.word	uxSchedulerSuspended
 2788 00c4 EC000000 		.word	xYieldPending
 2789 00c8 00000000 		.word	pxCurrentTCB
 2790 00cc E0000000 		.word	uxTopReadyPriority
 2791 00d0 04000000 		.word	pxReadyTasksLists
 2792              		.cfi_endproc
 2793              	.LFE91:
 2794              		.size	vTaskSwitchContext, .-vTaskSwitchContext
 2795              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2796              		.align	2
 2797              		.global	vTaskPlaceOnEventList
 2798              		.thumb
 2799              		.thumb_func
 2800              		.type	vTaskPlaceOnEventList, %function
 2801              	vTaskPlaceOnEventList:
 2802              	.LFB92:
2818:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2819:..\Source/tasks.c **** 
2820:..\Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2821:..\Source/tasks.c **** {
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 105


 2803              		.loc 1 2821 0
 2804              		.cfi_startproc
 2805              		@ args = 0, pretend = 0, frame = 8
 2806              		@ frame_needed = 1, uses_anonymous_args = 0
 2807 0000 80B5     		push	{r7, lr}
 2808              		.cfi_def_cfa_offset 8
 2809              		.cfi_offset 7, -8
 2810              		.cfi_offset 14, -4
 2811 0002 82B0     		sub	sp, sp, #8
 2812              		.cfi_def_cfa_offset 16
 2813 0004 00AF     		add	r7, sp, #0
 2814              		.cfi_def_cfa_register 7
 2815 0006 7860     		str	r0, [r7, #4]
 2816 0008 3960     		str	r1, [r7]
2822:..\Source/tasks.c **** 	configASSERT( pxEventList );
2823:..\Source/tasks.c **** 
2824:..\Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2825:..\Source/tasks.c **** 	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2826:..\Source/tasks.c **** 
2827:..\Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
2828:..\Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
2829:..\Source/tasks.c **** 	is the first to be woken by the event.  The queue that contains the event
2830:..\Source/tasks.c **** 	list is locked, preventing simultaneous access from interrupts. */
2831:..\Source/tasks.c **** 	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2817              		.loc 1 2831 0
 2818 000a 074B     		ldr	r3, .L189
 2819 000c 1B68     		ldr	r3, [r3]
 2820 000e 1833     		adds	r3, r3, #24
 2821 0010 7868     		ldr	r0, [r7, #4]
 2822 0012 1946     		mov	r1, r3
 2823 0014 FFF7FEFF 		bl	vListInsert
2832:..\Source/tasks.c **** 
2833:..\Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2824              		.loc 1 2833 0
 2825 0018 3868     		ldr	r0, [r7]
 2826 001a 0121     		movs	r1, #1
 2827 001c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2834:..\Source/tasks.c **** }
 2828              		.loc 1 2834 0
 2829 0020 0837     		adds	r7, r7, #8
 2830              		.cfi_def_cfa_offset 8
 2831 0022 BD46     		mov	sp, r7
 2832              		.cfi_def_cfa_register 13
 2833              		@ sp needed
 2834 0024 80BD     		pop	{r7, pc}
 2835              	.L190:
 2836 0026 00BF     		.align	2
 2837              	.L189:
 2838 0028 00000000 		.word	pxCurrentTCB
 2839              		.cfi_endproc
 2840              	.LFE92:
 2841              		.size	vTaskPlaceOnEventList, .-vTaskPlaceOnEventList
 2842              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 2843              		.align	2
 2844              		.global	vTaskPlaceOnUnorderedEventList
 2845              		.thumb
 2846              		.thumb_func
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 106


 2847              		.type	vTaskPlaceOnUnorderedEventList, %function
 2848              	vTaskPlaceOnUnorderedEventList:
 2849              	.LFB93:
2835:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2836:..\Source/tasks.c **** 
2837:..\Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickT
2838:..\Source/tasks.c **** {
 2850              		.loc 1 2838 0
 2851              		.cfi_startproc
 2852              		@ args = 0, pretend = 0, frame = 16
 2853              		@ frame_needed = 1, uses_anonymous_args = 0
 2854 0000 80B5     		push	{r7, lr}
 2855              		.cfi_def_cfa_offset 8
 2856              		.cfi_offset 7, -8
 2857              		.cfi_offset 14, -4
 2858 0002 84B0     		sub	sp, sp, #16
 2859              		.cfi_def_cfa_offset 24
 2860 0004 00AF     		add	r7, sp, #0
 2861              		.cfi_def_cfa_register 7
 2862 0006 F860     		str	r0, [r7, #12]
 2863 0008 B960     		str	r1, [r7, #8]
 2864 000a 7A60     		str	r2, [r7, #4]
2839:..\Source/tasks.c **** 	configASSERT( pxEventList );
2840:..\Source/tasks.c **** 
2841:..\Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2842:..\Source/tasks.c **** 	the event groups implementation. */
2843:..\Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != 0 );
2844:..\Source/tasks.c **** 
2845:..\Source/tasks.c **** 	/* Store the item value in the event list item.  It is safe to access the
2846:..\Source/tasks.c **** 	event list item here as interrupts won't access the event list item of a
2847:..\Source/tasks.c **** 	task that is not in the Blocked state. */
2848:..\Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE
 2865              		.loc 1 2848 0
 2866 000c 094B     		ldr	r3, .L192
 2867 000e 1B68     		ldr	r3, [r3]
 2868 0010 BA68     		ldr	r2, [r7, #8]
 2869 0012 42F00042 		orr	r2, r2, #-2147483648
 2870 0016 9A61     		str	r2, [r3, #24]
2849:..\Source/tasks.c **** 
2850:..\Source/tasks.c **** 	/* Place the event list item of the TCB at the end of the appropriate event
2851:..\Source/tasks.c **** 	list.  It is safe to access the event list here because it is part of an
2852:..\Source/tasks.c **** 	event group implementation - and interrupts don't access event groups
2853:..\Source/tasks.c **** 	directly (instead they access them indirectly by pending function calls to
2854:..\Source/tasks.c **** 	the task level). */
2855:..\Source/tasks.c **** 	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2871              		.loc 1 2855 0
 2872 0018 064B     		ldr	r3, .L192
 2873 001a 1B68     		ldr	r3, [r3]
 2874 001c 1833     		adds	r3, r3, #24
 2875 001e F868     		ldr	r0, [r7, #12]
 2876 0020 1946     		mov	r1, r3
 2877 0022 FFF7FEFF 		bl	vListInsertEnd
2856:..\Source/tasks.c **** 
2857:..\Source/tasks.c **** 	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2878              		.loc 1 2857 0
 2879 0026 7868     		ldr	r0, [r7, #4]
 2880 0028 0121     		movs	r1, #1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 107


 2881 002a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
2858:..\Source/tasks.c **** }
 2882              		.loc 1 2858 0
 2883 002e 1037     		adds	r7, r7, #16
 2884              		.cfi_def_cfa_offset 8
 2885 0030 BD46     		mov	sp, r7
 2886              		.cfi_def_cfa_register 13
 2887              		@ sp needed
 2888 0032 80BD     		pop	{r7, pc}
 2889              	.L193:
 2890              		.align	2
 2891              	.L192:
 2892 0034 00000000 		.word	pxCurrentTCB
 2893              		.cfi_endproc
 2894              	.LFE93:
 2895              		.size	vTaskPlaceOnUnorderedEventList, .-vTaskPlaceOnUnorderedEventList
 2896              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2897              		.align	2
 2898              		.global	xTaskRemoveFromEventList
 2899              		.thumb
 2900              		.thumb_func
 2901              		.type	xTaskRemoveFromEventList, %function
 2902              	xTaskRemoveFromEventList:
 2903              	.LFB94:
2859:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2860:..\Source/tasks.c **** 
2861:..\Source/tasks.c **** #if( configUSE_TIMERS == 1 )
2862:..\Source/tasks.c **** 
2863:..\Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const B
2864:..\Source/tasks.c **** 	{
2865:..\Source/tasks.c **** 		configASSERT( pxEventList );
2866:..\Source/tasks.c **** 
2867:..\Source/tasks.c **** 		/* This function should not be called by application code hence the
2868:..\Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
2869:..\Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
2870:..\Source/tasks.c **** 		it should be called with the scheduler suspended. */
2871:..\Source/tasks.c **** 
2872:..\Source/tasks.c **** 
2873:..\Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
2874:..\Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
2875:..\Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
2876:..\Source/tasks.c **** 		can be used in place of vListInsert. */
2877:..\Source/tasks.c **** 		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
2878:..\Source/tasks.c **** 
2879:..\Source/tasks.c **** 		/* If the task should block indefinitely then set the block time to a
2880:..\Source/tasks.c **** 		value that will be recognised as an indefinite delay inside the
2881:..\Source/tasks.c **** 		prvAddCurrentTaskToDelayedList() function. */
2882:..\Source/tasks.c **** 		if( xWaitIndefinitely != pdFALSE )
2883:..\Source/tasks.c **** 		{
2884:..\Source/tasks.c **** 			xTicksToWait = portMAX_DELAY;
2885:..\Source/tasks.c **** 		}
2886:..\Source/tasks.c **** 
2887:..\Source/tasks.c **** 		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
2888:..\Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
2889:..\Source/tasks.c **** 	}
2890:..\Source/tasks.c **** 
2891:..\Source/tasks.c **** #endif /* configUSE_TIMERS */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 108


2892:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2893:..\Source/tasks.c **** 
2894:..\Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2895:..\Source/tasks.c **** {
 2904              		.loc 1 2895 0
 2905              		.cfi_startproc
 2906              		@ args = 0, pretend = 0, frame = 16
 2907              		@ frame_needed = 1, uses_anonymous_args = 0
 2908 0000 80B5     		push	{r7, lr}
 2909              		.cfi_def_cfa_offset 8
 2910              		.cfi_offset 7, -8
 2911              		.cfi_offset 14, -4
 2912 0002 84B0     		sub	sp, sp, #16
 2913              		.cfi_def_cfa_offset 24
 2914 0004 00AF     		add	r7, sp, #0
 2915              		.cfi_def_cfa_register 7
 2916 0006 7860     		str	r0, [r7, #4]
2896:..\Source/tasks.c **** TCB_t *pxUnblockedTCB;
2897:..\Source/tasks.c **** BaseType_t xReturn;
2898:..\Source/tasks.c **** 
2899:..\Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2900:..\Source/tasks.c **** 	called from a critical section within an ISR. */
2901:..\Source/tasks.c **** 
2902:..\Source/tasks.c **** 	/* The event list is sorted in priority order, so the first in the list can
2903:..\Source/tasks.c **** 	be removed as it is known to be the highest priority.  Remove the TCB from
2904:..\Source/tasks.c **** 	the delayed list, and add it to the ready list.
2905:..\Source/tasks.c **** 
2906:..\Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
2907:..\Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
2908:..\Source/tasks.c **** 	means exclusive access to the event list is guaranteed here.
2909:..\Source/tasks.c **** 
2910:..\Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
2911:..\Source/tasks.c **** 	pxEventList is not empty. */
2912:..\Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2917              		.loc 1 2912 0
 2918 0008 7B68     		ldr	r3, [r7, #4]
 2919 000a DB68     		ldr	r3, [r3, #12]
 2920 000c DB68     		ldr	r3, [r3, #12]
 2921 000e BB60     		str	r3, [r7, #8]
2913:..\Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2914:..\Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2922              		.loc 1 2914 0
 2923 0010 BB68     		ldr	r3, [r7, #8]
 2924 0012 1833     		adds	r3, r3, #24
 2925 0014 1846     		mov	r0, r3
 2926 0016 FFF7FEFF 		bl	uxListRemove
2915:..\Source/tasks.c **** 
2916:..\Source/tasks.c **** 	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2927              		.loc 1 2916 0
 2928 001a 1E4B     		ldr	r3, .L200
 2929 001c 1B68     		ldr	r3, [r3]
 2930 001e 002B     		cmp	r3, #0
 2931 0020 1ED1     		bne	.L195
2917:..\Source/tasks.c **** 	{
2918:..\Source/tasks.c **** 		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2932              		.loc 1 2918 0
 2933 0022 BB68     		ldr	r3, [r7, #8]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 109


 2934 0024 0433     		adds	r3, r3, #4
 2935 0026 1846     		mov	r0, r3
 2936 0028 FFF7FEFF 		bl	uxListRemove
2919:..\Source/tasks.c **** 		prvAddTaskToReadyList( pxUnblockedTCB );
 2937              		.loc 1 2919 0
 2938 002c BB68     		ldr	r3, [r7, #8]
 2939 002e DB6A     		ldr	r3, [r3, #44]
 2940 0030 1A46     		mov	r2, r3
 2941 0032 0123     		movs	r3, #1
 2942 0034 03FA02F2 		lsl	r2, r3, r2
 2943 0038 174B     		ldr	r3, .L200+4
 2944 003a 1B68     		ldr	r3, [r3]
 2945 003c 1343     		orrs	r3, r3, r2
 2946 003e 164A     		ldr	r2, .L200+4
 2947 0040 1360     		str	r3, [r2]
 2948 0042 BB68     		ldr	r3, [r7, #8]
 2949 0044 DA6A     		ldr	r2, [r3, #44]
 2950 0046 1346     		mov	r3, r2
 2951 0048 9B00     		lsls	r3, r3, #2
 2952 004a 1344     		add	r3, r3, r2
 2953 004c 9B00     		lsls	r3, r3, #2
 2954 004e 134A     		ldr	r2, .L200+8
 2955 0050 1A44     		add	r2, r2, r3
 2956 0052 BB68     		ldr	r3, [r7, #8]
 2957 0054 0433     		adds	r3, r3, #4
 2958 0056 1046     		mov	r0, r2
 2959 0058 1946     		mov	r1, r3
 2960 005a FFF7FEFF 		bl	vListInsertEnd
 2961 005e 05E0     		b	.L196
 2962              	.L195:
2920:..\Source/tasks.c **** 	}
2921:..\Source/tasks.c **** 	else
2922:..\Source/tasks.c **** 	{
2923:..\Source/tasks.c **** 		/* The delayed and ready lists cannot be accessed, so hold this task
2924:..\Source/tasks.c **** 		pending until the scheduler is resumed. */
2925:..\Source/tasks.c **** 		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2963              		.loc 1 2925 0
 2964 0060 BB68     		ldr	r3, [r7, #8]
 2965 0062 1833     		adds	r3, r3, #24
 2966 0064 0E48     		ldr	r0, .L200+12
 2967 0066 1946     		mov	r1, r3
 2968 0068 FFF7FEFF 		bl	vListInsertEnd
 2969              	.L196:
2926:..\Source/tasks.c **** 	}
2927:..\Source/tasks.c **** 
2928:..\Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2970              		.loc 1 2928 0
 2971 006c BB68     		ldr	r3, [r7, #8]
 2972 006e DA6A     		ldr	r2, [r3, #44]
 2973 0070 0C4B     		ldr	r3, .L200+16
 2974 0072 1B68     		ldr	r3, [r3]
 2975 0074 DB6A     		ldr	r3, [r3, #44]
 2976 0076 9A42     		cmp	r2, r3
 2977 0078 05D9     		bls	.L197
2929:..\Source/tasks.c **** 	{
2930:..\Source/tasks.c **** 		/* Return true if the task removed from the event list has a higher
2931:..\Source/tasks.c **** 		priority than the calling task.  This allows the calling task to know if
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 110


2932:..\Source/tasks.c **** 		it should force a context switch now. */
2933:..\Source/tasks.c **** 		xReturn = pdTRUE;
 2978              		.loc 1 2933 0
 2979 007a 0123     		movs	r3, #1
 2980 007c FB60     		str	r3, [r7, #12]
2934:..\Source/tasks.c **** 
2935:..\Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2936:..\Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2937:..\Source/tasks.c **** 		xYieldPending = pdTRUE;
 2981              		.loc 1 2937 0
 2982 007e 0A4B     		ldr	r3, .L200+20
 2983 0080 0122     		movs	r2, #1
 2984 0082 1A60     		str	r2, [r3]
 2985 0084 01E0     		b	.L198
 2986              	.L197:
2938:..\Source/tasks.c **** 	}
2939:..\Source/tasks.c **** 	else
2940:..\Source/tasks.c **** 	{
2941:..\Source/tasks.c **** 		xReturn = pdFALSE;
 2987              		.loc 1 2941 0
 2988 0086 0023     		movs	r3, #0
 2989 0088 FB60     		str	r3, [r7, #12]
 2990              	.L198:
2942:..\Source/tasks.c **** 	}
2943:..\Source/tasks.c **** 
2944:..\Source/tasks.c **** 	#if( configUSE_TICKLESS_IDLE != 0 )
2945:..\Source/tasks.c **** 	{
2946:..\Source/tasks.c **** 		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
2947:..\Source/tasks.c **** 		might be set to the blocked task's time out time.  If the task is
2948:..\Source/tasks.c **** 		unblocked for a reason other than a timeout xNextTaskUnblockTime is
2949:..\Source/tasks.c **** 		normally left unchanged, because it is automatically reset to a new
2950:..\Source/tasks.c **** 		value when the tick count equals xNextTaskUnblockTime.  However if
2951:..\Source/tasks.c **** 		tickless idling is used it might be more important to enter sleep mode
2952:..\Source/tasks.c **** 		at the earliest possible time - so reset xNextTaskUnblockTime here to
2953:..\Source/tasks.c **** 		ensure it is updated at the earliest possible time. */
2954:..\Source/tasks.c **** 		prvResetNextTaskUnblockTime();
2955:..\Source/tasks.c **** 	}
2956:..\Source/tasks.c **** 	#endif
2957:..\Source/tasks.c **** 
2958:..\Source/tasks.c **** 	return xReturn;
 2991              		.loc 1 2958 0
 2992 008a FB68     		ldr	r3, [r7, #12]
2959:..\Source/tasks.c **** }
 2993              		.loc 1 2959 0
 2994 008c 1846     		mov	r0, r3
 2995 008e 1037     		adds	r7, r7, #16
 2996              		.cfi_def_cfa_offset 8
 2997 0090 BD46     		mov	sp, r7
 2998              		.cfi_def_cfa_register 13
 2999              		@ sp needed
 3000 0092 80BD     		pop	{r7, pc}
 3001              	.L201:
 3002              		.align	2
 3003              	.L200:
 3004 0094 00010000 		.word	uxSchedulerSuspended
 3005 0098 E0000000 		.word	uxTopReadyPriority
 3006 009c 04000000 		.word	pxReadyTasksLists
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 111


 3007 00a0 98000000 		.word	xPendingReadyList
 3008 00a4 00000000 		.word	pxCurrentTCB
 3009 00a8 EC000000 		.word	xYieldPending
 3010              		.cfi_endproc
 3011              	.LFE94:
 3012              		.size	xTaskRemoveFromEventList, .-xTaskRemoveFromEventList
 3013              		.section	.text.xTaskRemoveFromUnorderedEventList,"ax",%progbits
 3014              		.align	2
 3015              		.global	xTaskRemoveFromUnorderedEventList
 3016              		.thumb
 3017              		.thumb_func
 3018              		.type	xTaskRemoveFromUnorderedEventList, %function
 3019              	xTaskRemoveFromUnorderedEventList:
 3020              	.LFB95:
2960:..\Source/tasks.c **** /*-----------------------------------------------------------*/
2961:..\Source/tasks.c **** 
2962:..\Source/tasks.c **** BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemV
2963:..\Source/tasks.c **** {
 3021              		.loc 1 2963 0
 3022              		.cfi_startproc
 3023              		@ args = 0, pretend = 0, frame = 16
 3024              		@ frame_needed = 1, uses_anonymous_args = 0
 3025 0000 80B5     		push	{r7, lr}
 3026              		.cfi_def_cfa_offset 8
 3027              		.cfi_offset 7, -8
 3028              		.cfi_offset 14, -4
 3029 0002 84B0     		sub	sp, sp, #16
 3030              		.cfi_def_cfa_offset 24
 3031 0004 00AF     		add	r7, sp, #0
 3032              		.cfi_def_cfa_register 7
 3033 0006 7860     		str	r0, [r7, #4]
 3034 0008 3960     		str	r1, [r7]
2964:..\Source/tasks.c **** TCB_t *pxUnblockedTCB;
2965:..\Source/tasks.c **** BaseType_t xReturn;
2966:..\Source/tasks.c **** 
2967:..\Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2968:..\Source/tasks.c **** 	the event flags implementation. */
2969:..\Source/tasks.c **** 	configASSERT( uxSchedulerSuspended != pdFALSE );
2970:..\Source/tasks.c **** 
2971:..\Source/tasks.c **** 	/* Store the new item value in the event list. */
2972:..\Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 3035              		.loc 1 2972 0
 3036 000a 3B68     		ldr	r3, [r7]
 3037 000c 43F00042 		orr	r2, r3, #-2147483648
 3038 0010 7B68     		ldr	r3, [r7, #4]
 3039 0012 1A60     		str	r2, [r3]
2973:..\Source/tasks.c **** 
2974:..\Source/tasks.c **** 	/* Remove the event list form the event flag.  Interrupts do not access
2975:..\Source/tasks.c **** 	event flags. */
2976:..\Source/tasks.c **** 	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 3040              		.loc 1 2976 0
 3041 0014 7B68     		ldr	r3, [r7, #4]
 3042 0016 DB68     		ldr	r3, [r3, #12]
 3043 0018 BB60     		str	r3, [r7, #8]
2977:..\Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
2978:..\Source/tasks.c **** 	( void ) uxListRemove( pxEventListItem );
 3044              		.loc 1 2978 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 112


 3045 001a 7868     		ldr	r0, [r7, #4]
 3046 001c FFF7FEFF 		bl	uxListRemove
2979:..\Source/tasks.c **** 
2980:..\Source/tasks.c **** 	/* Remove the task from the delayed list and add it to the ready list.  The
2981:..\Source/tasks.c **** 	scheduler is suspended so interrupts will not be accessing the ready
2982:..\Source/tasks.c **** 	lists. */
2983:..\Source/tasks.c **** 	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 3047              		.loc 1 2983 0
 3048 0020 BB68     		ldr	r3, [r7, #8]
 3049 0022 0433     		adds	r3, r3, #4
 3050 0024 1846     		mov	r0, r3
 3051 0026 FFF7FEFF 		bl	uxListRemove
2984:..\Source/tasks.c **** 	prvAddTaskToReadyList( pxUnblockedTCB );
 3052              		.loc 1 2984 0
 3053 002a BB68     		ldr	r3, [r7, #8]
 3054 002c DB6A     		ldr	r3, [r3, #44]
 3055 002e 1A46     		mov	r2, r3
 3056 0030 0123     		movs	r3, #1
 3057 0032 03FA02F2 		lsl	r2, r3, r2
 3058 0036 134B     		ldr	r3, .L206
 3059 0038 1B68     		ldr	r3, [r3]
 3060 003a 1343     		orrs	r3, r3, r2
 3061 003c 114A     		ldr	r2, .L206
 3062 003e 1360     		str	r3, [r2]
 3063 0040 BB68     		ldr	r3, [r7, #8]
 3064 0042 DA6A     		ldr	r2, [r3, #44]
 3065 0044 1346     		mov	r3, r2
 3066 0046 9B00     		lsls	r3, r3, #2
 3067 0048 1344     		add	r3, r3, r2
 3068 004a 9B00     		lsls	r3, r3, #2
 3069 004c 0E4A     		ldr	r2, .L206+4
 3070 004e 1A44     		add	r2, r2, r3
 3071 0050 BB68     		ldr	r3, [r7, #8]
 3072 0052 0433     		adds	r3, r3, #4
 3073 0054 1046     		mov	r0, r2
 3074 0056 1946     		mov	r1, r3
 3075 0058 FFF7FEFF 		bl	vListInsertEnd
2985:..\Source/tasks.c **** 
2986:..\Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 3076              		.loc 1 2986 0
 3077 005c BB68     		ldr	r3, [r7, #8]
 3078 005e DA6A     		ldr	r2, [r3, #44]
 3079 0060 0A4B     		ldr	r3, .L206+8
 3080 0062 1B68     		ldr	r3, [r3]
 3081 0064 DB6A     		ldr	r3, [r3, #44]
 3082 0066 9A42     		cmp	r2, r3
 3083 0068 05D9     		bls	.L203
2987:..\Source/tasks.c **** 	{
2988:..\Source/tasks.c **** 		/* Return true if the task removed from the event list has
2989:..\Source/tasks.c **** 		a higher priority than the calling task.  This allows
2990:..\Source/tasks.c **** 		the calling task to know if it should force a context
2991:..\Source/tasks.c **** 		switch now. */
2992:..\Source/tasks.c **** 		xReturn = pdTRUE;
 3084              		.loc 1 2992 0
 3085 006a 0123     		movs	r3, #1
 3086 006c FB60     		str	r3, [r7, #12]
2993:..\Source/tasks.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 113


2994:..\Source/tasks.c **** 		/* Mark that a yield is pending in case the user is not using the
2995:..\Source/tasks.c **** 		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2996:..\Source/tasks.c **** 		xYieldPending = pdTRUE;
 3087              		.loc 1 2996 0
 3088 006e 084B     		ldr	r3, .L206+12
 3089 0070 0122     		movs	r2, #1
 3090 0072 1A60     		str	r2, [r3]
 3091 0074 01E0     		b	.L204
 3092              	.L203:
2997:..\Source/tasks.c **** 	}
2998:..\Source/tasks.c **** 	else
2999:..\Source/tasks.c **** 	{
3000:..\Source/tasks.c **** 		xReturn = pdFALSE;
 3093              		.loc 1 3000 0
 3094 0076 0023     		movs	r3, #0
 3095 0078 FB60     		str	r3, [r7, #12]
 3096              	.L204:
3001:..\Source/tasks.c **** 	}
3002:..\Source/tasks.c **** 
3003:..\Source/tasks.c **** 	return xReturn;
 3097              		.loc 1 3003 0
 3098 007a FB68     		ldr	r3, [r7, #12]
3004:..\Source/tasks.c **** }
 3099              		.loc 1 3004 0
 3100 007c 1846     		mov	r0, r3
 3101 007e 1037     		adds	r7, r7, #16
 3102              		.cfi_def_cfa_offset 8
 3103 0080 BD46     		mov	sp, r7
 3104              		.cfi_def_cfa_register 13
 3105              		@ sp needed
 3106 0082 80BD     		pop	{r7, pc}
 3107              	.L207:
 3108              		.align	2
 3109              	.L206:
 3110 0084 E0000000 		.word	uxTopReadyPriority
 3111 0088 04000000 		.word	pxReadyTasksLists
 3112 008c 00000000 		.word	pxCurrentTCB
 3113 0090 EC000000 		.word	xYieldPending
 3114              		.cfi_endproc
 3115              	.LFE95:
 3116              		.size	xTaskRemoveFromUnorderedEventList, .-xTaskRemoveFromUnorderedEventList
 3117              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 3118              		.align	2
 3119              		.global	vTaskSetTimeOutState
 3120              		.thumb
 3121              		.thumb_func
 3122              		.type	vTaskSetTimeOutState, %function
 3123              	vTaskSetTimeOutState:
 3124              	.LFB96:
3005:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3006:..\Source/tasks.c **** 
3007:..\Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3008:..\Source/tasks.c **** {
 3125              		.loc 1 3008 0
 3126              		.cfi_startproc
 3127              		@ args = 0, pretend = 0, frame = 8
 3128              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 114


 3129              		@ link register save eliminated.
 3130 0000 80B4     		push	{r7}
 3131              		.cfi_def_cfa_offset 4
 3132              		.cfi_offset 7, -4
 3133 0002 83B0     		sub	sp, sp, #12
 3134              		.cfi_def_cfa_offset 16
 3135 0004 00AF     		add	r7, sp, #0
 3136              		.cfi_def_cfa_register 7
 3137 0006 7860     		str	r0, [r7, #4]
3009:..\Source/tasks.c **** 	configASSERT( pxTimeOut );
3010:..\Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 3138              		.loc 1 3010 0
 3139 0008 064B     		ldr	r3, .L209
 3140 000a 1A68     		ldr	r2, [r3]
 3141 000c 7B68     		ldr	r3, [r7, #4]
 3142 000e 1A60     		str	r2, [r3]
3011:..\Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 3143              		.loc 1 3011 0
 3144 0010 054B     		ldr	r3, .L209+4
 3145 0012 1A68     		ldr	r2, [r3]
 3146 0014 7B68     		ldr	r3, [r7, #4]
 3147 0016 5A60     		str	r2, [r3, #4]
3012:..\Source/tasks.c **** }
 3148              		.loc 1 3012 0
 3149 0018 0C37     		adds	r7, r7, #12
 3150              		.cfi_def_cfa_offset 4
 3151 001a BD46     		mov	sp, r7
 3152              		.cfi_def_cfa_register 13
 3153              		@ sp needed
 3154 001c 5DF8047B 		ldr	r7, [sp], #4
 3155              		.cfi_restore 7
 3156              		.cfi_def_cfa_offset 0
 3157 0020 7047     		bx	lr
 3158              	.L210:
 3159 0022 00BF     		.align	2
 3160              	.L209:
 3161 0024 F0000000 		.word	xNumOfOverflows
 3162 0028 DC000000 		.word	xTickCount
 3163              		.cfi_endproc
 3164              	.LFE96:
 3165              		.size	vTaskSetTimeOutState, .-vTaskSetTimeOutState
 3166              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 3167              		.align	2
 3168              		.global	xTaskCheckForTimeOut
 3169              		.thumb
 3170              		.thumb_func
 3171              		.type	xTaskCheckForTimeOut, %function
 3172              	xTaskCheckForTimeOut:
 3173              	.LFB97:
3013:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3014:..\Source/tasks.c **** 
3015:..\Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
3016:..\Source/tasks.c **** {
 3174              		.loc 1 3016 0
 3175              		.cfi_startproc
 3176              		@ args = 0, pretend = 0, frame = 16
 3177              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 115


 3178 0000 80B5     		push	{r7, lr}
 3179              		.cfi_def_cfa_offset 8
 3180              		.cfi_offset 7, -8
 3181              		.cfi_offset 14, -4
 3182 0002 84B0     		sub	sp, sp, #16
 3183              		.cfi_def_cfa_offset 24
 3184 0004 00AF     		add	r7, sp, #0
 3185              		.cfi_def_cfa_register 7
 3186 0006 7860     		str	r0, [r7, #4]
 3187 0008 3960     		str	r1, [r7]
3017:..\Source/tasks.c **** BaseType_t xReturn;
3018:..\Source/tasks.c **** 
3019:..\Source/tasks.c **** 	configASSERT( pxTimeOut );
3020:..\Source/tasks.c **** 	configASSERT( pxTicksToWait );
3021:..\Source/tasks.c **** 
3022:..\Source/tasks.c **** 	taskENTER_CRITICAL();
 3188              		.loc 1 3022 0
 3189 000a FFF7FEFF 		bl	vPortEnterCritical
 3190              	.LBB49:
3023:..\Source/tasks.c **** 	{
3024:..\Source/tasks.c **** 		/* Minor optimisation.  The tick count cannot change in this block. */
3025:..\Source/tasks.c **** 		const TickType_t xConstTickCount = xTickCount;
 3191              		.loc 1 3025 0
 3192 000e 1C4B     		ldr	r3, .L217
 3193 0010 1B68     		ldr	r3, [r3]
 3194 0012 BB60     		str	r3, [r7, #8]
3026:..\Source/tasks.c **** 
3027:..\Source/tasks.c **** 		#if( INCLUDE_xTaskAbortDelay == 1 )
3028:..\Source/tasks.c **** 			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
3029:..\Source/tasks.c **** 			{
3030:..\Source/tasks.c **** 				/* The delay was aborted, which is not the same as a time out,
3031:..\Source/tasks.c **** 				but has the same result. */
3032:..\Source/tasks.c **** 				pxCurrentTCB->ucDelayAborted = pdFALSE;
3033:..\Source/tasks.c **** 				xReturn = pdTRUE;
3034:..\Source/tasks.c **** 			}
3035:..\Source/tasks.c **** 			else
3036:..\Source/tasks.c **** 		#endif
3037:..\Source/tasks.c **** 
3038:..\Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3039:..\Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 3195              		.loc 1 3039 0
 3196 0014 3B68     		ldr	r3, [r7]
 3197 0016 1B68     		ldr	r3, [r3]
 3198 0018 B3F1FF3F 		cmp	r3, #-1
 3199 001c 02D1     		bne	.L212
3040:..\Source/tasks.c **** 			{
3041:..\Source/tasks.c **** 				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
3042:..\Source/tasks.c **** 				specified is the maximum block time then the task should block
3043:..\Source/tasks.c **** 				indefinitely, and therefore never time out. */
3044:..\Source/tasks.c **** 				xReturn = pdFALSE;
 3200              		.loc 1 3044 0
 3201 001e 0023     		movs	r3, #0
 3202 0020 FB60     		str	r3, [r7, #12]
 3203 0022 26E0     		b	.L213
 3204              	.L212:
3045:..\Source/tasks.c **** 			}
3046:..\Source/tasks.c **** 			else
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 116


3047:..\Source/tasks.c **** 		#endif
3048:..\Source/tasks.c **** 
3049:..\Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEn
 3205              		.loc 1 3049 0
 3206 0024 7B68     		ldr	r3, [r7, #4]
 3207 0026 1A68     		ldr	r2, [r3]
 3208 0028 164B     		ldr	r3, .L217+4
 3209 002a 1B68     		ldr	r3, [r3]
 3210 002c 9A42     		cmp	r2, r3
 3211 002e 07D0     		beq	.L214
 3212              		.loc 1 3049 0 is_stmt 0 discriminator 1
 3213 0030 7B68     		ldr	r3, [r7, #4]
 3214 0032 5A68     		ldr	r2, [r3, #4]
 3215 0034 BB68     		ldr	r3, [r7, #8]
 3216 0036 9A42     		cmp	r2, r3
 3217 0038 02D8     		bhi	.L214
3050:..\Source/tasks.c **** 		{
3051:..\Source/tasks.c **** 			/* The tick count is greater than the time at which
3052:..\Source/tasks.c **** 			vTaskSetTimeout() was called, but has also overflowed since
3053:..\Source/tasks.c **** 			vTaskSetTimeOut() was called.  It must have wrapped all the way
3054:..\Source/tasks.c **** 			around and gone past again. This passed since vTaskSetTimeout()
3055:..\Source/tasks.c **** 			was called. */
3056:..\Source/tasks.c **** 			xReturn = pdTRUE;
 3218              		.loc 1 3056 0 is_stmt 1
 3219 003a 0123     		movs	r3, #1
 3220 003c FB60     		str	r3, [r7, #12]
 3221 003e 18E0     		b	.L213
 3222              	.L214:
3057:..\Source/tasks.c **** 		}
3058:..\Source/tasks.c **** 		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /
 3223              		.loc 1 3058 0
 3224 0040 7B68     		ldr	r3, [r7, #4]
 3225 0042 5B68     		ldr	r3, [r3, #4]
 3226 0044 BA68     		ldr	r2, [r7, #8]
 3227 0046 D21A     		subs	r2, r2, r3
 3228 0048 3B68     		ldr	r3, [r7]
 3229 004a 1B68     		ldr	r3, [r3]
 3230 004c 9A42     		cmp	r2, r3
 3231 004e 0ED2     		bcs	.L215
3059:..\Source/tasks.c **** 		{
3060:..\Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
3061:..\Source/tasks.c **** 			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 3232              		.loc 1 3061 0
 3233 0050 3B68     		ldr	r3, [r7]
 3234 0052 1A68     		ldr	r2, [r3]
 3235 0054 7B68     		ldr	r3, [r7, #4]
 3236 0056 5968     		ldr	r1, [r3, #4]
 3237 0058 BB68     		ldr	r3, [r7, #8]
 3238 005a CB1A     		subs	r3, r1, r3
 3239 005c 1A44     		add	r2, r2, r3
 3240 005e 3B68     		ldr	r3, [r7]
 3241 0060 1A60     		str	r2, [r3]
3062:..\Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 3242              		.loc 1 3062 0
 3243 0062 7868     		ldr	r0, [r7, #4]
 3244 0064 FFF7FEFF 		bl	vTaskSetTimeOutState
3063:..\Source/tasks.c **** 			xReturn = pdFALSE;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 117


 3245              		.loc 1 3063 0
 3246 0068 0023     		movs	r3, #0
 3247 006a FB60     		str	r3, [r7, #12]
 3248 006c 01E0     		b	.L213
 3249              	.L215:
3064:..\Source/tasks.c **** 		}
3065:..\Source/tasks.c **** 		else
3066:..\Source/tasks.c **** 		{
3067:..\Source/tasks.c **** 			xReturn = pdTRUE;
 3250              		.loc 1 3067 0
 3251 006e 0123     		movs	r3, #1
 3252 0070 FB60     		str	r3, [r7, #12]
 3253              	.L213:
 3254              	.LBE49:
3068:..\Source/tasks.c **** 		}
3069:..\Source/tasks.c **** 	}
3070:..\Source/tasks.c **** 	taskEXIT_CRITICAL();
 3255              		.loc 1 3070 0
 3256 0072 FFF7FEFF 		bl	vPortExitCritical
3071:..\Source/tasks.c **** 
3072:..\Source/tasks.c **** 	return xReturn;
 3257              		.loc 1 3072 0
 3258 0076 FB68     		ldr	r3, [r7, #12]
3073:..\Source/tasks.c **** }
 3259              		.loc 1 3073 0
 3260 0078 1846     		mov	r0, r3
 3261 007a 1037     		adds	r7, r7, #16
 3262              		.cfi_def_cfa_offset 8
 3263 007c BD46     		mov	sp, r7
 3264              		.cfi_def_cfa_register 13
 3265              		@ sp needed
 3266 007e 80BD     		pop	{r7, pc}
 3267              	.L218:
 3268              		.align	2
 3269              	.L217:
 3270 0080 DC000000 		.word	xTickCount
 3271 0084 F0000000 		.word	xNumOfOverflows
 3272              		.cfi_endproc
 3273              	.LFE97:
 3274              		.size	xTaskCheckForTimeOut, .-xTaskCheckForTimeOut
 3275              		.section	.text.vTaskMissedYield,"ax",%progbits
 3276              		.align	2
 3277              		.global	vTaskMissedYield
 3278              		.thumb
 3279              		.thumb_func
 3280              		.type	vTaskMissedYield, %function
 3281              	vTaskMissedYield:
 3282              	.LFB98:
3074:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3075:..\Source/tasks.c **** 
3076:..\Source/tasks.c **** void vTaskMissedYield( void )
3077:..\Source/tasks.c **** {
 3283              		.loc 1 3077 0
 3284              		.cfi_startproc
 3285              		@ args = 0, pretend = 0, frame = 0
 3286              		@ frame_needed = 1, uses_anonymous_args = 0
 3287              		@ link register save eliminated.
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 118


 3288 0000 80B4     		push	{r7}
 3289              		.cfi_def_cfa_offset 4
 3290              		.cfi_offset 7, -4
 3291 0002 00AF     		add	r7, sp, #0
 3292              		.cfi_def_cfa_register 7
3078:..\Source/tasks.c **** 	xYieldPending = pdTRUE;
 3293              		.loc 1 3078 0
 3294 0004 034B     		ldr	r3, .L220
 3295 0006 0122     		movs	r2, #1
 3296 0008 1A60     		str	r2, [r3]
3079:..\Source/tasks.c **** }
 3297              		.loc 1 3079 0
 3298 000a BD46     		mov	sp, r7
 3299              		.cfi_def_cfa_register 13
 3300              		@ sp needed
 3301 000c 5DF8047B 		ldr	r7, [sp], #4
 3302              		.cfi_restore 7
 3303              		.cfi_def_cfa_offset 0
 3304 0010 7047     		bx	lr
 3305              	.L221:
 3306 0012 00BF     		.align	2
 3307              	.L220:
 3308 0014 EC000000 		.word	xYieldPending
 3309              		.cfi_endproc
 3310              	.LFE98:
 3311              		.size	vTaskMissedYield, .-vTaskMissedYield
 3312              		.section	.text.prvIdleTask,"ax",%progbits
 3313              		.align	2
 3314              		.thumb
 3315              		.thumb_func
 3316              		.type	prvIdleTask, %function
 3317              	prvIdleTask:
 3318              	.LFB99:
3080:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3081:..\Source/tasks.c **** 
3082:..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3083:..\Source/tasks.c **** 
3084:..\Source/tasks.c **** 	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3085:..\Source/tasks.c **** 	{
3086:..\Source/tasks.c **** 	UBaseType_t uxReturn;
3087:..\Source/tasks.c **** 	TCB_t *pxTCB;
3088:..\Source/tasks.c **** 
3089:..\Source/tasks.c **** 		if( xTask != NULL )
3090:..\Source/tasks.c **** 		{
3091:..\Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
3092:..\Source/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
3093:..\Source/tasks.c **** 		}
3094:..\Source/tasks.c **** 		else
3095:..\Source/tasks.c **** 		{
3096:..\Source/tasks.c **** 			uxReturn = 0U;
3097:..\Source/tasks.c **** 		}
3098:..\Source/tasks.c **** 
3099:..\Source/tasks.c **** 		return uxReturn;
3100:..\Source/tasks.c **** 	}
3101:..\Source/tasks.c **** 
3102:..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3103:..\Source/tasks.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 119


3104:..\Source/tasks.c **** 
3105:..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3106:..\Source/tasks.c **** 
3107:..\Source/tasks.c **** 	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
3108:..\Source/tasks.c **** 	{
3109:..\Source/tasks.c **** 	TCB_t *pxTCB;
3110:..\Source/tasks.c **** 
3111:..\Source/tasks.c **** 		if( xTask != NULL )
3112:..\Source/tasks.c **** 		{
3113:..\Source/tasks.c **** 			pxTCB = ( TCB_t * ) xTask;
3114:..\Source/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
3115:..\Source/tasks.c **** 		}
3116:..\Source/tasks.c **** 	}
3117:..\Source/tasks.c **** 
3118:..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3119:..\Source/tasks.c **** 
3120:..\Source/tasks.c **** /*
3121:..\Source/tasks.c ****  * -----------------------------------------------------------
3122:..\Source/tasks.c ****  * The Idle task.
3123:..\Source/tasks.c ****  * ----------------------------------------------------------
3124:..\Source/tasks.c ****  *
3125:..\Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3126:..\Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3127:..\Source/tasks.c ****  *
3128:..\Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3129:..\Source/tasks.c ****  *
3130:..\Source/tasks.c ****  */
3131:..\Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3132:..\Source/tasks.c **** {
 3319              		.loc 1 3132 0
 3320              		.cfi_startproc
 3321              		@ args = 0, pretend = 0, frame = 8
 3322              		@ frame_needed = 1, uses_anonymous_args = 0
 3323 0000 80B5     		push	{r7, lr}
 3324              		.cfi_def_cfa_offset 8
 3325              		.cfi_offset 7, -8
 3326              		.cfi_offset 14, -4
 3327 0002 82B0     		sub	sp, sp, #8
 3328              		.cfi_def_cfa_offset 16
 3329 0004 00AF     		add	r7, sp, #0
 3330              		.cfi_def_cfa_register 7
 3331 0006 7860     		str	r0, [r7, #4]
 3332              	.L223:
3133:..\Source/tasks.c **** 	/* Stop warnings. */
3134:..\Source/tasks.c **** 	( void ) pvParameters;
3135:..\Source/tasks.c **** 
3136:..\Source/tasks.c **** 	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3137:..\Source/tasks.c **** 	SCHEDULER IS STARTED. **/
3138:..\Source/tasks.c **** 
3139:..\Source/tasks.c **** 	for( ;; )
3140:..\Source/tasks.c **** 	{
3141:..\Source/tasks.c **** 		/* See if any tasks have deleted themselves - if so then the idle task
3142:..\Source/tasks.c **** 		is responsible for freeing the deleted task's TCB and stack. */
3143:..\Source/tasks.c **** 		prvCheckTasksWaitingTermination();
 3333              		.loc 1 3143 0 discriminator 1
 3334 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
3144:..\Source/tasks.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 120


3145:..\Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
3146:..\Source/tasks.c **** 		{
3147:..\Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
3148:..\Source/tasks.c **** 			see if any other task has become available.  If we are using
3149:..\Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
3150:..\Source/tasks.c **** 			will automatically get the processor anyway. */
3151:..\Source/tasks.c **** 			taskYIELD();
3152:..\Source/tasks.c **** 		}
3153:..\Source/tasks.c **** 		#endif /* configUSE_PREEMPTION */
3154:..\Source/tasks.c **** 
3155:..\Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3156:..\Source/tasks.c **** 		{
3157:..\Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
3158:..\Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
3159:..\Source/tasks.c **** 			to run then the idle task should yield before the end of the
3160:..\Source/tasks.c **** 			timeslice.
3161:..\Source/tasks.c **** 
3162:..\Source/tasks.c **** 			A critical region is not required here as we are just reading from
3163:..\Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
3164:..\Source/tasks.c **** 			the ready list at the idle priority contains more than one task
3165:..\Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
3166:..\Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
3167:..\Source/tasks.c **** 			{
3168:..\Source/tasks.c **** 				taskYIELD();
3169:..\Source/tasks.c **** 			}
3170:..\Source/tasks.c **** 			else
3171:..\Source/tasks.c **** 			{
3172:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3173:..\Source/tasks.c **** 			}
3174:..\Source/tasks.c **** 		}
3175:..\Source/tasks.c **** 		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3176:..\Source/tasks.c **** 
3177:..\Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
3178:..\Source/tasks.c **** 		{
3179:..\Source/tasks.c **** 			extern void vApplicationIdleHook( void );
3180:..\Source/tasks.c **** 
3181:..\Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
3182:..\Source/tasks.c **** 			allows the application designer to add background functionality
3183:..\Source/tasks.c **** 			without the overhead of a separate task.
3184:..\Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
3185:..\Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
3186:..\Source/tasks.c **** 			vApplicationIdleHook();
3187:..\Source/tasks.c **** 		}
3188:..\Source/tasks.c **** 		#endif /* configUSE_IDLE_HOOK */
3189:..\Source/tasks.c **** 
3190:..\Source/tasks.c **** 		/* This conditional compilation should use inequality to 0, not equality
3191:..\Source/tasks.c **** 		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3192:..\Source/tasks.c **** 		user defined low power mode	implementations require
3193:..\Source/tasks.c **** 		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3194:..\Source/tasks.c **** 		#if ( configUSE_TICKLESS_IDLE != 0 )
3195:..\Source/tasks.c **** 		{
3196:..\Source/tasks.c **** 		TickType_t xExpectedIdleTime;
3197:..\Source/tasks.c **** 
3198:..\Source/tasks.c **** 			/* It is not desirable to suspend then resume the scheduler on
3199:..\Source/tasks.c **** 			each iteration of the idle task.  Therefore, a preliminary
3200:..\Source/tasks.c **** 			test of the expected idle time is performed without the
3201:..\Source/tasks.c **** 			scheduler suspended.  The result here is not necessarily
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 121


3202:..\Source/tasks.c **** 			valid. */
3203:..\Source/tasks.c **** 			xExpectedIdleTime = prvGetExpectedIdleTime();
3204:..\Source/tasks.c **** 
3205:..\Source/tasks.c **** 			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3206:..\Source/tasks.c **** 			{
3207:..\Source/tasks.c **** 				vTaskSuspendAll();
3208:..\Source/tasks.c **** 				{
3209:..\Source/tasks.c **** 					/* Now the scheduler is suspended, the expected idle
3210:..\Source/tasks.c **** 					time can be sampled again, and this time its value can
3211:..\Source/tasks.c **** 					be used. */
3212:..\Source/tasks.c **** 					configASSERT( xNextTaskUnblockTime >= xTickCount );
3213:..\Source/tasks.c **** 					xExpectedIdleTime = prvGetExpectedIdleTime();
3214:..\Source/tasks.c **** 
3215:..\Source/tasks.c **** 					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3216:..\Source/tasks.c **** 					{
3217:..\Source/tasks.c **** 						traceLOW_POWER_IDLE_BEGIN();
3218:..\Source/tasks.c **** 						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3219:..\Source/tasks.c **** 						traceLOW_POWER_IDLE_END();
3220:..\Source/tasks.c **** 					}
3221:..\Source/tasks.c **** 					else
3222:..\Source/tasks.c **** 					{
3223:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3224:..\Source/tasks.c **** 					}
3225:..\Source/tasks.c **** 				}
3226:..\Source/tasks.c **** 				( void ) xTaskResumeAll();
3227:..\Source/tasks.c **** 			}
3228:..\Source/tasks.c **** 			else
3229:..\Source/tasks.c **** 			{
3230:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3231:..\Source/tasks.c **** 			}
3232:..\Source/tasks.c **** 		}
3233:..\Source/tasks.c **** 		#endif /* configUSE_TICKLESS_IDLE */
3234:..\Source/tasks.c **** 	}
 3335              		.loc 1 3234 0 discriminator 1
 3336 000c FCE7     		b	.L223
 3337              		.cfi_endproc
 3338              	.LFE99:
 3339              		.size	prvIdleTask, .-prvIdleTask
 3340 000e 00BF     		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3341              		.align	2
 3342              		.thumb
 3343              		.thumb_func
 3344              		.type	prvInitialiseTaskLists, %function
 3345              	prvInitialiseTaskLists:
 3346              	.LFB100:
3235:..\Source/tasks.c **** }
3236:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3237:..\Source/tasks.c **** 
3238:..\Source/tasks.c **** #if( configUSE_TICKLESS_IDLE != 0 )
3239:..\Source/tasks.c **** 
3240:..\Source/tasks.c **** 	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3241:..\Source/tasks.c **** 	{
3242:..\Source/tasks.c **** 	/* The idle task exists in addition to the application tasks. */
3243:..\Source/tasks.c **** 	const UBaseType_t uxNonApplicationTasks = 1;
3244:..\Source/tasks.c **** 	eSleepModeStatus eReturn = eStandardSleep;
3245:..\Source/tasks.c **** 
3246:..\Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 122


3247:..\Source/tasks.c **** 		{
3248:..\Source/tasks.c **** 			/* A task was made ready while the scheduler was suspended. */
3249:..\Source/tasks.c **** 			eReturn = eAbortSleep;
3250:..\Source/tasks.c **** 		}
3251:..\Source/tasks.c **** 		else if( xYieldPending != pdFALSE )
3252:..\Source/tasks.c **** 		{
3253:..\Source/tasks.c **** 			/* A yield was pended while the scheduler was suspended. */
3254:..\Source/tasks.c **** 			eReturn = eAbortSleep;
3255:..\Source/tasks.c **** 		}
3256:..\Source/tasks.c **** 		else
3257:..\Source/tasks.c **** 		{
3258:..\Source/tasks.c **** 			/* If all the tasks are in the suspended list (which might mean they
3259:..\Source/tasks.c **** 			have an infinite block time rather than actually being suspended)
3260:..\Source/tasks.c **** 			then it is safe to turn all clocks off and just wait for external
3261:..\Source/tasks.c **** 			interrupts. */
3262:..\Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicatio
3263:..\Source/tasks.c **** 			{
3264:..\Source/tasks.c **** 				eReturn = eNoTasksWaitingTimeout;
3265:..\Source/tasks.c **** 			}
3266:..\Source/tasks.c **** 			else
3267:..\Source/tasks.c **** 			{
3268:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3269:..\Source/tasks.c **** 			}
3270:..\Source/tasks.c **** 		}
3271:..\Source/tasks.c **** 
3272:..\Source/tasks.c **** 		return eReturn;
3273:..\Source/tasks.c **** 	}
3274:..\Source/tasks.c **** 
3275:..\Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3276:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3277:..\Source/tasks.c **** 
3278:..\Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3279:..\Source/tasks.c **** 
3280:..\Source/tasks.c **** 	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue 
3281:..\Source/tasks.c **** 	{
3282:..\Source/tasks.c **** 	TCB_t *pxTCB;
3283:..\Source/tasks.c **** 
3284:..\Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3285:..\Source/tasks.c **** 		{
3286:..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToSet );
3287:..\Source/tasks.c **** 			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3288:..\Source/tasks.c **** 		}
3289:..\Source/tasks.c **** 	}
3290:..\Source/tasks.c **** 
3291:..\Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3292:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3293:..\Source/tasks.c **** 
3294:..\Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3295:..\Source/tasks.c **** 
3296:..\Source/tasks.c **** 	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
3297:..\Source/tasks.c **** 	{
3298:..\Source/tasks.c **** 	void *pvReturn = NULL;
3299:..\Source/tasks.c **** 	TCB_t *pxTCB;
3300:..\Source/tasks.c **** 
3301:..\Source/tasks.c **** 		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
3302:..\Source/tasks.c **** 		{
3303:..\Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 123


3304:..\Source/tasks.c **** 			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3305:..\Source/tasks.c **** 		}
3306:..\Source/tasks.c **** 		else
3307:..\Source/tasks.c **** 		{
3308:..\Source/tasks.c **** 			pvReturn = NULL;
3309:..\Source/tasks.c **** 		}
3310:..\Source/tasks.c **** 
3311:..\Source/tasks.c **** 		return pvReturn;
3312:..\Source/tasks.c **** 	}
3313:..\Source/tasks.c **** 
3314:..\Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3315:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3316:..\Source/tasks.c **** 
3317:..\Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3318:..\Source/tasks.c **** 
3319:..\Source/tasks.c **** 	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
3320:..\Source/tasks.c **** 	{
3321:..\Source/tasks.c **** 	TCB_t *pxTCB;
3322:..\Source/tasks.c **** 
3323:..\Source/tasks.c **** 		/* If null is passed in here then we are modifying the MPU settings of
3324:..\Source/tasks.c **** 		the calling task. */
3325:..\Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
3326:..\Source/tasks.c **** 
3327:..\Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3328:..\Source/tasks.c **** 	}
3329:..\Source/tasks.c **** 
3330:..\Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3331:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3332:..\Source/tasks.c **** 
3333:..\Source/tasks.c **** static void prvInitialiseTaskLists( void )
3334:..\Source/tasks.c **** {
 3347              		.loc 1 3334 0
 3348              		.cfi_startproc
 3349              		@ args = 0, pretend = 0, frame = 8
 3350              		@ frame_needed = 1, uses_anonymous_args = 0
 3351 0000 80B5     		push	{r7, lr}
 3352              		.cfi_def_cfa_offset 8
 3353              		.cfi_offset 7, -8
 3354              		.cfi_offset 14, -4
 3355 0002 82B0     		sub	sp, sp, #8
 3356              		.cfi_def_cfa_offset 16
 3357 0004 00AF     		add	r7, sp, #0
 3358              		.cfi_def_cfa_register 7
3335:..\Source/tasks.c **** UBaseType_t uxPriority;
3336:..\Source/tasks.c **** 
3337:..\Source/tasks.c **** 	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriorit
 3359              		.loc 1 3337 0
 3360 0006 0023     		movs	r3, #0
 3361 0008 7B60     		str	r3, [r7, #4]
 3362 000a 0CE0     		b	.L225
 3363              	.L226:
3338:..\Source/tasks.c **** 	{
3339:..\Source/tasks.c **** 		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 3364              		.loc 1 3339 0 discriminator 3
 3365 000c 7A68     		ldr	r2, [r7, #4]
 3366 000e 1346     		mov	r3, r2
 3367 0010 9B00     		lsls	r3, r3, #2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 124


 3368 0012 1344     		add	r3, r3, r2
 3369 0014 9B00     		lsls	r3, r3, #2
 3370 0016 114A     		ldr	r2, .L227
 3371 0018 1344     		add	r3, r3, r2
 3372 001a 1846     		mov	r0, r3
 3373 001c FFF7FEFF 		bl	vListInitialise
3337:..\Source/tasks.c **** 	{
 3374              		.loc 1 3337 0 discriminator 3
 3375 0020 7B68     		ldr	r3, [r7, #4]
 3376 0022 0133     		adds	r3, r3, #1
 3377 0024 7B60     		str	r3, [r7, #4]
 3378              	.L225:
3337:..\Source/tasks.c **** 	{
 3379              		.loc 1 3337 0 is_stmt 0 discriminator 1
 3380 0026 7B68     		ldr	r3, [r7, #4]
 3381 0028 042B     		cmp	r3, #4
 3382 002a EFD9     		bls	.L226
3340:..\Source/tasks.c **** 	}
3341:..\Source/tasks.c **** 
3342:..\Source/tasks.c **** 	vListInitialise( &xDelayedTaskList1 );
 3383              		.loc 1 3342 0 is_stmt 1
 3384 002c 0C48     		ldr	r0, .L227+4
 3385 002e FFF7FEFF 		bl	vListInitialise
3343:..\Source/tasks.c **** 	vListInitialise( &xDelayedTaskList2 );
 3386              		.loc 1 3343 0
 3387 0032 0C48     		ldr	r0, .L227+8
 3388 0034 FFF7FEFF 		bl	vListInitialise
3344:..\Source/tasks.c **** 	vListInitialise( &xPendingReadyList );
 3389              		.loc 1 3344 0
 3390 0038 0B48     		ldr	r0, .L227+12
 3391 003a FFF7FEFF 		bl	vListInitialise
3345:..\Source/tasks.c **** 
3346:..\Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3347:..\Source/tasks.c **** 	{
3348:..\Source/tasks.c **** 		vListInitialise( &xTasksWaitingTermination );
 3392              		.loc 1 3348 0
 3393 003e 0B48     		ldr	r0, .L227+16
 3394 0040 FFF7FEFF 		bl	vListInitialise
3349:..\Source/tasks.c **** 	}
3350:..\Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3351:..\Source/tasks.c **** 
3352:..\Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
3353:..\Source/tasks.c **** 	{
3354:..\Source/tasks.c **** 		vListInitialise( &xSuspendedTaskList );
 3395              		.loc 1 3354 0
 3396 0044 0A48     		ldr	r0, .L227+20
 3397 0046 FFF7FEFF 		bl	vListInitialise
3355:..\Source/tasks.c **** 	}
3356:..\Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
3357:..\Source/tasks.c **** 
3358:..\Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3359:..\Source/tasks.c **** 	using list2. */
3360:..\Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3398              		.loc 1 3360 0
 3399 004a 0A4B     		ldr	r3, .L227+24
 3400 004c 044A     		ldr	r2, .L227+4
 3401 004e 1A60     		str	r2, [r3]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 125


3361:..\Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3402              		.loc 1 3361 0
 3403 0050 094B     		ldr	r3, .L227+28
 3404 0052 044A     		ldr	r2, .L227+8
 3405 0054 1A60     		str	r2, [r3]
3362:..\Source/tasks.c **** }
 3406              		.loc 1 3362 0
 3407 0056 0837     		adds	r7, r7, #8
 3408              		.cfi_def_cfa_offset 8
 3409 0058 BD46     		mov	sp, r7
 3410              		.cfi_def_cfa_register 13
 3411              		@ sp needed
 3412 005a 80BD     		pop	{r7, pc}
 3413              	.L228:
 3414              		.align	2
 3415              	.L227:
 3416 005c 04000000 		.word	pxReadyTasksLists
 3417 0060 68000000 		.word	xDelayedTaskList1
 3418 0064 7C000000 		.word	xDelayedTaskList2
 3419 0068 98000000 		.word	xPendingReadyList
 3420 006c AC000000 		.word	xTasksWaitingTermination
 3421 0070 C4000000 		.word	xSuspendedTaskList
 3422 0074 90000000 		.word	pxDelayedTaskList
 3423 0078 94000000 		.word	pxOverflowDelayedTaskList
 3424              		.cfi_endproc
 3425              	.LFE100:
 3426              		.size	prvInitialiseTaskLists, .-prvInitialiseTaskLists
 3427              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3428              		.align	2
 3429              		.thumb
 3430              		.thumb_func
 3431              		.type	prvCheckTasksWaitingTermination, %function
 3432              	prvCheckTasksWaitingTermination:
 3433              	.LFB101:
3363:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3364:..\Source/tasks.c **** 
3365:..\Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3366:..\Source/tasks.c **** {
 3434              		.loc 1 3366 0
 3435              		.cfi_startproc
 3436              		@ args = 0, pretend = 0, frame = 8
 3437              		@ frame_needed = 1, uses_anonymous_args = 0
 3438 0000 80B5     		push	{r7, lr}
 3439              		.cfi_def_cfa_offset 8
 3440              		.cfi_offset 7, -8
 3441              		.cfi_offset 14, -4
 3442 0002 82B0     		sub	sp, sp, #8
 3443              		.cfi_def_cfa_offset 16
 3444 0004 00AF     		add	r7, sp, #0
 3445              		.cfi_def_cfa_register 7
 3446              	.LBB50:
3367:..\Source/tasks.c **** 
3368:..\Source/tasks.c **** 	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
3369:..\Source/tasks.c **** 
3370:..\Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
3371:..\Source/tasks.c **** 	{
3372:..\Source/tasks.c **** 		BaseType_t xListIsEmpty;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 126


3373:..\Source/tasks.c **** 
3374:..\Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
3375:..\Source/tasks.c **** 		too often in the idle task. */
3376:..\Source/tasks.c **** 		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 3447              		.loc 1 3376 0
 3448 0006 28E0     		b	.L230
 3449              	.L231:
3377:..\Source/tasks.c **** 		{
3378:..\Source/tasks.c **** 			vTaskSuspendAll();
 3450              		.loc 1 3378 0
 3451 0008 FFF7FEFF 		bl	vTaskSuspendAll
3379:..\Source/tasks.c **** 			{
3380:..\Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3452              		.loc 1 3380 0
 3453 000c 164B     		ldr	r3, .L232
 3454 000e 1B68     		ldr	r3, [r3]
 3455 0010 002B     		cmp	r3, #0
 3456 0012 0CBF     		ite	eq
 3457 0014 0123     		moveq	r3, #1
 3458 0016 0023     		movne	r3, #0
 3459 0018 DBB2     		uxtb	r3, r3
 3460 001a 7B60     		str	r3, [r7, #4]
3381:..\Source/tasks.c **** 			}
3382:..\Source/tasks.c **** 			( void ) xTaskResumeAll();
 3461              		.loc 1 3382 0
 3462 001c FFF7FEFF 		bl	xTaskResumeAll
3383:..\Source/tasks.c **** 
3384:..\Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 3463              		.loc 1 3384 0
 3464 0020 7B68     		ldr	r3, [r7, #4]
 3465 0022 002B     		cmp	r3, #0
 3466 0024 19D1     		bne	.L230
 3467              	.LBB51:
3385:..\Source/tasks.c **** 			{
3386:..\Source/tasks.c **** 				TCB_t *pxTCB;
3387:..\Source/tasks.c **** 
3388:..\Source/tasks.c **** 				taskENTER_CRITICAL();
 3468              		.loc 1 3388 0
 3469 0026 FFF7FEFF 		bl	vPortEnterCritical
3389:..\Source/tasks.c **** 				{
3390:..\Source/tasks.c **** 					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 3470              		.loc 1 3390 0
 3471 002a 0F4B     		ldr	r3, .L232
 3472 002c DB68     		ldr	r3, [r3, #12]
 3473 002e DB68     		ldr	r3, [r3, #12]
 3474 0030 3B60     		str	r3, [r7]
3391:..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 3475              		.loc 1 3391 0
 3476 0032 3B68     		ldr	r3, [r7]
 3477 0034 0433     		adds	r3, r3, #4
 3478 0036 1846     		mov	r0, r3
 3479 0038 FFF7FEFF 		bl	uxListRemove
3392:..\Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 3480              		.loc 1 3392 0
 3481 003c 0B4B     		ldr	r3, .L232+4
 3482 003e 1B68     		ldr	r3, [r3]
 3483 0040 013B     		subs	r3, r3, #1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 127


 3484 0042 0A4A     		ldr	r2, .L232+4
 3485 0044 1360     		str	r3, [r2]
3393:..\Source/tasks.c **** 					--uxDeletedTasksWaitingCleanUp;
 3486              		.loc 1 3393 0
 3487 0046 0A4B     		ldr	r3, .L232+8
 3488 0048 1B68     		ldr	r3, [r3]
 3489 004a 013B     		subs	r3, r3, #1
 3490 004c 084A     		ldr	r2, .L232+8
 3491 004e 1360     		str	r3, [r2]
3394:..\Source/tasks.c **** 				}
3395:..\Source/tasks.c **** 				taskEXIT_CRITICAL();
 3492              		.loc 1 3395 0
 3493 0050 FFF7FEFF 		bl	vPortExitCritical
3396:..\Source/tasks.c **** 
3397:..\Source/tasks.c **** 				prvDeleteTCB( pxTCB );
 3494              		.loc 1 3397 0
 3495 0054 3868     		ldr	r0, [r7]
 3496 0056 FFF7FEFF 		bl	prvDeleteTCB
 3497              	.L230:
 3498              	.LBE51:
3376:..\Source/tasks.c **** 		{
 3499              		.loc 1 3376 0
 3500 005a 054B     		ldr	r3, .L232+8
 3501 005c 1B68     		ldr	r3, [r3]
 3502 005e 002B     		cmp	r3, #0
 3503 0060 D2D1     		bne	.L231
 3504              	.LBE50:
3398:..\Source/tasks.c **** 			}
3399:..\Source/tasks.c **** 			else
3400:..\Source/tasks.c **** 			{
3401:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3402:..\Source/tasks.c **** 			}
3403:..\Source/tasks.c **** 		}
3404:..\Source/tasks.c **** 	}
3405:..\Source/tasks.c **** 	#endif /* INCLUDE_vTaskDelete */
3406:..\Source/tasks.c **** }
 3505              		.loc 1 3406 0
 3506 0062 0837     		adds	r7, r7, #8
 3507              		.cfi_def_cfa_offset 8
 3508 0064 BD46     		mov	sp, r7
 3509              		.cfi_def_cfa_register 13
 3510              		@ sp needed
 3511 0066 80BD     		pop	{r7, pc}
 3512              	.L233:
 3513              		.align	2
 3514              	.L232:
 3515 0068 AC000000 		.word	xTasksWaitingTermination
 3516 006c D8000000 		.word	uxCurrentNumberOfTasks
 3517 0070 C0000000 		.word	uxDeletedTasksWaitingCleanUp
 3518              		.cfi_endproc
 3519              	.LFE101:
 3520              		.size	prvCheckTasksWaitingTermination, .-prvCheckTasksWaitingTermination
 3521              		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 3522              		.align	2
 3523              		.thumb
 3524              		.thumb_func
 3525              		.type	prvTaskCheckFreeStackSpace, %function
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 128


 3526              	prvTaskCheckFreeStackSpace:
 3527              	.LFB102:
3407:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3408:..\Source/tasks.c **** 
3409:..\Source/tasks.c **** #if( configUSE_TRACE_FACILITY == 1 )
3410:..\Source/tasks.c **** 
3411:..\Source/tasks.c **** 	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, 
3412:..\Source/tasks.c **** 	{
3413:..\Source/tasks.c **** 	TCB_t *pxTCB;
3414:..\Source/tasks.c **** 
3415:..\Source/tasks.c **** 		/* xTask is NULL then get the state of the calling task. */
3416:..\Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
3417:..\Source/tasks.c **** 
3418:..\Source/tasks.c **** 		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
3419:..\Source/tasks.c **** 		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
3420:..\Source/tasks.c **** 		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
3421:..\Source/tasks.c **** 		pxTaskStatus->pxStackBase = pxTCB->pxStack;
3422:..\Source/tasks.c **** 		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
3423:..\Source/tasks.c **** 
3424:..\Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
3425:..\Source/tasks.c **** 		{
3426:..\Source/tasks.c **** 			/* If the task is in the suspended list then there is a chance it is
3427:..\Source/tasks.c **** 			actually just blocked indefinitely - so really it should be reported as
3428:..\Source/tasks.c **** 			being in the Blocked state. */
3429:..\Source/tasks.c **** 			if( pxTaskStatus->eCurrentState == eSuspended )
3430:..\Source/tasks.c **** 			{
3431:..\Source/tasks.c **** 				vTaskSuspendAll();
3432:..\Source/tasks.c **** 				{
3433:..\Source/tasks.c **** 					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
3434:..\Source/tasks.c **** 					{
3435:..\Source/tasks.c **** 						pxTaskStatus->eCurrentState = eBlocked;
3436:..\Source/tasks.c **** 					}
3437:..\Source/tasks.c **** 				}
3438:..\Source/tasks.c **** 				xTaskResumeAll();
3439:..\Source/tasks.c **** 			}
3440:..\Source/tasks.c **** 		}
3441:..\Source/tasks.c **** 		#endif /* INCLUDE_vTaskSuspend */
3442:..\Source/tasks.c **** 
3443:..\Source/tasks.c **** 		#if ( configUSE_MUTEXES == 1 )
3444:..\Source/tasks.c **** 		{
3445:..\Source/tasks.c **** 			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
3446:..\Source/tasks.c **** 		}
3447:..\Source/tasks.c **** 		#else
3448:..\Source/tasks.c **** 		{
3449:..\Source/tasks.c **** 			pxTaskStatus->uxBasePriority = 0;
3450:..\Source/tasks.c **** 		}
3451:..\Source/tasks.c **** 		#endif
3452:..\Source/tasks.c **** 
3453:..\Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
3454:..\Source/tasks.c **** 		{
3455:..\Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
3456:..\Source/tasks.c **** 		}
3457:..\Source/tasks.c **** 		#else
3458:..\Source/tasks.c **** 		{
3459:..\Source/tasks.c **** 			pxTaskStatus->ulRunTimeCounter = 0;
3460:..\Source/tasks.c **** 		}
3461:..\Source/tasks.c **** 		#endif
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 129


3462:..\Source/tasks.c **** 
3463:..\Source/tasks.c **** 		/* Obtaining the task state is a little fiddly, so is only done if the value
3464:..\Source/tasks.c **** 		of eState passed into this function is eInvalid - otherwise the state is
3465:..\Source/tasks.c **** 		just set to whatever is passed in. */
3466:..\Source/tasks.c **** 		if( eState != eInvalid )
3467:..\Source/tasks.c **** 		{
3468:..\Source/tasks.c **** 			pxTaskStatus->eCurrentState = eState;
3469:..\Source/tasks.c **** 		}
3470:..\Source/tasks.c **** 		else
3471:..\Source/tasks.c **** 		{
3472:..\Source/tasks.c **** 			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
3473:..\Source/tasks.c **** 		}
3474:..\Source/tasks.c **** 
3475:..\Source/tasks.c **** 		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3476:..\Source/tasks.c **** 		parameter is provided to allow it to be skipped. */
3477:..\Source/tasks.c **** 		if( xGetFreeStackSpace != pdFALSE )
3478:..\Source/tasks.c **** 		{
3479:..\Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
3480:..\Source/tasks.c **** 			{
3481:..\Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfSt
3482:..\Source/tasks.c **** 			}
3483:..\Source/tasks.c **** 			#else
3484:..\Source/tasks.c **** 			{
3485:..\Source/tasks.c **** 				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack )
3486:..\Source/tasks.c **** 			}
3487:..\Source/tasks.c **** 			#endif
3488:..\Source/tasks.c **** 		}
3489:..\Source/tasks.c **** 		else
3490:..\Source/tasks.c **** 		{
3491:..\Source/tasks.c **** 			pxTaskStatus->usStackHighWaterMark = 0;
3492:..\Source/tasks.c **** 		}
3493:..\Source/tasks.c **** 	}
3494:..\Source/tasks.c **** 
3495:..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3496:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3497:..\Source/tasks.c **** 
3498:..\Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3499:..\Source/tasks.c **** 
3500:..\Source/tasks.c **** 	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, 
3501:..\Source/tasks.c **** 	{
3502:..\Source/tasks.c **** 	volatile TCB_t *pxNextTCB, *pxFirstTCB;
3503:..\Source/tasks.c **** 	UBaseType_t uxTask = 0;
3504:..\Source/tasks.c **** 
3505:..\Source/tasks.c **** 		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
3506:..\Source/tasks.c **** 		{
3507:..\Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
3508:..\Source/tasks.c **** 
3509:..\Source/tasks.c **** 			/* Populate an TaskStatus_t structure within the
3510:..\Source/tasks.c **** 			pxTaskStatusArray array for each task that is referenced from
3511:..\Source/tasks.c **** 			pxList.  See the definition of TaskStatus_t in task.h for the
3512:..\Source/tasks.c **** 			meaning of each TaskStatus_t structure member. */
3513:..\Source/tasks.c **** 			do
3514:..\Source/tasks.c **** 			{
3515:..\Source/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
3516:..\Source/tasks.c **** 				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
3517:..\Source/tasks.c **** 				uxTask++;
3518:..\Source/tasks.c **** 			} while( pxNextTCB != pxFirstTCB );
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 130


3519:..\Source/tasks.c **** 		}
3520:..\Source/tasks.c **** 		else
3521:..\Source/tasks.c **** 		{
3522:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3523:..\Source/tasks.c **** 		}
3524:..\Source/tasks.c **** 
3525:..\Source/tasks.c **** 		return uxTask;
3526:..\Source/tasks.c **** 	}
3527:..\Source/tasks.c **** 
3528:..\Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3529:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3530:..\Source/tasks.c **** 
3531:..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3532:..\Source/tasks.c **** 
3533:..\Source/tasks.c **** 	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3534:..\Source/tasks.c **** 	{
 3528              		.loc 1 3534 0
 3529              		.cfi_startproc
 3530              		@ args = 0, pretend = 0, frame = 16
 3531              		@ frame_needed = 1, uses_anonymous_args = 0
 3532              		@ link register save eliminated.
 3533 0000 80B4     		push	{r7}
 3534              		.cfi_def_cfa_offset 4
 3535              		.cfi_offset 7, -4
 3536 0002 85B0     		sub	sp, sp, #20
 3537              		.cfi_def_cfa_offset 24
 3538 0004 00AF     		add	r7, sp, #0
 3539              		.cfi_def_cfa_register 7
 3540 0006 7860     		str	r0, [r7, #4]
3535:..\Source/tasks.c **** 	uint32_t ulCount = 0U;
 3541              		.loc 1 3535 0
 3542 0008 0023     		movs	r3, #0
 3543 000a FB60     		str	r3, [r7, #12]
3536:..\Source/tasks.c **** 
3537:..\Source/tasks.c **** 		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 3544              		.loc 1 3537 0
 3545 000c 05E0     		b	.L235
 3546              	.L236:
3538:..\Source/tasks.c **** 		{
3539:..\Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 3547              		.loc 1 3539 0
 3548 000e 7B68     		ldr	r3, [r7, #4]
 3549 0010 0133     		adds	r3, r3, #1
 3550 0012 7B60     		str	r3, [r7, #4]
3540:..\Source/tasks.c **** 			ulCount++;
 3551              		.loc 1 3540 0
 3552 0014 FB68     		ldr	r3, [r7, #12]
 3553 0016 0133     		adds	r3, r3, #1
 3554 0018 FB60     		str	r3, [r7, #12]
 3555              	.L235:
3537:..\Source/tasks.c **** 		{
 3556              		.loc 1 3537 0
 3557 001a 7B68     		ldr	r3, [r7, #4]
 3558 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 3559 001e A52B     		cmp	r3, #165
 3560 0020 F5D0     		beq	.L236
3541:..\Source/tasks.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 131


3542:..\Source/tasks.c **** 
3543:..\Source/tasks.c **** 		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller a
 3561              		.loc 1 3543 0
 3562 0022 FB68     		ldr	r3, [r7, #12]
 3563 0024 9B08     		lsrs	r3, r3, #2
 3564 0026 FB60     		str	r3, [r7, #12]
3544:..\Source/tasks.c **** 
3545:..\Source/tasks.c **** 		return ( uint16_t ) ulCount;
 3565              		.loc 1 3545 0
 3566 0028 FB68     		ldr	r3, [r7, #12]
 3567 002a 9BB2     		uxth	r3, r3
3546:..\Source/tasks.c **** 	}
 3568              		.loc 1 3546 0
 3569 002c 1846     		mov	r0, r3
 3570 002e 1437     		adds	r7, r7, #20
 3571              		.cfi_def_cfa_offset 4
 3572 0030 BD46     		mov	sp, r7
 3573              		.cfi_def_cfa_register 13
 3574              		@ sp needed
 3575 0032 5DF8047B 		ldr	r7, [sp], #4
 3576              		.cfi_restore 7
 3577              		.cfi_def_cfa_offset 0
 3578 0036 7047     		bx	lr
 3579              		.cfi_endproc
 3580              	.LFE102:
 3581              		.size	prvTaskCheckFreeStackSpace, .-prvTaskCheckFreeStackSpace
 3582              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 3583              		.align	2
 3584              		.global	uxTaskGetStackHighWaterMark
 3585              		.thumb
 3586              		.thumb_func
 3587              		.type	uxTaskGetStackHighWaterMark, %function
 3588              	uxTaskGetStackHighWaterMark:
 3589              	.LFB103:
3547:..\Source/tasks.c **** 
3548:..\Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3549:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3550:..\Source/tasks.c **** 
3551:..\Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3552:..\Source/tasks.c **** 
3553:..\Source/tasks.c **** 	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3554:..\Source/tasks.c **** 	{
 3590              		.loc 1 3554 0
 3591              		.cfi_startproc
 3592              		@ args = 0, pretend = 0, frame = 24
 3593              		@ frame_needed = 1, uses_anonymous_args = 0
 3594 0000 80B5     		push	{r7, lr}
 3595              		.cfi_def_cfa_offset 8
 3596              		.cfi_offset 7, -8
 3597              		.cfi_offset 14, -4
 3598 0002 86B0     		sub	sp, sp, #24
 3599              		.cfi_def_cfa_offset 32
 3600 0004 00AF     		add	r7, sp, #0
 3601              		.cfi_def_cfa_register 7
 3602 0006 7860     		str	r0, [r7, #4]
3555:..\Source/tasks.c **** 	TCB_t *pxTCB;
3556:..\Source/tasks.c **** 	uint8_t *pucEndOfStack;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 132


3557:..\Source/tasks.c **** 	UBaseType_t uxReturn;
3558:..\Source/tasks.c **** 
3559:..\Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 3603              		.loc 1 3559 0
 3604 0008 7B68     		ldr	r3, [r7, #4]
 3605 000a 002B     		cmp	r3, #0
 3606 000c 02D1     		bne	.L239
 3607              		.loc 1 3559 0 is_stmt 0 discriminator 1
 3608 000e 094B     		ldr	r3, .L242
 3609 0010 1B68     		ldr	r3, [r3]
 3610 0012 00E0     		b	.L240
 3611              	.L239:
 3612              		.loc 1 3559 0 discriminator 2
 3613 0014 7B68     		ldr	r3, [r7, #4]
 3614              	.L240:
 3615              		.loc 1 3559 0 discriminator 4
 3616 0016 7B61     		str	r3, [r7, #20]
3560:..\Source/tasks.c **** 
3561:..\Source/tasks.c **** 		#if portSTACK_GROWTH < 0
3562:..\Source/tasks.c **** 		{
3563:..\Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 3617              		.loc 1 3563 0 is_stmt 1 discriminator 4
 3618 0018 7B69     		ldr	r3, [r7, #20]
 3619 001a 1B6B     		ldr	r3, [r3, #48]
 3620 001c 3B61     		str	r3, [r7, #16]
3564:..\Source/tasks.c **** 		}
3565:..\Source/tasks.c **** 		#else
3566:..\Source/tasks.c **** 		{
3567:..\Source/tasks.c **** 			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3568:..\Source/tasks.c **** 		}
3569:..\Source/tasks.c **** 		#endif
3570:..\Source/tasks.c **** 
3571:..\Source/tasks.c **** 		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 3621              		.loc 1 3571 0 discriminator 4
 3622 001e 3869     		ldr	r0, [r7, #16]
 3623 0020 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 3624 0024 0346     		mov	r3, r0
 3625 0026 FB60     		str	r3, [r7, #12]
3572:..\Source/tasks.c **** 
3573:..\Source/tasks.c **** 		return uxReturn;
 3626              		.loc 1 3573 0 discriminator 4
 3627 0028 FB68     		ldr	r3, [r7, #12]
3574:..\Source/tasks.c **** 	}
 3628              		.loc 1 3574 0 discriminator 4
 3629 002a 1846     		mov	r0, r3
 3630 002c 1837     		adds	r7, r7, #24
 3631              		.cfi_def_cfa_offset 8
 3632 002e BD46     		mov	sp, r7
 3633              		.cfi_def_cfa_register 13
 3634              		@ sp needed
 3635 0030 80BD     		pop	{r7, pc}
 3636              	.L243:
 3637 0032 00BF     		.align	2
 3638              	.L242:
 3639 0034 00000000 		.word	pxCurrentTCB
 3640              		.cfi_endproc
 3641              	.LFE103:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 133


 3642              		.size	uxTaskGetStackHighWaterMark, .-uxTaskGetStackHighWaterMark
 3643              		.section	.text.prvDeleteTCB,"ax",%progbits
 3644              		.align	2
 3645              		.thumb
 3646              		.thumb_func
 3647              		.type	prvDeleteTCB, %function
 3648              	prvDeleteTCB:
 3649              	.LFB104:
3575:..\Source/tasks.c **** 
3576:..\Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3577:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3578:..\Source/tasks.c **** 
3579:..\Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
3580:..\Source/tasks.c **** 
3581:..\Source/tasks.c **** 	static void prvDeleteTCB( TCB_t *pxTCB )
3582:..\Source/tasks.c **** 	{
 3650              		.loc 1 3582 0
 3651              		.cfi_startproc
 3652              		@ args = 0, pretend = 0, frame = 8
 3653              		@ frame_needed = 1, uses_anonymous_args = 0
 3654 0000 80B5     		push	{r7, lr}
 3655              		.cfi_def_cfa_offset 8
 3656              		.cfi_offset 7, -8
 3657              		.cfi_offset 14, -4
 3658 0002 82B0     		sub	sp, sp, #8
 3659              		.cfi_def_cfa_offset 16
 3660 0004 00AF     		add	r7, sp, #0
 3661              		.cfi_def_cfa_register 7
 3662 0006 7860     		str	r0, [r7, #4]
3583:..\Source/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
3584:..\Source/tasks.c **** 		above the vPortFree() calls.  The call is also used by ports/demos that
3585:..\Source/tasks.c **** 		want to allocate and clean RAM statically. */
3586:..\Source/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
3587:..\Source/tasks.c **** 
3588:..\Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up
3589:..\Source/tasks.c **** 		to the task to free any memory allocated at the application level. */
3590:..\Source/tasks.c **** 		#if ( configUSE_NEWLIB_REENTRANT == 1 )
3591:..\Source/tasks.c **** 		{
3592:..\Source/tasks.c **** 			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
3593:..\Source/tasks.c **** 		}
3594:..\Source/tasks.c **** 		#endif /* configUSE_NEWLIB_REENTRANT */
3595:..\Source/tasks.c **** 
3596:..\Source/tasks.c **** 		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( p
3597:..\Source/tasks.c **** 		{
3598:..\Source/tasks.c **** 			/* The task can only have been allocated dynamically - free both
3599:..\Source/tasks.c **** 			the stack and TCB. */
3600:..\Source/tasks.c **** 			vPortFree( pxTCB->pxStack );
 3663              		.loc 1 3600 0
 3664 0008 7B68     		ldr	r3, [r7, #4]
 3665 000a 1B6B     		ldr	r3, [r3, #48]
 3666 000c 1846     		mov	r0, r3
 3667 000e FFF7FEFF 		bl	vPortFree
3601:..\Source/tasks.c **** 			vPortFree( pxTCB );
 3668              		.loc 1 3601 0
 3669 0012 7868     		ldr	r0, [r7, #4]
 3670 0014 FFF7FEFF 		bl	vPortFree
3602:..\Source/tasks.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 134


3603:..\Source/tasks.c **** 		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
3604:..\Source/tasks.c **** 		{
3605:..\Source/tasks.c **** 			/* The task could have been allocated statically or dynamically, so
3606:..\Source/tasks.c **** 			check what was statically allocated before trying to free the
3607:..\Source/tasks.c **** 			memory. */
3608:..\Source/tasks.c **** 			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
3609:..\Source/tasks.c **** 			{
3610:..\Source/tasks.c **** 				/* Both the stack and TCB were allocated dynamically, so both
3611:..\Source/tasks.c **** 				must be freed. */
3612:..\Source/tasks.c **** 				vPortFree( pxTCB->pxStack );
3613:..\Source/tasks.c **** 				vPortFree( pxTCB );
3614:..\Source/tasks.c **** 			}
3615:..\Source/tasks.c **** 			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
3616:..\Source/tasks.c **** 			{
3617:..\Source/tasks.c **** 				/* Only the stack was statically allocated, so the TCB is the
3618:..\Source/tasks.c **** 				only memory that must be freed. */
3619:..\Source/tasks.c **** 				vPortFree( pxTCB );
3620:..\Source/tasks.c **** 			}
3621:..\Source/tasks.c **** 			else
3622:..\Source/tasks.c **** 			{
3623:..\Source/tasks.c **** 				/* Neither the stack nor the TCB were allocated dynamically, so
3624:..\Source/tasks.c **** 				nothing needs to be freed. */
3625:..\Source/tasks.c **** 				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
3626:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3627:..\Source/tasks.c **** 			}
3628:..\Source/tasks.c **** 		}
3629:..\Source/tasks.c **** 		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
3630:..\Source/tasks.c **** 	}
 3671              		.loc 1 3630 0
 3672 0018 0837     		adds	r7, r7, #8
 3673              		.cfi_def_cfa_offset 8
 3674 001a BD46     		mov	sp, r7
 3675              		.cfi_def_cfa_register 13
 3676              		@ sp needed
 3677 001c 80BD     		pop	{r7, pc}
 3678              		.cfi_endproc
 3679              	.LFE104:
 3680              		.size	prvDeleteTCB, .-prvDeleteTCB
 3681 001e 00BF     		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
 3682              		.align	2
 3683              		.thumb
 3684              		.thumb_func
 3685              		.type	prvResetNextTaskUnblockTime, %function
 3686              	prvResetNextTaskUnblockTime:
 3687              	.LFB105:
3631:..\Source/tasks.c **** 
3632:..\Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
3633:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3634:..\Source/tasks.c **** 
3635:..\Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
3636:..\Source/tasks.c **** {
 3688              		.loc 1 3636 0
 3689              		.cfi_startproc
 3690              		@ args = 0, pretend = 0, frame = 8
 3691              		@ frame_needed = 1, uses_anonymous_args = 0
 3692              		@ link register save eliminated.
 3693 0000 80B4     		push	{r7}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 135


 3694              		.cfi_def_cfa_offset 4
 3695              		.cfi_offset 7, -4
 3696 0002 83B0     		sub	sp, sp, #12
 3697              		.cfi_def_cfa_offset 16
 3698 0004 00AF     		add	r7, sp, #0
 3699              		.cfi_def_cfa_register 7
3637:..\Source/tasks.c **** TCB_t *pxTCB;
3638:..\Source/tasks.c **** 
3639:..\Source/tasks.c **** 	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 3700              		.loc 1 3639 0
 3701 0006 0E4B     		ldr	r3, .L250
 3702 0008 1B68     		ldr	r3, [r3]
 3703 000a 1B68     		ldr	r3, [r3]
 3704 000c 002B     		cmp	r3, #0
 3705 000e 01D1     		bne	.L246
 3706              		.loc 1 3639 0 is_stmt 0 discriminator 1
 3707 0010 0123     		movs	r3, #1
 3708 0012 00E0     		b	.L247
 3709              	.L246:
 3710              		.loc 1 3639 0 discriminator 2
 3711 0014 0023     		movs	r3, #0
 3712              	.L247:
 3713              		.loc 1 3639 0 discriminator 4
 3714 0016 002B     		cmp	r3, #0
 3715 0018 04D0     		beq	.L248
3640:..\Source/tasks.c **** 	{
3641:..\Source/tasks.c **** 		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
3642:..\Source/tasks.c **** 		the maximum possible value so it is	extremely unlikely that the
3643:..\Source/tasks.c **** 		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3644:..\Source/tasks.c **** 		there is an item in the delayed list. */
3645:..\Source/tasks.c **** 		xNextTaskUnblockTime = portMAX_DELAY;
 3716              		.loc 1 3645 0 is_stmt 1
 3717 001a 0A4B     		ldr	r3, .L250+4
 3718 001c 4FF0FF32 		mov	r2, #-1
 3719 0020 1A60     		str	r2, [r3]
 3720 0022 08E0     		b	.L245
 3721              	.L248:
3646:..\Source/tasks.c **** 	}
3647:..\Source/tasks.c **** 	else
3648:..\Source/tasks.c **** 	{
3649:..\Source/tasks.c **** 		/* The new current delayed list is not empty, get the value of
3650:..\Source/tasks.c **** 		the item at the head of the delayed list.  This is the time at
3651:..\Source/tasks.c **** 		which the task at the head of the delayed list should be removed
3652:..\Source/tasks.c **** 		from the Blocked state. */
3653:..\Source/tasks.c **** 		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 3722              		.loc 1 3653 0
 3723 0024 064B     		ldr	r3, .L250
 3724 0026 1B68     		ldr	r3, [r3]
 3725 0028 DB68     		ldr	r3, [r3, #12]
 3726 002a DB68     		ldr	r3, [r3, #12]
 3727 002c 7B60     		str	r3, [r7, #4]
3654:..\Source/tasks.c **** 		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 3728              		.loc 1 3654 0
 3729 002e 7B68     		ldr	r3, [r7, #4]
 3730 0030 5B68     		ldr	r3, [r3, #4]
 3731 0032 044A     		ldr	r2, .L250+4
 3732 0034 1360     		str	r3, [r2]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 136


 3733              	.L245:
3655:..\Source/tasks.c **** 	}
3656:..\Source/tasks.c **** }
 3734              		.loc 1 3656 0
 3735 0036 0C37     		adds	r7, r7, #12
 3736              		.cfi_def_cfa_offset 4
 3737 0038 BD46     		mov	sp, r7
 3738              		.cfi_def_cfa_register 13
 3739              		@ sp needed
 3740 003a 5DF8047B 		ldr	r7, [sp], #4
 3741              		.cfi_restore 7
 3742              		.cfi_def_cfa_offset 0
 3743 003e 7047     		bx	lr
 3744              	.L251:
 3745              		.align	2
 3746              	.L250:
 3747 0040 90000000 		.word	pxDelayedTaskList
 3748 0044 F8000000 		.word	xNextTaskUnblockTime
 3749              		.cfi_endproc
 3750              	.LFE105:
 3751              		.size	prvResetNextTaskUnblockTime, .-prvResetNextTaskUnblockTime
 3752              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3753              		.align	2
 3754              		.global	xTaskGetCurrentTaskHandle
 3755              		.thumb
 3756              		.thumb_func
 3757              		.type	xTaskGetCurrentTaskHandle, %function
 3758              	xTaskGetCurrentTaskHandle:
 3759              	.LFB106:
3657:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3658:..\Source/tasks.c **** 
3659:..\Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3660:..\Source/tasks.c **** 
3661:..\Source/tasks.c **** 	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3662:..\Source/tasks.c **** 	{
 3760              		.loc 1 3662 0
 3761              		.cfi_startproc
 3762              		@ args = 0, pretend = 0, frame = 8
 3763              		@ frame_needed = 1, uses_anonymous_args = 0
 3764              		@ link register save eliminated.
 3765 0000 80B4     		push	{r7}
 3766              		.cfi_def_cfa_offset 4
 3767              		.cfi_offset 7, -4
 3768 0002 83B0     		sub	sp, sp, #12
 3769              		.cfi_def_cfa_offset 16
 3770 0004 00AF     		add	r7, sp, #0
 3771              		.cfi_def_cfa_register 7
3663:..\Source/tasks.c **** 	TaskHandle_t xReturn;
3664:..\Source/tasks.c **** 
3665:..\Source/tasks.c **** 		/* A critical section is not required as this is not called from
3666:..\Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
3667:..\Source/tasks.c **** 		individual execution thread. */
3668:..\Source/tasks.c **** 		xReturn = pxCurrentTCB;
 3772              		.loc 1 3668 0
 3773 0006 054B     		ldr	r3, .L254
 3774 0008 1B68     		ldr	r3, [r3]
 3775 000a 7B60     		str	r3, [r7, #4]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 137


3669:..\Source/tasks.c **** 
3670:..\Source/tasks.c **** 		return xReturn;
 3776              		.loc 1 3670 0
 3777 000c 7B68     		ldr	r3, [r7, #4]
3671:..\Source/tasks.c **** 	}
 3778              		.loc 1 3671 0
 3779 000e 1846     		mov	r0, r3
 3780 0010 0C37     		adds	r7, r7, #12
 3781              		.cfi_def_cfa_offset 4
 3782 0012 BD46     		mov	sp, r7
 3783              		.cfi_def_cfa_register 13
 3784              		@ sp needed
 3785 0014 5DF8047B 		ldr	r7, [sp], #4
 3786              		.cfi_restore 7
 3787              		.cfi_def_cfa_offset 0
 3788 0018 7047     		bx	lr
 3789              	.L255:
 3790 001a 00BF     		.align	2
 3791              	.L254:
 3792 001c 00000000 		.word	pxCurrentTCB
 3793              		.cfi_endproc
 3794              	.LFE106:
 3795              		.size	xTaskGetCurrentTaskHandle, .-xTaskGetCurrentTaskHandle
 3796              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3797              		.align	2
 3798              		.global	vTaskPriorityInherit
 3799              		.thumb
 3800              		.thumb_func
 3801              		.type	vTaskPriorityInherit, %function
 3802              	vTaskPriorityInherit:
 3803              	.LFB107:
3672:..\Source/tasks.c **** 
3673:..\Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3674:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3675:..\Source/tasks.c **** 
3676:..\Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3677:..\Source/tasks.c **** 
3678:..\Source/tasks.c **** 	BaseType_t xTaskGetSchedulerState( void )
3679:..\Source/tasks.c **** 	{
3680:..\Source/tasks.c **** 	BaseType_t xReturn;
3681:..\Source/tasks.c **** 
3682:..\Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
3683:..\Source/tasks.c **** 		{
3684:..\Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
3685:..\Source/tasks.c **** 		}
3686:..\Source/tasks.c **** 		else
3687:..\Source/tasks.c **** 		{
3688:..\Source/tasks.c **** 			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
3689:..\Source/tasks.c **** 			{
3690:..\Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
3691:..\Source/tasks.c **** 			}
3692:..\Source/tasks.c **** 			else
3693:..\Source/tasks.c **** 			{
3694:..\Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
3695:..\Source/tasks.c **** 			}
3696:..\Source/tasks.c **** 		}
3697:..\Source/tasks.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 138


3698:..\Source/tasks.c **** 		return xReturn;
3699:..\Source/tasks.c **** 	}
3700:..\Source/tasks.c **** 
3701:..\Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3702:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3703:..\Source/tasks.c **** 
3704:..\Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3705:..\Source/tasks.c **** 
3706:..\Source/tasks.c **** 	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3707:..\Source/tasks.c **** 	{
 3804              		.loc 1 3707 0
 3805              		.cfi_startproc
 3806              		@ args = 0, pretend = 0, frame = 16
 3807              		@ frame_needed = 1, uses_anonymous_args = 0
 3808 0000 80B5     		push	{r7, lr}
 3809              		.cfi_def_cfa_offset 8
 3810              		.cfi_offset 7, -8
 3811              		.cfi_offset 14, -4
 3812 0002 84B0     		sub	sp, sp, #16
 3813              		.cfi_def_cfa_offset 24
 3814 0004 00AF     		add	r7, sp, #0
 3815              		.cfi_def_cfa_register 7
 3816 0006 7860     		str	r0, [r7, #4]
3708:..\Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3817              		.loc 1 3708 0
 3818 0008 7B68     		ldr	r3, [r7, #4]
 3819 000a FB60     		str	r3, [r7, #12]
3709:..\Source/tasks.c **** 
3710:..\Source/tasks.c **** 		/* If the mutex was given back by an interrupt while the queue was
3711:..\Source/tasks.c **** 		locked then the mutex holder might now be NULL. */
3712:..\Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3820              		.loc 1 3712 0
 3821 000c 7B68     		ldr	r3, [r7, #4]
 3822 000e 002B     		cmp	r3, #0
 3823 0010 64D0     		beq	.L256
3713:..\Source/tasks.c **** 		{
3714:..\Source/tasks.c **** 			/* If the holder of the mutex has a priority below the priority of
3715:..\Source/tasks.c **** 			the task attempting to obtain the mutex then it will temporarily
3716:..\Source/tasks.c **** 			inherit the priority of the task attempting to obtain the mutex. */
3717:..\Source/tasks.c **** 			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3824              		.loc 1 3717 0
 3825 0012 FB68     		ldr	r3, [r7, #12]
 3826 0014 DA6A     		ldr	r2, [r3, #44]
 3827 0016 334B     		ldr	r3, .L265
 3828 0018 1B68     		ldr	r3, [r3]
 3829 001a DB6A     		ldr	r3, [r3, #44]
 3830 001c 9A42     		cmp	r2, r3
 3831 001e 5DD2     		bcs	.L256
3718:..\Source/tasks.c **** 			{
3719:..\Source/tasks.c **** 				/* Adjust the mutex holder state to account for its new
3720:..\Source/tasks.c **** 				priority.  Only reset the event list item value if the value is
3721:..\Source/tasks.c **** 				not	being used for anything else. */
3722:..\Source/tasks.c **** 				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE 
 3832              		.loc 1 3722 0
 3833 0020 FB68     		ldr	r3, [r7, #12]
 3834 0022 9B69     		ldr	r3, [r3, #24]
 3835 0024 002B     		cmp	r3, #0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 139


 3836 0026 06DB     		blt	.L258
3723:..\Source/tasks.c **** 				{
3724:..\Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 3837              		.loc 1 3724 0
 3838 0028 2E4B     		ldr	r3, .L265
 3839 002a 1B68     		ldr	r3, [r3]
 3840 002c DB6A     		ldr	r3, [r3, #44]
 3841 002e C3F10502 		rsb	r2, r3, #5
 3842 0032 FB68     		ldr	r3, [r7, #12]
 3843 0034 9A61     		str	r2, [r3, #24]
 3844              	.L258:
3725:..\Source/tasks.c **** 				}
3726:..\Source/tasks.c **** 				else
3727:..\Source/tasks.c **** 				{
3728:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3729:..\Source/tasks.c **** 				}
3730:..\Source/tasks.c **** 
3731:..\Source/tasks.c **** 				/* If the task being modified is in the ready state it will need
3732:..\Source/tasks.c **** 				to be moved into a new list. */
3733:..\Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListI
 3845              		.loc 1 3733 0
 3846 0036 FB68     		ldr	r3, [r7, #12]
 3847 0038 5969     		ldr	r1, [r3, #20]
 3848 003a FB68     		ldr	r3, [r7, #12]
 3849 003c DA6A     		ldr	r2, [r3, #44]
 3850 003e 1346     		mov	r3, r2
 3851 0040 9B00     		lsls	r3, r3, #2
 3852 0042 1344     		add	r3, r3, r2
 3853 0044 9B00     		lsls	r3, r3, #2
 3854 0046 284A     		ldr	r2, .L265+4
 3855 0048 1344     		add	r3, r3, r2
 3856 004a 9942     		cmp	r1, r3
 3857 004c 01D1     		bne	.L259
 3858              		.loc 1 3733 0 is_stmt 0 discriminator 1
 3859 004e 0123     		movs	r3, #1
 3860 0050 00E0     		b	.L260
 3861              	.L259:
 3862              		.loc 1 3733 0 discriminator 2
 3863 0052 0023     		movs	r3, #0
 3864              	.L260:
 3865              		.loc 1 3733 0 discriminator 4
 3866 0054 002B     		cmp	r3, #0
 3867 0056 3CD0     		beq	.L261
3734:..\Source/tasks.c **** 				{
3735:..\Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 3868              		.loc 1 3735 0 is_stmt 1
 3869 0058 FB68     		ldr	r3, [r7, #12]
 3870 005a 0433     		adds	r3, r3, #4
 3871 005c 1846     		mov	r0, r3
 3872 005e FFF7FEFF 		bl	uxListRemove
 3873 0062 0346     		mov	r3, r0
 3874 0064 002B     		cmp	r3, #0
 3875 0066 15D1     		bne	.L262
3736:..\Source/tasks.c **** 					{
3737:..\Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 3876              		.loc 1 3737 0
 3877 0068 FB68     		ldr	r3, [r7, #12]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 140


 3878 006a DA6A     		ldr	r2, [r3, #44]
 3879 006c 1E49     		ldr	r1, .L265+4
 3880 006e 1346     		mov	r3, r2
 3881 0070 9B00     		lsls	r3, r3, #2
 3882 0072 1344     		add	r3, r3, r2
 3883 0074 9B00     		lsls	r3, r3, #2
 3884 0076 0B44     		add	r3, r3, r1
 3885 0078 1B68     		ldr	r3, [r3]
 3886 007a 002B     		cmp	r3, #0
 3887 007c 0AD1     		bne	.L262
 3888              		.loc 1 3737 0 is_stmt 0 discriminator 1
 3889 007e FB68     		ldr	r3, [r7, #12]
 3890 0080 DB6A     		ldr	r3, [r3, #44]
 3891 0082 1A46     		mov	r2, r3
 3892 0084 0123     		movs	r3, #1
 3893 0086 9340     		lsls	r3, r3, r2
 3894 0088 DA43     		mvns	r2, r3
 3895 008a 184B     		ldr	r3, .L265+8
 3896 008c 1B68     		ldr	r3, [r3]
 3897 008e 1340     		ands	r3, r3, r2
 3898 0090 164A     		ldr	r2, .L265+8
 3899 0092 1360     		str	r3, [r2]
 3900              	.L262:
3738:..\Source/tasks.c **** 					}
3739:..\Source/tasks.c **** 					else
3740:..\Source/tasks.c **** 					{
3741:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3742:..\Source/tasks.c **** 					}
3743:..\Source/tasks.c **** 
3744:..\Source/tasks.c **** 					/* Inherit the priority before being moved into the new list. */
3745:..\Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3901              		.loc 1 3745 0 is_stmt 1
 3902 0094 134B     		ldr	r3, .L265
 3903 0096 1B68     		ldr	r3, [r3]
 3904 0098 DA6A     		ldr	r2, [r3, #44]
 3905 009a FB68     		ldr	r3, [r7, #12]
 3906 009c DA62     		str	r2, [r3, #44]
3746:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 3907              		.loc 1 3746 0
 3908 009e FB68     		ldr	r3, [r7, #12]
 3909 00a0 DB6A     		ldr	r3, [r3, #44]
 3910 00a2 1A46     		mov	r2, r3
 3911 00a4 0123     		movs	r3, #1
 3912 00a6 03FA02F2 		lsl	r2, r3, r2
 3913 00aa 104B     		ldr	r3, .L265+8
 3914 00ac 1B68     		ldr	r3, [r3]
 3915 00ae 1343     		orrs	r3, r3, r2
 3916 00b0 0E4A     		ldr	r2, .L265+8
 3917 00b2 1360     		str	r3, [r2]
 3918 00b4 FB68     		ldr	r3, [r7, #12]
 3919 00b6 DA6A     		ldr	r2, [r3, #44]
 3920 00b8 1346     		mov	r3, r2
 3921 00ba 9B00     		lsls	r3, r3, #2
 3922 00bc 1344     		add	r3, r3, r2
 3923 00be 9B00     		lsls	r3, r3, #2
 3924 00c0 094A     		ldr	r2, .L265+4
 3925 00c2 1A44     		add	r2, r2, r3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 141


 3926 00c4 FB68     		ldr	r3, [r7, #12]
 3927 00c6 0433     		adds	r3, r3, #4
 3928 00c8 1046     		mov	r0, r2
 3929 00ca 1946     		mov	r1, r3
 3930 00cc FFF7FEFF 		bl	vListInsertEnd
 3931 00d0 04E0     		b	.L256
 3932              	.L261:
3747:..\Source/tasks.c **** 				}
3748:..\Source/tasks.c **** 				else
3749:..\Source/tasks.c **** 				{
3750:..\Source/tasks.c **** 					/* Just inherit the priority. */
3751:..\Source/tasks.c **** 					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3933              		.loc 1 3751 0
 3934 00d2 044B     		ldr	r3, .L265
 3935 00d4 1B68     		ldr	r3, [r3]
 3936 00d6 DA6A     		ldr	r2, [r3, #44]
 3937 00d8 FB68     		ldr	r3, [r7, #12]
 3938 00da DA62     		str	r2, [r3, #44]
 3939              	.L256:
3752:..\Source/tasks.c **** 				}
3753:..\Source/tasks.c **** 
3754:..\Source/tasks.c **** 				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3755:..\Source/tasks.c **** 			}
3756:..\Source/tasks.c **** 			else
3757:..\Source/tasks.c **** 			{
3758:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3759:..\Source/tasks.c **** 			}
3760:..\Source/tasks.c **** 		}
3761:..\Source/tasks.c **** 		else
3762:..\Source/tasks.c **** 		{
3763:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3764:..\Source/tasks.c **** 		}
3765:..\Source/tasks.c **** 	}
 3940              		.loc 1 3765 0
 3941 00dc 1037     		adds	r7, r7, #16
 3942              		.cfi_def_cfa_offset 8
 3943 00de BD46     		mov	sp, r7
 3944              		.cfi_def_cfa_register 13
 3945              		@ sp needed
 3946 00e0 80BD     		pop	{r7, pc}
 3947              	.L266:
 3948 00e2 00BF     		.align	2
 3949              	.L265:
 3950 00e4 00000000 		.word	pxCurrentTCB
 3951 00e8 04000000 		.word	pxReadyTasksLists
 3952 00ec E0000000 		.word	uxTopReadyPriority
 3953              		.cfi_endproc
 3954              	.LFE107:
 3955              		.size	vTaskPriorityInherit, .-vTaskPriorityInherit
 3956              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 3957              		.align	2
 3958              		.global	xTaskPriorityDisinherit
 3959              		.thumb
 3960              		.thumb_func
 3961              		.type	xTaskPriorityDisinherit, %function
 3962              	xTaskPriorityDisinherit:
 3963              	.LFB108:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 142


3766:..\Source/tasks.c **** 
3767:..\Source/tasks.c **** #endif /* configUSE_MUTEXES */
3768:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3769:..\Source/tasks.c **** 
3770:..\Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
3771:..\Source/tasks.c **** 
3772:..\Source/tasks.c **** 	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3773:..\Source/tasks.c **** 	{
 3964              		.loc 1 3773 0
 3965              		.cfi_startproc
 3966              		@ args = 0, pretend = 0, frame = 16
 3967              		@ frame_needed = 1, uses_anonymous_args = 0
 3968 0000 80B5     		push	{r7, lr}
 3969              		.cfi_def_cfa_offset 8
 3970              		.cfi_offset 7, -8
 3971              		.cfi_offset 14, -4
 3972 0002 84B0     		sub	sp, sp, #16
 3973              		.cfi_def_cfa_offset 24
 3974 0004 00AF     		add	r7, sp, #0
 3975              		.cfi_def_cfa_register 7
 3976 0006 7860     		str	r0, [r7, #4]
3774:..\Source/tasks.c **** 	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 3977              		.loc 1 3774 0
 3978 0008 7B68     		ldr	r3, [r7, #4]
 3979 000a BB60     		str	r3, [r7, #8]
3775:..\Source/tasks.c **** 	BaseType_t xReturn = pdFALSE;
 3980              		.loc 1 3775 0
 3981 000c 0023     		movs	r3, #0
 3982 000e FB60     		str	r3, [r7, #12]
3776:..\Source/tasks.c **** 
3777:..\Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3983              		.loc 1 3777 0
 3984 0010 7B68     		ldr	r3, [r7, #4]
 3985 0012 002B     		cmp	r3, #0
 3986 0014 51D0     		beq	.L268
3778:..\Source/tasks.c **** 		{
3779:..\Source/tasks.c **** 			/* A task can only have an inherited priority if it holds the mutex.
3780:..\Source/tasks.c **** 			If the mutex is held by a task then it cannot be given from an
3781:..\Source/tasks.c **** 			interrupt, and if a mutex is given by the holding task then it must
3782:..\Source/tasks.c **** 			be the running state task. */
3783:..\Source/tasks.c **** 			configASSERT( pxTCB == pxCurrentTCB );
3784:..\Source/tasks.c **** 
3785:..\Source/tasks.c **** 			configASSERT( pxTCB->uxMutexesHeld );
3786:..\Source/tasks.c **** 			( pxTCB->uxMutexesHeld )--;
 3987              		.loc 1 3786 0
 3988 0016 BB68     		ldr	r3, [r7, #8]
 3989 0018 5B6C     		ldr	r3, [r3, #68]
 3990 001a 5A1E     		subs	r2, r3, #1
 3991 001c BB68     		ldr	r3, [r7, #8]
 3992 001e 5A64     		str	r2, [r3, #68]
3787:..\Source/tasks.c **** 
3788:..\Source/tasks.c **** 			/* Has the holder of the mutex inherited the priority of another
3789:..\Source/tasks.c **** 			task? */
3790:..\Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3993              		.loc 1 3790 0
 3994 0020 BB68     		ldr	r3, [r7, #8]
 3995 0022 DA6A     		ldr	r2, [r3, #44]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 143


 3996 0024 BB68     		ldr	r3, [r7, #8]
 3997 0026 1B6C     		ldr	r3, [r3, #64]
 3998 0028 9A42     		cmp	r2, r3
 3999 002a 46D0     		beq	.L268
3791:..\Source/tasks.c **** 			{
3792:..\Source/tasks.c **** 				/* Only disinherit if no other mutexes are held. */
3793:..\Source/tasks.c **** 				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 4000              		.loc 1 3793 0
 4001 002c BB68     		ldr	r3, [r7, #8]
 4002 002e 5B6C     		ldr	r3, [r3, #68]
 4003 0030 002B     		cmp	r3, #0
 4004 0032 42D1     		bne	.L268
3794:..\Source/tasks.c **** 				{
3795:..\Source/tasks.c **** 					/* A task can only have an inherited priority if it holds
3796:..\Source/tasks.c **** 					the mutex.  If the mutex is held by a task then it cannot be
3797:..\Source/tasks.c **** 					given from an interrupt, and if a mutex is given by the
3798:..\Source/tasks.c **** 					holding	task then it must be the running state task.  Remove
3799:..\Source/tasks.c **** 					the	holding task from the ready	list. */
3800:..\Source/tasks.c **** 					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 4005              		.loc 1 3800 0
 4006 0034 BB68     		ldr	r3, [r7, #8]
 4007 0036 0433     		adds	r3, r3, #4
 4008 0038 1846     		mov	r0, r3
 4009 003a FFF7FEFF 		bl	uxListRemove
 4010 003e 0346     		mov	r3, r0
 4011 0040 002B     		cmp	r3, #0
 4012 0042 15D1     		bne	.L269
3801:..\Source/tasks.c **** 					{
3802:..\Source/tasks.c **** 						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 4013              		.loc 1 3802 0
 4014 0044 BB68     		ldr	r3, [r7, #8]
 4015 0046 DA6A     		ldr	r2, [r3, #44]
 4016 0048 1E49     		ldr	r1, .L272
 4017 004a 1346     		mov	r3, r2
 4018 004c 9B00     		lsls	r3, r3, #2
 4019 004e 1344     		add	r3, r3, r2
 4020 0050 9B00     		lsls	r3, r3, #2
 4021 0052 0B44     		add	r3, r3, r1
 4022 0054 1B68     		ldr	r3, [r3]
 4023 0056 002B     		cmp	r3, #0
 4024 0058 0AD1     		bne	.L269
 4025              		.loc 1 3802 0 is_stmt 0 discriminator 1
 4026 005a BB68     		ldr	r3, [r7, #8]
 4027 005c DB6A     		ldr	r3, [r3, #44]
 4028 005e 1A46     		mov	r2, r3
 4029 0060 0123     		movs	r3, #1
 4030 0062 9340     		lsls	r3, r3, r2
 4031 0064 DA43     		mvns	r2, r3
 4032 0066 184B     		ldr	r3, .L272+4
 4033 0068 1B68     		ldr	r3, [r3]
 4034 006a 1340     		ands	r3, r3, r2
 4035 006c 164A     		ldr	r2, .L272+4
 4036 006e 1360     		str	r3, [r2]
 4037              	.L269:
3803:..\Source/tasks.c **** 					}
3804:..\Source/tasks.c **** 					else
3805:..\Source/tasks.c **** 					{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 144


3806:..\Source/tasks.c **** 						mtCOVERAGE_TEST_MARKER();
3807:..\Source/tasks.c **** 					}
3808:..\Source/tasks.c **** 
3809:..\Source/tasks.c **** 					/* Disinherit the priority before adding the task into the
3810:..\Source/tasks.c **** 					new	ready list. */
3811:..\Source/tasks.c **** 					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3812:..\Source/tasks.c **** 					pxTCB->uxPriority = pxTCB->uxBasePriority;
 4038              		.loc 1 3812 0 is_stmt 1
 4039 0070 BB68     		ldr	r3, [r7, #8]
 4040 0072 1A6C     		ldr	r2, [r3, #64]
 4041 0074 BB68     		ldr	r3, [r7, #8]
 4042 0076 DA62     		str	r2, [r3, #44]
3813:..\Source/tasks.c **** 
3814:..\Source/tasks.c **** 					/* Reset the event list item value.  It cannot be in use for
3815:..\Source/tasks.c **** 					any other purpose if this task is running, and it must be
3816:..\Source/tasks.c **** 					running to give back the mutex. */
3817:..\Source/tasks.c **** 					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( T
 4043              		.loc 1 3817 0
 4044 0078 BB68     		ldr	r3, [r7, #8]
 4045 007a DB6A     		ldr	r3, [r3, #44]
 4046 007c C3F10502 		rsb	r2, r3, #5
 4047 0080 BB68     		ldr	r3, [r7, #8]
 4048 0082 9A61     		str	r2, [r3, #24]
3818:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4049              		.loc 1 3818 0
 4050 0084 BB68     		ldr	r3, [r7, #8]
 4051 0086 DB6A     		ldr	r3, [r3, #44]
 4052 0088 1A46     		mov	r2, r3
 4053 008a 0123     		movs	r3, #1
 4054 008c 03FA02F2 		lsl	r2, r3, r2
 4055 0090 0D4B     		ldr	r3, .L272+4
 4056 0092 1B68     		ldr	r3, [r3]
 4057 0094 1343     		orrs	r3, r3, r2
 4058 0096 0C4A     		ldr	r2, .L272+4
 4059 0098 1360     		str	r3, [r2]
 4060 009a BB68     		ldr	r3, [r7, #8]
 4061 009c DA6A     		ldr	r2, [r3, #44]
 4062 009e 1346     		mov	r3, r2
 4063 00a0 9B00     		lsls	r3, r3, #2
 4064 00a2 1344     		add	r3, r3, r2
 4065 00a4 9B00     		lsls	r3, r3, #2
 4066 00a6 074A     		ldr	r2, .L272
 4067 00a8 1A44     		add	r2, r2, r3
 4068 00aa BB68     		ldr	r3, [r7, #8]
 4069 00ac 0433     		adds	r3, r3, #4
 4070 00ae 1046     		mov	r0, r2
 4071 00b0 1946     		mov	r1, r3
 4072 00b2 FFF7FEFF 		bl	vListInsertEnd
3819:..\Source/tasks.c **** 
3820:..\Source/tasks.c **** 					/* Return true to indicate that a context switch is required.
3821:..\Source/tasks.c **** 					This is only actually required in the corner case whereby
3822:..\Source/tasks.c **** 					multiple mutexes were held and the mutexes were given back
3823:..\Source/tasks.c **** 					in an order different to that in which they were taken.
3824:..\Source/tasks.c **** 					If a context switch did not occur when the first mutex was
3825:..\Source/tasks.c **** 					returned, even if a task was waiting on it, then a context
3826:..\Source/tasks.c **** 					switch should occur when the last mutex is returned whether
3827:..\Source/tasks.c **** 					a task is waiting on it or not. */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 145


3828:..\Source/tasks.c **** 					xReturn = pdTRUE;
 4073              		.loc 1 3828 0
 4074 00b6 0123     		movs	r3, #1
 4075 00b8 FB60     		str	r3, [r7, #12]
 4076              	.L268:
3829:..\Source/tasks.c **** 				}
3830:..\Source/tasks.c **** 				else
3831:..\Source/tasks.c **** 				{
3832:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3833:..\Source/tasks.c **** 				}
3834:..\Source/tasks.c **** 			}
3835:..\Source/tasks.c **** 			else
3836:..\Source/tasks.c **** 			{
3837:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3838:..\Source/tasks.c **** 			}
3839:..\Source/tasks.c **** 		}
3840:..\Source/tasks.c **** 		else
3841:..\Source/tasks.c **** 		{
3842:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3843:..\Source/tasks.c **** 		}
3844:..\Source/tasks.c **** 
3845:..\Source/tasks.c **** 		return xReturn;
 4077              		.loc 1 3845 0
 4078 00ba FB68     		ldr	r3, [r7, #12]
3846:..\Source/tasks.c **** 	}
 4079              		.loc 1 3846 0
 4080 00bc 1846     		mov	r0, r3
 4081 00be 1037     		adds	r7, r7, #16
 4082              		.cfi_def_cfa_offset 8
 4083 00c0 BD46     		mov	sp, r7
 4084              		.cfi_def_cfa_register 13
 4085              		@ sp needed
 4086 00c2 80BD     		pop	{r7, pc}
 4087              	.L273:
 4088              		.align	2
 4089              	.L272:
 4090 00c4 04000000 		.word	pxReadyTasksLists
 4091 00c8 E0000000 		.word	uxTopReadyPriority
 4092              		.cfi_endproc
 4093              	.LFE108:
 4094              		.size	xTaskPriorityDisinherit, .-xTaskPriorityDisinherit
 4095              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 4096              		.align	2
 4097              		.global	uxTaskResetEventItemValue
 4098              		.thumb
 4099              		.thumb_func
 4100              		.type	uxTaskResetEventItemValue, %function
 4101              	uxTaskResetEventItemValue:
 4102              	.LFB109:
3847:..\Source/tasks.c **** 
3848:..\Source/tasks.c **** #endif /* configUSE_MUTEXES */
3849:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3850:..\Source/tasks.c **** 
3851:..\Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3852:..\Source/tasks.c **** 
3853:..\Source/tasks.c **** 	void vTaskEnterCritical( void )
3854:..\Source/tasks.c **** 	{
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 146


3855:..\Source/tasks.c **** 		portDISABLE_INTERRUPTS();
3856:..\Source/tasks.c **** 
3857:..\Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3858:..\Source/tasks.c **** 		{
3859:..\Source/tasks.c **** 			( pxCurrentTCB->uxCriticalNesting )++;
3860:..\Source/tasks.c **** 
3861:..\Source/tasks.c **** 			/* This is not the interrupt safe version of the enter critical
3862:..\Source/tasks.c **** 			function so	assert() if it is being called from an interrupt
3863:..\Source/tasks.c **** 			context.  Only API functions that end in "FromISR" can be used in an
3864:..\Source/tasks.c **** 			interrupt.  Only assert if the critical nesting count is 1 to
3865:..\Source/tasks.c **** 			protect against recursive calls if the assert function also uses a
3866:..\Source/tasks.c **** 			critical section. */
3867:..\Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting == 1 )
3868:..\Source/tasks.c **** 			{
3869:..\Source/tasks.c **** 				portASSERT_IF_IN_ISR();
3870:..\Source/tasks.c **** 			}
3871:..\Source/tasks.c **** 		}
3872:..\Source/tasks.c **** 		else
3873:..\Source/tasks.c **** 		{
3874:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3875:..\Source/tasks.c **** 		}
3876:..\Source/tasks.c **** 	}
3877:..\Source/tasks.c **** 
3878:..\Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
3879:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3880:..\Source/tasks.c **** 
3881:..\Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3882:..\Source/tasks.c **** 
3883:..\Source/tasks.c **** 	void vTaskExitCritical( void )
3884:..\Source/tasks.c **** 	{
3885:..\Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
3886:..\Source/tasks.c **** 		{
3887:..\Source/tasks.c **** 			if( pxCurrentTCB->uxCriticalNesting > 0U )
3888:..\Source/tasks.c **** 			{
3889:..\Source/tasks.c **** 				( pxCurrentTCB->uxCriticalNesting )--;
3890:..\Source/tasks.c **** 
3891:..\Source/tasks.c **** 				if( pxCurrentTCB->uxCriticalNesting == 0U )
3892:..\Source/tasks.c **** 				{
3893:..\Source/tasks.c **** 					portENABLE_INTERRUPTS();
3894:..\Source/tasks.c **** 				}
3895:..\Source/tasks.c **** 				else
3896:..\Source/tasks.c **** 				{
3897:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
3898:..\Source/tasks.c **** 				}
3899:..\Source/tasks.c **** 			}
3900:..\Source/tasks.c **** 			else
3901:..\Source/tasks.c **** 			{
3902:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
3903:..\Source/tasks.c **** 			}
3904:..\Source/tasks.c **** 		}
3905:..\Source/tasks.c **** 		else
3906:..\Source/tasks.c **** 		{
3907:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
3908:..\Source/tasks.c **** 		}
3909:..\Source/tasks.c **** 	}
3910:..\Source/tasks.c **** 
3911:..\Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 147


3912:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3913:..\Source/tasks.c **** 
3914:..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3915:..\Source/tasks.c **** 
3916:..\Source/tasks.c **** 	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
3917:..\Source/tasks.c **** 	{
3918:..\Source/tasks.c **** 	size_t x;
3919:..\Source/tasks.c **** 
3920:..\Source/tasks.c **** 		/* Start by copying the entire string. */
3921:..\Source/tasks.c **** 		strcpy( pcBuffer, pcTaskName );
3922:..\Source/tasks.c **** 
3923:..\Source/tasks.c **** 		/* Pad the end of the string with spaces to ensure columns line up when
3924:..\Source/tasks.c **** 		printed out. */
3925:..\Source/tasks.c **** 		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
3926:..\Source/tasks.c **** 		{
3927:..\Source/tasks.c **** 			pcBuffer[ x ] = ' ';
3928:..\Source/tasks.c **** 		}
3929:..\Source/tasks.c **** 
3930:..\Source/tasks.c **** 		/* Terminate. */
3931:..\Source/tasks.c **** 		pcBuffer[ x ] = 0x00;
3932:..\Source/tasks.c **** 
3933:..\Source/tasks.c **** 		/* Return the new end of string. */
3934:..\Source/tasks.c **** 		return &( pcBuffer[ x ] );
3935:..\Source/tasks.c **** 	}
3936:..\Source/tasks.c **** 
3937:..\Source/tasks.c **** #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
3938:..\Source/tasks.c **** /*-----------------------------------------------------------*/
3939:..\Source/tasks.c **** 
3940:..\Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
3941:..\Source/tasks.c **** 
3942:..\Source/tasks.c **** 	void vTaskList( char * pcWriteBuffer )
3943:..\Source/tasks.c **** 	{
3944:..\Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
3945:..\Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
3946:..\Source/tasks.c **** 	char cStatus;
3947:..\Source/tasks.c **** 
3948:..\Source/tasks.c **** 		/*
3949:..\Source/tasks.c **** 		 * PLEASE NOTE:
3950:..\Source/tasks.c **** 		 *
3951:..\Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
3952:..\Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
3953:..\Source/tasks.c **** 		 * scheduler.
3954:..\Source/tasks.c **** 		 *
3955:..\Source/tasks.c **** 		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3956:..\Source/tasks.c **** 		 * uxTaskGetSystemState() output into a human readable table that
3957:..\Source/tasks.c **** 		 * displays task names, states and stack usage.
3958:..\Source/tasks.c **** 		 *
3959:..\Source/tasks.c **** 		 * vTaskList() has a dependency on the sprintf() C library function that
3960:..\Source/tasks.c **** 		 * might bloat the code size, use a lot of stack, and provide different
3961:..\Source/tasks.c **** 		 * results on different platforms.  An alternative, tiny, third party,
3962:..\Source/tasks.c **** 		 * and limited functionality implementation of sprintf() is provided in
3963:..\Source/tasks.c **** 		 * many of the FreeRTOS/Demo sub-directories in a file called
3964:..\Source/tasks.c **** 		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3965:..\Source/tasks.c **** 		 * snprintf() implementation!).
3966:..\Source/tasks.c **** 		 *
3967:..\Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
3968:..\Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 148


3969:..\Source/tasks.c **** 		 * through a call to vTaskList().
3970:..\Source/tasks.c **** 		 */
3971:..\Source/tasks.c **** 
3972:..\Source/tasks.c **** 
3973:..\Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
3974:..\Source/tasks.c **** 		*pcWriteBuffer = 0x00;
3975:..\Source/tasks.c **** 
3976:..\Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
3977:..\Source/tasks.c **** 		function is executing. */
3978:..\Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
3979:..\Source/tasks.c **** 
3980:..\Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  if
3981:..\Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
3982:..\Source/tasks.c **** 		equate to NULL. */
3983:..\Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3984:..\Source/tasks.c **** 
3985:..\Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
3986:..\Source/tasks.c **** 		{
3987:..\Source/tasks.c **** 			/* Generate the (binary) data. */
3988:..\Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
3989:..\Source/tasks.c **** 
3990:..\Source/tasks.c **** 			/* Create a human readable table from the binary data. */
3991:..\Source/tasks.c **** 			for( x = 0; x < uxArraySize; x++ )
3992:..\Source/tasks.c **** 			{
3993:..\Source/tasks.c **** 				switch( pxTaskStatusArray[ x ].eCurrentState )
3994:..\Source/tasks.c **** 				{
3995:..\Source/tasks.c **** 					case eReady:		cStatus = tskREADY_CHAR;
3996:..\Source/tasks.c **** 										break;
3997:..\Source/tasks.c **** 
3998:..\Source/tasks.c **** 					case eBlocked:		cStatus = tskBLOCKED_CHAR;
3999:..\Source/tasks.c **** 										break;
4000:..\Source/tasks.c **** 
4001:..\Source/tasks.c **** 					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
4002:..\Source/tasks.c **** 										break;
4003:..\Source/tasks.c **** 
4004:..\Source/tasks.c **** 					case eDeleted:		cStatus = tskDELETED_CHAR;
4005:..\Source/tasks.c **** 										break;
4006:..\Source/tasks.c **** 
4007:..\Source/tasks.c **** 					default:			/* Should not get here, but it is included
4008:..\Source/tasks.c **** 										to prevent static checking errors. */
4009:..\Source/tasks.c **** 										cStatus = 0x00;
4010:..\Source/tasks.c **** 										break;
4011:..\Source/tasks.c **** 				}
4012:..\Source/tasks.c **** 
4013:..\Source/tasks.c **** 				/* Write the task name to the string, padding with spaces so it
4014:..\Source/tasks.c **** 				can be printed in tabular form more easily. */
4015:..\Source/tasks.c **** 				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4016:..\Source/tasks.c **** 
4017:..\Source/tasks.c **** 				/* Write the rest of the string. */
4018:..\Source/tasks.c **** 				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x 
4019:..\Source/tasks.c **** 				pcWriteBuffer += strlen( pcWriteBuffer );
4020:..\Source/tasks.c **** 			}
4021:..\Source/tasks.c **** 
4022:..\Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4023:..\Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4024:..\Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4025:..\Source/tasks.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 149


4026:..\Source/tasks.c **** 		else
4027:..\Source/tasks.c **** 		{
4028:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4029:..\Source/tasks.c **** 		}
4030:..\Source/tasks.c **** 	}
4031:..\Source/tasks.c **** 
4032:..\Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4033:..\Source/tasks.c **** /*----------------------------------------------------------*/
4034:..\Source/tasks.c **** 
4035:..\Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4036:..\Source/tasks.c **** 
4037:..\Source/tasks.c **** 	void vTaskGetRunTimeStats( char *pcWriteBuffer )
4038:..\Source/tasks.c **** 	{
4039:..\Source/tasks.c **** 	TaskStatus_t *pxTaskStatusArray;
4040:..\Source/tasks.c **** 	volatile UBaseType_t uxArraySize, x;
4041:..\Source/tasks.c **** 	uint32_t ulTotalTime, ulStatsAsPercentage;
4042:..\Source/tasks.c **** 
4043:..\Source/tasks.c **** 		#if( configUSE_TRACE_FACILITY != 1 )
4044:..\Source/tasks.c **** 		{
4045:..\Source/tasks.c **** 			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTime
4046:..\Source/tasks.c **** 		}
4047:..\Source/tasks.c **** 		#endif
4048:..\Source/tasks.c **** 
4049:..\Source/tasks.c **** 		/*
4050:..\Source/tasks.c **** 		 * PLEASE NOTE:
4051:..\Source/tasks.c **** 		 *
4052:..\Source/tasks.c **** 		 * This function is provided for convenience only, and is used by many
4053:..\Source/tasks.c **** 		 * of the demo applications.  Do not consider it to be part of the
4054:..\Source/tasks.c **** 		 * scheduler.
4055:..\Source/tasks.c **** 		 *
4056:..\Source/tasks.c **** 		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4057:..\Source/tasks.c **** 		 * of the uxTaskGetSystemState() output into a human readable table that
4058:..\Source/tasks.c **** 		 * displays the amount of time each task has spent in the Running state
4059:..\Source/tasks.c **** 		 * in both absolute and percentage terms.
4060:..\Source/tasks.c **** 		 *
4061:..\Source/tasks.c **** 		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4062:..\Source/tasks.c **** 		 * function that might bloat the code size, use a lot of stack, and
4063:..\Source/tasks.c **** 		 * provide different results on different platforms.  An alternative,
4064:..\Source/tasks.c **** 		 * tiny, third party, and limited functionality implementation of
4065:..\Source/tasks.c **** 		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4066:..\Source/tasks.c **** 		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4067:..\Source/tasks.c **** 		 * a full snprintf() implementation!).
4068:..\Source/tasks.c **** 		 *
4069:..\Source/tasks.c **** 		 * It is recommended that production systems call uxTaskGetSystemState()
4070:..\Source/tasks.c **** 		 * directly to get access to raw stats data, rather than indirectly
4071:..\Source/tasks.c **** 		 * through a call to vTaskGetRunTimeStats().
4072:..\Source/tasks.c **** 		 */
4073:..\Source/tasks.c **** 
4074:..\Source/tasks.c **** 		/* Make sure the write buffer does not contain a string. */
4075:..\Source/tasks.c **** 		*pcWriteBuffer = 0x00;
4076:..\Source/tasks.c **** 
4077:..\Source/tasks.c **** 		/* Take a snapshot of the number of tasks in case it changes while this
4078:..\Source/tasks.c **** 		function is executing. */
4079:..\Source/tasks.c **** 		uxArraySize = uxCurrentNumberOfTasks;
4080:..\Source/tasks.c **** 
4081:..\Source/tasks.c **** 		/* Allocate an array index for each task.  NOTE!  If
4082:..\Source/tasks.c **** 		configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 150


4083:..\Source/tasks.c **** 		equate to NULL. */
4084:..\Source/tasks.c **** 		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
4085:..\Source/tasks.c **** 
4086:..\Source/tasks.c **** 		if( pxTaskStatusArray != NULL )
4087:..\Source/tasks.c **** 		{
4088:..\Source/tasks.c **** 			/* Generate the (binary) data. */
4089:..\Source/tasks.c **** 			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4090:..\Source/tasks.c **** 
4091:..\Source/tasks.c **** 			/* For percentage calculations. */
4092:..\Source/tasks.c **** 			ulTotalTime /= 100UL;
4093:..\Source/tasks.c **** 
4094:..\Source/tasks.c **** 			/* Avoid divide by zero errors. */
4095:..\Source/tasks.c **** 			if( ulTotalTime > 0 )
4096:..\Source/tasks.c **** 			{
4097:..\Source/tasks.c **** 				/* Create a human readable table from the binary data. */
4098:..\Source/tasks.c **** 				for( x = 0; x < uxArraySize; x++ )
4099:..\Source/tasks.c **** 				{
4100:..\Source/tasks.c **** 					/* What percentage of the total run time has the task used?
4101:..\Source/tasks.c **** 					This will always be rounded down to the nearest integer.
4102:..\Source/tasks.c **** 					ulTotalRunTimeDiv100 has already been divided by 100. */
4103:..\Source/tasks.c **** 					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4104:..\Source/tasks.c **** 
4105:..\Source/tasks.c **** 					/* Write the task name to the string, padding with
4106:..\Source/tasks.c **** 					spaces so it can be printed in tabular form more
4107:..\Source/tasks.c **** 					easily. */
4108:..\Source/tasks.c **** 					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
4109:..\Source/tasks.c **** 
4110:..\Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
4111:..\Source/tasks.c **** 					{
4112:..\Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4113:..\Source/tasks.c **** 						{
4114:..\Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulSta
4115:..\Source/tasks.c **** 						}
4116:..\Source/tasks.c **** 						#else
4117:..\Source/tasks.c **** 						{
4118:..\Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4119:..\Source/tasks.c **** 							printf() library can be used. */
4120:..\Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4121:..\Source/tasks.c **** 						}
4122:..\Source/tasks.c **** 						#endif
4123:..\Source/tasks.c **** 					}
4124:..\Source/tasks.c **** 					else
4125:..\Source/tasks.c **** 					{
4126:..\Source/tasks.c **** 						/* If the percentage is zero here then the task has
4127:..\Source/tasks.c **** 						consumed less than 1% of the total run time. */
4128:..\Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4129:..\Source/tasks.c **** 						{
4130:..\Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
4131:..\Source/tasks.c **** 						}
4132:..\Source/tasks.c **** 						#else
4133:..\Source/tasks.c **** 						{
4134:..\Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
4135:..\Source/tasks.c **** 							printf() library can be used. */
4136:..\Source/tasks.c **** 							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTim
4137:..\Source/tasks.c **** 						}
4138:..\Source/tasks.c **** 						#endif
4139:..\Source/tasks.c **** 					}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 151


4140:..\Source/tasks.c **** 
4141:..\Source/tasks.c **** 					pcWriteBuffer += strlen( pcWriteBuffer );
4142:..\Source/tasks.c **** 				}
4143:..\Source/tasks.c **** 			}
4144:..\Source/tasks.c **** 			else
4145:..\Source/tasks.c **** 			{
4146:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4147:..\Source/tasks.c **** 			}
4148:..\Source/tasks.c **** 
4149:..\Source/tasks.c **** 			/* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4150:..\Source/tasks.c **** 			is 0 then vPortFree() will be #defined to nothing. */
4151:..\Source/tasks.c **** 			vPortFree( pxTaskStatusArray );
4152:..\Source/tasks.c **** 		}
4153:..\Source/tasks.c **** 		else
4154:..\Source/tasks.c **** 		{
4155:..\Source/tasks.c **** 			mtCOVERAGE_TEST_MARKER();
4156:..\Source/tasks.c **** 		}
4157:..\Source/tasks.c **** 	}
4158:..\Source/tasks.c **** 
4159:..\Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4160:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4161:..\Source/tasks.c **** 
4162:..\Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4163:..\Source/tasks.c **** {
 4103              		.loc 1 4163 0
 4104              		.cfi_startproc
 4105              		@ args = 0, pretend = 0, frame = 8
 4106              		@ frame_needed = 1, uses_anonymous_args = 0
 4107              		@ link register save eliminated.
 4108 0000 80B4     		push	{r7}
 4109              		.cfi_def_cfa_offset 4
 4110              		.cfi_offset 7, -4
 4111 0002 83B0     		sub	sp, sp, #12
 4112              		.cfi_def_cfa_offset 16
 4113 0004 00AF     		add	r7, sp, #0
 4114              		.cfi_def_cfa_register 7
4164:..\Source/tasks.c **** TickType_t uxReturn;
4165:..\Source/tasks.c **** 
4166:..\Source/tasks.c **** 	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 4115              		.loc 1 4166 0
 4116 0006 094B     		ldr	r3, .L276
 4117 0008 1B68     		ldr	r3, [r3]
 4118 000a 9B69     		ldr	r3, [r3, #24]
 4119 000c 7B60     		str	r3, [r7, #4]
4167:..\Source/tasks.c **** 
4168:..\Source/tasks.c **** 	/* Reset the event list item to its normal value - so it can be used with
4169:..\Source/tasks.c **** 	queues and semaphores. */
4170:..\Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES 
 4120              		.loc 1 4170 0
 4121 000e 074B     		ldr	r3, .L276
 4122 0010 1B68     		ldr	r3, [r3]
 4123 0012 064A     		ldr	r2, .L276
 4124 0014 1268     		ldr	r2, [r2]
 4125 0016 D26A     		ldr	r2, [r2, #44]
 4126 0018 C2F10502 		rsb	r2, r2, #5
 4127 001c 9A61     		str	r2, [r3, #24]
4171:..\Source/tasks.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 152


4172:..\Source/tasks.c **** 	return uxReturn;
 4128              		.loc 1 4172 0
 4129 001e 7B68     		ldr	r3, [r7, #4]
4173:..\Source/tasks.c **** }
 4130              		.loc 1 4173 0
 4131 0020 1846     		mov	r0, r3
 4132 0022 0C37     		adds	r7, r7, #12
 4133              		.cfi_def_cfa_offset 4
 4134 0024 BD46     		mov	sp, r7
 4135              		.cfi_def_cfa_register 13
 4136              		@ sp needed
 4137 0026 5DF8047B 		ldr	r7, [sp], #4
 4138              		.cfi_restore 7
 4139              		.cfi_def_cfa_offset 0
 4140 002a 7047     		bx	lr
 4141              	.L277:
 4142              		.align	2
 4143              	.L276:
 4144 002c 00000000 		.word	pxCurrentTCB
 4145              		.cfi_endproc
 4146              	.LFE109:
 4147              		.size	uxTaskResetEventItemValue, .-uxTaskResetEventItemValue
 4148              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 4149              		.align	2
 4150              		.global	pvTaskIncrementMutexHeldCount
 4151              		.thumb
 4152              		.thumb_func
 4153              		.type	pvTaskIncrementMutexHeldCount, %function
 4154              	pvTaskIncrementMutexHeldCount:
 4155              	.LFB110:
4174:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4175:..\Source/tasks.c **** 
4176:..\Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4177:..\Source/tasks.c **** 
4178:..\Source/tasks.c **** 	void *pvTaskIncrementMutexHeldCount( void )
4179:..\Source/tasks.c **** 	{
 4156              		.loc 1 4179 0
 4157              		.cfi_startproc
 4158              		@ args = 0, pretend = 0, frame = 0
 4159              		@ frame_needed = 1, uses_anonymous_args = 0
 4160              		@ link register save eliminated.
 4161 0000 80B4     		push	{r7}
 4162              		.cfi_def_cfa_offset 4
 4163              		.cfi_offset 7, -4
 4164 0002 00AF     		add	r7, sp, #0
 4165              		.cfi_def_cfa_register 7
4180:..\Source/tasks.c **** 		/* If xSemaphoreCreateMutex() is called before any tasks have been created
4181:..\Source/tasks.c **** 		then pxCurrentTCB will be NULL. */
4182:..\Source/tasks.c **** 		if( pxCurrentTCB != NULL )
 4166              		.loc 1 4182 0
 4167 0004 074B     		ldr	r3, .L281
 4168 0006 1B68     		ldr	r3, [r3]
 4169 0008 002B     		cmp	r3, #0
 4170 000a 04D0     		beq	.L279
4183:..\Source/tasks.c **** 		{
4184:..\Source/tasks.c **** 			( pxCurrentTCB->uxMutexesHeld )++;
 4171              		.loc 1 4184 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 153


 4172 000c 054B     		ldr	r3, .L281
 4173 000e 1B68     		ldr	r3, [r3]
 4174 0010 5A6C     		ldr	r2, [r3, #68]
 4175 0012 0132     		adds	r2, r2, #1
 4176 0014 5A64     		str	r2, [r3, #68]
 4177              	.L279:
4185:..\Source/tasks.c **** 		}
4186:..\Source/tasks.c **** 
4187:..\Source/tasks.c **** 		return pxCurrentTCB;
 4178              		.loc 1 4187 0
 4179 0016 034B     		ldr	r3, .L281
 4180 0018 1B68     		ldr	r3, [r3]
4188:..\Source/tasks.c **** 	}
 4181              		.loc 1 4188 0
 4182 001a 1846     		mov	r0, r3
 4183 001c BD46     		mov	sp, r7
 4184              		.cfi_def_cfa_register 13
 4185              		@ sp needed
 4186 001e 5DF8047B 		ldr	r7, [sp], #4
 4187              		.cfi_restore 7
 4188              		.cfi_def_cfa_offset 0
 4189 0022 7047     		bx	lr
 4190              	.L282:
 4191              		.align	2
 4192              	.L281:
 4193 0024 00000000 		.word	pxCurrentTCB
 4194              		.cfi_endproc
 4195              	.LFE110:
 4196              		.size	pvTaskIncrementMutexHeldCount, .-pvTaskIncrementMutexHeldCount
 4197              		.section	.text.ulTaskNotifyTake,"ax",%progbits
 4198              		.align	2
 4199              		.global	ulTaskNotifyTake
 4200              		.thumb
 4201              		.thumb_func
 4202              		.type	ulTaskNotifyTake, %function
 4203              	ulTaskNotifyTake:
 4204              	.LFB111:
4189:..\Source/tasks.c **** 
4190:..\Source/tasks.c **** #endif /* configUSE_MUTEXES */
4191:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4192:..\Source/tasks.c **** 
4193:..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4194:..\Source/tasks.c **** 
4195:..\Source/tasks.c **** 	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
4196:..\Source/tasks.c **** 	{
 4205              		.loc 1 4196 0
 4206              		.cfi_startproc
 4207              		@ args = 0, pretend = 0, frame = 16
 4208              		@ frame_needed = 1, uses_anonymous_args = 0
 4209 0000 80B5     		push	{r7, lr}
 4210              		.cfi_def_cfa_offset 8
 4211              		.cfi_offset 7, -8
 4212              		.cfi_offset 14, -4
 4213 0002 84B0     		sub	sp, sp, #16
 4214              		.cfi_def_cfa_offset 24
 4215 0004 00AF     		add	r7, sp, #0
 4216              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 154


 4217 0006 7860     		str	r0, [r7, #4]
 4218 0008 3960     		str	r1, [r7]
4197:..\Source/tasks.c **** 	uint32_t ulReturn;
4198:..\Source/tasks.c **** 
4199:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4219              		.loc 1 4199 0
 4220 000a FFF7FEFF 		bl	vPortEnterCritical
4200:..\Source/tasks.c **** 		{
4201:..\Source/tasks.c **** 			/* Only block if the notification count is not already non-zero. */
4202:..\Source/tasks.c **** 			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 4221              		.loc 1 4202 0
 4222 000e 1E4B     		ldr	r3, .L289
 4223 0010 1B68     		ldr	r3, [r3]
 4224 0012 9B6C     		ldr	r3, [r3, #72]
 4225 0014 002B     		cmp	r3, #0
 4226 0016 13D1     		bne	.L284
4203:..\Source/tasks.c **** 			{
4204:..\Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4205:..\Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 4227              		.loc 1 4205 0
 4228 0018 1B4B     		ldr	r3, .L289
 4229 001a 1B68     		ldr	r3, [r3]
 4230 001c 0122     		movs	r2, #1
 4231 001e 83F84C20 		strb	r2, [r3, #76]
4206:..\Source/tasks.c **** 
4207:..\Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 4232              		.loc 1 4207 0
 4233 0022 3B68     		ldr	r3, [r7]
 4234 0024 002B     		cmp	r3, #0
 4235 0026 0BD0     		beq	.L284
4208:..\Source/tasks.c **** 				{
4209:..\Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4236              		.loc 1 4209 0
 4237 0028 3868     		ldr	r0, [r7]
 4238 002a 0121     		movs	r1, #1
 4239 002c FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4210:..\Source/tasks.c **** 					traceTASK_NOTIFY_TAKE_BLOCK();
4211:..\Source/tasks.c **** 
4212:..\Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4213:..\Source/tasks.c **** 					section (some will yield immediately, others wait until the
4214:..\Source/tasks.c **** 					critical section exits) - but it is not something that
4215:..\Source/tasks.c **** 					application code should ever do. */
4216:..\Source/tasks.c **** 					portYIELD_WITHIN_API();
 4240              		.loc 1 4216 0
 4241 0030 164B     		ldr	r3, .L289+4
 4242 0032 4FF08052 		mov	r2, #268435456
 4243 0036 1A60     		str	r2, [r3]
 4244              	@ 4216 "..\Source\tasks.c" 1
 4245 0038 BFF34F8F 		dsb
 4246              	@ 0 "" 2
 4247              	@ 4216 "..\Source\tasks.c" 1
 4248 003c BFF36F8F 		isb
 4249              	@ 0 "" 2
 4250              		.thumb
 4251              	.L284:
4217:..\Source/tasks.c **** 				}
4218:..\Source/tasks.c **** 				else
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 155


4219:..\Source/tasks.c **** 				{
4220:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4221:..\Source/tasks.c **** 				}
4222:..\Source/tasks.c **** 			}
4223:..\Source/tasks.c **** 			else
4224:..\Source/tasks.c **** 			{
4225:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4226:..\Source/tasks.c **** 			}
4227:..\Source/tasks.c **** 		}
4228:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4252              		.loc 1 4228 0
 4253 0040 FFF7FEFF 		bl	vPortExitCritical
4229:..\Source/tasks.c **** 
4230:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4254              		.loc 1 4230 0
 4255 0044 FFF7FEFF 		bl	vPortEnterCritical
4231:..\Source/tasks.c **** 		{
4232:..\Source/tasks.c **** 			traceTASK_NOTIFY_TAKE();
4233:..\Source/tasks.c **** 			ulReturn = pxCurrentTCB->ulNotifiedValue;
 4256              		.loc 1 4233 0
 4257 0048 0F4B     		ldr	r3, .L289
 4258 004a 1B68     		ldr	r3, [r3]
 4259 004c 9B6C     		ldr	r3, [r3, #72]
 4260 004e FB60     		str	r3, [r7, #12]
4234:..\Source/tasks.c **** 
4235:..\Source/tasks.c **** 			if( ulReturn != 0UL )
 4261              		.loc 1 4235 0
 4262 0050 FB68     		ldr	r3, [r7, #12]
 4263 0052 002B     		cmp	r3, #0
 4264 0054 0CD0     		beq	.L285
4236:..\Source/tasks.c **** 			{
4237:..\Source/tasks.c **** 				if( xClearCountOnExit != pdFALSE )
 4265              		.loc 1 4237 0
 4266 0056 7B68     		ldr	r3, [r7, #4]
 4267 0058 002B     		cmp	r3, #0
 4268 005a 04D0     		beq	.L286
4238:..\Source/tasks.c **** 				{
4239:..\Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = 0UL;
 4269              		.loc 1 4239 0
 4270 005c 0A4B     		ldr	r3, .L289
 4271 005e 1B68     		ldr	r3, [r3]
 4272 0060 0022     		movs	r2, #0
 4273 0062 9A64     		str	r2, [r3, #72]
 4274 0064 04E0     		b	.L285
 4275              	.L286:
4240:..\Source/tasks.c **** 				}
4241:..\Source/tasks.c **** 				else
4242:..\Source/tasks.c **** 				{
4243:..\Source/tasks.c **** 					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 4276              		.loc 1 4243 0
 4277 0066 084B     		ldr	r3, .L289
 4278 0068 1B68     		ldr	r3, [r3]
 4279 006a FA68     		ldr	r2, [r7, #12]
 4280 006c 013A     		subs	r2, r2, #1
 4281 006e 9A64     		str	r2, [r3, #72]
 4282              	.L285:
4244:..\Source/tasks.c **** 				}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 156


4245:..\Source/tasks.c **** 			}
4246:..\Source/tasks.c **** 			else
4247:..\Source/tasks.c **** 			{
4248:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4249:..\Source/tasks.c **** 			}
4250:..\Source/tasks.c **** 
4251:..\Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 4283              		.loc 1 4251 0
 4284 0070 054B     		ldr	r3, .L289
 4285 0072 1B68     		ldr	r3, [r3]
 4286 0074 0022     		movs	r2, #0
 4287 0076 83F84C20 		strb	r2, [r3, #76]
4252:..\Source/tasks.c **** 		}
4253:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4288              		.loc 1 4253 0
 4289 007a FFF7FEFF 		bl	vPortExitCritical
4254:..\Source/tasks.c **** 
4255:..\Source/tasks.c **** 		return ulReturn;
 4290              		.loc 1 4255 0
 4291 007e FB68     		ldr	r3, [r7, #12]
4256:..\Source/tasks.c **** 	}
 4292              		.loc 1 4256 0
 4293 0080 1846     		mov	r0, r3
 4294 0082 1037     		adds	r7, r7, #16
 4295              		.cfi_def_cfa_offset 8
 4296 0084 BD46     		mov	sp, r7
 4297              		.cfi_def_cfa_register 13
 4298              		@ sp needed
 4299 0086 80BD     		pop	{r7, pc}
 4300              	.L290:
 4301              		.align	2
 4302              	.L289:
 4303 0088 00000000 		.word	pxCurrentTCB
 4304 008c 04ED00E0 		.word	-536810236
 4305              		.cfi_endproc
 4306              	.LFE111:
 4307              		.size	ulTaskNotifyTake, .-ulTaskNotifyTake
 4308              		.section	.text.xTaskNotifyWait,"ax",%progbits
 4309              		.align	2
 4310              		.global	xTaskNotifyWait
 4311              		.thumb
 4312              		.thumb_func
 4313              		.type	xTaskNotifyWait, %function
 4314              	xTaskNotifyWait:
 4315              	.LFB112:
4257:..\Source/tasks.c **** 
4258:..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4259:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4260:..\Source/tasks.c **** 
4261:..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4262:..\Source/tasks.c **** 
4263:..\Source/tasks.c **** 	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t 
4264:..\Source/tasks.c **** 	{
 4316              		.loc 1 4264 0
 4317              		.cfi_startproc
 4318              		@ args = 0, pretend = 0, frame = 24
 4319              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 157


 4320 0000 80B5     		push	{r7, lr}
 4321              		.cfi_def_cfa_offset 8
 4322              		.cfi_offset 7, -8
 4323              		.cfi_offset 14, -4
 4324 0002 86B0     		sub	sp, sp, #24
 4325              		.cfi_def_cfa_offset 32
 4326 0004 00AF     		add	r7, sp, #0
 4327              		.cfi_def_cfa_register 7
 4328 0006 F860     		str	r0, [r7, #12]
 4329 0008 B960     		str	r1, [r7, #8]
 4330 000a 7A60     		str	r2, [r7, #4]
 4331 000c 3B60     		str	r3, [r7]
4265:..\Source/tasks.c **** 	BaseType_t xReturn;
4266:..\Source/tasks.c **** 
4267:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4332              		.loc 1 4267 0
 4333 000e FFF7FEFF 		bl	vPortEnterCritical
4268:..\Source/tasks.c **** 		{
4269:..\Source/tasks.c **** 			/* Only block if a notification is not already pending. */
4270:..\Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 4334              		.loc 1 4270 0
 4335 0012 264B     		ldr	r3, .L297
 4336 0014 1B68     		ldr	r3, [r3]
 4337 0016 93F84C30 		ldrb	r3, [r3, #76]
 4338 001a DBB2     		uxtb	r3, r3
 4339 001c 022B     		cmp	r3, #2
 4340 001e 1AD0     		beq	.L292
4271:..\Source/tasks.c **** 			{
4272:..\Source/tasks.c **** 				/* Clear bits in the task's notification value as bits may get
4273:..\Source/tasks.c **** 				set	by the notifying task or interrupt.  This can be used to
4274:..\Source/tasks.c **** 				clear the value to zero. */
4275:..\Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 4341              		.loc 1 4275 0
 4342 0020 224B     		ldr	r3, .L297
 4343 0022 1B68     		ldr	r3, [r3]
 4344 0024 996C     		ldr	r1, [r3, #72]
 4345 0026 FA68     		ldr	r2, [r7, #12]
 4346 0028 D243     		mvns	r2, r2
 4347 002a 0A40     		ands	r2, r2, r1
 4348 002c 9A64     		str	r2, [r3, #72]
4276:..\Source/tasks.c **** 
4277:..\Source/tasks.c **** 				/* Mark this task as waiting for a notification. */
4278:..\Source/tasks.c **** 				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 4349              		.loc 1 4278 0
 4350 002e 1F4B     		ldr	r3, .L297
 4351 0030 1B68     		ldr	r3, [r3]
 4352 0032 0122     		movs	r2, #1
 4353 0034 83F84C20 		strb	r2, [r3, #76]
4279:..\Source/tasks.c **** 
4280:..\Source/tasks.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
 4354              		.loc 1 4280 0
 4355 0038 3B68     		ldr	r3, [r7]
 4356 003a 002B     		cmp	r3, #0
 4357 003c 0BD0     		beq	.L292
4281:..\Source/tasks.c **** 				{
4282:..\Source/tasks.c **** 					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4358              		.loc 1 4282 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 158


 4359 003e 3868     		ldr	r0, [r7]
 4360 0040 0121     		movs	r1, #1
 4361 0042 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4283:..\Source/tasks.c **** 					traceTASK_NOTIFY_WAIT_BLOCK();
4284:..\Source/tasks.c **** 
4285:..\Source/tasks.c **** 					/* All ports are written to allow a yield in a critical
4286:..\Source/tasks.c **** 					section (some will yield immediately, others wait until the
4287:..\Source/tasks.c **** 					critical section exits) - but it is not something that
4288:..\Source/tasks.c **** 					application code should ever do. */
4289:..\Source/tasks.c **** 					portYIELD_WITHIN_API();
 4362              		.loc 1 4289 0
 4363 0046 1A4B     		ldr	r3, .L297+4
 4364 0048 4FF08052 		mov	r2, #268435456
 4365 004c 1A60     		str	r2, [r3]
 4366              	@ 4289 "..\Source\tasks.c" 1
 4367 004e BFF34F8F 		dsb
 4368              	@ 0 "" 2
 4369              	@ 4289 "..\Source\tasks.c" 1
 4370 0052 BFF36F8F 		isb
 4371              	@ 0 "" 2
 4372              		.thumb
 4373              	.L292:
4290:..\Source/tasks.c **** 				}
4291:..\Source/tasks.c **** 				else
4292:..\Source/tasks.c **** 				{
4293:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4294:..\Source/tasks.c **** 				}
4295:..\Source/tasks.c **** 			}
4296:..\Source/tasks.c **** 			else
4297:..\Source/tasks.c **** 			{
4298:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4299:..\Source/tasks.c **** 			}
4300:..\Source/tasks.c **** 		}
4301:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4374              		.loc 1 4301 0
 4375 0056 FFF7FEFF 		bl	vPortExitCritical
4302:..\Source/tasks.c **** 
4303:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4376              		.loc 1 4303 0
 4377 005a FFF7FEFF 		bl	vPortEnterCritical
4304:..\Source/tasks.c **** 		{
4305:..\Source/tasks.c **** 			traceTASK_NOTIFY_WAIT();
4306:..\Source/tasks.c **** 
4307:..\Source/tasks.c **** 			if( pulNotificationValue != NULL )
 4378              		.loc 1 4307 0
 4379 005e 7B68     		ldr	r3, [r7, #4]
 4380 0060 002B     		cmp	r3, #0
 4381 0062 04D0     		beq	.L293
4308:..\Source/tasks.c **** 			{
4309:..\Source/tasks.c **** 				/* Output the current notification value, which may or may not
4310:..\Source/tasks.c **** 				have changed. */
4311:..\Source/tasks.c **** 				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 4382              		.loc 1 4311 0
 4383 0064 114B     		ldr	r3, .L297
 4384 0066 1B68     		ldr	r3, [r3]
 4385 0068 9A6C     		ldr	r2, [r3, #72]
 4386 006a 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 159


 4387 006c 1A60     		str	r2, [r3]
 4388              	.L293:
4312:..\Source/tasks.c **** 			}
4313:..\Source/tasks.c **** 
4314:..\Source/tasks.c **** 			/* If ucNotifyValue is set then either the task never entered the
4315:..\Source/tasks.c **** 			blocked state (because a notification was already pending) or the
4316:..\Source/tasks.c **** 			task unblocked because of a notification.  Otherwise the task
4317:..\Source/tasks.c **** 			unblocked because of a timeout. */
4318:..\Source/tasks.c **** 			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 4389              		.loc 1 4318 0
 4390 006e 0F4B     		ldr	r3, .L297
 4391 0070 1B68     		ldr	r3, [r3]
 4392 0072 93F84C30 		ldrb	r3, [r3, #76]
 4393 0076 DBB2     		uxtb	r3, r3
 4394 0078 012B     		cmp	r3, #1
 4395 007a 02D1     		bne	.L294
4319:..\Source/tasks.c **** 			{
4320:..\Source/tasks.c **** 				/* A notification was not received. */
4321:..\Source/tasks.c **** 				xReturn = pdFALSE;
 4396              		.loc 1 4321 0
 4397 007c 0023     		movs	r3, #0
 4398 007e 7B61     		str	r3, [r7, #20]
 4399 0080 08E0     		b	.L295
 4400              	.L294:
4322:..\Source/tasks.c **** 			}
4323:..\Source/tasks.c **** 			else
4324:..\Source/tasks.c **** 			{
4325:..\Source/tasks.c **** 				/* A notification was already pending or a notification was
4326:..\Source/tasks.c **** 				received while the task was waiting. */
4327:..\Source/tasks.c **** 				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 4401              		.loc 1 4327 0
 4402 0082 0A4B     		ldr	r3, .L297
 4403 0084 1B68     		ldr	r3, [r3]
 4404 0086 996C     		ldr	r1, [r3, #72]
 4405 0088 BA68     		ldr	r2, [r7, #8]
 4406 008a D243     		mvns	r2, r2
 4407 008c 0A40     		ands	r2, r2, r1
 4408 008e 9A64     		str	r2, [r3, #72]
4328:..\Source/tasks.c **** 				xReturn = pdTRUE;
 4409              		.loc 1 4328 0
 4410 0090 0123     		movs	r3, #1
 4411 0092 7B61     		str	r3, [r7, #20]
 4412              	.L295:
4329:..\Source/tasks.c **** 			}
4330:..\Source/tasks.c **** 
4331:..\Source/tasks.c **** 			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 4413              		.loc 1 4331 0
 4414 0094 054B     		ldr	r3, .L297
 4415 0096 1B68     		ldr	r3, [r3]
 4416 0098 0022     		movs	r2, #0
 4417 009a 83F84C20 		strb	r2, [r3, #76]
4332:..\Source/tasks.c **** 		}
4333:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4418              		.loc 1 4333 0
 4419 009e FFF7FEFF 		bl	vPortExitCritical
4334:..\Source/tasks.c **** 
4335:..\Source/tasks.c **** 		return xReturn;
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 160


 4420              		.loc 1 4335 0
 4421 00a2 7B69     		ldr	r3, [r7, #20]
4336:..\Source/tasks.c **** 	}
 4422              		.loc 1 4336 0
 4423 00a4 1846     		mov	r0, r3
 4424 00a6 1837     		adds	r7, r7, #24
 4425              		.cfi_def_cfa_offset 8
 4426 00a8 BD46     		mov	sp, r7
 4427              		.cfi_def_cfa_register 13
 4428              		@ sp needed
 4429 00aa 80BD     		pop	{r7, pc}
 4430              	.L298:
 4431              		.align	2
 4432              	.L297:
 4433 00ac 00000000 		.word	pxCurrentTCB
 4434 00b0 04ED00E0 		.word	-536810236
 4435              		.cfi_endproc
 4436              	.LFE112:
 4437              		.size	xTaskNotifyWait, .-xTaskNotifyWait
 4438              		.section	.text.xTaskGenericNotify,"ax",%progbits
 4439              		.align	2
 4440              		.global	xTaskGenericNotify
 4441              		.thumb
 4442              		.thumb_func
 4443              		.type	xTaskGenericNotify, %function
 4444              	xTaskGenericNotify:
 4445              	.LFB113:
4337:..\Source/tasks.c **** 
4338:..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4339:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4340:..\Source/tasks.c **** 
4341:..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4342:..\Source/tasks.c **** 
4343:..\Source/tasks.c **** 	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction
4344:..\Source/tasks.c **** 	{
 4446              		.loc 1 4344 0
 4447              		.cfi_startproc
 4448              		@ args = 0, pretend = 0, frame = 32
 4449              		@ frame_needed = 1, uses_anonymous_args = 0
 4450 0000 80B5     		push	{r7, lr}
 4451              		.cfi_def_cfa_offset 8
 4452              		.cfi_offset 7, -8
 4453              		.cfi_offset 14, -4
 4454 0002 88B0     		sub	sp, sp, #32
 4455              		.cfi_def_cfa_offset 40
 4456 0004 00AF     		add	r7, sp, #0
 4457              		.cfi_def_cfa_register 7
 4458 0006 F860     		str	r0, [r7, #12]
 4459 0008 B960     		str	r1, [r7, #8]
 4460 000a 3B60     		str	r3, [r7]
 4461 000c 1346     		mov	r3, r2
 4462 000e FB71     		strb	r3, [r7, #7]
4345:..\Source/tasks.c **** 	TCB_t * pxTCB;
4346:..\Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4463              		.loc 1 4346 0
 4464 0010 0123     		movs	r3, #1
 4465 0012 FB61     		str	r3, [r7, #28]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 161


4347:..\Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4348:..\Source/tasks.c **** 
4349:..\Source/tasks.c **** 		configASSERT( xTaskToNotify );
4350:..\Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 4466              		.loc 1 4350 0
 4467 0014 FB68     		ldr	r3, [r7, #12]
 4468 0016 BB61     		str	r3, [r7, #24]
4351:..\Source/tasks.c **** 
4352:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 4469              		.loc 1 4352 0
 4470 0018 FFF7FEFF 		bl	vPortEnterCritical
4353:..\Source/tasks.c **** 		{
4354:..\Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4471              		.loc 1 4354 0
 4472 001c 3B68     		ldr	r3, [r7]
 4473 001e 002B     		cmp	r3, #0
 4474 0020 03D0     		beq	.L300
4355:..\Source/tasks.c **** 			{
4356:..\Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4475              		.loc 1 4356 0
 4476 0022 BB69     		ldr	r3, [r7, #24]
 4477 0024 9A6C     		ldr	r2, [r3, #72]
 4478 0026 3B68     		ldr	r3, [r7]
 4479 0028 1A60     		str	r2, [r3]
 4480              	.L300:
4357:..\Source/tasks.c **** 			}
4358:..\Source/tasks.c **** 
4359:..\Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4481              		.loc 1 4359 0
 4482 002a BB69     		ldr	r3, [r7, #24]
 4483 002c 93F84C30 		ldrb	r3, [r3, #76]
 4484 0030 FB75     		strb	r3, [r7, #23]
4360:..\Source/tasks.c **** 
4361:..\Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4485              		.loc 1 4361 0
 4486 0032 BB69     		ldr	r3, [r7, #24]
 4487 0034 0222     		movs	r2, #2
 4488 0036 83F84C20 		strb	r2, [r3, #76]
4362:..\Source/tasks.c **** 
4363:..\Source/tasks.c **** 			switch( eAction )
 4489              		.loc 1 4363 0
 4490 003a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4491 003c 042B     		cmp	r3, #4
 4492 003e 28D8     		bhi	.L301
 4493 0040 01A2     		adr	r2, .L303
 4494 0042 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4495 0046 00BF     		.p2align 2
 4496              	.L303:
 4497 0048 93000000 		.word	.L301+1
 4498 004c 5D000000 		.word	.L304+1
 4499 0050 6B000000 		.word	.L305+1
 4500 0054 77000000 		.word	.L306+1
 4501 0058 7F000000 		.word	.L307+1
 4502              		.p2align 1
 4503              	.L304:
4364:..\Source/tasks.c **** 			{
4365:..\Source/tasks.c **** 				case eSetBits	:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 162


4366:..\Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 4504              		.loc 1 4366 0
 4505 005c BB69     		ldr	r3, [r7, #24]
 4506 005e 9A6C     		ldr	r2, [r3, #72]
 4507 0060 BB68     		ldr	r3, [r7, #8]
 4508 0062 1A43     		orrs	r2, r2, r3
 4509 0064 BB69     		ldr	r3, [r7, #24]
 4510 0066 9A64     		str	r2, [r3, #72]
4367:..\Source/tasks.c **** 					break;
 4511              		.loc 1 4367 0
 4512 0068 13E0     		b	.L301
 4513              	.L305:
4368:..\Source/tasks.c **** 
4369:..\Source/tasks.c **** 				case eIncrement	:
4370:..\Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4514              		.loc 1 4370 0
 4515 006a BB69     		ldr	r3, [r7, #24]
 4516 006c 9B6C     		ldr	r3, [r3, #72]
 4517 006e 5A1C     		adds	r2, r3, #1
 4518 0070 BB69     		ldr	r3, [r7, #24]
 4519 0072 9A64     		str	r2, [r3, #72]
4371:..\Source/tasks.c **** 					break;
 4520              		.loc 1 4371 0
 4521 0074 0DE0     		b	.L301
 4522              	.L306:
4372:..\Source/tasks.c **** 
4373:..\Source/tasks.c **** 				case eSetValueWithOverwrite	:
4374:..\Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4523              		.loc 1 4374 0
 4524 0076 BB69     		ldr	r3, [r7, #24]
 4525 0078 BA68     		ldr	r2, [r7, #8]
 4526 007a 9A64     		str	r2, [r3, #72]
4375:..\Source/tasks.c **** 					break;
 4527              		.loc 1 4375 0
 4528 007c 09E0     		b	.L301
 4529              	.L307:
4376:..\Source/tasks.c **** 
4377:..\Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4378:..\Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4530              		.loc 1 4378 0
 4531 007e FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4532 0080 022B     		cmp	r3, #2
 4533 0082 03D0     		beq	.L308
4379:..\Source/tasks.c **** 					{
4380:..\Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 4534              		.loc 1 4380 0
 4535 0084 BB69     		ldr	r3, [r7, #24]
 4536 0086 BA68     		ldr	r2, [r7, #8]
 4537 0088 9A64     		str	r2, [r3, #72]
4381:..\Source/tasks.c **** 					}
4382:..\Source/tasks.c **** 					else
4383:..\Source/tasks.c **** 					{
4384:..\Source/tasks.c **** 						/* The value could not be written to the task. */
4385:..\Source/tasks.c **** 						xReturn = pdFAIL;
4386:..\Source/tasks.c **** 					}
4387:..\Source/tasks.c **** 					break;
 4538              		.loc 1 4387 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 163


 4539 008a 01E0     		b	.L312
 4540              	.L308:
4385:..\Source/tasks.c **** 					}
 4541              		.loc 1 4385 0
 4542 008c 0023     		movs	r3, #0
 4543 008e FB61     		str	r3, [r7, #28]
 4544              	.L312:
 4545              		.loc 1 4387 0
 4546 0090 00BF     		nop
 4547              	.L301:
4388:..\Source/tasks.c **** 
4389:..\Source/tasks.c **** 				case eNoAction:
4390:..\Source/tasks.c **** 					/* The task is being notified without its notify value being
4391:..\Source/tasks.c **** 					updated. */
4392:..\Source/tasks.c **** 					break;
4393:..\Source/tasks.c **** 			}
4394:..\Source/tasks.c **** 
4395:..\Source/tasks.c **** 			traceTASK_NOTIFY();
4396:..\Source/tasks.c **** 
4397:..\Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4398:..\Source/tasks.c **** 			notification then unblock it now. */
4399:..\Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4548              		.loc 1 4399 0
 4549 0092 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4550 0094 012B     		cmp	r3, #1
 4551 0096 2CD1     		bne	.L310
4400:..\Source/tasks.c **** 			{
4401:..\Source/tasks.c **** 				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4552              		.loc 1 4401 0
 4553 0098 BB69     		ldr	r3, [r7, #24]
 4554 009a 0433     		adds	r3, r3, #4
 4555 009c 1846     		mov	r0, r3
 4556 009e FFF7FEFF 		bl	uxListRemove
4402:..\Source/tasks.c **** 				prvAddTaskToReadyList( pxTCB );
 4557              		.loc 1 4402 0
 4558 00a2 BB69     		ldr	r3, [r7, #24]
 4559 00a4 DB6A     		ldr	r3, [r3, #44]
 4560 00a6 1A46     		mov	r2, r3
 4561 00a8 0123     		movs	r3, #1
 4562 00aa 03FA02F2 		lsl	r2, r3, r2
 4563 00ae 144B     		ldr	r3, .L313
 4564 00b0 1B68     		ldr	r3, [r3]
 4565 00b2 1343     		orrs	r3, r3, r2
 4566 00b4 124A     		ldr	r2, .L313
 4567 00b6 1360     		str	r3, [r2]
 4568 00b8 BB69     		ldr	r3, [r7, #24]
 4569 00ba DA6A     		ldr	r2, [r3, #44]
 4570 00bc 1346     		mov	r3, r2
 4571 00be 9B00     		lsls	r3, r3, #2
 4572 00c0 1344     		add	r3, r3, r2
 4573 00c2 9B00     		lsls	r3, r3, #2
 4574 00c4 0F4A     		ldr	r2, .L313+4
 4575 00c6 1A44     		add	r2, r2, r3
 4576 00c8 BB69     		ldr	r3, [r7, #24]
 4577 00ca 0433     		adds	r3, r3, #4
 4578 00cc 1046     		mov	r0, r2
 4579 00ce 1946     		mov	r1, r3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 164


 4580 00d0 FFF7FEFF 		bl	vListInsertEnd
4403:..\Source/tasks.c **** 
4404:..\Source/tasks.c **** 				/* The task should not have been on an event list. */
4405:..\Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4406:..\Source/tasks.c **** 
4407:..\Source/tasks.c **** 				#if( configUSE_TICKLESS_IDLE != 0 )
4408:..\Source/tasks.c **** 				{
4409:..\Source/tasks.c **** 					/* If a task is blocked waiting for a notification then
4410:..\Source/tasks.c **** 					xNextTaskUnblockTime might be set to the blocked task's time
4411:..\Source/tasks.c **** 					out time.  If the task is unblocked for a reason other than
4412:..\Source/tasks.c **** 					a timeout xNextTaskUnblockTime is normally left unchanged,
4413:..\Source/tasks.c **** 					because it will automatically get reset to a new value when
4414:..\Source/tasks.c **** 					the tick count equals xNextTaskUnblockTime.  However if
4415:..\Source/tasks.c **** 					tickless idling is used it might be more important to enter
4416:..\Source/tasks.c **** 					sleep mode at the earliest possible time - so reset
4417:..\Source/tasks.c **** 					xNextTaskUnblockTime here to ensure it is updated at the
4418:..\Source/tasks.c **** 					earliest possible time. */
4419:..\Source/tasks.c **** 					prvResetNextTaskUnblockTime();
4420:..\Source/tasks.c **** 				}
4421:..\Source/tasks.c **** 				#endif
4422:..\Source/tasks.c **** 
4423:..\Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4581              		.loc 1 4423 0
 4582 00d4 BB69     		ldr	r3, [r7, #24]
 4583 00d6 DA6A     		ldr	r2, [r3, #44]
 4584 00d8 0B4B     		ldr	r3, .L313+8
 4585 00da 1B68     		ldr	r3, [r3]
 4586 00dc DB6A     		ldr	r3, [r3, #44]
 4587 00de 9A42     		cmp	r2, r3
 4588 00e0 07D9     		bls	.L310
4424:..\Source/tasks.c **** 				{
4425:..\Source/tasks.c **** 					/* The notified task has a priority above the currently
4426:..\Source/tasks.c **** 					executing task so a yield is required. */
4427:..\Source/tasks.c **** 					taskYIELD_IF_USING_PREEMPTION();
 4589              		.loc 1 4427 0
 4590 00e2 0A4B     		ldr	r3, .L313+12
 4591 00e4 4FF08052 		mov	r2, #268435456
 4592 00e8 1A60     		str	r2, [r3]
 4593              	@ 4427 "..\Source\tasks.c" 1
 4594 00ea BFF34F8F 		dsb
 4595              	@ 0 "" 2
 4596              	@ 4427 "..\Source\tasks.c" 1
 4597 00ee BFF36F8F 		isb
 4598              	@ 0 "" 2
 4599              		.thumb
 4600              	.L310:
4428:..\Source/tasks.c **** 				}
4429:..\Source/tasks.c **** 				else
4430:..\Source/tasks.c **** 				{
4431:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4432:..\Source/tasks.c **** 				}
4433:..\Source/tasks.c **** 			}
4434:..\Source/tasks.c **** 			else
4435:..\Source/tasks.c **** 			{
4436:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4437:..\Source/tasks.c **** 			}
4438:..\Source/tasks.c **** 		}
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 165


4439:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 4601              		.loc 1 4439 0
 4602 00f2 FFF7FEFF 		bl	vPortExitCritical
4440:..\Source/tasks.c **** 
4441:..\Source/tasks.c **** 		return xReturn;
 4603              		.loc 1 4441 0
 4604 00f6 FB69     		ldr	r3, [r7, #28]
4442:..\Source/tasks.c **** 	}
 4605              		.loc 1 4442 0
 4606 00f8 1846     		mov	r0, r3
 4607 00fa 2037     		adds	r7, r7, #32
 4608              		.cfi_def_cfa_offset 8
 4609 00fc BD46     		mov	sp, r7
 4610              		.cfi_def_cfa_register 13
 4611              		@ sp needed
 4612 00fe 80BD     		pop	{r7, pc}
 4613              	.L314:
 4614              		.align	2
 4615              	.L313:
 4616 0100 E0000000 		.word	uxTopReadyPriority
 4617 0104 04000000 		.word	pxReadyTasksLists
 4618 0108 00000000 		.word	pxCurrentTCB
 4619 010c 04ED00E0 		.word	-536810236
 4620              		.cfi_endproc
 4621              	.LFE113:
 4622              		.size	xTaskGenericNotify, .-xTaskGenericNotify
 4623              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 4624              		.align	2
 4625              		.global	xTaskGenericNotifyFromISR
 4626              		.thumb
 4627              		.thumb_func
 4628              		.type	xTaskGenericNotifyFromISR, %function
 4629              	xTaskGenericNotifyFromISR:
 4630              	.LFB114:
4443:..\Source/tasks.c **** 
4444:..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4445:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4446:..\Source/tasks.c **** 
4447:..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4448:..\Source/tasks.c **** 
4449:..\Source/tasks.c **** 	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction 
4450:..\Source/tasks.c **** 	{
 4631              		.loc 1 4450 0
 4632              		.cfi_startproc
 4633              		@ args = 4, pretend = 0, frame = 48
 4634              		@ frame_needed = 1, uses_anonymous_args = 0
 4635 0000 80B5     		push	{r7, lr}
 4636              		.cfi_def_cfa_offset 8
 4637              		.cfi_offset 7, -8
 4638              		.cfi_offset 14, -4
 4639 0002 8CB0     		sub	sp, sp, #48
 4640              		.cfi_def_cfa_offset 56
 4641 0004 00AF     		add	r7, sp, #0
 4642              		.cfi_def_cfa_register 7
 4643 0006 F860     		str	r0, [r7, #12]
 4644 0008 B960     		str	r1, [r7, #8]
 4645 000a 3B60     		str	r3, [r7]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 166


 4646 000c 1346     		mov	r3, r2
 4647 000e FB71     		strb	r3, [r7, #7]
4451:..\Source/tasks.c **** 	TCB_t * pxTCB;
4452:..\Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4453:..\Source/tasks.c **** 	BaseType_t xReturn = pdPASS;
 4648              		.loc 1 4453 0
 4649 0010 0123     		movs	r3, #1
 4650 0012 FB62     		str	r3, [r7, #44]
4454:..\Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4455:..\Source/tasks.c **** 
4456:..\Source/tasks.c **** 		configASSERT( xTaskToNotify );
4457:..\Source/tasks.c **** 
4458:..\Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4459:..\Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4460:..\Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4461:..\Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4462:..\Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4463:..\Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4464:..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4465:..\Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4466:..\Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4467:..\Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4468:..\Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4469:..\Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4470:..\Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4471:..\Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4472:..\Source/tasks.c **** 		provided on the following link:
4473:..\Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4474:..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4475:..\Source/tasks.c **** 
4476:..\Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 4651              		.loc 1 4476 0
 4652 0014 FB68     		ldr	r3, [r7, #12]
 4653 0016 BB62     		str	r3, [r7, #40]
 4654              	.LBB52:
 4655              	.LBB53:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 4656              		.loc 2 253 0
 4657              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 4658 0018 EFF31182 			mrs r2, basepri											
 4659 001c 4FF0A003 		mov r3, #160												
 4660 0020 83F31188 		msr basepri, r3											
 4661 0024 BFF36F8F 		isb														
 4662 0028 BFF34F8F 		dsb														
 4663              	
 4664              	@ 0 "" 2
 4665              		.thumb
 4666 002c FA61     		str	r2, [r7, #28]
 4667 002e BB61     		str	r3, [r7, #24]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 4668              		.loc 2 265 0
 4669 0030 FB69     		ldr	r3, [r7, #28]
 4670              	.LBE53:
 4671              	.LBE52:
4477:..\Source/tasks.c **** 
4478:..\Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4672              		.loc 1 4478 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 167


 4673 0032 7B62     		str	r3, [r7, #36]
4479:..\Source/tasks.c **** 		{
4480:..\Source/tasks.c **** 			if( pulPreviousNotificationValue != NULL )
 4674              		.loc 1 4480 0
 4675 0034 3B68     		ldr	r3, [r7]
 4676 0036 002B     		cmp	r3, #0
 4677 0038 03D0     		beq	.L317
4481:..\Source/tasks.c **** 			{
4482:..\Source/tasks.c **** 				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 4678              		.loc 1 4482 0
 4679 003a BB6A     		ldr	r3, [r7, #40]
 4680 003c 9A6C     		ldr	r2, [r3, #72]
 4681 003e 3B68     		ldr	r3, [r7]
 4682 0040 1A60     		str	r2, [r3]
 4683              	.L317:
4483:..\Source/tasks.c **** 			}
4484:..\Source/tasks.c **** 
4485:..\Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4684              		.loc 1 4485 0
 4685 0042 BB6A     		ldr	r3, [r7, #40]
 4686 0044 93F84C30 		ldrb	r3, [r3, #76]
 4687 0048 87F82330 		strb	r3, [r7, #35]
4486:..\Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4688              		.loc 1 4486 0
 4689 004c BB6A     		ldr	r3, [r7, #40]
 4690 004e 0222     		movs	r2, #2
 4691 0050 83F84C20 		strb	r2, [r3, #76]
4487:..\Source/tasks.c **** 
4488:..\Source/tasks.c **** 			switch( eAction )
 4692              		.loc 1 4488 0
 4693 0054 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 4694 0056 042B     		cmp	r3, #4
 4695 0058 28D8     		bhi	.L318
 4696 005a 01A2     		adr	r2, .L320
 4697 005c 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 4698              		.p2align 2
 4699              	.L320:
 4700 0060 AD000000 		.word	.L318+1
 4701 0064 75000000 		.word	.L321+1
 4702 0068 83000000 		.word	.L322+1
 4703 006c 8F000000 		.word	.L323+1
 4704 0070 97000000 		.word	.L324+1
 4705              		.p2align 1
 4706              	.L321:
4489:..\Source/tasks.c **** 			{
4490:..\Source/tasks.c **** 				case eSetBits	:
4491:..\Source/tasks.c **** 					pxTCB->ulNotifiedValue |= ulValue;
 4707              		.loc 1 4491 0
 4708 0074 BB6A     		ldr	r3, [r7, #40]
 4709 0076 9A6C     		ldr	r2, [r3, #72]
 4710 0078 BB68     		ldr	r3, [r7, #8]
 4711 007a 1A43     		orrs	r2, r2, r3
 4712 007c BB6A     		ldr	r3, [r7, #40]
 4713 007e 9A64     		str	r2, [r3, #72]
4492:..\Source/tasks.c **** 					break;
 4714              		.loc 1 4492 0
 4715 0080 14E0     		b	.L318
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 168


 4716              	.L322:
4493:..\Source/tasks.c **** 
4494:..\Source/tasks.c **** 				case eIncrement	:
4495:..\Source/tasks.c **** 					( pxTCB->ulNotifiedValue )++;
 4717              		.loc 1 4495 0
 4718 0082 BB6A     		ldr	r3, [r7, #40]
 4719 0084 9B6C     		ldr	r3, [r3, #72]
 4720 0086 5A1C     		adds	r2, r3, #1
 4721 0088 BB6A     		ldr	r3, [r7, #40]
 4722 008a 9A64     		str	r2, [r3, #72]
4496:..\Source/tasks.c **** 					break;
 4723              		.loc 1 4496 0
 4724 008c 0EE0     		b	.L318
 4725              	.L323:
4497:..\Source/tasks.c **** 
4498:..\Source/tasks.c **** 				case eSetValueWithOverwrite	:
4499:..\Source/tasks.c **** 					pxTCB->ulNotifiedValue = ulValue;
 4726              		.loc 1 4499 0
 4727 008e BB6A     		ldr	r3, [r7, #40]
 4728 0090 BA68     		ldr	r2, [r7, #8]
 4729 0092 9A64     		str	r2, [r3, #72]
4500:..\Source/tasks.c **** 					break;
 4730              		.loc 1 4500 0
 4731 0094 0AE0     		b	.L318
 4732              	.L324:
4501:..\Source/tasks.c **** 
4502:..\Source/tasks.c **** 				case eSetValueWithoutOverwrite :
4503:..\Source/tasks.c **** 					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 4733              		.loc 1 4503 0
 4734 0096 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 4735 009a 022B     		cmp	r3, #2
 4736 009c 03D0     		beq	.L325
4504:..\Source/tasks.c **** 					{
4505:..\Source/tasks.c **** 						pxTCB->ulNotifiedValue = ulValue;
 4737              		.loc 1 4505 0
 4738 009e BB6A     		ldr	r3, [r7, #40]
 4739 00a0 BA68     		ldr	r2, [r7, #8]
 4740 00a2 9A64     		str	r2, [r3, #72]
4506:..\Source/tasks.c **** 					}
4507:..\Source/tasks.c **** 					else
4508:..\Source/tasks.c **** 					{
4509:..\Source/tasks.c **** 						/* The value could not be written to the task. */
4510:..\Source/tasks.c **** 						xReturn = pdFAIL;
4511:..\Source/tasks.c **** 					}
4512:..\Source/tasks.c **** 					break;
 4741              		.loc 1 4512 0
 4742 00a4 01E0     		b	.L333
 4743              	.L325:
4510:..\Source/tasks.c **** 					}
 4744              		.loc 1 4510 0
 4745 00a6 0023     		movs	r3, #0
 4746 00a8 FB62     		str	r3, [r7, #44]
 4747              	.L333:
 4748              		.loc 1 4512 0
 4749 00aa 00BF     		nop
 4750              	.L318:
4513:..\Source/tasks.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 169


4514:..\Source/tasks.c **** 				case eNoAction :
4515:..\Source/tasks.c **** 					/* The task is being notified without its notify value being
4516:..\Source/tasks.c **** 					updated. */
4517:..\Source/tasks.c **** 					break;
4518:..\Source/tasks.c **** 			}
4519:..\Source/tasks.c **** 
4520:..\Source/tasks.c **** 			traceTASK_NOTIFY_FROM_ISR();
4521:..\Source/tasks.c **** 
4522:..\Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4523:..\Source/tasks.c **** 			notification then unblock it now. */
4524:..\Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4751              		.loc 1 4524 0
 4752 00ac 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 4753 00b0 012B     		cmp	r3, #1
 4754 00b2 39D1     		bne	.L327
4525:..\Source/tasks.c **** 			{
4526:..\Source/tasks.c **** 				/* The task should not have been on an event list. */
4527:..\Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4528:..\Source/tasks.c **** 
4529:..\Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4755              		.loc 1 4529 0
 4756 00b4 214B     		ldr	r3, .L334
 4757 00b6 1B68     		ldr	r3, [r3]
 4758 00b8 002B     		cmp	r3, #0
 4759 00ba 1ED1     		bne	.L328
4530:..\Source/tasks.c **** 				{
4531:..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4760              		.loc 1 4531 0
 4761 00bc BB6A     		ldr	r3, [r7, #40]
 4762 00be 0433     		adds	r3, r3, #4
 4763 00c0 1846     		mov	r0, r3
 4764 00c2 FFF7FEFF 		bl	uxListRemove
4532:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4765              		.loc 1 4532 0
 4766 00c6 BB6A     		ldr	r3, [r7, #40]
 4767 00c8 DB6A     		ldr	r3, [r3, #44]
 4768 00ca 1A46     		mov	r2, r3
 4769 00cc 0123     		movs	r3, #1
 4770 00ce 03FA02F2 		lsl	r2, r3, r2
 4771 00d2 1B4B     		ldr	r3, .L334+4
 4772 00d4 1B68     		ldr	r3, [r3]
 4773 00d6 1343     		orrs	r3, r3, r2
 4774 00d8 194A     		ldr	r2, .L334+4
 4775 00da 1360     		str	r3, [r2]
 4776 00dc BB6A     		ldr	r3, [r7, #40]
 4777 00de DA6A     		ldr	r2, [r3, #44]
 4778 00e0 1346     		mov	r3, r2
 4779 00e2 9B00     		lsls	r3, r3, #2
 4780 00e4 1344     		add	r3, r3, r2
 4781 00e6 9B00     		lsls	r3, r3, #2
 4782 00e8 164A     		ldr	r2, .L334+8
 4783 00ea 1A44     		add	r2, r2, r3
 4784 00ec BB6A     		ldr	r3, [r7, #40]
 4785 00ee 0433     		adds	r3, r3, #4
 4786 00f0 1046     		mov	r0, r2
 4787 00f2 1946     		mov	r1, r3
 4788 00f4 FFF7FEFF 		bl	vListInsertEnd
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 170


 4789 00f8 05E0     		b	.L329
 4790              	.L328:
4533:..\Source/tasks.c **** 				}
4534:..\Source/tasks.c **** 				else
4535:..\Source/tasks.c **** 				{
4536:..\Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4537:..\Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4538:..\Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4791              		.loc 1 4538 0
 4792 00fa BB6A     		ldr	r3, [r7, #40]
 4793 00fc 1833     		adds	r3, r3, #24
 4794 00fe 1248     		ldr	r0, .L334+12
 4795 0100 1946     		mov	r1, r3
 4796 0102 FFF7FEFF 		bl	vListInsertEnd
 4797              	.L329:
4539:..\Source/tasks.c **** 				}
4540:..\Source/tasks.c **** 
4541:..\Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4798              		.loc 1 4541 0
 4799 0106 BB6A     		ldr	r3, [r7, #40]
 4800 0108 DA6A     		ldr	r2, [r3, #44]
 4801 010a 104B     		ldr	r3, .L334+16
 4802 010c 1B68     		ldr	r3, [r3]
 4803 010e DB6A     		ldr	r3, [r3, #44]
 4804 0110 9A42     		cmp	r2, r3
 4805 0112 09D9     		bls	.L327
4542:..\Source/tasks.c **** 				{
4543:..\Source/tasks.c **** 					/* The notified task has a priority above the currently
4544:..\Source/tasks.c **** 					executing task so a yield is required. */
4545:..\Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
 4806              		.loc 1 4545 0
 4807 0114 BB6B     		ldr	r3, [r7, #56]
 4808 0116 002B     		cmp	r3, #0
 4809 0118 03D0     		beq	.L330
4546:..\Source/tasks.c **** 					{
4547:..\Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4810              		.loc 1 4547 0
 4811 011a BB6B     		ldr	r3, [r7, #56]
 4812 011c 0122     		movs	r2, #1
 4813 011e 1A60     		str	r2, [r3]
 4814 0120 02E0     		b	.L327
 4815              	.L330:
4548:..\Source/tasks.c **** 					}
4549:..\Source/tasks.c **** 					else
4550:..\Source/tasks.c **** 					{
4551:..\Source/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4552:..\Source/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter to an ISR
4553:..\Source/tasks.c **** 						safe FreeRTOS function. */
4554:..\Source/tasks.c **** 						xYieldPending = pdTRUE;
 4816              		.loc 1 4554 0
 4817 0122 0B4B     		ldr	r3, .L334+20
 4818 0124 0122     		movs	r2, #1
 4819 0126 1A60     		str	r2, [r3]
 4820              	.L327:
 4821 0128 7B6A     		ldr	r3, [r7, #36]
 4822 012a 7B61     		str	r3, [r7, #20]
 4823              	.LBB54:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 171


 4824              	.LBB55:
 4825              		.loc 2 271 0
 4826 012c 7B69     		ldr	r3, [r7, #20]
 4827              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 4828 012e 83F31188 			msr basepri, r3	
 4829              	@ 0 "" 2
 4830              		.thumb
 4831              	.LBE55:
 4832              	.LBE54:
4555:..\Source/tasks.c **** 					}
4556:..\Source/tasks.c **** 				}
4557:..\Source/tasks.c **** 				else
4558:..\Source/tasks.c **** 				{
4559:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4560:..\Source/tasks.c **** 				}
4561:..\Source/tasks.c **** 			}
4562:..\Source/tasks.c **** 		}
4563:..\Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4564:..\Source/tasks.c **** 
4565:..\Source/tasks.c **** 		return xReturn;
 4833              		.loc 1 4565 0
 4834 0132 FB6A     		ldr	r3, [r7, #44]
4566:..\Source/tasks.c **** 	}
 4835              		.loc 1 4566 0
 4836 0134 1846     		mov	r0, r3
 4837 0136 3037     		adds	r7, r7, #48
 4838              		.cfi_def_cfa_offset 8
 4839 0138 BD46     		mov	sp, r7
 4840              		.cfi_def_cfa_register 13
 4841              		@ sp needed
 4842 013a 80BD     		pop	{r7, pc}
 4843              	.L335:
 4844              		.align	2
 4845              	.L334:
 4846 013c 00010000 		.word	uxSchedulerSuspended
 4847 0140 E0000000 		.word	uxTopReadyPriority
 4848 0144 04000000 		.word	pxReadyTasksLists
 4849 0148 98000000 		.word	xPendingReadyList
 4850 014c 00000000 		.word	pxCurrentTCB
 4851 0150 EC000000 		.word	xYieldPending
 4852              		.cfi_endproc
 4853              	.LFE114:
 4854              		.size	xTaskGenericNotifyFromISR, .-xTaskGenericNotifyFromISR
 4855              		.section	.text.vTaskNotifyGiveFromISR,"ax",%progbits
 4856              		.align	2
 4857              		.global	vTaskNotifyGiveFromISR
 4858              		.thumb
 4859              		.thumb_func
 4860              		.type	vTaskNotifyGiveFromISR, %function
 4861              	vTaskNotifyGiveFromISR:
 4862              	.LFB115:
4567:..\Source/tasks.c **** 
4568:..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4569:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4570:..\Source/tasks.c **** 
4571:..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4572:..\Source/tasks.c **** 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 172


4573:..\Source/tasks.c **** 	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
4574:..\Source/tasks.c **** 	{
 4863              		.loc 1 4574 0
 4864              		.cfi_startproc
 4865              		@ args = 0, pretend = 0, frame = 32
 4866              		@ frame_needed = 1, uses_anonymous_args = 0
 4867 0000 80B5     		push	{r7, lr}
 4868              		.cfi_def_cfa_offset 8
 4869              		.cfi_offset 7, -8
 4870              		.cfi_offset 14, -4
 4871 0002 88B0     		sub	sp, sp, #32
 4872              		.cfi_def_cfa_offset 40
 4873 0004 00AF     		add	r7, sp, #0
 4874              		.cfi_def_cfa_register 7
 4875 0006 7860     		str	r0, [r7, #4]
 4876 0008 3960     		str	r1, [r7]
4575:..\Source/tasks.c **** 	TCB_t * pxTCB;
4576:..\Source/tasks.c **** 	uint8_t ucOriginalNotifyState;
4577:..\Source/tasks.c **** 	UBaseType_t uxSavedInterruptStatus;
4578:..\Source/tasks.c **** 
4579:..\Source/tasks.c **** 		configASSERT( xTaskToNotify );
4580:..\Source/tasks.c **** 
4581:..\Source/tasks.c **** 		/* RTOS ports that support interrupt nesting have the concept of a
4582:..\Source/tasks.c **** 		maximum	system call (or maximum API call) interrupt priority.
4583:..\Source/tasks.c **** 		Interrupts that are	above the maximum system call priority are keep
4584:..\Source/tasks.c **** 		permanently enabled, even when the RTOS kernel is in a critical section,
4585:..\Source/tasks.c **** 		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
4586:..\Source/tasks.c **** 		is defined in FreeRTOSConfig.h then
4587:..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
4588:..\Source/tasks.c **** 		failure if a FreeRTOS API function is called from an interrupt that has
4589:..\Source/tasks.c **** 		been assigned a priority above the configured maximum system call
4590:..\Source/tasks.c **** 		priority.  Only FreeRTOS functions that end in FromISR can be called
4591:..\Source/tasks.c **** 		from interrupts	that have been assigned a priority at or (logically)
4592:..\Source/tasks.c **** 		below the maximum system call interrupt priority.  FreeRTOS maintains a
4593:..\Source/tasks.c **** 		separate interrupt safe API to ensure interrupt entry is as fast and as
4594:..\Source/tasks.c **** 		simple as possible.  More information (albeit Cortex-M specific) is
4595:..\Source/tasks.c **** 		provided on the following link:
4596:..\Source/tasks.c **** 		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
4597:..\Source/tasks.c **** 		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
4598:..\Source/tasks.c **** 
4599:..\Source/tasks.c **** 		pxTCB = ( TCB_t * ) xTaskToNotify;
 4877              		.loc 1 4599 0
 4878 000a 7B68     		ldr	r3, [r7, #4]
 4879 000c FB61     		str	r3, [r7, #28]
 4880              	.LBB56:
 4881              	.LBB57:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 4882              		.loc 2 253 0
 4883              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 4884 000e EFF31182 			mrs r2, basepri											
 4885 0012 4FF0A003 		mov r3, #160												
 4886 0016 83F31188 		msr basepri, r3											
 4887 001a BFF36F8F 		isb														
 4888 001e BFF34F8F 		dsb														
 4889              	
 4890              	@ 0 "" 2
 4891              		.thumb
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 173


 4892 0022 3A61     		str	r2, [r7, #16]
 4893 0024 FB60     		str	r3, [r7, #12]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 4894              		.loc 2 265 0
 4895 0026 3B69     		ldr	r3, [r7, #16]
 4896              	.LBE57:
 4897              	.LBE56:
4600:..\Source/tasks.c **** 
4601:..\Source/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4898              		.loc 1 4601 0
 4899 0028 BB61     		str	r3, [r7, #24]
4602:..\Source/tasks.c **** 		{
4603:..\Source/tasks.c **** 			ucOriginalNotifyState = pxTCB->ucNotifyState;
 4900              		.loc 1 4603 0
 4901 002a FB69     		ldr	r3, [r7, #28]
 4902 002c 93F84C30 		ldrb	r3, [r3, #76]
 4903 0030 FB75     		strb	r3, [r7, #23]
4604:..\Source/tasks.c **** 			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 4904              		.loc 1 4604 0
 4905 0032 FB69     		ldr	r3, [r7, #28]
 4906 0034 0222     		movs	r2, #2
 4907 0036 83F84C20 		strb	r2, [r3, #76]
4605:..\Source/tasks.c **** 
4606:..\Source/tasks.c **** 			/* 'Giving' is equivalent to incrementing a count in a counting
4607:..\Source/tasks.c **** 			semaphore. */
4608:..\Source/tasks.c **** 			( pxTCB->ulNotifiedValue )++;
 4908              		.loc 1 4608 0
 4909 003a FB69     		ldr	r3, [r7, #28]
 4910 003c 9B6C     		ldr	r3, [r3, #72]
 4911 003e 5A1C     		adds	r2, r3, #1
 4912 0040 FB69     		ldr	r3, [r7, #28]
 4913 0042 9A64     		str	r2, [r3, #72]
4609:..\Source/tasks.c **** 
4610:..\Source/tasks.c **** 			traceTASK_NOTIFY_GIVE_FROM_ISR();
4611:..\Source/tasks.c **** 
4612:..\Source/tasks.c **** 			/* If the task is in the blocked state specifically to wait for a
4613:..\Source/tasks.c **** 			notification then unblock it now. */
4614:..\Source/tasks.c **** 			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 4914              		.loc 1 4614 0
 4915 0044 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 4916 0046 012B     		cmp	r3, #1
 4917 0048 39D1     		bne	.L338
4615:..\Source/tasks.c **** 			{
4616:..\Source/tasks.c **** 				/* The task should not have been on an event list. */
4617:..\Source/tasks.c **** 				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
4618:..\Source/tasks.c **** 
4619:..\Source/tasks.c **** 				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 4918              		.loc 1 4619 0
 4919 004a 214B     		ldr	r3, .L343
 4920 004c 1B68     		ldr	r3, [r3]
 4921 004e 002B     		cmp	r3, #0
 4922 0050 1ED1     		bne	.L339
4620:..\Source/tasks.c **** 				{
4621:..\Source/tasks.c **** 					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 4923              		.loc 1 4621 0
 4924 0052 FB69     		ldr	r3, [r7, #28]
 4925 0054 0433     		adds	r3, r3, #4
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 174


 4926 0056 1846     		mov	r0, r3
 4927 0058 FFF7FEFF 		bl	uxListRemove
4622:..\Source/tasks.c **** 					prvAddTaskToReadyList( pxTCB );
 4928              		.loc 1 4622 0
 4929 005c FB69     		ldr	r3, [r7, #28]
 4930 005e DB6A     		ldr	r3, [r3, #44]
 4931 0060 1A46     		mov	r2, r3
 4932 0062 0123     		movs	r3, #1
 4933 0064 03FA02F2 		lsl	r2, r3, r2
 4934 0068 1A4B     		ldr	r3, .L343+4
 4935 006a 1B68     		ldr	r3, [r3]
 4936 006c 1343     		orrs	r3, r3, r2
 4937 006e 194A     		ldr	r2, .L343+4
 4938 0070 1360     		str	r3, [r2]
 4939 0072 FB69     		ldr	r3, [r7, #28]
 4940 0074 DA6A     		ldr	r2, [r3, #44]
 4941 0076 1346     		mov	r3, r2
 4942 0078 9B00     		lsls	r3, r3, #2
 4943 007a 1344     		add	r3, r3, r2
 4944 007c 9B00     		lsls	r3, r3, #2
 4945 007e 164A     		ldr	r2, .L343+8
 4946 0080 1A44     		add	r2, r2, r3
 4947 0082 FB69     		ldr	r3, [r7, #28]
 4948 0084 0433     		adds	r3, r3, #4
 4949 0086 1046     		mov	r0, r2
 4950 0088 1946     		mov	r1, r3
 4951 008a FFF7FEFF 		bl	vListInsertEnd
 4952 008e 05E0     		b	.L340
 4953              	.L339:
4623:..\Source/tasks.c **** 				}
4624:..\Source/tasks.c **** 				else
4625:..\Source/tasks.c **** 				{
4626:..\Source/tasks.c **** 					/* The delayed and ready lists cannot be accessed, so hold
4627:..\Source/tasks.c **** 					this task pending until the scheduler is resumed. */
4628:..\Source/tasks.c **** 					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4954              		.loc 1 4628 0
 4955 0090 FB69     		ldr	r3, [r7, #28]
 4956 0092 1833     		adds	r3, r3, #24
 4957 0094 1148     		ldr	r0, .L343+12
 4958 0096 1946     		mov	r1, r3
 4959 0098 FFF7FEFF 		bl	vListInsertEnd
 4960              	.L340:
4629:..\Source/tasks.c **** 				}
4630:..\Source/tasks.c **** 
4631:..\Source/tasks.c **** 				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 4961              		.loc 1 4631 0
 4962 009c FB69     		ldr	r3, [r7, #28]
 4963 009e DA6A     		ldr	r2, [r3, #44]
 4964 00a0 0F4B     		ldr	r3, .L343+16
 4965 00a2 1B68     		ldr	r3, [r3]
 4966 00a4 DB6A     		ldr	r3, [r3, #44]
 4967 00a6 9A42     		cmp	r2, r3
 4968 00a8 09D9     		bls	.L338
4632:..\Source/tasks.c **** 				{
4633:..\Source/tasks.c **** 					/* The notified task has a priority above the currently
4634:..\Source/tasks.c **** 					executing task so a yield is required. */
4635:..\Source/tasks.c **** 					if( pxHigherPriorityTaskWoken != NULL )
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 175


 4969              		.loc 1 4635 0
 4970 00aa 3B68     		ldr	r3, [r7]
 4971 00ac 002B     		cmp	r3, #0
 4972 00ae 03D0     		beq	.L341
4636:..\Source/tasks.c **** 					{
4637:..\Source/tasks.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4973              		.loc 1 4637 0
 4974 00b0 3B68     		ldr	r3, [r7]
 4975 00b2 0122     		movs	r2, #1
 4976 00b4 1A60     		str	r2, [r3]
 4977 00b6 02E0     		b	.L338
 4978              	.L341:
4638:..\Source/tasks.c **** 					}
4639:..\Source/tasks.c **** 					else
4640:..\Source/tasks.c **** 					{
4641:..\Source/tasks.c **** 						/* Mark that a yield is pending in case the user is not
4642:..\Source/tasks.c **** 						using the "xHigherPriorityTaskWoken" parameter in an ISR
4643:..\Source/tasks.c **** 						safe FreeRTOS function. */
4644:..\Source/tasks.c **** 						xYieldPending = pdTRUE;
 4979              		.loc 1 4644 0
 4980 00b8 0A4B     		ldr	r3, .L343+20
 4981 00ba 0122     		movs	r2, #1
 4982 00bc 1A60     		str	r2, [r3]
 4983              	.L338:
 4984 00be BB69     		ldr	r3, [r7, #24]
 4985 00c0 BB60     		str	r3, [r7, #8]
 4986              	.LBB58:
 4987              	.LBB59:
 4988              		.loc 2 271 0
 4989 00c2 BB68     		ldr	r3, [r7, #8]
 4990              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 4991 00c4 83F31188 			msr basepri, r3	
 4992              	@ 0 "" 2
 4993              		.thumb
 4994              	.LBE59:
 4995              	.LBE58:
4645:..\Source/tasks.c **** 					}
4646:..\Source/tasks.c **** 				}
4647:..\Source/tasks.c **** 				else
4648:..\Source/tasks.c **** 				{
4649:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4650:..\Source/tasks.c **** 				}
4651:..\Source/tasks.c **** 			}
4652:..\Source/tasks.c **** 		}
4653:..\Source/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
4654:..\Source/tasks.c **** 	}
 4996              		.loc 1 4654 0
 4997 00c8 2037     		adds	r7, r7, #32
 4998              		.cfi_def_cfa_offset 8
 4999 00ca BD46     		mov	sp, r7
 5000              		.cfi_def_cfa_register 13
 5001              		@ sp needed
 5002 00cc 80BD     		pop	{r7, pc}
 5003              	.L344:
 5004 00ce 00BF     		.align	2
 5005              	.L343:
 5006 00d0 00010000 		.word	uxSchedulerSuspended
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 176


 5007 00d4 E0000000 		.word	uxTopReadyPriority
 5008 00d8 04000000 		.word	pxReadyTasksLists
 5009 00dc 98000000 		.word	xPendingReadyList
 5010 00e0 00000000 		.word	pxCurrentTCB
 5011 00e4 EC000000 		.word	xYieldPending
 5012              		.cfi_endproc
 5013              	.LFE115:
 5014              		.size	vTaskNotifyGiveFromISR, .-vTaskNotifyGiveFromISR
 5015              		.section	.text.xTaskNotifyStateClear,"ax",%progbits
 5016              		.align	2
 5017              		.global	xTaskNotifyStateClear
 5018              		.thumb
 5019              		.thumb_func
 5020              		.type	xTaskNotifyStateClear, %function
 5021              	xTaskNotifyStateClear:
 5022              	.LFB116:
4655:..\Source/tasks.c **** 
4656:..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4657:..\Source/tasks.c **** 
4658:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4659:..\Source/tasks.c **** 
4660:..\Source/tasks.c **** #if( configUSE_TASK_NOTIFICATIONS == 1 )
4661:..\Source/tasks.c **** 
4662:..\Source/tasks.c **** 	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
4663:..\Source/tasks.c **** 	{
 5023              		.loc 1 4663 0
 5024              		.cfi_startproc
 5025              		@ args = 0, pretend = 0, frame = 16
 5026              		@ frame_needed = 1, uses_anonymous_args = 0
 5027 0000 80B5     		push	{r7, lr}
 5028              		.cfi_def_cfa_offset 8
 5029              		.cfi_offset 7, -8
 5030              		.cfi_offset 14, -4
 5031 0002 84B0     		sub	sp, sp, #16
 5032              		.cfi_def_cfa_offset 24
 5033 0004 00AF     		add	r7, sp, #0
 5034              		.cfi_def_cfa_register 7
 5035 0006 7860     		str	r0, [r7, #4]
4664:..\Source/tasks.c **** 	TCB_t *pxTCB;
4665:..\Source/tasks.c **** 	BaseType_t xReturn;
4666:..\Source/tasks.c **** 
4667:..\Source/tasks.c **** 		/* If null is passed in here then it is the calling task that is having
4668:..\Source/tasks.c **** 		its notification state cleared. */
4669:..\Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 5036              		.loc 1 4669 0
 5037 0008 7B68     		ldr	r3, [r7, #4]
 5038 000a 002B     		cmp	r3, #0
 5039 000c 02D1     		bne	.L346
 5040              		.loc 1 4669 0 is_stmt 0 discriminator 1
 5041 000e 0E4B     		ldr	r3, .L351
 5042 0010 1B68     		ldr	r3, [r3]
 5043 0012 00E0     		b	.L347
 5044              	.L346:
 5045              		.loc 1 4669 0 discriminator 2
 5046 0014 7B68     		ldr	r3, [r7, #4]
 5047              	.L347:
 5048              		.loc 1 4669 0 discriminator 4
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 177


 5049 0016 BB60     		str	r3, [r7, #8]
4670:..\Source/tasks.c **** 
4671:..\Source/tasks.c **** 		taskENTER_CRITICAL();
 5050              		.loc 1 4671 0 is_stmt 1 discriminator 4
 5051 0018 FFF7FEFF 		bl	vPortEnterCritical
4672:..\Source/tasks.c **** 		{
4673:..\Source/tasks.c **** 			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 5052              		.loc 1 4673 0 discriminator 4
 5053 001c BB68     		ldr	r3, [r7, #8]
 5054 001e 93F84C30 		ldrb	r3, [r3, #76]
 5055 0022 DBB2     		uxtb	r3, r3
 5056 0024 022B     		cmp	r3, #2
 5057 0026 06D1     		bne	.L348
4674:..\Source/tasks.c **** 			{
4675:..\Source/tasks.c **** 				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 5058              		.loc 1 4675 0
 5059 0028 BB68     		ldr	r3, [r7, #8]
 5060 002a 0022     		movs	r2, #0
 5061 002c 83F84C20 		strb	r2, [r3, #76]
4676:..\Source/tasks.c **** 				xReturn = pdPASS;
 5062              		.loc 1 4676 0
 5063 0030 0123     		movs	r3, #1
 5064 0032 FB60     		str	r3, [r7, #12]
 5065 0034 01E0     		b	.L349
 5066              	.L348:
4677:..\Source/tasks.c **** 			}
4678:..\Source/tasks.c **** 			else
4679:..\Source/tasks.c **** 			{
4680:..\Source/tasks.c **** 				xReturn = pdFAIL;
 5067              		.loc 1 4680 0
 5068 0036 0023     		movs	r3, #0
 5069 0038 FB60     		str	r3, [r7, #12]
 5070              	.L349:
4681:..\Source/tasks.c **** 			}
4682:..\Source/tasks.c **** 		}
4683:..\Source/tasks.c **** 		taskEXIT_CRITICAL();
 5071              		.loc 1 4683 0
 5072 003a FFF7FEFF 		bl	vPortExitCritical
4684:..\Source/tasks.c **** 
4685:..\Source/tasks.c **** 		return xReturn;
 5073              		.loc 1 4685 0
 5074 003e FB68     		ldr	r3, [r7, #12]
4686:..\Source/tasks.c **** 	}
 5075              		.loc 1 4686 0
 5076 0040 1846     		mov	r0, r3
 5077 0042 1037     		adds	r7, r7, #16
 5078              		.cfi_def_cfa_offset 8
 5079 0044 BD46     		mov	sp, r7
 5080              		.cfi_def_cfa_register 13
 5081              		@ sp needed
 5082 0046 80BD     		pop	{r7, pc}
 5083              	.L352:
 5084              		.align	2
 5085              	.L351:
 5086 0048 00000000 		.word	pxCurrentTCB
 5087              		.cfi_endproc
 5088              	.LFE116:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 178


 5089              		.size	xTaskNotifyStateClear, .-xTaskNotifyStateClear
 5090              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 5091              		.align	2
 5092              		.thumb
 5093              		.thumb_func
 5094              		.type	prvAddCurrentTaskToDelayedList, %function
 5095              	prvAddCurrentTaskToDelayedList:
 5096              	.LFB117:
4687:..\Source/tasks.c **** 
4688:..\Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4689:..\Source/tasks.c **** /*-----------------------------------------------------------*/
4690:..\Source/tasks.c **** 
4691:..\Source/tasks.c **** 
4692:..\Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockInde
4693:..\Source/tasks.c **** {
 5097              		.loc 1 4693 0
 5098              		.cfi_startproc
 5099              		@ args = 0, pretend = 0, frame = 16
 5100              		@ frame_needed = 1, uses_anonymous_args = 0
 5101 0000 80B5     		push	{r7, lr}
 5102              		.cfi_def_cfa_offset 8
 5103              		.cfi_offset 7, -8
 5104              		.cfi_offset 14, -4
 5105 0002 84B0     		sub	sp, sp, #16
 5106              		.cfi_def_cfa_offset 24
 5107 0004 00AF     		add	r7, sp, #0
 5108              		.cfi_def_cfa_register 7
 5109 0006 7860     		str	r0, [r7, #4]
 5110 0008 3960     		str	r1, [r7]
4694:..\Source/tasks.c **** TickType_t xTimeToWake;
4695:..\Source/tasks.c **** const TickType_t xConstTickCount = xTickCount;
 5111              		.loc 1 4695 0
 5112 000a 284B     		ldr	r3, .L358
 5113 000c 1B68     		ldr	r3, [r3]
 5114 000e FB60     		str	r3, [r7, #12]
4696:..\Source/tasks.c **** 
4697:..\Source/tasks.c **** 	#if( INCLUDE_xTaskAbortDelay == 1 )
4698:..\Source/tasks.c **** 	{
4699:..\Source/tasks.c **** 		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
4700:..\Source/tasks.c **** 		reset to pdFALSE so it can be detected as having been set to pdTRUE
4701:..\Source/tasks.c **** 		when the task leaves the Blocked state. */
4702:..\Source/tasks.c **** 		pxCurrentTCB->ucDelayAborted = pdFALSE;
4703:..\Source/tasks.c **** 	}
4704:..\Source/tasks.c **** 	#endif
4705:..\Source/tasks.c **** 
4706:..\Source/tasks.c **** 	/* Remove the task from the ready list before adding it to the blocked list
4707:..\Source/tasks.c **** 	as the same list item is used for both lists. */
4708:..\Source/tasks.c **** 	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5115              		.loc 1 4708 0
 5116 0010 274B     		ldr	r3, .L358+4
 5117 0012 1B68     		ldr	r3, [r3]
 5118 0014 0433     		adds	r3, r3, #4
 5119 0016 1846     		mov	r0, r3
 5120 0018 FFF7FEFF 		bl	uxListRemove
 5121 001c 0346     		mov	r3, r0
 5122 001e 002B     		cmp	r3, #0
 5123 0020 0BD1     		bne	.L354
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 179


4709:..\Source/tasks.c **** 	{
4710:..\Source/tasks.c **** 		/* The current task must be in a ready list, so there is no need to
4711:..\Source/tasks.c **** 		check, and the port reset macro can be called directly. */
4712:..\Source/tasks.c **** 		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 5124              		.loc 1 4712 0
 5125 0022 234B     		ldr	r3, .L358+4
 5126 0024 1B68     		ldr	r3, [r3]
 5127 0026 DB6A     		ldr	r3, [r3, #44]
 5128 0028 1A46     		mov	r2, r3
 5129 002a 0123     		movs	r3, #1
 5130 002c 9340     		lsls	r3, r3, r2
 5131 002e DA43     		mvns	r2, r3
 5132 0030 204B     		ldr	r3, .L358+8
 5133 0032 1B68     		ldr	r3, [r3]
 5134 0034 1340     		ands	r3, r3, r2
 5135 0036 1F4A     		ldr	r2, .L358+8
 5136 0038 1360     		str	r3, [r2]
 5137              	.L354:
4713:..\Source/tasks.c **** 	}
4714:..\Source/tasks.c **** 	else
4715:..\Source/tasks.c **** 	{
4716:..\Source/tasks.c **** 		mtCOVERAGE_TEST_MARKER();
4717:..\Source/tasks.c **** 	}
4718:..\Source/tasks.c **** 
4719:..\Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
4720:..\Source/tasks.c **** 	{
4721:..\Source/tasks.c **** 		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 5138              		.loc 1 4721 0
 5139 003a 7B68     		ldr	r3, [r7, #4]
 5140 003c B3F1FF3F 		cmp	r3, #-1
 5141 0040 0AD1     		bne	.L355
 5142              		.loc 1 4721 0 is_stmt 0 discriminator 1
 5143 0042 3B68     		ldr	r3, [r7]
 5144 0044 002B     		cmp	r3, #0
 5145 0046 07D0     		beq	.L355
4722:..\Source/tasks.c **** 		{
4723:..\Source/tasks.c **** 			/* Add the task to the suspended task list instead of a delayed task
4724:..\Source/tasks.c **** 			list to ensure it is not woken by a timing event.  It will block
4725:..\Source/tasks.c **** 			indefinitely. */
4726:..\Source/tasks.c **** 			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5146              		.loc 1 4726 0 is_stmt 1
 5147 0048 194B     		ldr	r3, .L358+4
 5148 004a 1B68     		ldr	r3, [r3]
 5149 004c 0433     		adds	r3, r3, #4
 5150 004e 1A48     		ldr	r0, .L358+12
 5151 0050 1946     		mov	r1, r3
 5152 0052 FFF7FEFF 		bl	vListInsertEnd
 5153 0056 26E0     		b	.L353
 5154              	.L355:
4727:..\Source/tasks.c **** 		}
4728:..\Source/tasks.c **** 		else
4729:..\Source/tasks.c **** 		{
4730:..\Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event
4731:..\Source/tasks.c **** 			does not occur.  This may overflow but this doesn't matter, the
4732:..\Source/tasks.c **** 			kernel will manage it correctly. */
4733:..\Source/tasks.c **** 			xTimeToWake = xConstTickCount + xTicksToWait;
 5155              		.loc 1 4733 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 180


 5156 0058 FA68     		ldr	r2, [r7, #12]
 5157 005a 7B68     		ldr	r3, [r7, #4]
 5158 005c 1344     		add	r3, r3, r2
 5159 005e BB60     		str	r3, [r7, #8]
4734:..\Source/tasks.c **** 
4735:..\Source/tasks.c **** 			/* The list item will be inserted in wake time order. */
4736:..\Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 5160              		.loc 1 4736 0
 5161 0060 134B     		ldr	r3, .L358+4
 5162 0062 1B68     		ldr	r3, [r3]
 5163 0064 BA68     		ldr	r2, [r7, #8]
 5164 0066 5A60     		str	r2, [r3, #4]
4737:..\Source/tasks.c **** 
4738:..\Source/tasks.c **** 			if( xTimeToWake < xConstTickCount )
 5165              		.loc 1 4738 0
 5166 0068 BA68     		ldr	r2, [r7, #8]
 5167 006a FB68     		ldr	r3, [r7, #12]
 5168 006c 9A42     		cmp	r2, r3
 5169 006e 09D2     		bcs	.L357
4739:..\Source/tasks.c **** 			{
4740:..\Source/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow
4741:..\Source/tasks.c **** 				list. */
4742:..\Source/tasks.c **** 				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5170              		.loc 1 4742 0
 5171 0070 124B     		ldr	r3, .L358+16
 5172 0072 1A68     		ldr	r2, [r3]
 5173 0074 0E4B     		ldr	r3, .L358+4
 5174 0076 1B68     		ldr	r3, [r3]
 5175 0078 0433     		adds	r3, r3, #4
 5176 007a 1046     		mov	r0, r2
 5177 007c 1946     		mov	r1, r3
 5178 007e FFF7FEFF 		bl	vListInsert
 5179 0082 10E0     		b	.L353
 5180              	.L357:
4743:..\Source/tasks.c **** 			}
4744:..\Source/tasks.c **** 			else
4745:..\Source/tasks.c **** 			{
4746:..\Source/tasks.c **** 				/* The wake time has not overflowed, so the current block list
4747:..\Source/tasks.c **** 				is used. */
4748:..\Source/tasks.c **** 				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 5181              		.loc 1 4748 0
 5182 0084 0E4B     		ldr	r3, .L358+20
 5183 0086 1A68     		ldr	r2, [r3]
 5184 0088 094B     		ldr	r3, .L358+4
 5185 008a 1B68     		ldr	r3, [r3]
 5186 008c 0433     		adds	r3, r3, #4
 5187 008e 1046     		mov	r0, r2
 5188 0090 1946     		mov	r1, r3
 5189 0092 FFF7FEFF 		bl	vListInsert
4749:..\Source/tasks.c **** 
4750:..\Source/tasks.c **** 				/* If the task entering the blocked state was placed at the
4751:..\Source/tasks.c **** 				head of the list of blocked tasks then xNextTaskUnblockTime
4752:..\Source/tasks.c **** 				needs to be updated too. */
4753:..\Source/tasks.c **** 				if( xTimeToWake < xNextTaskUnblockTime )
 5190              		.loc 1 4753 0
 5191 0096 0B4B     		ldr	r3, .L358+24
 5192 0098 1B68     		ldr	r3, [r3]
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 181


 5193 009a BA68     		ldr	r2, [r7, #8]
 5194 009c 9A42     		cmp	r2, r3
 5195 009e 02D2     		bcs	.L353
4754:..\Source/tasks.c **** 				{
4755:..\Source/tasks.c **** 					xNextTaskUnblockTime = xTimeToWake;
 5196              		.loc 1 4755 0
 5197 00a0 084A     		ldr	r2, .L358+24
 5198 00a2 BB68     		ldr	r3, [r7, #8]
 5199 00a4 1360     		str	r3, [r2]
 5200              	.L353:
4756:..\Source/tasks.c **** 				}
4757:..\Source/tasks.c **** 				else
4758:..\Source/tasks.c **** 				{
4759:..\Source/tasks.c **** 					mtCOVERAGE_TEST_MARKER();
4760:..\Source/tasks.c **** 				}
4761:..\Source/tasks.c **** 			}
4762:..\Source/tasks.c **** 		}
4763:..\Source/tasks.c **** 	}
4764:..\Source/tasks.c **** 	#else /* INCLUDE_vTaskSuspend */
4765:..\Source/tasks.c **** 	{
4766:..\Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event
4767:..\Source/tasks.c **** 		does not occur.  This may overflow but this doesn't matter, the kernel
4768:..\Source/tasks.c **** 		will manage it correctly. */
4769:..\Source/tasks.c **** 		xTimeToWake = xConstTickCount + xTicksToWait;
4770:..\Source/tasks.c **** 
4771:..\Source/tasks.c **** 		/* The list item will be inserted in wake time order. */
4772:..\Source/tasks.c **** 		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
4773:..\Source/tasks.c **** 
4774:..\Source/tasks.c **** 		if( xTimeToWake < xConstTickCount )
4775:..\Source/tasks.c **** 		{
4776:..\Source/tasks.c **** 			/* Wake time has overflowed.  Place this item in the overflow list. */
4777:..\Source/tasks.c **** 			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4778:..\Source/tasks.c **** 		}
4779:..\Source/tasks.c **** 		else
4780:..\Source/tasks.c **** 		{
4781:..\Source/tasks.c **** 			/* The wake time has not overflowed, so the current block list is used. */
4782:..\Source/tasks.c **** 			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
4783:..\Source/tasks.c **** 
4784:..\Source/tasks.c **** 			/* If the task entering the blocked state was placed at the head of the
4785:..\Source/tasks.c **** 			list of blocked tasks then xNextTaskUnblockTime needs to be updated
4786:..\Source/tasks.c **** 			too. */
4787:..\Source/tasks.c **** 			if( xTimeToWake < xNextTaskUnblockTime )
4788:..\Source/tasks.c **** 			{
4789:..\Source/tasks.c **** 				xNextTaskUnblockTime = xTimeToWake;
4790:..\Source/tasks.c **** 			}
4791:..\Source/tasks.c **** 			else
4792:..\Source/tasks.c **** 			{
4793:..\Source/tasks.c **** 				mtCOVERAGE_TEST_MARKER();
4794:..\Source/tasks.c **** 			}
4795:..\Source/tasks.c **** 		}
4796:..\Source/tasks.c **** 
4797:..\Source/tasks.c **** 		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
4798:..\Source/tasks.c **** 		( void ) xCanBlockIndefinitely;
4799:..\Source/tasks.c **** 	}
4800:..\Source/tasks.c **** 	#endif /* INCLUDE_vTaskSuspend */
4801:..\Source/tasks.c **** }
 5201              		.loc 1 4801 0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 182


 5202 00a6 1037     		adds	r7, r7, #16
 5203              		.cfi_def_cfa_offset 8
 5204 00a8 BD46     		mov	sp, r7
 5205              		.cfi_def_cfa_register 13
 5206              		@ sp needed
 5207 00aa 80BD     		pop	{r7, pc}
 5208              	.L359:
 5209              		.align	2
 5210              	.L358:
 5211 00ac DC000000 		.word	xTickCount
 5212 00b0 00000000 		.word	pxCurrentTCB
 5213 00b4 E0000000 		.word	uxTopReadyPriority
 5214 00b8 C4000000 		.word	xSuspendedTaskList
 5215 00bc 94000000 		.word	pxOverflowDelayedTaskList
 5216 00c0 90000000 		.word	pxDelayedTaskList
 5217 00c4 F8000000 		.word	xNextTaskUnblockTime
 5218              		.cfi_endproc
 5219              	.LFE117:
 5220              		.size	prvAddCurrentTaskToDelayedList, .-prvAddCurrentTaskToDelayedList
 5221              		.text
 5222              	.Letext0:
 5223              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 5224              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 5225              		.file 5 "c:\\program files (x86)\\cypress\\psoc creator\\4.0\\psoc creator\\import\\gnu\\arm\\4.9.
 5226              		.file 6 "..\\Source\\include/projdefs.h"
 5227              		.file 7 "..\\Source\\include/list.h"
 5228              		.file 8 "..\\Source\\include/task.h"
 5229              		.file 9 "Generated_Source\\PSoC5/core_cm3.h"
 5230              		.section	.debug_info,"",%progbits
 5231              	.Ldebug_info0:
 5232 0000 37160000 		.4byte	0x1637
 5233 0004 0400     		.2byte	0x4
 5234 0006 00000000 		.4byte	.Ldebug_abbrev0
 5235 000a 04       		.byte	0x4
 5236 000b 01       		.uleb128 0x1
 5237 000c 6A070000 		.4byte	.LASF220
 5238 0010 01       		.byte	0x1
 5239 0011 D00A0000 		.4byte	.LASF221
 5240 0015 F7010000 		.4byte	.LASF222
 5241 0019 00000000 		.4byte	.Ldebug_ranges0+0
 5242 001d 00000000 		.4byte	0
 5243 0021 00000000 		.4byte	.Ldebug_line0
 5244 0025 02       		.uleb128 0x2
 5245 0026 25040000 		.4byte	.LASF2
 5246 002a 03       		.byte	0x3
 5247 002b D4       		.byte	0xd4
 5248 002c 30000000 		.4byte	0x30
 5249 0030 03       		.uleb128 0x3
 5250 0031 04       		.byte	0x4
 5251 0032 07       		.byte	0x7
 5252 0033 C1000000 		.4byte	.LASF0
 5253 0037 04       		.uleb128 0x4
 5254 0038 04       		.byte	0x4
 5255 0039 05       		.byte	0x5
 5256 003a 696E7400 		.ascii	"int\000"
 5257 003e 03       		.uleb128 0x3
 5258 003f 01       		.byte	0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 183


 5259 0040 06       		.byte	0x6
 5260 0041 130D0000 		.4byte	.LASF1
 5261 0045 02       		.uleb128 0x2
 5262 0046 370A0000 		.4byte	.LASF3
 5263 004a 04       		.byte	0x4
 5264 004b 1D       		.byte	0x1d
 5265 004c 50000000 		.4byte	0x50
 5266 0050 03       		.uleb128 0x3
 5267 0051 01       		.byte	0x1
 5268 0052 08       		.byte	0x8
 5269 0053 650B0000 		.4byte	.LASF4
 5270 0057 03       		.uleb128 0x3
 5271 0058 02       		.byte	0x2
 5272 0059 05       		.byte	0x5
 5273 005a 3D090000 		.4byte	.LASF5
 5274 005e 02       		.uleb128 0x2
 5275 005f CD030000 		.4byte	.LASF6
 5276 0063 04       		.byte	0x4
 5277 0064 2B       		.byte	0x2b
 5278 0065 69000000 		.4byte	0x69
 5279 0069 03       		.uleb128 0x3
 5280 006a 02       		.byte	0x2
 5281 006b 07       		.byte	0x7
 5282 006c 1F0D0000 		.4byte	.LASF7
 5283 0070 02       		.uleb128 0x2
 5284 0071 3C010000 		.4byte	.LASF8
 5285 0075 04       		.byte	0x4
 5286 0076 3F       		.byte	0x3f
 5287 0077 7B000000 		.4byte	0x7b
 5288 007b 03       		.uleb128 0x3
 5289 007c 04       		.byte	0x4
 5290 007d 05       		.byte	0x5
 5291 007e 5F090000 		.4byte	.LASF9
 5292 0082 02       		.uleb128 0x2
 5293 0083 B40B0000 		.4byte	.LASF10
 5294 0087 04       		.byte	0x4
 5295 0088 41       		.byte	0x41
 5296 0089 8D000000 		.4byte	0x8d
 5297 008d 03       		.uleb128 0x3
 5298 008e 04       		.byte	0x4
 5299 008f 07       		.byte	0x7
 5300 0090 AC0A0000 		.4byte	.LASF11
 5301 0094 03       		.uleb128 0x3
 5302 0095 08       		.byte	0x8
 5303 0096 05       		.byte	0x5
 5304 0097 C3060000 		.4byte	.LASF12
 5305 009b 03       		.uleb128 0x3
 5306 009c 08       		.byte	0x8
 5307 009d 07       		.byte	0x7
 5308 009e 3C030000 		.4byte	.LASF13
 5309 00a2 03       		.uleb128 0x3
 5310 00a3 04       		.byte	0x4
 5311 00a4 07       		.byte	0x7
 5312 00a5 840A0000 		.4byte	.LASF14
 5313 00a9 05       		.uleb128 0x5
 5314 00aa 04       		.byte	0x4
 5315 00ab 06       		.uleb128 0x6
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 184


 5316 00ac 04       		.byte	0x4
 5317 00ad B1000000 		.4byte	0xb1
 5318 00b1 03       		.uleb128 0x3
 5319 00b2 01       		.byte	0x1
 5320 00b3 08       		.byte	0x8
 5321 00b4 7C050000 		.4byte	.LASF15
 5322 00b8 06       		.uleb128 0x6
 5323 00b9 04       		.byte	0x4
 5324 00ba BE000000 		.4byte	0xbe
 5325 00be 07       		.uleb128 0x7
 5326 00bf B1000000 		.4byte	0xb1
 5327 00c3 02       		.uleb128 0x2
 5328 00c4 50060000 		.4byte	.LASF16
 5329 00c8 05       		.byte	0x5
 5330 00c9 15       		.byte	0x15
 5331 00ca 45000000 		.4byte	0x45
 5332 00ce 02       		.uleb128 0x2
 5333 00cf E9080000 		.4byte	.LASF17
 5334 00d3 05       		.byte	0x5
 5335 00d4 21       		.byte	0x21
 5336 00d5 5E000000 		.4byte	0x5e
 5337 00d9 02       		.uleb128 0x2
 5338 00da FE0A0000 		.4byte	.LASF18
 5339 00de 05       		.byte	0x5
 5340 00df 2C       		.byte	0x2c
 5341 00e0 70000000 		.4byte	0x70
 5342 00e4 02       		.uleb128 0x2
 5343 00e5 A6020000 		.4byte	.LASF19
 5344 00e9 05       		.byte	0x5
 5345 00ea 2D       		.byte	0x2d
 5346 00eb 82000000 		.4byte	0x82
 5347 00ef 03       		.uleb128 0x3
 5348 00f0 04       		.byte	0x4
 5349 00f1 04       		.byte	0x4
 5350 00f2 F1020000 		.4byte	.LASF20
 5351 00f6 03       		.uleb128 0x3
 5352 00f7 08       		.byte	0x8
 5353 00f8 04       		.byte	0x4
 5354 00f9 530D0000 		.4byte	.LASF21
 5355 00fd 08       		.uleb128 0x8
 5356 00fe E4000000 		.4byte	0xe4
 5357 0102 08       		.uleb128 0x8
 5358 0103 C3000000 		.4byte	0xc3
 5359 0107 02       		.uleb128 0x2
 5360 0108 54070000 		.4byte	.LASF22
 5361 010c 06       		.byte	0x6
 5362 010d 4D       		.byte	0x4d
 5363 010e 12010000 		.4byte	0x112
 5364 0112 06       		.uleb128 0x6
 5365 0113 04       		.byte	0x4
 5366 0114 18010000 		.4byte	0x118
 5367 0118 09       		.uleb128 0x9
 5368 0119 23010000 		.4byte	0x123
 5369 011d 0A       		.uleb128 0xa
 5370 011e A9000000 		.4byte	0xa9
 5371 0122 00       		.byte	0
 5372 0123 02       		.uleb128 0x2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 185


 5373 0124 09010000 		.4byte	.LASF23
 5374 0128 02       		.byte	0x2
 5375 0129 61       		.byte	0x61
 5376 012a E4000000 		.4byte	0xe4
 5377 012e 02       		.uleb128 0x2
 5378 012f 02070000 		.4byte	.LASF24
 5379 0133 02       		.byte	0x2
 5380 0134 62       		.byte	0x62
 5381 0135 7B000000 		.4byte	0x7b
 5382 0139 02       		.uleb128 0x2
 5383 013a B3050000 		.4byte	.LASF25
 5384 013e 02       		.byte	0x2
 5385 013f 63       		.byte	0x63
 5386 0140 8D000000 		.4byte	0x8d
 5387 0144 02       		.uleb128 0x2
 5388 0145 B2080000 		.4byte	.LASF26
 5389 0149 02       		.byte	0x2
 5390 014a 69       		.byte	0x69
 5391 014b E4000000 		.4byte	0xe4
 5392 014f 06       		.uleb128 0x6
 5393 0150 04       		.byte	0x4
 5394 0151 C3000000 		.4byte	0xc3
 5395 0155 0B       		.uleb128 0xb
 5396 0156 46010000 		.4byte	.LASF33
 5397 015a 14       		.byte	0x14
 5398 015b 07       		.byte	0x7
 5399 015c B5       		.byte	0xb5
 5400 015d 9E010000 		.4byte	0x19e
 5401 0161 0C       		.uleb128 0xc
 5402 0162 54090000 		.4byte	.LASF27
 5403 0166 07       		.byte	0x7
 5404 0167 B8       		.byte	0xb8
 5405 0168 44010000 		.4byte	0x144
 5406 016c 00       		.byte	0
 5407 016d 0C       		.uleb128 0xc
 5408 016e 63070000 		.4byte	.LASF28
 5409 0172 07       		.byte	0x7
 5410 0173 B9       		.byte	0xb9
 5411 0174 9E010000 		.4byte	0x19e
 5412 0178 04       		.byte	0x4
 5413 0179 0C       		.uleb128 0xc
 5414 017a A9030000 		.4byte	.LASF29
 5415 017e 07       		.byte	0x7
 5416 017f BA       		.byte	0xba
 5417 0180 9E010000 		.4byte	0x19e
 5418 0184 08       		.byte	0x8
 5419 0185 0C       		.uleb128 0xc
 5420 0186 480C0000 		.4byte	.LASF30
 5421 018a 07       		.byte	0x7
 5422 018b BB       		.byte	0xbb
 5423 018c A9000000 		.4byte	0xa9
 5424 0190 0C       		.byte	0xc
 5425 0191 0C       		.uleb128 0xc
 5426 0192 21090000 		.4byte	.LASF31
 5427 0196 07       		.byte	0x7
 5428 0197 BC       		.byte	0xbc
 5429 0198 A9000000 		.4byte	0xa9
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 186


 5430 019c 10       		.byte	0x10
 5431 019d 00       		.byte	0
 5432 019e 06       		.uleb128 0x6
 5433 019f 04       		.byte	0x4
 5434 01a0 55010000 		.4byte	0x155
 5435 01a4 02       		.uleb128 0x2
 5436 01a5 81050000 		.4byte	.LASF32
 5437 01a9 07       		.byte	0x7
 5438 01aa BF       		.byte	0xbf
 5439 01ab 55010000 		.4byte	0x155
 5440 01af 0B       		.uleb128 0xb
 5441 01b0 37040000 		.4byte	.LASF34
 5442 01b4 0C       		.byte	0xc
 5443 01b5 07       		.byte	0x7
 5444 01b6 C1       		.byte	0xc1
 5445 01b7 E0010000 		.4byte	0x1e0
 5446 01bb 0C       		.uleb128 0xc
 5447 01bc 54090000 		.4byte	.LASF27
 5448 01c0 07       		.byte	0x7
 5449 01c1 C4       		.byte	0xc4
 5450 01c2 44010000 		.4byte	0x144
 5451 01c6 00       		.byte	0
 5452 01c7 0C       		.uleb128 0xc
 5453 01c8 63070000 		.4byte	.LASF28
 5454 01cc 07       		.byte	0x7
 5455 01cd C5       		.byte	0xc5
 5456 01ce 9E010000 		.4byte	0x19e
 5457 01d2 04       		.byte	0x4
 5458 01d3 0C       		.uleb128 0xc
 5459 01d4 A9030000 		.4byte	.LASF29
 5460 01d8 07       		.byte	0x7
 5461 01d9 C6       		.byte	0xc6
 5462 01da 9E010000 		.4byte	0x19e
 5463 01de 08       		.byte	0x8
 5464 01df 00       		.byte	0
 5465 01e0 02       		.uleb128 0x2
 5466 01e1 0C060000 		.4byte	.LASF35
 5467 01e5 07       		.byte	0x7
 5468 01e6 C8       		.byte	0xc8
 5469 01e7 AF010000 		.4byte	0x1af
 5470 01eb 0B       		.uleb128 0xb
 5471 01ec 54040000 		.4byte	.LASF36
 5472 01f0 14       		.byte	0x14
 5473 01f1 07       		.byte	0x7
 5474 01f2 CD       		.byte	0xcd
 5475 01f3 1C020000 		.4byte	0x21c
 5476 01f7 0C       		.uleb128 0xc
 5477 01f8 0B000000 		.4byte	.LASF37
 5478 01fc 07       		.byte	0x7
 5479 01fd D0       		.byte	0xd0
 5480 01fe 39010000 		.4byte	0x139
 5481 0202 00       		.byte	0
 5482 0203 0C       		.uleb128 0xc
 5483 0204 EC000000 		.4byte	.LASF38
 5484 0208 07       		.byte	0x7
 5485 0209 D1       		.byte	0xd1
 5486 020a 1C020000 		.4byte	0x21c
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 187


 5487 020e 04       		.byte	0x4
 5488 020f 0C       		.uleb128 0xc
 5489 0210 E5050000 		.4byte	.LASF39
 5490 0214 07       		.byte	0x7
 5491 0215 D2       		.byte	0xd2
 5492 0216 E0010000 		.4byte	0x1e0
 5493 021a 08       		.byte	0x8
 5494 021b 00       		.byte	0
 5495 021c 06       		.uleb128 0x6
 5496 021d 04       		.byte	0x4
 5497 021e A4010000 		.4byte	0x1a4
 5498 0222 02       		.uleb128 0x2
 5499 0223 9E080000 		.4byte	.LASF40
 5500 0227 07       		.byte	0x7
 5501 0228 D4       		.byte	0xd4
 5502 0229 EB010000 		.4byte	0x1eb
 5503 022d 02       		.uleb128 0x2
 5504 022e 44080000 		.4byte	.LASF41
 5505 0232 08       		.byte	0x8
 5506 0233 67       		.byte	0x67
 5507 0234 A9000000 		.4byte	0xa9
 5508 0238 0D       		.uleb128 0xd
 5509 0239 01       		.byte	0x1
 5510 023a 08       		.byte	0x8
 5511 023b 71       		.byte	0x71
 5512 023c 65020000 		.4byte	0x265
 5513 0240 0E       		.uleb128 0xe
 5514 0241 370B0000 		.4byte	.LASF42
 5515 0245 00       		.sleb128 0
 5516 0246 0E       		.uleb128 0xe
 5517 0247 58060000 		.4byte	.LASF43
 5518 024b 01       		.sleb128 1
 5519 024c 0E       		.uleb128 0xe
 5520 024d 5D0C0000 		.4byte	.LASF44
 5521 0251 02       		.sleb128 2
 5522 0252 0E       		.uleb128 0xe
 5523 0253 3E000000 		.4byte	.LASF45
 5524 0257 03       		.sleb128 3
 5525 0258 0E       		.uleb128 0xe
 5526 0259 D1060000 		.4byte	.LASF46
 5527 025d 04       		.sleb128 4
 5528 025e 0E       		.uleb128 0xe
 5529 025f 49000000 		.4byte	.LASF47
 5530 0263 05       		.sleb128 5
 5531 0264 00       		.byte	0
 5532 0265 02       		.uleb128 0x2
 5533 0266 93080000 		.4byte	.LASF48
 5534 026a 08       		.byte	0x8
 5535 026b 78       		.byte	0x78
 5536 026c 38020000 		.4byte	0x238
 5537 0270 0D       		.uleb128 0xd
 5538 0271 01       		.byte	0x1
 5539 0272 08       		.byte	0x8
 5540 0273 7C       		.byte	0x7c
 5541 0274 97020000 		.4byte	0x297
 5542 0278 0E       		.uleb128 0xe
 5543 0279 A4000000 		.4byte	.LASF49
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 188


 5544 027d 00       		.sleb128 0
 5545 027e 0E       		.uleb128 0xe
 5546 027f D1080000 		.4byte	.LASF50
 5547 0283 01       		.sleb128 1
 5548 0284 0E       		.uleb128 0xe
 5549 0285 2C040000 		.4byte	.LASF51
 5550 0289 02       		.sleb128 2
 5551 028a 0E       		.uleb128 0xe
 5552 028b 25030000 		.4byte	.LASF52
 5553 028f 03       		.sleb128 3
 5554 0290 0E       		.uleb128 0xe
 5555 0291 8C050000 		.4byte	.LASF53
 5556 0295 04       		.sleb128 4
 5557 0296 00       		.byte	0
 5558 0297 02       		.uleb128 0x2
 5559 0298 17040000 		.4byte	.LASF54
 5560 029c 08       		.byte	0x8
 5561 029d 82       		.byte	0x82
 5562 029e 70020000 		.4byte	0x270
 5563 02a2 0B       		.uleb128 0xb
 5564 02a3 15010000 		.4byte	.LASF55
 5565 02a7 08       		.byte	0x8
 5566 02a8 08       		.byte	0x8
 5567 02a9 87       		.byte	0x87
 5568 02aa C7020000 		.4byte	0x2c7
 5569 02ae 0C       		.uleb128 0xc
 5570 02af E8010000 		.4byte	.LASF56
 5571 02b3 08       		.byte	0x8
 5572 02b4 89       		.byte	0x89
 5573 02b5 2E010000 		.4byte	0x12e
 5574 02b9 00       		.byte	0
 5575 02ba 0C       		.uleb128 0xc
 5576 02bb 36070000 		.4byte	.LASF57
 5577 02bf 08       		.byte	0x8
 5578 02c0 8A       		.byte	0x8a
 5579 02c1 44010000 		.4byte	0x144
 5580 02c5 04       		.byte	0x4
 5581 02c6 00       		.byte	0
 5582 02c7 02       		.uleb128 0x2
 5583 02c8 2D080000 		.4byte	.LASF58
 5584 02cc 08       		.byte	0x8
 5585 02cd 8B       		.byte	0x8b
 5586 02ce A2020000 		.4byte	0x2a2
 5587 02d2 0B       		.uleb128 0xb
 5588 02d3 DA080000 		.4byte	.LASF59
 5589 02d7 0C       		.byte	0xc
 5590 02d8 08       		.byte	0x8
 5591 02d9 90       		.byte	0x90
 5592 02da 03030000 		.4byte	0x303
 5593 02de 0C       		.uleb128 0xc
 5594 02df 490B0000 		.4byte	.LASF60
 5595 02e3 08       		.byte	0x8
 5596 02e4 92       		.byte	0x92
 5597 02e5 A9000000 		.4byte	0xa9
 5598 02e9 00       		.byte	0
 5599 02ea 0C       		.uleb128 0xc
 5600 02eb F2060000 		.4byte	.LASF61
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 189


 5601 02ef 08       		.byte	0x8
 5602 02f0 93       		.byte	0x93
 5603 02f1 E4000000 		.4byte	0xe4
 5604 02f5 04       		.byte	0x4
 5605 02f6 0C       		.uleb128 0xc
 5606 02f7 3E020000 		.4byte	.LASF62
 5607 02fb 08       		.byte	0x8
 5608 02fc 94       		.byte	0x94
 5609 02fd E4000000 		.4byte	0xe4
 5610 0301 08       		.byte	0x8
 5611 0302 00       		.byte	0
 5612 0303 02       		.uleb128 0x2
 5613 0304 81060000 		.4byte	.LASF63
 5614 0308 08       		.byte	0x8
 5615 0309 95       		.byte	0x95
 5616 030a D2020000 		.4byte	0x2d2
 5617 030e 07       		.uleb128 0x7
 5618 030f B8000000 		.4byte	0xb8
 5619 0313 06       		.uleb128 0x6
 5620 0314 04       		.byte	0x4
 5621 0315 23010000 		.4byte	0x123
 5622 0319 0F       		.uleb128 0xf
 5623 031a B9040000 		.4byte	.LASF64
 5624 031e 50       		.byte	0x50
 5625 031f 01       		.byte	0x1
 5626 0320 2501     		.2byte	0x125
 5627 0322 A9030000 		.4byte	0x3a9
 5628 0326 10       		.uleb128 0x10
 5629 0327 6F0D0000 		.4byte	.LASF65
 5630 032b 01       		.byte	0x1
 5631 032c 2701     		.2byte	0x127
 5632 032e A9030000 		.4byte	0x3a9
 5633 0332 00       		.byte	0
 5634 0333 10       		.uleb128 0x10
 5635 0334 3E0D0000 		.4byte	.LASF66
 5636 0338 01       		.byte	0x1
 5637 0339 2D01     		.2byte	0x12d
 5638 033b A4010000 		.4byte	0x1a4
 5639 033f 04       		.byte	0x4
 5640 0340 10       		.uleb128 0x10
 5641 0341 100C0000 		.4byte	.LASF67
 5642 0345 01       		.byte	0x1
 5643 0346 2E01     		.2byte	0x12e
 5644 0348 A4010000 		.4byte	0x1a4
 5645 034c 18       		.byte	0x18
 5646 034d 10       		.uleb128 0x10
 5647 034e 1B000000 		.4byte	.LASF68
 5648 0352 01       		.byte	0x1
 5649 0353 2F01     		.2byte	0x12f
 5650 0355 39010000 		.4byte	0x139
 5651 0359 2C       		.byte	0x2c
 5652 035a 10       		.uleb128 0x10
 5653 035b E2090000 		.4byte	.LASF69
 5654 035f 01       		.byte	0x1
 5655 0360 3001     		.2byte	0x130
 5656 0362 13030000 		.4byte	0x313
 5657 0366 30       		.byte	0x30
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 190


 5658 0367 10       		.uleb128 0x10
 5659 0368 00000000 		.4byte	.LASF70
 5660 036c 01       		.byte	0x1
 5661 036d 3101     		.2byte	0x131
 5662 036f B4030000 		.4byte	0x3b4
 5663 0373 34       		.byte	0x34
 5664 0374 10       		.uleb128 0x10
 5665 0375 F10B0000 		.4byte	.LASF71
 5666 0379 01       		.byte	0x1
 5667 037a 4101     		.2byte	0x141
 5668 037c 39010000 		.4byte	0x139
 5669 0380 40       		.byte	0x40
 5670 0381 10       		.uleb128 0x10
 5671 0382 3D050000 		.4byte	.LASF72
 5672 0386 01       		.byte	0x1
 5673 0387 4201     		.2byte	0x142
 5674 0389 39010000 		.4byte	0x139
 5675 038d 44       		.byte	0x44
 5676 038e 10       		.uleb128 0x10
 5677 038f 2D050000 		.4byte	.LASF73
 5678 0393 01       		.byte	0x1
 5679 0394 5D01     		.2byte	0x15d
 5680 0396 FD000000 		.4byte	0xfd
 5681 039a 48       		.byte	0x48
 5682 039b 10       		.uleb128 0x10
 5683 039c AF020000 		.4byte	.LASF74
 5684 03a0 01       		.byte	0x1
 5685 03a1 5E01     		.2byte	0x15e
 5686 03a3 02010000 		.4byte	0x102
 5687 03a7 4C       		.byte	0x4c
 5688 03a8 00       		.byte	0
 5689 03a9 06       		.uleb128 0x6
 5690 03aa 04       		.byte	0x4
 5691 03ab AF030000 		.4byte	0x3af
 5692 03af 08       		.uleb128 0x8
 5693 03b0 23010000 		.4byte	0x123
 5694 03b4 11       		.uleb128 0x11
 5695 03b5 B1000000 		.4byte	0xb1
 5696 03b9 C4030000 		.4byte	0x3c4
 5697 03bd 12       		.uleb128 0x12
 5698 03be A2000000 		.4byte	0xa2
 5699 03c2 0B       		.byte	0xb
 5700 03c3 00       		.byte	0
 5701 03c4 13       		.uleb128 0x13
 5702 03c5 88020000 		.4byte	.LASF75
 5703 03c9 01       		.byte	0x1
 5704 03ca 6B01     		.2byte	0x16b
 5705 03cc 19030000 		.4byte	0x319
 5706 03d0 13       		.uleb128 0x13
 5707 03d1 350C0000 		.4byte	.LASF76
 5708 03d5 01       		.byte	0x1
 5709 03d6 6F01     		.2byte	0x16f
 5710 03d8 C4030000 		.4byte	0x3c4
 5711 03dc 14       		.uleb128 0x14
 5712 03dd A5060000 		.4byte	.LASF81
 5713 03e1 02       		.byte	0x2
 5714 03e2 F9       		.byte	0xf9
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 191


 5715 03e3 E4000000 		.4byte	0xe4
 5716 03e7 03       		.byte	0x3
 5717 03e8 03040000 		.4byte	0x403
 5718 03ec 15       		.uleb128 0x15
 5719 03ed CC020000 		.4byte	.LASF77
 5720 03f1 02       		.byte	0x2
 5721 03f2 FB       		.byte	0xfb
 5722 03f3 E4000000 		.4byte	0xe4
 5723 03f7 15       		.uleb128 0x15
 5724 03f8 A6050000 		.4byte	.LASF78
 5725 03fc 02       		.byte	0x2
 5726 03fd FB       		.byte	0xfb
 5727 03fe E4000000 		.4byte	0xe4
 5728 0402 00       		.byte	0
 5729 0403 16       		.uleb128 0x16
 5730 0404 A1040000 		.4byte	.LASF79
 5731 0408 02       		.byte	0x2
 5732 0409 0D01     		.2byte	0x10d
 5733 040b 03       		.byte	0x3
 5734 040c 1D040000 		.4byte	0x41d
 5735 0410 17       		.uleb128 0x17
 5736 0411 59080000 		.4byte	.LASF83
 5737 0415 02       		.byte	0x2
 5738 0416 0D01     		.2byte	0x10d
 5739 0418 E4000000 		.4byte	0xe4
 5740 041c 00       		.byte	0
 5741 041d 18       		.uleb128 0x18
 5742 041e BE0A0000 		.4byte	.LASF80
 5743 0422 02       		.byte	0x2
 5744 0423 E9       		.byte	0xe9
 5745 0424 03       		.byte	0x3
 5746 0425 35040000 		.4byte	0x435
 5747 0429 15       		.uleb128 0x15
 5748 042a A6050000 		.4byte	.LASF78
 5749 042e 02       		.byte	0x2
 5750 042f EB       		.byte	0xeb
 5751 0430 E4000000 		.4byte	0xe4
 5752 0434 00       		.byte	0
 5753 0435 14       		.uleb128 0x14
 5754 0436 DA060000 		.4byte	.LASF82
 5755 043a 02       		.byte	0x2
 5756 043b AC       		.byte	0xac
 5757 043c C3000000 		.4byte	0xc3
 5758 0440 03       		.byte	0x3
 5759 0441 5C040000 		.4byte	0x45c
 5760 0445 19       		.uleb128 0x19
 5761 0446 BB010000 		.4byte	.LASF84
 5762 044a 02       		.byte	0x2
 5763 044b AC       		.byte	0xac
 5764 044c E4000000 		.4byte	0xe4
 5765 0450 15       		.uleb128 0x15
 5766 0451 410A0000 		.4byte	.LASF85
 5767 0455 02       		.byte	0x2
 5768 0456 AE       		.byte	0xae
 5769 0457 C3000000 		.4byte	0xc3
 5770 045b 00       		.byte	0
 5771 045c 1A       		.uleb128 0x1a
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 192


 5772 045d 2B060000 		.4byte	.LASF109
 5773 0461 01       		.byte	0x1
 5774 0462 A402     		.2byte	0x2a4
 5775 0464 2E010000 		.4byte	0x12e
 5776 0468 00000000 		.4byte	.LFB68
 5777 046c 82000000 		.4byte	.LFE68-.LFB68
 5778 0470 01       		.uleb128 0x1
 5779 0471 9C       		.byte	0x9c
 5780 0472 08050000 		.4byte	0x508
 5781 0476 1B       		.uleb128 0x1b
 5782 0477 76060000 		.4byte	.LASF86
 5783 047b 01       		.byte	0x1
 5784 047c A402     		.2byte	0x2a4
 5785 047e 07010000 		.4byte	0x107
 5786 0482 02       		.uleb128 0x2
 5787 0483 91       		.byte	0x91
 5788 0484 64       		.sleb128 -28
 5789 0485 1B       		.uleb128 0x1b
 5790 0486 81020000 		.4byte	.LASF87
 5791 048a 01       		.byte	0x1
 5792 048b A502     		.2byte	0x2a5
 5793 048d 0E030000 		.4byte	0x30e
 5794 0491 02       		.uleb128 0x2
 5795 0492 91       		.byte	0x91
 5796 0493 60       		.sleb128 -32
 5797 0494 1B       		.uleb128 0x1b
 5798 0495 06030000 		.4byte	.LASF88
 5799 0499 01       		.byte	0x1
 5800 049a A602     		.2byte	0x2a6
 5801 049c 08050000 		.4byte	0x508
 5802 04a0 02       		.uleb128 0x2
 5803 04a1 91       		.byte	0x91
 5804 04a2 5E       		.sleb128 -34
 5805 04a3 1B       		.uleb128 0x1b
 5806 04a4 47090000 		.4byte	.LASF89
 5807 04a8 01       		.byte	0x1
 5808 04a9 A702     		.2byte	0x2a7
 5809 04ab 0D050000 		.4byte	0x50d
 5810 04af 02       		.uleb128 0x2
 5811 04b0 91       		.byte	0x91
 5812 04b1 58       		.sleb128 -40
 5813 04b2 1B       		.uleb128 0x1b
 5814 04b3 1B000000 		.4byte	.LASF68
 5815 04b7 01       		.byte	0x1
 5816 04b8 A802     		.2byte	0x2a8
 5817 04ba 39010000 		.4byte	0x139
 5818 04be 02       		.uleb128 0x2
 5819 04bf 91       		.byte	0x91
 5820 04c0 00       		.sleb128 0
 5821 04c1 1B       		.uleb128 0x1b
 5822 04c2 AF0D0000 		.4byte	.LASF90
 5823 04c6 01       		.byte	0x1
 5824 04c7 A902     		.2byte	0x2a9
 5825 04c9 12050000 		.4byte	0x512
 5826 04cd 02       		.uleb128 0x2
 5827 04ce 91       		.byte	0x91
 5828 04cf 04       		.sleb128 4
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 193


 5829 04d0 1C       		.uleb128 0x1c
 5830 04d1 6D060000 		.4byte	.LASF91
 5831 04d5 01       		.byte	0x1
 5832 04d6 AB02     		.2byte	0x2ab
 5833 04d8 1D050000 		.4byte	0x51d
 5834 04dc 02       		.uleb128 0x2
 5835 04dd 91       		.byte	0x91
 5836 04de 74       		.sleb128 -12
 5837 04df 1C       		.uleb128 0x1c
 5838 04e0 7C0A0000 		.4byte	.LASF92
 5839 04e4 01       		.byte	0x1
 5840 04e5 AC02     		.2byte	0x2ac
 5841 04e7 2E010000 		.4byte	0x12e
 5842 04eb 02       		.uleb128 0x2
 5843 04ec 91       		.byte	0x91
 5844 04ed 70       		.sleb128 -16
 5845 04ee 1D       		.uleb128 0x1d
 5846 04ef 10000000 		.4byte	.LBB27
 5847 04f3 34000000 		.4byte	.LBE27-.LBB27
 5848 04f7 1C       		.uleb128 0x1c
 5849 04f8 E2090000 		.4byte	.LASF69
 5850 04fc 01       		.byte	0x1
 5851 04fd C902     		.2byte	0x2c9
 5852 04ff 13030000 		.4byte	0x313
 5853 0503 02       		.uleb128 0x2
 5854 0504 91       		.byte	0x91
 5855 0505 6C       		.sleb128 -20
 5856 0506 00       		.byte	0
 5857 0507 00       		.byte	0
 5858 0508 07       		.uleb128 0x7
 5859 0509 CE000000 		.4byte	0xce
 5860 050d 07       		.uleb128 0x7
 5861 050e A9000000 		.4byte	0xa9
 5862 0512 07       		.uleb128 0x7
 5863 0513 17050000 		.4byte	0x517
 5864 0517 06       		.uleb128 0x6
 5865 0518 04       		.byte	0x4
 5866 0519 2D020000 		.4byte	0x22d
 5867 051d 06       		.uleb128 0x6
 5868 051e 04       		.byte	0x4
 5869 051f D0030000 		.4byte	0x3d0
 5870 0523 1E       		.uleb128 0x1e
 5871 0524 75000000 		.4byte	.LASF95
 5872 0528 01       		.byte	0x1
 5873 0529 FF02     		.2byte	0x2ff
 5874 052b 00000000 		.4byte	.LFB69
 5875 052f EC000000 		.4byte	.LFE69-.LFB69
 5876 0533 01       		.uleb128 0x1
 5877 0534 9C       		.byte	0x9c
 5878 0535 CE050000 		.4byte	0x5ce
 5879 0539 1B       		.uleb128 0x1b
 5880 053a 76060000 		.4byte	.LASF86
 5881 053e 01       		.byte	0x1
 5882 053f FF02     		.2byte	0x2ff
 5883 0541 07010000 		.4byte	0x107
 5884 0545 02       		.uleb128 0x2
 5885 0546 91       		.byte	0x91
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 194


 5886 0547 6C       		.sleb128 -20
 5887 0548 1B       		.uleb128 0x1b
 5888 0549 81020000 		.4byte	.LASF87
 5889 054d 01       		.byte	0x1
 5890 054e 0003     		.2byte	0x300
 5891 0550 0E030000 		.4byte	0x30e
 5892 0554 02       		.uleb128 0x2
 5893 0555 91       		.byte	0x91
 5894 0556 68       		.sleb128 -24
 5895 0557 1B       		.uleb128 0x1b
 5896 0558 BF050000 		.4byte	.LASF93
 5897 055c 01       		.byte	0x1
 5898 055d 0103     		.2byte	0x301
 5899 055f CE050000 		.4byte	0x5ce
 5900 0563 02       		.uleb128 0x2
 5901 0564 91       		.byte	0x91
 5902 0565 64       		.sleb128 -28
 5903 0566 1B       		.uleb128 0x1b
 5904 0567 47090000 		.4byte	.LASF89
 5905 056b 01       		.byte	0x1
 5906 056c 0203     		.2byte	0x302
 5907 056e 0D050000 		.4byte	0x50d
 5908 0572 02       		.uleb128 0x2
 5909 0573 91       		.byte	0x91
 5910 0574 60       		.sleb128 -32
 5911 0575 1B       		.uleb128 0x1b
 5912 0576 1B000000 		.4byte	.LASF68
 5913 057a 01       		.byte	0x1
 5914 057b 0303     		.2byte	0x303
 5915 057d 39010000 		.4byte	0x139
 5916 0581 02       		.uleb128 0x2
 5917 0582 91       		.byte	0x91
 5918 0583 00       		.sleb128 0
 5919 0584 1B       		.uleb128 0x1b
 5920 0585 AF0D0000 		.4byte	.LASF90
 5921 0589 01       		.byte	0x1
 5922 058a 0403     		.2byte	0x304
 5923 058c 12050000 		.4byte	0x512
 5924 0590 02       		.uleb128 0x2
 5925 0591 91       		.byte	0x91
 5926 0592 04       		.sleb128 4
 5927 0593 1B       		.uleb128 0x1b
 5928 0594 6D060000 		.4byte	.LASF91
 5929 0598 01       		.byte	0x1
 5930 0599 0503     		.2byte	0x305
 5931 059b 1D050000 		.4byte	0x51d
 5932 059f 02       		.uleb128 0x2
 5933 05a0 91       		.byte	0x91
 5934 05a1 08       		.sleb128 8
 5935 05a2 1B       		.uleb128 0x1b
 5936 05a3 B80C0000 		.4byte	.LASF94
 5937 05a7 01       		.byte	0x1
 5938 05a8 0603     		.2byte	0x306
 5939 05aa D3050000 		.4byte	0x5d3
 5940 05ae 02       		.uleb128 0x2
 5941 05af 91       		.byte	0x91
 5942 05b0 0C       		.sleb128 12
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 195


 5943 05b1 1C       		.uleb128 0x1c
 5944 05b2 6F0D0000 		.4byte	.LASF65
 5945 05b6 01       		.byte	0x1
 5946 05b7 0803     		.2byte	0x308
 5947 05b9 13030000 		.4byte	0x313
 5948 05bd 02       		.uleb128 0x2
 5949 05be 91       		.byte	0x91
 5950 05bf 70       		.sleb128 -16
 5951 05c0 1F       		.uleb128 0x1f
 5952 05c1 7800     		.ascii	"x\000"
 5953 05c3 01       		.byte	0x1
 5954 05c4 0903     		.2byte	0x309
 5955 05c6 39010000 		.4byte	0x139
 5956 05ca 02       		.uleb128 0x2
 5957 05cb 91       		.byte	0x91
 5958 05cc 74       		.sleb128 -12
 5959 05cd 00       		.byte	0
 5960 05ce 07       		.uleb128 0x7
 5961 05cf E4000000 		.4byte	0xe4
 5962 05d3 07       		.uleb128 0x7
 5963 05d4 D8050000 		.4byte	0x5d8
 5964 05d8 06       		.uleb128 0x6
 5965 05d9 04       		.byte	0x4
 5966 05da DE050000 		.4byte	0x5de
 5967 05de 07       		.uleb128 0x7
 5968 05df 03030000 		.4byte	0x303
 5969 05e3 1E       		.uleb128 0x1e
 5970 05e4 37060000 		.4byte	.LASF96
 5971 05e8 01       		.byte	0x1
 5972 05e9 C303     		.2byte	0x3c3
 5973 05eb 00000000 		.4byte	.LFB70
 5974 05ef D8000000 		.4byte	.LFE70-.LFB70
 5975 05f3 01       		.uleb128 0x1
 5976 05f4 9C       		.byte	0x9c
 5977 05f5 09060000 		.4byte	0x609
 5978 05f9 1B       		.uleb128 0x1b
 5979 05fa 6D060000 		.4byte	.LASF91
 5980 05fe 01       		.byte	0x1
 5981 05ff C303     		.2byte	0x3c3
 5982 0601 1D050000 		.4byte	0x51d
 5983 0605 02       		.uleb128 0x2
 5984 0606 91       		.byte	0x91
 5985 0607 74       		.sleb128 -12
 5986 0608 00       		.byte	0
 5987 0609 20       		.uleb128 0x20
 5988 060a F2080000 		.4byte	.LASF99
 5989 060e 01       		.byte	0x1
 5990 060f 1804     		.2byte	0x418
 5991 0611 00000000 		.4byte	.LFB71
 5992 0615 FC000000 		.4byte	.LFE71-.LFB71
 5993 0619 01       		.uleb128 0x1
 5994 061a 9C       		.byte	0x9c
 5995 061b 3E060000 		.4byte	0x63e
 5996 061f 1B       		.uleb128 0x1b
 5997 0620 EA090000 		.4byte	.LASF97
 5998 0624 01       		.byte	0x1
 5999 0625 1804     		.2byte	0x418
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 196


 6000 0627 2D020000 		.4byte	0x22d
 6001 062b 02       		.uleb128 0x2
 6002 062c 91       		.byte	0x91
 6003 062d 6C       		.sleb128 -20
 6004 062e 1C       		.uleb128 0x1c
 6005 062f 4D0D0000 		.4byte	.LASF98
 6006 0633 01       		.byte	0x1
 6007 0634 1A04     		.2byte	0x41a
 6008 0636 1D050000 		.4byte	0x51d
 6009 063a 02       		.uleb128 0x2
 6010 063b 91       		.byte	0x91
 6011 063c 74       		.sleb128 -12
 6012 063d 00       		.byte	0
 6013 063e 20       		.uleb128 0x20
 6014 063f 000C0000 		.4byte	.LASF100
 6015 0643 01       		.byte	0x1
 6016 0644 7404     		.2byte	0x474
 6017 0646 00000000 		.4byte	.LFB72
 6018 064a A0000000 		.4byte	.LFE72-.LFB72
 6019 064e 01       		.uleb128 0x1
 6020 064f 9C       		.byte	0x9c
 6021 0650 B9060000 		.4byte	0x6b9
 6022 0654 1B       		.uleb128 0x1b
 6023 0655 240A0000 		.4byte	.LASF101
 6024 0659 01       		.byte	0x1
 6025 065a 7404     		.2byte	0x474
 6026 065c B9060000 		.4byte	0x6b9
 6027 0660 02       		.uleb128 0x2
 6028 0661 91       		.byte	0x91
 6029 0662 64       		.sleb128 -28
 6030 0663 1B       		.uleb128 0x1b
 6031 0664 040D0000 		.4byte	.LASF102
 6032 0668 01       		.byte	0x1
 6033 0669 7404     		.2byte	0x474
 6034 066b C4060000 		.4byte	0x6c4
 6035 066f 02       		.uleb128 0x2
 6036 0670 91       		.byte	0x91
 6037 0671 60       		.sleb128 -32
 6038 0672 1C       		.uleb128 0x1c
 6039 0673 320D0000 		.4byte	.LASF103
 6040 0677 01       		.byte	0x1
 6041 0678 7604     		.2byte	0x476
 6042 067a 44010000 		.4byte	0x144
 6043 067e 02       		.uleb128 0x2
 6044 067f 91       		.byte	0x91
 6045 0680 6C       		.sleb128 -20
 6046 0681 1C       		.uleb128 0x1c
 6047 0682 730C0000 		.4byte	.LASF104
 6048 0686 01       		.byte	0x1
 6049 0687 7704     		.2byte	0x477
 6050 0689 2E010000 		.4byte	0x12e
 6051 068d 02       		.uleb128 0x2
 6052 068e 91       		.byte	0x91
 6053 068f 68       		.sleb128 -24
 6054 0690 1C       		.uleb128 0x1c
 6055 0691 CC050000 		.4byte	.LASF105
 6056 0695 01       		.byte	0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 197


 6057 0696 7704     		.2byte	0x477
 6058 0698 2E010000 		.4byte	0x12e
 6059 069c 02       		.uleb128 0x2
 6060 069d 91       		.byte	0x91
 6061 069e 74       		.sleb128 -12
 6062 069f 1D       		.uleb128 0x1d
 6063 06a0 12000000 		.4byte	.LBB28
 6064 06a4 62000000 		.4byte	.LBE28-.LBB28
 6065 06a8 1C       		.uleb128 0x1c
 6066 06a9 7E040000 		.4byte	.LASF106
 6067 06ad 01       		.byte	0x1
 6068 06ae 8104     		.2byte	0x481
 6069 06b0 C4060000 		.4byte	0x6c4
 6070 06b4 02       		.uleb128 0x2
 6071 06b5 91       		.byte	0x91
 6072 06b6 70       		.sleb128 -16
 6073 06b7 00       		.byte	0
 6074 06b8 00       		.byte	0
 6075 06b9 07       		.uleb128 0x7
 6076 06ba BE060000 		.4byte	0x6be
 6077 06be 06       		.uleb128 0x6
 6078 06bf 04       		.byte	0x4
 6079 06c0 44010000 		.4byte	0x144
 6080 06c4 07       		.uleb128 0x7
 6081 06c5 44010000 		.4byte	0x144
 6082 06c9 20       		.uleb128 0x20
 6083 06ca 04050000 		.4byte	.LASF107
 6084 06ce 01       		.byte	0x1
 6085 06cf C804     		.2byte	0x4c8
 6086 06d1 00000000 		.4byte	.LFB73
 6087 06d5 44000000 		.4byte	.LFE73-.LFB73
 6088 06d9 01       		.uleb128 0x1
 6089 06da 9C       		.byte	0x9c
 6090 06db FE060000 		.4byte	0x6fe
 6091 06df 1B       		.uleb128 0x1b
 6092 06e0 570B0000 		.4byte	.LASF108
 6093 06e4 01       		.byte	0x1
 6094 06e5 C804     		.2byte	0x4c8
 6095 06e7 C4060000 		.4byte	0x6c4
 6096 06eb 02       		.uleb128 0x2
 6097 06ec 91       		.byte	0x91
 6098 06ed 6C       		.sleb128 -20
 6099 06ee 1C       		.uleb128 0x1c
 6100 06ef 730C0000 		.4byte	.LASF104
 6101 06f3 01       		.byte	0x1
 6102 06f4 CA04     		.2byte	0x4ca
 6103 06f6 2E010000 		.4byte	0x12e
 6104 06fa 02       		.uleb128 0x2
 6105 06fb 91       		.byte	0x91
 6106 06fc 74       		.sleb128 -12
 6107 06fd 00       		.byte	0
 6108 06fe 1A       		.uleb128 0x1a
 6109 06ff 5F060000 		.4byte	.LASF110
 6110 0703 01       		.byte	0x1
 6111 0704 F504     		.2byte	0x4f5
 6112 0706 65020000 		.4byte	0x265
 6113 070a 00000000 		.4byte	.LFB74
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 198


 6114 070e 98000000 		.4byte	.LFE74-.LFB74
 6115 0712 01       		.uleb128 0x1
 6116 0713 9C       		.byte	0x9c
 6117 0714 55070000 		.4byte	0x755
 6118 0718 1B       		.uleb128 0x1b
 6119 0719 CB080000 		.4byte	.LASF111
 6120 071d 01       		.byte	0x1
 6121 071e F504     		.2byte	0x4f5
 6122 0720 2D020000 		.4byte	0x22d
 6123 0724 02       		.uleb128 0x2
 6124 0725 91       		.byte	0x91
 6125 0726 64       		.sleb128 -28
 6126 0727 1C       		.uleb128 0x1c
 6127 0728 4B020000 		.4byte	.LASF112
 6128 072c 01       		.byte	0x1
 6129 072d F704     		.2byte	0x4f7
 6130 072f 65020000 		.4byte	0x265
 6131 0733 02       		.uleb128 0x2
 6132 0734 91       		.byte	0x91
 6133 0735 77       		.sleb128 -9
 6134 0736 1C       		.uleb128 0x1c
 6135 0737 32000000 		.4byte	.LASF113
 6136 073b 01       		.byte	0x1
 6137 073c F804     		.2byte	0x4f8
 6138 073e 55070000 		.4byte	0x755
 6139 0742 02       		.uleb128 0x2
 6140 0743 91       		.byte	0x91
 6141 0744 6C       		.sleb128 -20
 6142 0745 1C       		.uleb128 0x1c
 6143 0746 4D0D0000 		.4byte	.LASF98
 6144 074a 01       		.byte	0x1
 6145 074b F904     		.2byte	0x4f9
 6146 074d 5B070000 		.4byte	0x75b
 6147 0751 02       		.uleb128 0x2
 6148 0752 91       		.byte	0x91
 6149 0753 70       		.sleb128 -16
 6150 0754 00       		.byte	0
 6151 0755 06       		.uleb128 0x6
 6152 0756 04       		.byte	0x4
 6153 0757 22020000 		.4byte	0x222
 6154 075b 07       		.uleb128 0x7
 6155 075c 60070000 		.4byte	0x760
 6156 0760 06       		.uleb128 0x6
 6157 0761 04       		.byte	0x4
 6158 0762 66070000 		.4byte	0x766
 6159 0766 07       		.uleb128 0x7
 6160 0767 D0030000 		.4byte	0x3d0
 6161 076b 1A       		.uleb128 0x1a
 6162 076c 6C040000 		.4byte	.LASF114
 6163 0770 01       		.byte	0x1
 6164 0771 3C05     		.2byte	0x53c
 6165 0773 39010000 		.4byte	0x139
 6166 0777 00000000 		.4byte	.LFB75
 6167 077b 34000000 		.4byte	.LFE75-.LFB75
 6168 077f 01       		.uleb128 0x1
 6169 0780 9C       		.byte	0x9c
 6170 0781 B3070000 		.4byte	0x7b3
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 199


 6171 0785 1B       		.uleb128 0x1b
 6172 0786 CB080000 		.4byte	.LASF111
 6173 078a 01       		.byte	0x1
 6174 078b 3C05     		.2byte	0x53c
 6175 078d 2D020000 		.4byte	0x22d
 6176 0791 02       		.uleb128 0x2
 6177 0792 91       		.byte	0x91
 6178 0793 6C       		.sleb128 -20
 6179 0794 1C       		.uleb128 0x1c
 6180 0795 4D0D0000 		.4byte	.LASF98
 6181 0799 01       		.byte	0x1
 6182 079a 3E05     		.2byte	0x53e
 6183 079c 1D050000 		.4byte	0x51d
 6184 07a0 02       		.uleb128 0x2
 6185 07a1 91       		.byte	0x91
 6186 07a2 74       		.sleb128 -12
 6187 07a3 1C       		.uleb128 0x1c
 6188 07a4 61020000 		.4byte	.LASF115
 6189 07a8 01       		.byte	0x1
 6190 07a9 3F05     		.2byte	0x53f
 6191 07ab 39010000 		.4byte	0x139
 6192 07af 02       		.uleb128 0x2
 6193 07b0 91       		.byte	0x91
 6194 07b1 70       		.sleb128 -16
 6195 07b2 00       		.byte	0
 6196 07b3 21       		.uleb128 0x21
 6197 07b4 02080000 		.4byte	.LASF116
 6198 07b8 01       		.byte	0x1
 6199 07b9 5205     		.2byte	0x552
 6200 07bb 39010000 		.4byte	0x139
 6201 07bf 00000000 		.4byte	.LFB76
 6202 07c3 58000000 		.4byte	.LFE76-.LFB76
 6203 07c7 01       		.uleb128 0x1
 6204 07c8 9C       		.byte	0x9c
 6205 07c9 52080000 		.4byte	0x852
 6206 07cd 1B       		.uleb128 0x1b
 6207 07ce CB080000 		.4byte	.LASF111
 6208 07d2 01       		.byte	0x1
 6209 07d3 5205     		.2byte	0x552
 6210 07d5 2D020000 		.4byte	0x22d
 6211 07d9 02       		.uleb128 0x2
 6212 07da 91       		.byte	0x91
 6213 07db 5C       		.sleb128 -36
 6214 07dc 1C       		.uleb128 0x1c
 6215 07dd 4D0D0000 		.4byte	.LASF98
 6216 07e1 01       		.byte	0x1
 6217 07e2 5405     		.2byte	0x554
 6218 07e4 1D050000 		.4byte	0x51d
 6219 07e8 02       		.uleb128 0x2
 6220 07e9 91       		.byte	0x91
 6221 07ea 70       		.sleb128 -16
 6222 07eb 1C       		.uleb128 0x1c
 6223 07ec 61020000 		.4byte	.LASF115
 6224 07f0 01       		.byte	0x1
 6225 07f1 5505     		.2byte	0x555
 6226 07f3 39010000 		.4byte	0x139
 6227 07f7 02       		.uleb128 0x2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 200


 6228 07f8 91       		.byte	0x91
 6229 07f9 6C       		.sleb128 -20
 6230 07fa 1C       		.uleb128 0x1c
 6231 07fb 6C030000 		.4byte	.LASF117
 6232 07ff 01       		.byte	0x1
 6233 0800 5505     		.2byte	0x555
 6234 0802 39010000 		.4byte	0x139
 6235 0806 02       		.uleb128 0x2
 6236 0807 91       		.byte	0x91
 6237 0808 74       		.sleb128 -12
 6238 0809 22       		.uleb128 0x22
 6239 080a DC030000 		.4byte	0x3dc
 6240 080e 08000000 		.4byte	.LBB29
 6241 0812 1A000000 		.4byte	.LBE29-.LBB29
 6242 0816 01       		.byte	0x1
 6243 0817 6905     		.2byte	0x569
 6244 0819 38080000 		.4byte	0x838
 6245 081d 1D       		.uleb128 0x1d
 6246 081e 08000000 		.4byte	.LBB30
 6247 0822 1A000000 		.4byte	.LBE30-.LBB30
 6248 0826 23       		.uleb128 0x23
 6249 0827 EC030000 		.4byte	0x3ec
 6250 082b 02       		.uleb128 0x2
 6251 082c 91       		.byte	0x91
 6252 082d 68       		.sleb128 -24
 6253 082e 23       		.uleb128 0x23
 6254 082f F7030000 		.4byte	0x3f7
 6255 0833 02       		.uleb128 0x2
 6256 0834 91       		.byte	0x91
 6257 0835 64       		.sleb128 -28
 6258 0836 00       		.byte	0
 6259 0837 00       		.byte	0
 6260 0838 24       		.uleb128 0x24
 6261 0839 03040000 		.4byte	0x403
 6262 083d 3E000000 		.4byte	.LBB31
 6263 0841 06000000 		.4byte	.LBE31-.LBB31
 6264 0845 01       		.byte	0x1
 6265 0846 7005     		.2byte	0x570
 6266 0848 25       		.uleb128 0x25
 6267 0849 10040000 		.4byte	0x410
 6268 084d 02       		.uleb128 0x2
 6269 084e 91       		.byte	0x91
 6270 084f 60       		.sleb128 -32
 6271 0850 00       		.byte	0
 6272 0851 00       		.byte	0
 6273 0852 20       		.uleb128 0x20
 6274 0853 82080000 		.4byte	.LASF118
 6275 0857 01       		.byte	0x1
 6276 0858 7A05     		.2byte	0x57a
 6277 085a 00000000 		.4byte	.LFB77
 6278 085e 44010000 		.4byte	.LFE77-.LFB77
 6279 0862 01       		.uleb128 0x1
 6280 0863 9C       		.byte	0x9c
 6281 0864 C3080000 		.4byte	0x8c3
 6282 0868 1B       		.uleb128 0x1b
 6283 0869 CB080000 		.4byte	.LASF111
 6284 086d 01       		.byte	0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 201


 6285 086e 7A05     		.2byte	0x57a
 6286 0870 2D020000 		.4byte	0x22d
 6287 0874 02       		.uleb128 0x2
 6288 0875 91       		.byte	0x91
 6289 0876 64       		.sleb128 -28
 6290 0877 1B       		.uleb128 0x1b
 6291 0878 46070000 		.4byte	.LASF119
 6292 087c 01       		.byte	0x1
 6293 087d 7A05     		.2byte	0x57a
 6294 087f 39010000 		.4byte	0x139
 6295 0883 02       		.uleb128 0x2
 6296 0884 91       		.byte	0x91
 6297 0885 60       		.sleb128 -32
 6298 0886 1C       		.uleb128 0x1c
 6299 0887 4D0D0000 		.4byte	.LASF98
 6300 088b 01       		.byte	0x1
 6301 088c 7C05     		.2byte	0x57c
 6302 088e 1D050000 		.4byte	0x51d
 6303 0892 02       		.uleb128 0x2
 6304 0893 91       		.byte	0x91
 6305 0894 70       		.sleb128 -16
 6306 0895 1C       		.uleb128 0x1c
 6307 0896 E60D0000 		.4byte	.LASF120
 6308 089a 01       		.byte	0x1
 6309 089b 7D05     		.2byte	0x57d
 6310 089d 39010000 		.4byte	0x139
 6311 08a1 02       		.uleb128 0x2
 6312 08a2 91       		.byte	0x91
 6313 08a3 6C       		.sleb128 -20
 6314 08a4 1C       		.uleb128 0x1c
 6315 08a5 1F0C0000 		.4byte	.LASF121
 6316 08a9 01       		.byte	0x1
 6317 08aa 7D05     		.2byte	0x57d
 6318 08ac 39010000 		.4byte	0x139
 6319 08b0 02       		.uleb128 0x2
 6320 08b1 91       		.byte	0x91
 6321 08b2 68       		.sleb128 -24
 6322 08b3 1C       		.uleb128 0x1c
 6323 08b4 BD020000 		.4byte	.LASF122
 6324 08b8 01       		.byte	0x1
 6325 08b9 7E05     		.2byte	0x57e
 6326 08bb 2E010000 		.4byte	0x12e
 6327 08bf 02       		.uleb128 0x2
 6328 08c0 91       		.byte	0x91
 6329 08c1 74       		.sleb128 -12
 6330 08c2 00       		.byte	0
 6331 08c3 20       		.uleb128 0x20
 6332 08c4 660C0000 		.4byte	.LASF123
 6333 08c8 01       		.byte	0x1
 6334 08c9 1E06     		.2byte	0x61e
 6335 08cb 00000000 		.4byte	.LFB78
 6336 08cf EC000000 		.4byte	.LFE78-.LFB78
 6337 08d3 01       		.uleb128 0x1
 6338 08d4 9C       		.byte	0x9c
 6339 08d5 F8080000 		.4byte	0x8f8
 6340 08d9 1B       		.uleb128 0x1b
 6341 08da 000A0000 		.4byte	.LASF124
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 202


 6342 08de 01       		.byte	0x1
 6343 08df 1E06     		.2byte	0x61e
 6344 08e1 2D020000 		.4byte	0x22d
 6345 08e5 02       		.uleb128 0x2
 6346 08e6 91       		.byte	0x91
 6347 08e7 6C       		.sleb128 -20
 6348 08e8 1C       		.uleb128 0x1c
 6349 08e9 4D0D0000 		.4byte	.LASF98
 6350 08ed 01       		.byte	0x1
 6351 08ee 2006     		.2byte	0x620
 6352 08f0 1D050000 		.4byte	0x51d
 6353 08f4 02       		.uleb128 0x2
 6354 08f5 91       		.byte	0x91
 6355 08f6 74       		.sleb128 -12
 6356 08f7 00       		.byte	0
 6357 08f8 26       		.uleb128 0x26
 6358 08f9 AD090000 		.4byte	.LASF164
 6359 08fd 01       		.byte	0x1
 6360 08fe 7806     		.2byte	0x678
 6361 0900 2E010000 		.4byte	0x12e
 6362 0904 00000000 		.4byte	.LFB79
 6363 0908 5C000000 		.4byte	.LFE79-.LFB79
 6364 090c 01       		.uleb128 0x1
 6365 090d 9C       		.byte	0x9c
 6366 090e 40090000 		.4byte	0x940
 6367 0912 1B       		.uleb128 0x1b
 6368 0913 CB080000 		.4byte	.LASF111
 6369 0917 01       		.byte	0x1
 6370 0918 7806     		.2byte	0x678
 6371 091a 40090000 		.4byte	0x940
 6372 091e 02       		.uleb128 0x2
 6373 091f 91       		.byte	0x91
 6374 0920 6C       		.sleb128 -20
 6375 0921 1C       		.uleb128 0x1c
 6376 0922 7C0A0000 		.4byte	.LASF92
 6377 0926 01       		.byte	0x1
 6378 0927 7A06     		.2byte	0x67a
 6379 0929 2E010000 		.4byte	0x12e
 6380 092d 02       		.uleb128 0x2
 6381 092e 91       		.byte	0x91
 6382 092f 74       		.sleb128 -12
 6383 0930 1C       		.uleb128 0x1c
 6384 0931 4D0D0000 		.4byte	.LASF98
 6385 0935 01       		.byte	0x1
 6386 0936 7B06     		.2byte	0x67b
 6387 0938 5B070000 		.4byte	0x75b
 6388 093c 02       		.uleb128 0x2
 6389 093d 91       		.byte	0x91
 6390 093e 70       		.sleb128 -16
 6391 093f 00       		.byte	0
 6392 0940 07       		.uleb128 0x7
 6393 0941 2D020000 		.4byte	0x22d
 6394 0945 20       		.uleb128 0x20
 6395 0946 7C0D0000 		.4byte	.LASF125
 6396 094a 01       		.byte	0x1
 6397 094b A606     		.2byte	0x6a6
 6398 094d 00000000 		.4byte	.LFB80
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 203


 6399 0951 A0000000 		.4byte	.LFE80-.LFB80
 6400 0955 01       		.uleb128 0x1
 6401 0956 9C       		.byte	0x9c
 6402 0957 7A090000 		.4byte	0x97a
 6403 095b 1B       		.uleb128 0x1b
 6404 095c 53020000 		.4byte	.LASF126
 6405 0960 01       		.byte	0x1
 6406 0961 A606     		.2byte	0x6a6
 6407 0963 2D020000 		.4byte	0x22d
 6408 0967 02       		.uleb128 0x2
 6409 0968 91       		.byte	0x91
 6410 0969 6C       		.sleb128 -20
 6411 096a 1C       		.uleb128 0x1c
 6412 096b 4D0D0000 		.4byte	.LASF98
 6413 096f 01       		.byte	0x1
 6414 0970 A806     		.2byte	0x6a8
 6415 0972 7A090000 		.4byte	0x97a
 6416 0976 02       		.uleb128 0x2
 6417 0977 91       		.byte	0x91
 6418 0978 74       		.sleb128 -12
 6419 0979 00       		.byte	0
 6420 097a 07       		.uleb128 0x7
 6421 097b 1D050000 		.4byte	0x51d
 6422 097f 1A       		.uleb128 0x1a
 6423 0980 D8030000 		.4byte	.LASF127
 6424 0984 01       		.byte	0x1
 6425 0985 DC06     		.2byte	0x6dc
 6426 0987 2E010000 		.4byte	0x12e
 6427 098b 00000000 		.4byte	.LFB81
 6428 098f C4000000 		.4byte	.LFE81-.LFB81
 6429 0993 01       		.uleb128 0x1
 6430 0994 9C       		.byte	0x9c
 6431 0995 1E0A0000 		.4byte	0xa1e
 6432 0999 1B       		.uleb128 0x1b
 6433 099a 53020000 		.4byte	.LASF126
 6434 099e 01       		.byte	0x1
 6435 099f DC06     		.2byte	0x6dc
 6436 09a1 2D020000 		.4byte	0x22d
 6437 09a5 02       		.uleb128 0x2
 6438 09a6 91       		.byte	0x91
 6439 09a7 5C       		.sleb128 -36
 6440 09a8 1C       		.uleb128 0x1c
 6441 09a9 BD020000 		.4byte	.LASF122
 6442 09ad 01       		.byte	0x1
 6443 09ae DE06     		.2byte	0x6de
 6444 09b0 2E010000 		.4byte	0x12e
 6445 09b4 02       		.uleb128 0x2
 6446 09b5 91       		.byte	0x91
 6447 09b6 74       		.sleb128 -12
 6448 09b7 1C       		.uleb128 0x1c
 6449 09b8 4D0D0000 		.4byte	.LASF98
 6450 09bc 01       		.byte	0x1
 6451 09bd DF06     		.2byte	0x6df
 6452 09bf 7A090000 		.4byte	0x97a
 6453 09c3 02       		.uleb128 0x2
 6454 09c4 91       		.byte	0x91
 6455 09c5 70       		.sleb128 -16
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 204


 6456 09c6 1C       		.uleb128 0x1c
 6457 09c7 8F020000 		.4byte	.LASF128
 6458 09cb 01       		.byte	0x1
 6459 09cc E006     		.2byte	0x6e0
 6460 09ce 39010000 		.4byte	0x139
 6461 09d2 02       		.uleb128 0x2
 6462 09d3 91       		.byte	0x91
 6463 09d4 6C       		.sleb128 -20
 6464 09d5 22       		.uleb128 0x22
 6465 09d6 DC030000 		.4byte	0x3dc
 6466 09da 10000000 		.4byte	.LBB33
 6467 09de 1A000000 		.4byte	.LBE33-.LBB33
 6468 09e2 01       		.byte	0x1
 6469 09e3 F606     		.2byte	0x6f6
 6470 09e5 040A0000 		.4byte	0xa04
 6471 09e9 1D       		.uleb128 0x1d
 6472 09ea 10000000 		.4byte	.LBB34
 6473 09ee 1A000000 		.4byte	.LBE34-.LBB34
 6474 09f2 23       		.uleb128 0x23
 6475 09f3 EC030000 		.4byte	0x3ec
 6476 09f7 02       		.uleb128 0x2
 6477 09f8 91       		.byte	0x91
 6478 09f9 68       		.sleb128 -24
 6479 09fa 23       		.uleb128 0x23
 6480 09fb F7030000 		.4byte	0x3f7
 6481 09ff 02       		.uleb128 0x2
 6482 0a00 91       		.byte	0x91
 6483 0a01 64       		.sleb128 -28
 6484 0a02 00       		.byte	0
 6485 0a03 00       		.byte	0
 6486 0a04 24       		.uleb128 0x24
 6487 0a05 03040000 		.4byte	0x403
 6488 0a09 A0000000 		.4byte	.LBB35
 6489 0a0d 06000000 		.4byte	.LBE35-.LBB35
 6490 0a11 01       		.byte	0x1
 6491 0a12 1A07     		.2byte	0x71a
 6492 0a14 25       		.uleb128 0x25
 6493 0a15 10040000 		.4byte	0x410
 6494 0a19 02       		.uleb128 0x2
 6495 0a1a 91       		.byte	0x91
 6496 0a1b 60       		.sleb128 -32
 6497 0a1c 00       		.byte	0
 6498 0a1d 00       		.byte	0
 6499 0a1e 20       		.uleb128 0x20
 6500 0a1f 0D0B0000 		.4byte	.LASF129
 6501 0a23 01       		.byte	0x1
 6502 0a24 2207     		.2byte	0x722
 6503 0a26 00000000 		.4byte	.LFB82
 6504 0a2a 6C000000 		.4byte	.LFE82-.LFB82
 6505 0a2e 01       		.uleb128 0x1
 6506 0a2f 9C       		.byte	0x9c
 6507 0a30 670A0000 		.4byte	0xa67
 6508 0a34 1C       		.uleb128 0x1c
 6509 0a35 7C0A0000 		.4byte	.LASF92
 6510 0a39 01       		.byte	0x1
 6511 0a3a 2407     		.2byte	0x724
 6512 0a3c 2E010000 		.4byte	0x12e
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 205


 6513 0a40 02       		.uleb128 0x2
 6514 0a41 91       		.byte	0x91
 6515 0a42 74       		.sleb128 -12
 6516 0a43 24       		.uleb128 0x24
 6517 0a44 1D040000 		.4byte	0x41d
 6518 0a48 22000000 		.4byte	.LBB37
 6519 0a4c 12000000 		.4byte	.LBE37-.LBB37
 6520 0a50 01       		.byte	0x1
 6521 0a51 6007     		.2byte	0x760
 6522 0a53 1D       		.uleb128 0x1d
 6523 0a54 22000000 		.4byte	.LBB38
 6524 0a58 12000000 		.4byte	.LBE38-.LBB38
 6525 0a5c 23       		.uleb128 0x23
 6526 0a5d 29040000 		.4byte	0x429
 6527 0a61 02       		.uleb128 0x2
 6528 0a62 91       		.byte	0x91
 6529 0a63 70       		.sleb128 -16
 6530 0a64 00       		.byte	0
 6531 0a65 00       		.byte	0
 6532 0a66 00       		.byte	0
 6533 0a67 20       		.uleb128 0x20
 6534 0a68 5A040000 		.4byte	.LASF130
 6535 0a6c 01       		.byte	0x1
 6536 0a6d 8D07     		.2byte	0x78d
 6537 0a6f 00000000 		.4byte	.LFB83
 6538 0a73 2C000000 		.4byte	.LFE83-.LFB83
 6539 0a77 01       		.uleb128 0x1
 6540 0a78 9C       		.byte	0x9c
 6541 0a79 A10A0000 		.4byte	0xaa1
 6542 0a7d 24       		.uleb128 0x24
 6543 0a7e 1D040000 		.4byte	0x41d
 6544 0a82 06000000 		.4byte	.LBB39
 6545 0a86 12000000 		.4byte	.LBE39-.LBB39
 6546 0a8a 01       		.byte	0x1
 6547 0a8b 9207     		.2byte	0x792
 6548 0a8d 1D       		.uleb128 0x1d
 6549 0a8e 06000000 		.4byte	.LBB40
 6550 0a92 12000000 		.4byte	.LBE40-.LBB40
 6551 0a96 23       		.uleb128 0x23
 6552 0a97 29040000 		.4byte	0x429
 6553 0a9b 02       		.uleb128 0x2
 6554 0a9c 91       		.byte	0x91
 6555 0a9d 74       		.sleb128 -12
 6556 0a9e 00       		.byte	0
 6557 0a9f 00       		.byte	0
 6558 0aa0 00       		.byte	0
 6559 0aa1 27       		.uleb128 0x27
 6560 0aa2 EB030000 		.4byte	.LASF158
 6561 0aa6 01       		.byte	0x1
 6562 0aa7 9807     		.2byte	0x798
 6563 0aa9 00000000 		.4byte	.LFB84
 6564 0aad 1C000000 		.4byte	.LFE84-.LFB84
 6565 0ab1 01       		.uleb128 0x1
 6566 0ab2 9C       		.byte	0x9c
 6567 0ab3 1A       		.uleb128 0x1a
 6568 0ab4 75090000 		.4byte	.LASF131
 6569 0ab8 01       		.byte	0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 206


 6570 0ab9 E107     		.2byte	0x7e1
 6571 0abb 2E010000 		.4byte	0x12e
 6572 0abf 00000000 		.4byte	.LFB85
 6573 0ac3 20010000 		.4byte	.LFE85-.LFB85
 6574 0ac7 01       		.uleb128 0x1
 6575 0ac8 9C       		.byte	0x9c
 6576 0ac9 050B0000 		.4byte	0xb05
 6577 0acd 1C       		.uleb128 0x1c
 6578 0ace 4D0D0000 		.4byte	.LASF98
 6579 0ad2 01       		.byte	0x1
 6580 0ad3 E307     		.2byte	0x7e3
 6581 0ad5 1D050000 		.4byte	0x51d
 6582 0ad9 02       		.uleb128 0x2
 6583 0ada 91       		.byte	0x91
 6584 0adb 74       		.sleb128 -12
 6585 0adc 1C       		.uleb128 0x1c
 6586 0add 730C0000 		.4byte	.LASF104
 6587 0ae1 01       		.byte	0x1
 6588 0ae2 E407     		.2byte	0x7e4
 6589 0ae4 2E010000 		.4byte	0x12e
 6590 0ae8 02       		.uleb128 0x2
 6591 0ae9 91       		.byte	0x91
 6592 0aea 70       		.sleb128 -16
 6593 0aeb 1D       		.uleb128 0x1d
 6594 0aec A2000000 		.4byte	.LBB41
 6595 0af0 2E000000 		.4byte	.LBE41-.LBB41
 6596 0af4 1C       		.uleb128 0x1c
 6597 0af5 52000000 		.4byte	.LASF132
 6598 0af9 01       		.byte	0x1
 6599 0afa 1C08     		.2byte	0x81c
 6600 0afc 39010000 		.4byte	0x139
 6601 0b00 02       		.uleb128 0x2
 6602 0b01 91       		.byte	0x91
 6603 0b02 6C       		.sleb128 -20
 6604 0b03 00       		.byte	0
 6605 0b04 00       		.byte	0
 6606 0b05 21       		.uleb128 0x21
 6607 0b06 1B080000 		.4byte	.LASF133
 6608 0b0a 01       		.byte	0x1
 6609 0b0b 4F08     		.2byte	0x84f
 6610 0b0d 44010000 		.4byte	0x144
 6611 0b11 00000000 		.4byte	.LFB86
 6612 0b15 20000000 		.4byte	.LFE86-.LFB86
 6613 0b19 01       		.uleb128 0x1
 6614 0b1a 9C       		.byte	0x9c
 6615 0b1b 2F0B0000 		.4byte	0xb2f
 6616 0b1f 1C       		.uleb128 0x1c
 6617 0b20 060B0000 		.4byte	.LASF134
 6618 0b24 01       		.byte	0x1
 6619 0b25 5108     		.2byte	0x851
 6620 0b27 44010000 		.4byte	0x144
 6621 0b2b 02       		.uleb128 0x2
 6622 0b2c 91       		.byte	0x91
 6623 0b2d 74       		.sleb128 -12
 6624 0b2e 00       		.byte	0
 6625 0b2f 21       		.uleb128 0x21
 6626 0b30 53030000 		.4byte	.LASF135
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 207


 6627 0b34 01       		.byte	0x1
 6628 0b35 5E08     		.2byte	0x85e
 6629 0b37 44010000 		.4byte	0x144
 6630 0b3b 00000000 		.4byte	.LFB87
 6631 0b3f 24000000 		.4byte	.LFE87-.LFB87
 6632 0b43 01       		.uleb128 0x1
 6633 0b44 9C       		.byte	0x9c
 6634 0b45 680B0000 		.4byte	0xb68
 6635 0b49 1C       		.uleb128 0x1c
 6636 0b4a 7C0A0000 		.4byte	.LASF92
 6637 0b4e 01       		.byte	0x1
 6638 0b4f 6008     		.2byte	0x860
 6639 0b51 44010000 		.4byte	0x144
 6640 0b55 02       		.uleb128 0x2
 6641 0b56 91       		.byte	0x91
 6642 0b57 70       		.sleb128 -16
 6643 0b58 1C       		.uleb128 0x1c
 6644 0b59 8F020000 		.4byte	.LASF128
 6645 0b5d 01       		.byte	0x1
 6646 0b5e 6108     		.2byte	0x861
 6647 0b60 39010000 		.4byte	0x139
 6648 0b64 02       		.uleb128 0x2
 6649 0b65 91       		.byte	0x91
 6650 0b66 74       		.sleb128 -12
 6651 0b67 00       		.byte	0
 6652 0b68 28       		.uleb128 0x28
 6653 0b69 6A020000 		.4byte	.LASF177
 6654 0b6d 01       		.byte	0x1
 6655 0b6e 7D08     		.2byte	0x87d
 6656 0b70 39010000 		.4byte	0x139
 6657 0b74 00000000 		.4byte	.LFB88
 6658 0b78 18000000 		.4byte	.LFE88-.LFB88
 6659 0b7c 01       		.uleb128 0x1
 6660 0b7d 9C       		.byte	0x9c
 6661 0b7e 21       		.uleb128 0x21
 6662 0b7f F00A0000 		.4byte	.LASF136
 6663 0b83 01       		.byte	0x1
 6664 0b84 8508     		.2byte	0x885
 6665 0b86 AB000000 		.4byte	0xab
 6666 0b8a 00000000 		.4byte	.LFB89
 6667 0b8e 2C000000 		.4byte	.LFE89-.LFB89
 6668 0b92 01       		.uleb128 0x1
 6669 0b93 9C       		.byte	0x9c
 6670 0b94 B70B0000 		.4byte	0xbb7
 6671 0b98 1B       		.uleb128 0x1b
 6672 0b99 A5080000 		.4byte	.LASF137
 6673 0b9d 01       		.byte	0x1
 6674 0b9e 8508     		.2byte	0x885
 6675 0ba0 2D020000 		.4byte	0x22d
 6676 0ba4 02       		.uleb128 0x2
 6677 0ba5 91       		.byte	0x91
 6678 0ba6 6C       		.sleb128 -20
 6679 0ba7 1C       		.uleb128 0x1c
 6680 0ba8 4D0D0000 		.4byte	.LASF98
 6681 0bac 01       		.byte	0x1
 6682 0bad 8708     		.2byte	0x887
 6683 0baf 1D050000 		.4byte	0x51d
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 208


 6684 0bb3 02       		.uleb128 0x2
 6685 0bb4 91       		.byte	0x91
 6686 0bb5 74       		.sleb128 -12
 6687 0bb6 00       		.byte	0
 6688 0bb7 1A       		.uleb128 0x1a
 6689 0bb8 A8010000 		.4byte	.LASF138
 6690 0bbc 01       		.byte	0x1
 6691 0bbd C309     		.2byte	0x9c3
 6692 0bbf 2E010000 		.4byte	0x12e
 6693 0bc3 00000000 		.4byte	.LFB90
 6694 0bc7 5C010000 		.4byte	.LFE90-.LFB90
 6695 0bcb 01       		.uleb128 0x1
 6696 0bcc 9C       		.byte	0x9c
 6697 0bcd 310C0000 		.4byte	0xc31
 6698 0bd1 1C       		.uleb128 0x1c
 6699 0bd2 4D0D0000 		.4byte	.LASF98
 6700 0bd6 01       		.byte	0x1
 6701 0bd7 C509     		.2byte	0x9c5
 6702 0bd9 1D050000 		.4byte	0x51d
 6703 0bdd 02       		.uleb128 0x2
 6704 0bde 91       		.byte	0x91
 6705 0bdf 68       		.sleb128 -24
 6706 0be0 1C       		.uleb128 0x1c
 6707 0be1 54090000 		.4byte	.LASF27
 6708 0be5 01       		.byte	0x1
 6709 0be6 C609     		.2byte	0x9c6
 6710 0be8 44010000 		.4byte	0x144
 6711 0bec 02       		.uleb128 0x2
 6712 0bed 91       		.byte	0x91
 6713 0bee 64       		.sleb128 -28
 6714 0bef 1C       		.uleb128 0x1c
 6715 0bf0 C4090000 		.4byte	.LASF139
 6716 0bf4 01       		.byte	0x1
 6717 0bf5 C709     		.2byte	0x9c7
 6718 0bf7 2E010000 		.4byte	0x12e
 6719 0bfb 02       		.uleb128 0x2
 6720 0bfc 91       		.byte	0x91
 6721 0bfd 74       		.sleb128 -12
 6722 0bfe 1D       		.uleb128 0x1d
 6723 0bff 12000000 		.4byte	.LBB42
 6724 0c03 FC000000 		.4byte	.LBE42-.LBB42
 6725 0c07 1C       		.uleb128 0x1c
 6726 0c08 7E040000 		.4byte	.LASF106
 6727 0c0c 01       		.byte	0x1
 6728 0c0d D109     		.2byte	0x9d1
 6729 0c0f C4060000 		.4byte	0x6c4
 6730 0c13 02       		.uleb128 0x2
 6731 0c14 91       		.byte	0x91
 6732 0c15 70       		.sleb128 -16
 6733 0c16 1D       		.uleb128 0x1d
 6734 0c17 26000000 		.4byte	.LBB43
 6735 0c1b 22000000 		.4byte	.LBE43-.LBB43
 6736 0c1f 1C       		.uleb128 0x1c
 6737 0c20 E7040000 		.4byte	.LASF140
 6738 0c24 01       		.byte	0x1
 6739 0c25 D909     		.2byte	0x9d9
 6740 0c27 55070000 		.4byte	0x755
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 209


 6741 0c2b 02       		.uleb128 0x2
 6742 0c2c 91       		.byte	0x91
 6743 0c2d 6C       		.sleb128 -20
 6744 0c2e 00       		.byte	0
 6745 0c2f 00       		.byte	0
 6746 0c30 00       		.byte	0
 6747 0c31 20       		.uleb128 0x20
 6748 0c32 FE080000 		.4byte	.LASF141
 6749 0c36 01       		.byte	0x1
 6750 0c37 C90A     		.2byte	0xac9
 6751 0c39 00000000 		.4byte	.LFB91
 6752 0c3d D4000000 		.4byte	.LFE91-.LFB91
 6753 0c41 01       		.uleb128 0x1
 6754 0c42 9C       		.byte	0x9c
 6755 0c43 D50C0000 		.4byte	0xcd5
 6756 0c47 29       		.uleb128 0x29
 6757 0c48 1C000000 		.4byte	.LBB44
 6758 0c4c 4E000000 		.4byte	.LBE44-.LBB44
 6759 0c50 730C0000 		.4byte	0xc73
 6760 0c54 1C       		.uleb128 0x1c
 6761 0c55 400B0000 		.4byte	.LASF142
 6762 0c59 01       		.byte	0x1
 6763 0c5a F20A     		.2byte	0xaf2
 6764 0c5c D50C0000 		.4byte	0xcd5
 6765 0c60 02       		.uleb128 0x2
 6766 0c61 91       		.byte	0x91
 6767 0c62 74       		.sleb128 -12
 6768 0c63 1C       		.uleb128 0x1c
 6769 0c64 0D070000 		.4byte	.LASF143
 6770 0c68 01       		.byte	0x1
 6771 0c69 F20A     		.2byte	0xaf2
 6772 0c6b CE050000 		.4byte	0x5ce
 6773 0c6f 02       		.uleb128 0x2
 6774 0c70 91       		.byte	0x91
 6775 0c71 70       		.sleb128 -16
 6776 0c72 00       		.byte	0
 6777 0c73 1D       		.uleb128 0x1d
 6778 0c74 6A000000 		.4byte	.LBB45
 6779 0c78 50000000 		.4byte	.LBE45-.LBB45
 6780 0c7c 1C       		.uleb128 0x1c
 6781 0c7d E30B0000 		.4byte	.LASF144
 6782 0c81 01       		.byte	0x1
 6783 0c82 F60A     		.2byte	0xaf6
 6784 0c84 39010000 		.4byte	0x139
 6785 0c88 02       		.uleb128 0x2
 6786 0c89 91       		.byte	0x91
 6787 0c8a 6C       		.sleb128 -20
 6788 0c8b 22       		.uleb128 0x22
 6789 0c8c 35040000 		.4byte	0x435
 6790 0c90 70000000 		.4byte	.LBB46
 6791 0c94 0A000000 		.4byte	.LBE46-.LBB46
 6792 0c98 01       		.byte	0x1
 6793 0c99 F60A     		.2byte	0xaf6
 6794 0c9b BA0C0000 		.4byte	0xcba
 6795 0c9f 25       		.uleb128 0x25
 6796 0ca0 45040000 		.4byte	0x445
 6797 0ca4 02       		.uleb128 0x2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 210


 6798 0ca5 91       		.byte	0x91
 6799 0ca6 64       		.sleb128 -28
 6800 0ca7 1D       		.uleb128 0x1d
 6801 0ca8 70000000 		.4byte	.LBB47
 6802 0cac 0A000000 		.4byte	.LBE47-.LBB47
 6803 0cb0 23       		.uleb128 0x23
 6804 0cb1 50040000 		.4byte	0x450
 6805 0cb5 02       		.uleb128 0x2
 6806 0cb6 91       		.byte	0x91
 6807 0cb7 63       		.sleb128 -29
 6808 0cb8 00       		.byte	0
 6809 0cb9 00       		.byte	0
 6810 0cba 1D       		.uleb128 0x1d
 6811 0cbb 80000000 		.4byte	.LBB48
 6812 0cbf 3A000000 		.4byte	.LBE48-.LBB48
 6813 0cc3 1C       		.uleb128 0x1c
 6814 0cc4 26000000 		.4byte	.LASF145
 6815 0cc8 01       		.byte	0x1
 6816 0cc9 F60A     		.2byte	0xaf6
 6817 0ccb E00C0000 		.4byte	0xce0
 6818 0ccf 02       		.uleb128 0x2
 6819 0cd0 91       		.byte	0x91
 6820 0cd1 68       		.sleb128 -24
 6821 0cd2 00       		.byte	0
 6822 0cd3 00       		.byte	0
 6823 0cd4 00       		.byte	0
 6824 0cd5 07       		.uleb128 0x7
 6825 0cd6 DA0C0000 		.4byte	0xcda
 6826 0cda 06       		.uleb128 0x6
 6827 0cdb 04       		.byte	0x4
 6828 0cdc CE050000 		.4byte	0x5ce
 6829 0ce0 07       		.uleb128 0x7
 6830 0ce1 55070000 		.4byte	0x755
 6831 0ce5 20       		.uleb128 0x20
 6832 0ce6 EE040000 		.4byte	.LASF146
 6833 0cea 01       		.byte	0x1
 6834 0ceb 040B     		.2byte	0xb04
 6835 0ced 00000000 		.4byte	.LFB92
 6836 0cf1 2C000000 		.4byte	.LFE92-.LFB92
 6837 0cf5 01       		.uleb128 0x1
 6838 0cf6 9C       		.byte	0x9c
 6839 0cf7 1A0D0000 		.4byte	0xd1a
 6840 0cfb 1B       		.uleb128 0x1b
 6841 0cfc CE000000 		.4byte	.LASF147
 6842 0d00 01       		.byte	0x1
 6843 0d01 040B     		.2byte	0xb04
 6844 0d03 E00C0000 		.4byte	0xce0
 6845 0d07 02       		.uleb128 0x2
 6846 0d08 91       		.byte	0x91
 6847 0d09 74       		.sleb128 -12
 6848 0d0a 1B       		.uleb128 0x1b
 6849 0d0b 3B0C0000 		.4byte	.LASF148
 6850 0d0f 01       		.byte	0x1
 6851 0d10 040B     		.2byte	0xb04
 6852 0d12 C4060000 		.4byte	0x6c4
 6853 0d16 02       		.uleb128 0x2
 6854 0d17 91       		.byte	0x91
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 211


 6855 0d18 70       		.sleb128 -16
 6856 0d19 00       		.byte	0
 6857 0d1a 20       		.uleb128 0x20
 6858 0d1b 730B0000 		.4byte	.LASF149
 6859 0d1f 01       		.byte	0x1
 6860 0d20 150B     		.2byte	0xb15
 6861 0d22 00000000 		.4byte	.LFB93
 6862 0d26 38000000 		.4byte	.LFE93-.LFB93
 6863 0d2a 01       		.uleb128 0x1
 6864 0d2b 9C       		.byte	0x9c
 6865 0d2c 5E0D0000 		.4byte	0xd5e
 6866 0d30 1B       		.uleb128 0x1b
 6867 0d31 CE000000 		.4byte	.LASF147
 6868 0d35 01       		.byte	0x1
 6869 0d36 150B     		.2byte	0xb15
 6870 0d38 55070000 		.4byte	0x755
 6871 0d3c 02       		.uleb128 0x2
 6872 0d3d 91       		.byte	0x91
 6873 0d3e 74       		.sleb128 -12
 6874 0d3f 1B       		.uleb128 0x1b
 6875 0d40 54090000 		.4byte	.LASF27
 6876 0d44 01       		.byte	0x1
 6877 0d45 150B     		.2byte	0xb15
 6878 0d47 C4060000 		.4byte	0x6c4
 6879 0d4b 02       		.uleb128 0x2
 6880 0d4c 91       		.byte	0x91
 6881 0d4d 70       		.sleb128 -16
 6882 0d4e 1B       		.uleb128 0x1b
 6883 0d4f 3B0C0000 		.4byte	.LASF148
 6884 0d53 01       		.byte	0x1
 6885 0d54 150B     		.2byte	0xb15
 6886 0d56 C4060000 		.4byte	0x6c4
 6887 0d5a 02       		.uleb128 0x2
 6888 0d5b 91       		.byte	0x91
 6889 0d5c 6C       		.sleb128 -20
 6890 0d5d 00       		.byte	0
 6891 0d5e 1A       		.uleb128 0x1a
 6892 0d5f 63050000 		.4byte	.LASF150
 6893 0d63 01       		.byte	0x1
 6894 0d64 4E0B     		.2byte	0xb4e
 6895 0d66 2E010000 		.4byte	0x12e
 6896 0d6a 00000000 		.4byte	.LFB94
 6897 0d6e AC000000 		.4byte	.LFE94-.LFB94
 6898 0d72 01       		.uleb128 0x1
 6899 0d73 9C       		.byte	0x9c
 6900 0d74 A60D0000 		.4byte	0xda6
 6901 0d78 1B       		.uleb128 0x1b
 6902 0d79 CE000000 		.4byte	.LASF147
 6903 0d7d 01       		.byte	0x1
 6904 0d7e 4E0B     		.2byte	0xb4e
 6905 0d80 A60D0000 		.4byte	0xda6
 6906 0d84 02       		.uleb128 0x2
 6907 0d85 91       		.byte	0x91
 6908 0d86 6C       		.sleb128 -20
 6909 0d87 1C       		.uleb128 0x1c
 6910 0d88 F7020000 		.4byte	.LASF151
 6911 0d8c 01       		.byte	0x1
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 212


 6912 0d8d 500B     		.2byte	0xb50
 6913 0d8f 1D050000 		.4byte	0x51d
 6914 0d93 02       		.uleb128 0x2
 6915 0d94 91       		.byte	0x91
 6916 0d95 70       		.sleb128 -16
 6917 0d96 1C       		.uleb128 0x1c
 6918 0d97 7C0A0000 		.4byte	.LASF92
 6919 0d9b 01       		.byte	0x1
 6920 0d9c 510B     		.2byte	0xb51
 6921 0d9e 2E010000 		.4byte	0x12e
 6922 0da2 02       		.uleb128 0x2
 6923 0da3 91       		.byte	0x91
 6924 0da4 74       		.sleb128 -12
 6925 0da5 00       		.byte	0
 6926 0da6 07       		.uleb128 0x7
 6927 0da7 AB0D0000 		.4byte	0xdab
 6928 0dab 06       		.uleb128 0x6
 6929 0dac 04       		.byte	0x4
 6930 0dad B10D0000 		.4byte	0xdb1
 6931 0db1 07       		.uleb128 0x7
 6932 0db2 22020000 		.4byte	0x222
 6933 0db6 1A       		.uleb128 0x1a
 6934 0db7 920B0000 		.4byte	.LASF152
 6935 0dbb 01       		.byte	0x1
 6936 0dbc 920B     		.2byte	0xb92
 6937 0dbe 2E010000 		.4byte	0x12e
 6938 0dc2 00000000 		.4byte	.LFB95
 6939 0dc6 94000000 		.4byte	.LFE95-.LFB95
 6940 0dca 01       		.uleb128 0x1
 6941 0dcb 9C       		.byte	0x9c
 6942 0dcc 0D0E0000 		.4byte	0xe0d
 6943 0dd0 1B       		.uleb128 0x1b
 6944 0dd1 9F0D0000 		.4byte	.LASF153
 6945 0dd5 01       		.byte	0x1
 6946 0dd6 920B     		.2byte	0xb92
 6947 0dd8 1C020000 		.4byte	0x21c
 6948 0ddc 02       		.uleb128 0x2
 6949 0ddd 91       		.byte	0x91
 6950 0dde 6C       		.sleb128 -20
 6951 0ddf 1B       		.uleb128 0x1b
 6952 0de0 54090000 		.4byte	.LASF27
 6953 0de4 01       		.byte	0x1
 6954 0de5 920B     		.2byte	0xb92
 6955 0de7 C4060000 		.4byte	0x6c4
 6956 0deb 02       		.uleb128 0x2
 6957 0dec 91       		.byte	0x91
 6958 0ded 68       		.sleb128 -24
 6959 0dee 1C       		.uleb128 0x1c
 6960 0def F7020000 		.4byte	.LASF151
 6961 0df3 01       		.byte	0x1
 6962 0df4 940B     		.2byte	0xb94
 6963 0df6 1D050000 		.4byte	0x51d
 6964 0dfa 02       		.uleb128 0x2
 6965 0dfb 91       		.byte	0x91
 6966 0dfc 70       		.sleb128 -16
 6967 0dfd 1C       		.uleb128 0x1c
 6968 0dfe 7C0A0000 		.4byte	.LASF92
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 213


 6969 0e02 01       		.byte	0x1
 6970 0e03 950B     		.2byte	0xb95
 6971 0e05 2E010000 		.4byte	0x12e
 6972 0e09 02       		.uleb128 0x2
 6973 0e0a 91       		.byte	0x91
 6974 0e0b 74       		.sleb128 -12
 6975 0e0c 00       		.byte	0
 6976 0e0d 2A       		.uleb128 0x2a
 6977 0e0e 79010000 		.4byte	.LASF154
 6978 0e12 01       		.byte	0x1
 6979 0e13 BF0B     		.2byte	0xbbf
 6980 0e15 00000000 		.4byte	.LFB96
 6981 0e19 2C000000 		.4byte	.LFE96-.LFB96
 6982 0e1d 01       		.uleb128 0x1
 6983 0e1e 9C       		.byte	0x9c
 6984 0e1f 330E0000 		.4byte	0xe33
 6985 0e23 1B       		.uleb128 0x1b
 6986 0e24 F8070000 		.4byte	.LASF155
 6987 0e28 01       		.byte	0x1
 6988 0e29 BF0B     		.2byte	0xbbf
 6989 0e2b 330E0000 		.4byte	0xe33
 6990 0e2f 02       		.uleb128 0x2
 6991 0e30 91       		.byte	0x91
 6992 0e31 74       		.sleb128 -12
 6993 0e32 00       		.byte	0
 6994 0e33 07       		.uleb128 0x7
 6995 0e34 380E0000 		.4byte	0xe38
 6996 0e38 06       		.uleb128 0x6
 6997 0e39 04       		.byte	0x4
 6998 0e3a C7020000 		.4byte	0x2c7
 6999 0e3e 1A       		.uleb128 0x1a
 7000 0e3f 0F0A0000 		.4byte	.LASF156
 7001 0e43 01       		.byte	0x1
 7002 0e44 C70B     		.2byte	0xbc7
 7003 0e46 2E010000 		.4byte	0x12e
 7004 0e4a 00000000 		.4byte	.LFB97
 7005 0e4e 88000000 		.4byte	.LFE97-.LFB97
 7006 0e52 01       		.uleb128 0x1
 7007 0e53 9C       		.byte	0x9c
 7008 0e54 9F0E0000 		.4byte	0xe9f
 7009 0e58 1B       		.uleb128 0x1b
 7010 0e59 F8070000 		.4byte	.LASF155
 7011 0e5d 01       		.byte	0x1
 7012 0e5e C70B     		.2byte	0xbc7
 7013 0e60 330E0000 		.4byte	0xe33
 7014 0e64 02       		.uleb128 0x2
 7015 0e65 91       		.byte	0x91
 7016 0e66 6C       		.sleb128 -20
 7017 0e67 1B       		.uleb128 0x1b
 7018 0e68 D50B0000 		.4byte	.LASF157
 7019 0e6c 01       		.byte	0x1
 7020 0e6d C70B     		.2byte	0xbc7
 7021 0e6f B9060000 		.4byte	0x6b9
 7022 0e73 02       		.uleb128 0x2
 7023 0e74 91       		.byte	0x91
 7024 0e75 68       		.sleb128 -24
 7025 0e76 1C       		.uleb128 0x1c
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 214


 7026 0e77 7C0A0000 		.4byte	.LASF92
 7027 0e7b 01       		.byte	0x1
 7028 0e7c C90B     		.2byte	0xbc9
 7029 0e7e 2E010000 		.4byte	0x12e
 7030 0e82 02       		.uleb128 0x2
 7031 0e83 91       		.byte	0x91
 7032 0e84 74       		.sleb128 -12
 7033 0e85 1D       		.uleb128 0x1d
 7034 0e86 0E000000 		.4byte	.LBB49
 7035 0e8a 64000000 		.4byte	.LBE49-.LBB49
 7036 0e8e 1C       		.uleb128 0x1c
 7037 0e8f 7E040000 		.4byte	.LASF106
 7038 0e93 01       		.byte	0x1
 7039 0e94 D10B     		.2byte	0xbd1
 7040 0e96 C4060000 		.4byte	0x6c4
 7041 0e9a 02       		.uleb128 0x2
 7042 0e9b 91       		.byte	0x91
 7043 0e9c 70       		.sleb128 -16
 7044 0e9d 00       		.byte	0
 7045 0e9e 00       		.byte	0
 7046 0e9f 27       		.uleb128 0x27
 7047 0ea0 8D0A0000 		.4byte	.LASF159
 7048 0ea4 01       		.byte	0x1
 7049 0ea5 040C     		.2byte	0xc04
 7050 0ea7 00000000 		.4byte	.LFB98
 7051 0eab 18000000 		.4byte	.LFE98-.LFB98
 7052 0eaf 01       		.uleb128 0x1
 7053 0eb0 9C       		.byte	0x9c
 7054 0eb1 1E       		.uleb128 0x1e
 7055 0eb2 D9050000 		.4byte	.LASF160
 7056 0eb6 01       		.byte	0x1
 7057 0eb7 3B0C     		.2byte	0xc3b
 7058 0eb9 00000000 		.4byte	.LFB99
 7059 0ebd 0E000000 		.4byte	.LFE99-.LFB99
 7060 0ec1 01       		.uleb128 0x1
 7061 0ec2 9C       		.byte	0x9c
 7062 0ec3 D70E0000 		.4byte	0xed7
 7063 0ec7 1B       		.uleb128 0x1b
 7064 0ec8 47090000 		.4byte	.LASF89
 7065 0ecc 01       		.byte	0x1
 7066 0ecd 3B0C     		.2byte	0xc3b
 7067 0ecf A9000000 		.4byte	0xa9
 7068 0ed3 02       		.uleb128 0x2
 7069 0ed4 91       		.byte	0x91
 7070 0ed5 74       		.sleb128 -12
 7071 0ed6 00       		.byte	0
 7072 0ed7 1E       		.uleb128 0x1e
 7073 0ed8 880D0000 		.4byte	.LASF161
 7074 0edc 01       		.byte	0x1
 7075 0edd 050D     		.2byte	0xd05
 7076 0edf 00000000 		.4byte	.LFB100
 7077 0ee3 7C000000 		.4byte	.LFE100-.LFB100
 7078 0ee7 01       		.uleb128 0x1
 7079 0ee8 9C       		.byte	0x9c
 7080 0ee9 FD0E0000 		.4byte	0xefd
 7081 0eed 1C       		.uleb128 0x1c
 7082 0eee 1B000000 		.4byte	.LASF68
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 215


 7083 0ef2 01       		.byte	0x1
 7084 0ef3 070D     		.2byte	0xd07
 7085 0ef5 39010000 		.4byte	0x139
 7086 0ef9 02       		.uleb128 0x2
 7087 0efa 91       		.byte	0x91
 7088 0efb 74       		.sleb128 -12
 7089 0efc 00       		.byte	0
 7090 0efd 1E       		.uleb128 0x1e
 7091 0efe BD0D0000 		.4byte	.LASF162
 7092 0f02 01       		.byte	0x1
 7093 0f03 250D     		.2byte	0xd25
 7094 0f05 00000000 		.4byte	.LFB101
 7095 0f09 74000000 		.4byte	.LFE101-.LFB101
 7096 0f0d 01       		.uleb128 0x1
 7097 0f0e 9C       		.byte	0x9c
 7098 0f0f 460F0000 		.4byte	0xf46
 7099 0f13 1D       		.uleb128 0x1d
 7100 0f14 06000000 		.4byte	.LBB50
 7101 0f18 5C000000 		.4byte	.LBE50-.LBB50
 7102 0f1c 1C       		.uleb128 0x1c
 7103 0f1d EE050000 		.4byte	.LASF163
 7104 0f21 01       		.byte	0x1
 7105 0f22 2C0D     		.2byte	0xd2c
 7106 0f24 2E010000 		.4byte	0x12e
 7107 0f28 02       		.uleb128 0x2
 7108 0f29 91       		.byte	0x91
 7109 0f2a 74       		.sleb128 -12
 7110 0f2b 1D       		.uleb128 0x1d
 7111 0f2c 26000000 		.4byte	.LBB51
 7112 0f30 34000000 		.4byte	.LBE51-.LBB51
 7113 0f34 1C       		.uleb128 0x1c
 7114 0f35 4D0D0000 		.4byte	.LASF98
 7115 0f39 01       		.byte	0x1
 7116 0f3a 3A0D     		.2byte	0xd3a
 7117 0f3c 1D050000 		.4byte	0x51d
 7118 0f40 02       		.uleb128 0x2
 7119 0f41 91       		.byte	0x91
 7120 0f42 70       		.sleb128 -16
 7121 0f43 00       		.byte	0
 7122 0f44 00       		.byte	0
 7123 0f45 00       		.byte	0
 7124 0f46 26       		.uleb128 0x26
 7125 0f47 9D0C0000 		.4byte	.LASF165
 7126 0f4b 01       		.byte	0x1
 7127 0f4c CD0D     		.2byte	0xdcd
 7128 0f4e CE000000 		.4byte	0xce
 7129 0f52 00000000 		.4byte	.LFB102
 7130 0f56 38000000 		.4byte	.LFE102-.LFB102
 7131 0f5a 01       		.uleb128 0x1
 7132 0f5b 9C       		.byte	0x9c
 7133 0f5c 7F0F0000 		.4byte	0xf7f
 7134 0f60 1B       		.uleb128 0x1b
 7135 0f61 47040000 		.4byte	.LASF166
 7136 0f65 01       		.byte	0x1
 7137 0f66 CD0D     		.2byte	0xdcd
 7138 0f68 7F0F0000 		.4byte	0xf7f
 7139 0f6c 02       		.uleb128 0x2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 216


 7140 0f6d 91       		.byte	0x91
 7141 0f6e 6C       		.sleb128 -20
 7142 0f6f 1C       		.uleb128 0x1c
 7143 0f70 B1040000 		.4byte	.LASF167
 7144 0f74 01       		.byte	0x1
 7145 0f75 CF0D     		.2byte	0xdcf
 7146 0f77 E4000000 		.4byte	0xe4
 7147 0f7b 02       		.uleb128 0x2
 7148 0f7c 91       		.byte	0x91
 7149 0f7d 74       		.sleb128 -12
 7150 0f7e 00       		.byte	0
 7151 0f7f 06       		.uleb128 0x6
 7152 0f80 04       		.byte	0x4
 7153 0f81 850F0000 		.4byte	0xf85
 7154 0f85 07       		.uleb128 0x7
 7155 0f86 C3000000 		.4byte	0xc3
 7156 0f8a 1A       		.uleb128 0x1a
 7157 0f8b FB030000 		.4byte	.LASF168
 7158 0f8f 01       		.byte	0x1
 7159 0f90 E10D     		.2byte	0xde1
 7160 0f92 39010000 		.4byte	0x139
 7161 0f96 00000000 		.4byte	.LFB103
 7162 0f9a 38000000 		.4byte	.LFE103-.LFB103
 7163 0f9e 01       		.uleb128 0x1
 7164 0f9f 9C       		.byte	0x9c
 7165 0fa0 E10F0000 		.4byte	0xfe1
 7166 0fa4 1B       		.uleb128 0x1b
 7167 0fa5 CB080000 		.4byte	.LASF111
 7168 0fa9 01       		.byte	0x1
 7169 0faa E10D     		.2byte	0xde1
 7170 0fac 2D020000 		.4byte	0x22d
 7171 0fb0 02       		.uleb128 0x2
 7172 0fb1 91       		.byte	0x91
 7173 0fb2 64       		.sleb128 -28
 7174 0fb3 1C       		.uleb128 0x1c
 7175 0fb4 4D0D0000 		.4byte	.LASF98
 7176 0fb8 01       		.byte	0x1
 7177 0fb9 E30D     		.2byte	0xde3
 7178 0fbb 1D050000 		.4byte	0x51d
 7179 0fbf 02       		.uleb128 0x2
 7180 0fc0 91       		.byte	0x91
 7181 0fc1 74       		.sleb128 -12
 7182 0fc2 1C       		.uleb128 0x1c
 7183 0fc3 E20A0000 		.4byte	.LASF169
 7184 0fc7 01       		.byte	0x1
 7185 0fc8 E40D     		.2byte	0xde4
 7186 0fca 4F010000 		.4byte	0x14f
 7187 0fce 02       		.uleb128 0x2
 7188 0fcf 91       		.byte	0x91
 7189 0fd0 70       		.sleb128 -16
 7190 0fd1 1C       		.uleb128 0x1c
 7191 0fd2 61020000 		.4byte	.LASF115
 7192 0fd6 01       		.byte	0x1
 7193 0fd7 E50D     		.2byte	0xde5
 7194 0fd9 39010000 		.4byte	0x139
 7195 0fdd 02       		.uleb128 0x2
 7196 0fde 91       		.byte	0x91
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 217


 7197 0fdf 6C       		.sleb128 -20
 7198 0fe0 00       		.byte	0
 7199 0fe1 1E       		.uleb128 0x1e
 7200 0fe2 500C0000 		.4byte	.LASF170
 7201 0fe6 01       		.byte	0x1
 7202 0fe7 FD0D     		.2byte	0xdfd
 7203 0fe9 00000000 		.4byte	.LFB104
 7204 0fed 1E000000 		.4byte	.LFE104-.LFB104
 7205 0ff1 01       		.uleb128 0x1
 7206 0ff2 9C       		.byte	0x9c
 7207 0ff3 07100000 		.4byte	0x1007
 7208 0ff7 1B       		.uleb128 0x1b
 7209 0ff8 4D0D0000 		.4byte	.LASF98
 7210 0ffc 01       		.byte	0x1
 7211 0ffd FD0D     		.2byte	0xdfd
 7212 0fff 1D050000 		.4byte	0x51d
 7213 1003 02       		.uleb128 0x2
 7214 1004 91       		.byte	0x91
 7215 1005 74       		.sleb128 -12
 7216 1006 00       		.byte	0
 7217 1007 2B       		.uleb128 0x2b
 7218 1008 1A070000 		.4byte	.LASF171
 7219 100c 01       		.byte	0x1
 7220 100d 330E     		.2byte	0xe33
 7221 100f 00000000 		.4byte	.LFB105
 7222 1013 48000000 		.4byte	.LFE105-.LFB105
 7223 1017 01       		.uleb128 0x1
 7224 1018 9C       		.byte	0x9c
 7225 1019 2D100000 		.4byte	0x102d
 7226 101d 1C       		.uleb128 0x1c
 7227 101e 4D0D0000 		.4byte	.LASF98
 7228 1022 01       		.byte	0x1
 7229 1023 350E     		.2byte	0xe35
 7230 1025 1D050000 		.4byte	0x51d
 7231 1029 02       		.uleb128 0x2
 7232 102a 91       		.byte	0x91
 7233 102b 74       		.sleb128 -12
 7234 102c 00       		.byte	0
 7235 102d 21       		.uleb128 0x21
 7236 102e 830C0000 		.4byte	.LASF172
 7237 1032 01       		.byte	0x1
 7238 1033 4D0E     		.2byte	0xe4d
 7239 1035 2D020000 		.4byte	0x22d
 7240 1039 00000000 		.4byte	.LFB106
 7241 103d 20000000 		.4byte	.LFE106-.LFB106
 7242 1041 01       		.uleb128 0x1
 7243 1042 9C       		.byte	0x9c
 7244 1043 57100000 		.4byte	0x1057
 7245 1047 1C       		.uleb128 0x1c
 7246 1048 7C0A0000 		.4byte	.LASF92
 7247 104c 01       		.byte	0x1
 7248 104d 4F0E     		.2byte	0xe4f
 7249 104f 2D020000 		.4byte	0x22d
 7250 1053 02       		.uleb128 0x2
 7251 1054 91       		.byte	0x91
 7252 1055 74       		.sleb128 -12
 7253 1056 00       		.byte	0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 218


 7254 1057 20       		.uleb128 0x20
 7255 1058 F4000000 		.4byte	.LASF173
 7256 105c 01       		.byte	0x1
 7257 105d 7A0E     		.2byte	0xe7a
 7258 105f 00000000 		.4byte	.LFB107
 7259 1063 F0000000 		.4byte	.LFE107-.LFB107
 7260 1067 01       		.uleb128 0x1
 7261 1068 9C       		.byte	0x9c
 7262 1069 8C100000 		.4byte	0x108c
 7263 106d 1B       		.uleb128 0x1b
 7264 106e D4090000 		.4byte	.LASF174
 7265 1072 01       		.byte	0x1
 7266 1073 7A0E     		.2byte	0xe7a
 7267 1075 40090000 		.4byte	0x940
 7268 1079 02       		.uleb128 0x2
 7269 107a 91       		.byte	0x91
 7270 107b 6C       		.sleb128 -20
 7271 107c 1C       		.uleb128 0x1c
 7272 107d 4D0D0000 		.4byte	.LASF98
 7273 1081 01       		.byte	0x1
 7274 1082 7C0E     		.2byte	0xe7c
 7275 1084 7A090000 		.4byte	0x97a
 7276 1088 02       		.uleb128 0x2
 7277 1089 91       		.byte	0x91
 7278 108a 74       		.sleb128 -12
 7279 108b 00       		.byte	0
 7280 108c 1A       		.uleb128 0x1a
 7281 108d 4B050000 		.4byte	.LASF175
 7282 1091 01       		.byte	0x1
 7283 1092 BC0E     		.2byte	0xebc
 7284 1094 2E010000 		.4byte	0x12e
 7285 1098 00000000 		.4byte	.LFB108
 7286 109c CC000000 		.4byte	.LFE108-.LFB108
 7287 10a0 01       		.uleb128 0x1
 7288 10a1 9C       		.byte	0x9c
 7289 10a2 D4100000 		.4byte	0x10d4
 7290 10a6 1B       		.uleb128 0x1b
 7291 10a7 D4090000 		.4byte	.LASF174
 7292 10ab 01       		.byte	0x1
 7293 10ac BC0E     		.2byte	0xebc
 7294 10ae 40090000 		.4byte	0x940
 7295 10b2 02       		.uleb128 0x2
 7296 10b3 91       		.byte	0x91
 7297 10b4 6C       		.sleb128 -20
 7298 10b5 1C       		.uleb128 0x1c
 7299 10b6 4D0D0000 		.4byte	.LASF98
 7300 10ba 01       		.byte	0x1
 7301 10bb BE0E     		.2byte	0xebe
 7302 10bd 7A090000 		.4byte	0x97a
 7303 10c1 02       		.uleb128 0x2
 7304 10c2 91       		.byte	0x91
 7305 10c3 70       		.sleb128 -16
 7306 10c4 1C       		.uleb128 0x1c
 7307 10c5 7C0A0000 		.4byte	.LASF92
 7308 10c9 01       		.byte	0x1
 7309 10ca BF0E     		.2byte	0xebf
 7310 10cc 2E010000 		.4byte	0x12e
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 219


 7311 10d0 02       		.uleb128 0x2
 7312 10d1 91       		.byte	0x91
 7313 10d2 74       		.sleb128 -12
 7314 10d3 00       		.byte	0
 7315 10d4 21       		.uleb128 0x21
 7316 10d5 68080000 		.4byte	.LASF176
 7317 10d9 01       		.byte	0x1
 7318 10da 4210     		.2byte	0x1042
 7319 10dc 44010000 		.4byte	0x144
 7320 10e0 00000000 		.4byte	.LFB109
 7321 10e4 30000000 		.4byte	.LFE109-.LFB109
 7322 10e8 01       		.uleb128 0x1
 7323 10e9 9C       		.byte	0x9c
 7324 10ea FE100000 		.4byte	0x10fe
 7325 10ee 1C       		.uleb128 0x1c
 7326 10ef 61020000 		.4byte	.LASF115
 7327 10f3 01       		.byte	0x1
 7328 10f4 4410     		.2byte	0x1044
 7329 10f6 44010000 		.4byte	0x144
 7330 10fa 02       		.uleb128 0x2
 7331 10fb 91       		.byte	0x91
 7332 10fc 74       		.sleb128 -12
 7333 10fd 00       		.byte	0
 7334 10fe 28       		.uleb128 0x28
 7335 10ff 0F050000 		.4byte	.LASF178
 7336 1103 01       		.byte	0x1
 7337 1104 5210     		.2byte	0x1052
 7338 1106 A9000000 		.4byte	0xa9
 7339 110a 00000000 		.4byte	.LFB110
 7340 110e 28000000 		.4byte	.LFE110-.LFB110
 7341 1112 01       		.uleb128 0x1
 7342 1113 9C       		.byte	0x9c
 7343 1114 1A       		.uleb128 0x1a
 7344 1115 FB050000 		.4byte	.LASF179
 7345 1119 01       		.byte	0x1
 7346 111a 6310     		.2byte	0x1063
 7347 111c E4000000 		.4byte	0xe4
 7348 1120 00000000 		.4byte	.LFB111
 7349 1124 90000000 		.4byte	.LFE111-.LFB111
 7350 1128 01       		.uleb128 0x1
 7351 1129 9C       		.byte	0x9c
 7352 112a 5C110000 		.4byte	0x115c
 7353 112e 1B       		.uleb128 0x1b
 7354 112f 13030000 		.4byte	.LASF180
 7355 1133 01       		.byte	0x1
 7356 1134 6310     		.2byte	0x1063
 7357 1136 2E010000 		.4byte	0x12e
 7358 113a 02       		.uleb128 0x2
 7359 113b 91       		.byte	0x91
 7360 113c 6C       		.sleb128 -20
 7361 113d 1B       		.uleb128 0x1b
 7362 113e 3B0C0000 		.4byte	.LASF148
 7363 1142 01       		.byte	0x1
 7364 1143 6310     		.2byte	0x1063
 7365 1145 44010000 		.4byte	0x144
 7366 1149 02       		.uleb128 0x2
 7367 114a 91       		.byte	0x91
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 220


 7368 114b 68       		.sleb128 -24
 7369 114c 1C       		.uleb128 0x1c
 7370 114d DD0D0000 		.4byte	.LASF181
 7371 1151 01       		.byte	0x1
 7372 1152 6510     		.2byte	0x1065
 7373 1154 E4000000 		.4byte	0xe4
 7374 1158 02       		.uleb128 0x2
 7375 1159 91       		.byte	0x91
 7376 115a 74       		.sleb128 -12
 7377 115b 00       		.byte	0
 7378 115c 1A       		.uleb128 0x1a
 7379 115d 1B060000 		.4byte	.LASF182
 7380 1161 01       		.byte	0x1
 7381 1162 A710     		.2byte	0x10a7
 7382 1164 2E010000 		.4byte	0x12e
 7383 1168 00000000 		.4byte	.LFB112
 7384 116c B4000000 		.4byte	.LFE112-.LFB112
 7385 1170 01       		.uleb128 0x1
 7386 1171 9C       		.byte	0x9c
 7387 1172 C2110000 		.4byte	0x11c2
 7388 1176 1B       		.uleb128 0x1b
 7389 1177 82030000 		.4byte	.LASF183
 7390 117b 01       		.byte	0x1
 7391 117c A710     		.2byte	0x10a7
 7392 117e E4000000 		.4byte	0xe4
 7393 1182 02       		.uleb128 0x2
 7394 1183 91       		.byte	0x91
 7395 1184 6C       		.sleb128 -20
 7396 1185 1B       		.uleb128 0x1b
 7397 1186 61000000 		.4byte	.LASF184
 7398 118a 01       		.byte	0x1
 7399 118b A710     		.2byte	0x10a7
 7400 118d E4000000 		.4byte	0xe4
 7401 1191 02       		.uleb128 0x2
 7402 1192 91       		.byte	0x91
 7403 1193 68       		.sleb128 -24
 7404 1194 1B       		.uleb128 0x1b
 7405 1195 670A0000 		.4byte	.LASF185
 7406 1199 01       		.byte	0x1
 7407 119a A710     		.2byte	0x10a7
 7408 119c C2110000 		.4byte	0x11c2
 7409 11a0 02       		.uleb128 0x2
 7410 11a1 91       		.byte	0x91
 7411 11a2 64       		.sleb128 -28
 7412 11a3 1B       		.uleb128 0x1b
 7413 11a4 3B0C0000 		.4byte	.LASF148
 7414 11a8 01       		.byte	0x1
 7415 11a9 A710     		.2byte	0x10a7
 7416 11ab 44010000 		.4byte	0x144
 7417 11af 02       		.uleb128 0x2
 7418 11b0 91       		.byte	0x91
 7419 11b1 60       		.sleb128 -32
 7420 11b2 1C       		.uleb128 0x1c
 7421 11b3 7C0A0000 		.4byte	.LASF92
 7422 11b7 01       		.byte	0x1
 7423 11b8 A910     		.2byte	0x10a9
 7424 11ba 2E010000 		.4byte	0x12e
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 221


 7425 11be 02       		.uleb128 0x2
 7426 11bf 91       		.byte	0x91
 7427 11c0 74       		.sleb128 -12
 7428 11c1 00       		.byte	0
 7429 11c2 06       		.uleb128 0x6
 7430 11c3 04       		.byte	0x4
 7431 11c4 E4000000 		.4byte	0xe4
 7432 11c8 1A       		.uleb128 0x1a
 7433 11c9 DE020000 		.4byte	.LASF186
 7434 11cd 01       		.byte	0x1
 7435 11ce F710     		.2byte	0x10f7
 7436 11d0 2E010000 		.4byte	0x12e
 7437 11d4 00000000 		.4byte	.LFB113
 7438 11d8 10010000 		.4byte	.LFE113-.LFB113
 7439 11dc 01       		.uleb128 0x1
 7440 11dd 9C       		.byte	0x9c
 7441 11de 4C120000 		.4byte	0x124c
 7442 11e2 1B       		.uleb128 0x1b
 7443 11e3 BD080000 		.4byte	.LASF187
 7444 11e7 01       		.byte	0x1
 7445 11e8 F710     		.2byte	0x10f7
 7446 11ea 2D020000 		.4byte	0x22d
 7447 11ee 02       		.uleb128 0x2
 7448 11ef 91       		.byte	0x91
 7449 11f0 64       		.sleb128 -28
 7450 11f1 1B       		.uleb128 0x1b
 7451 11f2 F8090000 		.4byte	.LASF188
 7452 11f6 01       		.byte	0x1
 7453 11f7 F710     		.2byte	0x10f7
 7454 11f9 E4000000 		.4byte	0xe4
 7455 11fd 02       		.uleb128 0x2
 7456 11fe 91       		.byte	0x91
 7457 11ff 60       		.sleb128 -32
 7458 1200 1B       		.uleb128 0x1b
 7459 1201 51080000 		.4byte	.LASF189
 7460 1205 01       		.byte	0x1
 7461 1206 F710     		.2byte	0x10f7
 7462 1208 97020000 		.4byte	0x297
 7463 120c 02       		.uleb128 0x2
 7464 120d 91       		.byte	0x91
 7465 120e 5F       		.sleb128 -33
 7466 120f 1B       		.uleb128 0x1b
 7467 1210 4A0A0000 		.4byte	.LASF190
 7468 1214 01       		.byte	0x1
 7469 1215 F710     		.2byte	0x10f7
 7470 1217 C2110000 		.4byte	0x11c2
 7471 121b 02       		.uleb128 0x2
 7472 121c 91       		.byte	0x91
 7473 121d 58       		.sleb128 -40
 7474 121e 1C       		.uleb128 0x1c
 7475 121f 4D0D0000 		.4byte	.LASF98
 7476 1223 01       		.byte	0x1
 7477 1224 F910     		.2byte	0x10f9
 7478 1226 1D050000 		.4byte	0x51d
 7479 122a 02       		.uleb128 0x2
 7480 122b 91       		.byte	0x91
 7481 122c 70       		.sleb128 -16
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 222


 7482 122d 1C       		.uleb128 0x1c
 7483 122e 7C0A0000 		.4byte	.LASF92
 7484 1232 01       		.byte	0x1
 7485 1233 FA10     		.2byte	0x10fa
 7486 1235 2E010000 		.4byte	0x12e
 7487 1239 02       		.uleb128 0x2
 7488 123a 91       		.byte	0x91
 7489 123b 74       		.sleb128 -12
 7490 123c 1C       		.uleb128 0x1c
 7491 123d 63010000 		.4byte	.LASF191
 7492 1241 01       		.byte	0x1
 7493 1242 FB10     		.2byte	0x10fb
 7494 1244 C3000000 		.4byte	0xc3
 7495 1248 02       		.uleb128 0x2
 7496 1249 91       		.byte	0x91
 7497 124a 6F       		.sleb128 -17
 7498 124b 00       		.byte	0
 7499 124c 1A       		.uleb128 0x1a
 7500 124d 8E010000 		.4byte	.LASF192
 7501 1251 01       		.byte	0x1
 7502 1252 6111     		.2byte	0x1161
 7503 1254 2E010000 		.4byte	0x12e
 7504 1258 00000000 		.4byte	.LFB114
 7505 125c 54010000 		.4byte	.LFE114-.LFB114
 7506 1260 01       		.uleb128 0x1
 7507 1261 9C       		.byte	0x9c
 7508 1262 36130000 		.4byte	0x1336
 7509 1266 1B       		.uleb128 0x1b
 7510 1267 BD080000 		.4byte	.LASF187
 7511 126b 01       		.byte	0x1
 7512 126c 6111     		.2byte	0x1161
 7513 126e 2D020000 		.4byte	0x22d
 7514 1272 02       		.uleb128 0x2
 7515 1273 91       		.byte	0x91
 7516 1274 54       		.sleb128 -44
 7517 1275 1B       		.uleb128 0x1b
 7518 1276 F8090000 		.4byte	.LASF188
 7519 127a 01       		.byte	0x1
 7520 127b 6111     		.2byte	0x1161
 7521 127d E4000000 		.4byte	0xe4
 7522 1281 02       		.uleb128 0x2
 7523 1282 91       		.byte	0x91
 7524 1283 50       		.sleb128 -48
 7525 1284 1B       		.uleb128 0x1b
 7526 1285 51080000 		.4byte	.LASF189
 7527 1289 01       		.byte	0x1
 7528 128a 6111     		.2byte	0x1161
 7529 128c 97020000 		.4byte	0x297
 7530 1290 02       		.uleb128 0x2
 7531 1291 91       		.byte	0x91
 7532 1292 4F       		.sleb128 -49
 7533 1293 1B       		.uleb128 0x1b
 7534 1294 4A0A0000 		.4byte	.LASF190
 7535 1298 01       		.byte	0x1
 7536 1299 6111     		.2byte	0x1161
 7537 129b C2110000 		.4byte	0x11c2
 7538 129f 02       		.uleb128 0x2
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 223


 7539 12a0 91       		.byte	0x91
 7540 12a1 48       		.sleb128 -56
 7541 12a2 1B       		.uleb128 0x1b
 7542 12a3 8A000000 		.4byte	.LASF193
 7543 12a7 01       		.byte	0x1
 7544 12a8 6111     		.2byte	0x1161
 7545 12aa 36130000 		.4byte	0x1336
 7546 12ae 02       		.uleb128 0x2
 7547 12af 91       		.byte	0x91
 7548 12b0 00       		.sleb128 0
 7549 12b1 1C       		.uleb128 0x1c
 7550 12b2 4D0D0000 		.4byte	.LASF98
 7551 12b6 01       		.byte	0x1
 7552 12b7 6311     		.2byte	0x1163
 7553 12b9 1D050000 		.4byte	0x51d
 7554 12bd 02       		.uleb128 0x2
 7555 12be 91       		.byte	0x91
 7556 12bf 70       		.sleb128 -16
 7557 12c0 1C       		.uleb128 0x1c
 7558 12c1 63010000 		.4byte	.LASF191
 7559 12c5 01       		.byte	0x1
 7560 12c6 6411     		.2byte	0x1164
 7561 12c8 C3000000 		.4byte	0xc3
 7562 12cc 02       		.uleb128 0x2
 7563 12cd 91       		.byte	0x91
 7564 12ce 6B       		.sleb128 -21
 7565 12cf 1C       		.uleb128 0x1c
 7566 12d0 7C0A0000 		.4byte	.LASF92
 7567 12d4 01       		.byte	0x1
 7568 12d5 6511     		.2byte	0x1165
 7569 12d7 2E010000 		.4byte	0x12e
 7570 12db 02       		.uleb128 0x2
 7571 12dc 91       		.byte	0x91
 7572 12dd 74       		.sleb128 -12
 7573 12de 1C       		.uleb128 0x1c
 7574 12df 8F020000 		.4byte	.LASF128
 7575 12e3 01       		.byte	0x1
 7576 12e4 6611     		.2byte	0x1166
 7577 12e6 39010000 		.4byte	0x139
 7578 12ea 02       		.uleb128 0x2
 7579 12eb 91       		.byte	0x91
 7580 12ec 6C       		.sleb128 -20
 7581 12ed 22       		.uleb128 0x22
 7582 12ee DC030000 		.4byte	0x3dc
 7583 12f2 18000000 		.4byte	.LBB52
 7584 12f6 1A000000 		.4byte	.LBE52-.LBB52
 7585 12fa 01       		.byte	0x1
 7586 12fb 7E11     		.2byte	0x117e
 7587 12fd 1C130000 		.4byte	0x131c
 7588 1301 1D       		.uleb128 0x1d
 7589 1302 18000000 		.4byte	.LBB53
 7590 1306 1A000000 		.4byte	.LBE53-.LBB53
 7591 130a 23       		.uleb128 0x23
 7592 130b EC030000 		.4byte	0x3ec
 7593 130f 02       		.uleb128 0x2
 7594 1310 91       		.byte	0x91
 7595 1311 64       		.sleb128 -28
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 224


 7596 1312 23       		.uleb128 0x23
 7597 1313 F7030000 		.4byte	0x3f7
 7598 1317 02       		.uleb128 0x2
 7599 1318 91       		.byte	0x91
 7600 1319 60       		.sleb128 -32
 7601 131a 00       		.byte	0
 7602 131b 00       		.byte	0
 7603 131c 24       		.uleb128 0x24
 7604 131d 03040000 		.4byte	0x403
 7605 1321 2C010000 		.4byte	.LBB54
 7606 1325 06000000 		.4byte	.LBE54-.LBB54
 7607 1329 01       		.byte	0x1
 7608 132a D311     		.2byte	0x11d3
 7609 132c 25       		.uleb128 0x25
 7610 132d 10040000 		.4byte	0x410
 7611 1331 02       		.uleb128 0x2
 7612 1332 91       		.byte	0x91
 7613 1333 5C       		.sleb128 -36
 7614 1334 00       		.byte	0
 7615 1335 00       		.byte	0
 7616 1336 06       		.uleb128 0x6
 7617 1337 04       		.byte	0x4
 7618 1338 2E010000 		.4byte	0x12e
 7619 133c 20       		.uleb128 0x20
 7620 133d 84090000 		.4byte	.LASF194
 7621 1341 01       		.byte	0x1
 7622 1342 DD11     		.2byte	0x11dd
 7623 1344 00000000 		.4byte	.LFB115
 7624 1348 E8000000 		.4byte	.LFE115-.LFB115
 7625 134c 01       		.uleb128 0x1
 7626 134d 9C       		.byte	0x9c
 7627 134e E6130000 		.4byte	0x13e6
 7628 1352 1B       		.uleb128 0x1b
 7629 1353 BD080000 		.4byte	.LASF187
 7630 1357 01       		.byte	0x1
 7631 1358 DD11     		.2byte	0x11dd
 7632 135a 2D020000 		.4byte	0x22d
 7633 135e 02       		.uleb128 0x2
 7634 135f 91       		.byte	0x91
 7635 1360 5C       		.sleb128 -36
 7636 1361 1B       		.uleb128 0x1b
 7637 1362 8A000000 		.4byte	.LASF193
 7638 1366 01       		.byte	0x1
 7639 1367 DD11     		.2byte	0x11dd
 7640 1369 36130000 		.4byte	0x1336
 7641 136d 02       		.uleb128 0x2
 7642 136e 91       		.byte	0x91
 7643 136f 58       		.sleb128 -40
 7644 1370 1C       		.uleb128 0x1c
 7645 1371 4D0D0000 		.4byte	.LASF98
 7646 1375 01       		.byte	0x1
 7647 1376 DF11     		.2byte	0x11df
 7648 1378 1D050000 		.4byte	0x51d
 7649 137c 02       		.uleb128 0x2
 7650 137d 91       		.byte	0x91
 7651 137e 74       		.sleb128 -12
 7652 137f 1C       		.uleb128 0x1c
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 225


 7653 1380 63010000 		.4byte	.LASF191
 7654 1384 01       		.byte	0x1
 7655 1385 E011     		.2byte	0x11e0
 7656 1387 C3000000 		.4byte	0xc3
 7657 138b 02       		.uleb128 0x2
 7658 138c 91       		.byte	0x91
 7659 138d 6F       		.sleb128 -17
 7660 138e 1C       		.uleb128 0x1c
 7661 138f 8F020000 		.4byte	.LASF128
 7662 1393 01       		.byte	0x1
 7663 1394 E111     		.2byte	0x11e1
 7664 1396 39010000 		.4byte	0x139
 7665 139a 02       		.uleb128 0x2
 7666 139b 91       		.byte	0x91
 7667 139c 70       		.sleb128 -16
 7668 139d 22       		.uleb128 0x22
 7669 139e DC030000 		.4byte	0x3dc
 7670 13a2 0E000000 		.4byte	.LBB56
 7671 13a6 1A000000 		.4byte	.LBE56-.LBB56
 7672 13aa 01       		.byte	0x1
 7673 13ab F911     		.2byte	0x11f9
 7674 13ad CC130000 		.4byte	0x13cc
 7675 13b1 1D       		.uleb128 0x1d
 7676 13b2 0E000000 		.4byte	.LBB57
 7677 13b6 1A000000 		.4byte	.LBE57-.LBB57
 7678 13ba 23       		.uleb128 0x23
 7679 13bb EC030000 		.4byte	0x3ec
 7680 13bf 02       		.uleb128 0x2
 7681 13c0 91       		.byte	0x91
 7682 13c1 68       		.sleb128 -24
 7683 13c2 23       		.uleb128 0x23
 7684 13c3 F7030000 		.4byte	0x3f7
 7685 13c7 02       		.uleb128 0x2
 7686 13c8 91       		.byte	0x91
 7687 13c9 64       		.sleb128 -28
 7688 13ca 00       		.byte	0
 7689 13cb 00       		.byte	0
 7690 13cc 24       		.uleb128 0x24
 7691 13cd 03040000 		.4byte	0x403
 7692 13d1 C2000000 		.4byte	.LBB58
 7693 13d5 06000000 		.4byte	.LBE58-.LBB58
 7694 13d9 01       		.byte	0x1
 7695 13da 2D12     		.2byte	0x122d
 7696 13dc 25       		.uleb128 0x25
 7697 13dd 10040000 		.4byte	0x410
 7698 13e1 02       		.uleb128 0x2
 7699 13e2 91       		.byte	0x91
 7700 13e3 60       		.sleb128 -32
 7701 13e4 00       		.byte	0
 7702 13e5 00       		.byte	0
 7703 13e6 1A       		.uleb128 0x1a
 7704 13e7 BF0B0000 		.4byte	.LASF195
 7705 13eb 01       		.byte	0x1
 7706 13ec 3612     		.2byte	0x1236
 7707 13ee 2E010000 		.4byte	0x12e
 7708 13f2 00000000 		.4byte	.LFB116
 7709 13f6 4C000000 		.4byte	.LFE116-.LFB116
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 226


 7710 13fa 01       		.uleb128 0x1
 7711 13fb 9C       		.byte	0x9c
 7712 13fc 2E140000 		.4byte	0x142e
 7713 1400 1B       		.uleb128 0x1b
 7714 1401 CB080000 		.4byte	.LASF111
 7715 1405 01       		.byte	0x1
 7716 1406 3612     		.2byte	0x1236
 7717 1408 2D020000 		.4byte	0x22d
 7718 140c 02       		.uleb128 0x2
 7719 140d 91       		.byte	0x91
 7720 140e 6C       		.sleb128 -20
 7721 140f 1C       		.uleb128 0x1c
 7722 1410 4D0D0000 		.4byte	.LASF98
 7723 1414 01       		.byte	0x1
 7724 1415 3812     		.2byte	0x1238
 7725 1417 1D050000 		.4byte	0x51d
 7726 141b 02       		.uleb128 0x2
 7727 141c 91       		.byte	0x91
 7728 141d 70       		.sleb128 -16
 7729 141e 1C       		.uleb128 0x1c
 7730 141f 7C0A0000 		.4byte	.LASF92
 7731 1423 01       		.byte	0x1
 7732 1424 3912     		.2byte	0x1239
 7733 1426 2E010000 		.4byte	0x12e
 7734 142a 02       		.uleb128 0x2
 7735 142b 91       		.byte	0x91
 7736 142c 74       		.sleb128 -12
 7737 142d 00       		.byte	0
 7738 142e 1E       		.uleb128 0x1e
 7739 142f C10C0000 		.4byte	.LASF196
 7740 1433 01       		.byte	0x1
 7741 1434 5412     		.2byte	0x1254
 7742 1436 00000000 		.4byte	.LFB117
 7743 143a C8000000 		.4byte	.LFE117-.LFB117
 7744 143e 01       		.uleb128 0x1
 7745 143f 9C       		.byte	0x9c
 7746 1440 81140000 		.4byte	0x1481
 7747 1444 1B       		.uleb128 0x1b
 7748 1445 3B0C0000 		.4byte	.LASF148
 7749 1449 01       		.byte	0x1
 7750 144a 5412     		.2byte	0x1254
 7751 144c 44010000 		.4byte	0x144
 7752 1450 02       		.uleb128 0x2
 7753 1451 91       		.byte	0x91
 7754 1452 6C       		.sleb128 -20
 7755 1453 1B       		.uleb128 0x1b
 7756 1454 210B0000 		.4byte	.LASF197
 7757 1458 01       		.byte	0x1
 7758 1459 5412     		.2byte	0x1254
 7759 145b 81140000 		.4byte	0x1481
 7760 145f 02       		.uleb128 0x2
 7761 1460 91       		.byte	0x91
 7762 1461 68       		.sleb128 -24
 7763 1462 1C       		.uleb128 0x1c
 7764 1463 320D0000 		.4byte	.LASF103
 7765 1467 01       		.byte	0x1
 7766 1468 5612     		.2byte	0x1256
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 227


 7767 146a 44010000 		.4byte	0x144
 7768 146e 02       		.uleb128 0x2
 7769 146f 91       		.byte	0x91
 7770 1470 70       		.sleb128 -16
 7771 1471 1C       		.uleb128 0x1c
 7772 1472 7E040000 		.4byte	.LASF106
 7773 1476 01       		.byte	0x1
 7774 1477 5712     		.2byte	0x1257
 7775 1479 C4060000 		.4byte	0x6c4
 7776 147d 02       		.uleb128 0x2
 7777 147e 91       		.byte	0x91
 7778 147f 74       		.sleb128 -12
 7779 1480 00       		.byte	0
 7780 1481 07       		.uleb128 0x7
 7781 1482 2E010000 		.4byte	0x12e
 7782 1486 11       		.uleb128 0x11
 7783 1487 22020000 		.4byte	0x222
 7784 148b 96140000 		.4byte	0x1496
 7785 148f 12       		.uleb128 0x12
 7786 1490 A2000000 		.4byte	0xa2
 7787 1494 04       		.byte	0x4
 7788 1495 00       		.byte	0
 7789 1496 1C       		.uleb128 0x1c
 7790 1497 51010000 		.4byte	.LASF198
 7791 149b 01       		.byte	0x1
 7792 149c 7701     		.2byte	0x177
 7793 149e 86140000 		.4byte	0x1486
 7794 14a2 05       		.uleb128 0x5
 7795 14a3 03       		.byte	0x3
 7796 14a4 04000000 		.4byte	pxReadyTasksLists
 7797 14a8 1C       		.uleb128 0x1c
 7798 14a9 C4010000 		.4byte	.LASF199
 7799 14ad 01       		.byte	0x1
 7800 14ae 7801     		.2byte	0x178
 7801 14b0 22020000 		.4byte	0x222
 7802 14b4 05       		.uleb128 0x5
 7803 14b5 03       		.byte	0x3
 7804 14b6 68000000 		.4byte	xDelayedTaskList1
 7805 14ba 1C       		.uleb128 0x1c
 7806 14bb D6010000 		.4byte	.LASF200
 7807 14bf 01       		.byte	0x1
 7808 14c0 7901     		.2byte	0x179
 7809 14c2 22020000 		.4byte	0x222
 7810 14c6 05       		.uleb128 0x5
 7811 14c7 03       		.byte	0x3
 7812 14c8 7C000000 		.4byte	xDelayedTaskList2
 7813 14cc 1C       		.uleb128 0x1c
 7814 14cd 9B090000 		.4byte	.LASF201
 7815 14d1 01       		.byte	0x1
 7816 14d2 7A01     		.2byte	0x17a
 7817 14d4 DE140000 		.4byte	0x14de
 7818 14d8 05       		.uleb128 0x5
 7819 14d9 03       		.byte	0x3
 7820 14da 90000000 		.4byte	pxDelayedTaskList
 7821 14de 08       		.uleb128 0x8
 7822 14df 55070000 		.4byte	0x755
 7823 14e3 1C       		.uleb128 0x1c
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 228


 7824 14e4 CD040000 		.4byte	.LASF202
 7825 14e8 01       		.byte	0x1
 7826 14e9 7B01     		.2byte	0x17b
 7827 14eb DE140000 		.4byte	0x14de
 7828 14ef 05       		.uleb128 0x5
 7829 14f0 03       		.byte	0x3
 7830 14f1 94000000 		.4byte	pxOverflowDelayedTaskList
 7831 14f5 1C       		.uleb128 0x1c
 7832 14f6 97030000 		.4byte	.LASF203
 7833 14fa 01       		.byte	0x1
 7834 14fb 7C01     		.2byte	0x17c
 7835 14fd 22020000 		.4byte	0x222
 7836 1501 05       		.uleb128 0x5
 7837 1502 03       		.byte	0x3
 7838 1503 98000000 		.4byte	xPendingReadyList
 7839 1507 1C       		.uleb128 0x1c
 7840 1508 B4030000 		.4byte	.LASF204
 7841 150c 01       		.byte	0x1
 7842 150d 8001     		.2byte	0x180
 7843 150f 22020000 		.4byte	0x222
 7844 1513 05       		.uleb128 0x5
 7845 1514 03       		.byte	0x3
 7846 1515 AC000000 		.4byte	xTasksWaitingTermination
 7847 1519 1C       		.uleb128 0x1c
 7848 151a 1F010000 		.4byte	.LASF205
 7849 151e 01       		.byte	0x1
 7850 151f 8101     		.2byte	0x181
 7851 1521 2B150000 		.4byte	0x152b
 7852 1525 05       		.uleb128 0x5
 7853 1526 03       		.byte	0x3
 7854 1527 C0000000 		.4byte	uxDeletedTasksWaitingCleanUp
 7855 152b 08       		.uleb128 0x8
 7856 152c 39010000 		.4byte	0x139
 7857 1530 1C       		.uleb128 0x1c
 7858 1531 8E040000 		.4byte	.LASF206
 7859 1535 01       		.byte	0x1
 7860 1536 8701     		.2byte	0x187
 7861 1538 22020000 		.4byte	0x222
 7862 153c 05       		.uleb128 0x5
 7863 153d 03       		.byte	0x3
 7864 153e C4000000 		.4byte	xSuspendedTaskList
 7865 1542 1C       		.uleb128 0x1c
 7866 1543 ED0C0000 		.4byte	.LASF207
 7867 1547 01       		.byte	0x1
 7868 1548 8C01     		.2byte	0x18c
 7869 154a 2B150000 		.4byte	0x152b
 7870 154e 05       		.uleb128 0x5
 7871 154f 03       		.byte	0x3
 7872 1550 D8000000 		.4byte	uxCurrentNumberOfTasks
 7873 1554 1C       		.uleb128 0x1c
 7874 1555 B8060000 		.4byte	.LASF208
 7875 1559 01       		.byte	0x1
 7876 155a 8D01     		.2byte	0x18d
 7877 155c 66150000 		.4byte	0x1566
 7878 1560 05       		.uleb128 0x5
 7879 1561 03       		.byte	0x3
 7880 1562 DC000000 		.4byte	xTickCount
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 229


 7881 1566 08       		.uleb128 0x8
 7882 1567 44010000 		.4byte	0x144
 7883 156b 1C       		.uleb128 0x1c
 7884 156c AE000000 		.4byte	.LASF209
 7885 1570 01       		.byte	0x1
 7886 1571 8E01     		.2byte	0x18e
 7887 1573 2B150000 		.4byte	0x152b
 7888 1577 05       		.uleb128 0x5
 7889 1578 03       		.byte	0x3
 7890 1579 E0000000 		.4byte	uxTopReadyPriority
 7891 157d 1C       		.uleb128 0x1c
 7892 157e DA000000 		.4byte	.LASF210
 7893 1582 01       		.byte	0x1
 7894 1583 8F01     		.2byte	0x18f
 7895 1585 8F150000 		.4byte	0x158f
 7896 1589 05       		.uleb128 0x5
 7897 158a 03       		.byte	0x3
 7898 158b E4000000 		.4byte	xSchedulerRunning
 7899 158f 08       		.uleb128 0x8
 7900 1590 2E010000 		.4byte	0x12e
 7901 1594 1C       		.uleb128 0x1c
 7902 1595 9E0A0000 		.4byte	.LASF211
 7903 1599 01       		.byte	0x1
 7904 159a 9001     		.2byte	0x190
 7905 159c 2B150000 		.4byte	0x152b
 7906 15a0 05       		.uleb128 0x5
 7907 15a1 03       		.byte	0x3
 7908 15a2 E8000000 		.4byte	uxPendedTicks
 7909 15a6 1C       		.uleb128 0x1c
 7910 15a7 FC0D0000 		.4byte	.LASF212
 7911 15ab 01       		.byte	0x1
 7912 15ac 9101     		.2byte	0x191
 7913 15ae 8F150000 		.4byte	0x158f
 7914 15b2 05       		.uleb128 0x5
 7915 15b3 03       		.byte	0x3
 7916 15b4 EC000000 		.4byte	xYieldPending
 7917 15b8 1C       		.uleb128 0x1c
 7918 15b9 11090000 		.4byte	.LASF213
 7919 15bd 01       		.byte	0x1
 7920 15be 9201     		.2byte	0x192
 7921 15c0 8F150000 		.4byte	0x158f
 7922 15c4 05       		.uleb128 0x5
 7923 15c5 03       		.byte	0x3
 7924 15c6 F0000000 		.4byte	xNumOfOverflows
 7925 15ca 1C       		.uleb128 0x1c
 7926 15cb 37080000 		.4byte	.LASF214
 7927 15cf 01       		.byte	0x1
 7928 15d0 9301     		.2byte	0x193
 7929 15d2 39010000 		.4byte	0x139
 7930 15d6 05       		.uleb128 0x5
 7931 15d7 03       		.byte	0x3
 7932 15d8 F4000000 		.4byte	uxTaskNumber
 7933 15dc 1C       		.uleb128 0x1c
 7934 15dd 90060000 		.4byte	.LASF215
 7935 15e1 01       		.byte	0x1
 7936 15e2 9401     		.2byte	0x194
 7937 15e4 66150000 		.4byte	0x1566
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 230


 7938 15e8 05       		.uleb128 0x5
 7939 15e9 03       		.byte	0x3
 7940 15ea F8000000 		.4byte	xNextTaskUnblockTime
 7941 15ee 1C       		.uleb128 0x1c
 7942 15ef 2D090000 		.4byte	.LASF216
 7943 15f3 01       		.byte	0x1
 7944 15f4 9501     		.2byte	0x195
 7945 15f6 2D020000 		.4byte	0x22d
 7946 15fa 05       		.uleb128 0x5
 7947 15fb 03       		.byte	0x3
 7948 15fc FC000000 		.4byte	xIdleTaskHandle
 7949 1600 1C       		.uleb128 0x1c
 7950 1601 5A0D0000 		.4byte	.LASF217
 7951 1605 01       		.byte	0x1
 7952 1606 9F01     		.2byte	0x19f
 7953 1608 2B150000 		.4byte	0x152b
 7954 160c 05       		.uleb128 0x5
 7955 160d 03       		.byte	0x3
 7956 160e 00010000 		.4byte	uxSchedulerSuspended
 7957 1612 2C       		.uleb128 0x2c
 7958 1613 68090000 		.4byte	.LASF218
 7959 1617 09       		.byte	0x9
 7960 1618 9606     		.2byte	0x696
 7961 161a 1E160000 		.4byte	0x161e
 7962 161e 08       		.uleb128 0x8
 7963 161f D9000000 		.4byte	0xd9
 7964 1623 2D       		.uleb128 0x2d
 7965 1624 E00C0000 		.4byte	.LASF219
 7966 1628 01       		.byte	0x1
 7967 1629 7401     		.2byte	0x174
 7968 162b 35160000 		.4byte	0x1635
 7969 162f 05       		.uleb128 0x5
 7970 1630 03       		.byte	0x3
 7971 1631 00000000 		.4byte	pxCurrentTCB
 7972 1635 08       		.uleb128 0x8
 7973 1636 1D050000 		.4byte	0x51d
 7974 163a 00       		.byte	0
 7975              		.section	.debug_abbrev,"",%progbits
 7976              	.Ldebug_abbrev0:
 7977 0000 01       		.uleb128 0x1
 7978 0001 11       		.uleb128 0x11
 7979 0002 01       		.byte	0x1
 7980 0003 25       		.uleb128 0x25
 7981 0004 0E       		.uleb128 0xe
 7982 0005 13       		.uleb128 0x13
 7983 0006 0B       		.uleb128 0xb
 7984 0007 03       		.uleb128 0x3
 7985 0008 0E       		.uleb128 0xe
 7986 0009 1B       		.uleb128 0x1b
 7987 000a 0E       		.uleb128 0xe
 7988 000b 55       		.uleb128 0x55
 7989 000c 17       		.uleb128 0x17
 7990 000d 11       		.uleb128 0x11
 7991 000e 01       		.uleb128 0x1
 7992 000f 10       		.uleb128 0x10
 7993 0010 17       		.uleb128 0x17
 7994 0011 00       		.byte	0
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 231


 7995 0012 00       		.byte	0
 7996 0013 02       		.uleb128 0x2
 7997 0014 16       		.uleb128 0x16
 7998 0015 00       		.byte	0
 7999 0016 03       		.uleb128 0x3
 8000 0017 0E       		.uleb128 0xe
 8001 0018 3A       		.uleb128 0x3a
 8002 0019 0B       		.uleb128 0xb
 8003 001a 3B       		.uleb128 0x3b
 8004 001b 0B       		.uleb128 0xb
 8005 001c 49       		.uleb128 0x49
 8006 001d 13       		.uleb128 0x13
 8007 001e 00       		.byte	0
 8008 001f 00       		.byte	0
 8009 0020 03       		.uleb128 0x3
 8010 0021 24       		.uleb128 0x24
 8011 0022 00       		.byte	0
 8012 0023 0B       		.uleb128 0xb
 8013 0024 0B       		.uleb128 0xb
 8014 0025 3E       		.uleb128 0x3e
 8015 0026 0B       		.uleb128 0xb
 8016 0027 03       		.uleb128 0x3
 8017 0028 0E       		.uleb128 0xe
 8018 0029 00       		.byte	0
 8019 002a 00       		.byte	0
 8020 002b 04       		.uleb128 0x4
 8021 002c 24       		.uleb128 0x24
 8022 002d 00       		.byte	0
 8023 002e 0B       		.uleb128 0xb
 8024 002f 0B       		.uleb128 0xb
 8025 0030 3E       		.uleb128 0x3e
 8026 0031 0B       		.uleb128 0xb
 8027 0032 03       		.uleb128 0x3
 8028 0033 08       		.uleb128 0x8
 8029 0034 00       		.byte	0
 8030 0035 00       		.byte	0
 8031 0036 05       		.uleb128 0x5
 8032 0037 0F       		.uleb128 0xf
 8033 0038 00       		.byte	0
 8034 0039 0B       		.uleb128 0xb
 8035 003a 0B       		.uleb128 0xb
 8036 003b 00       		.byte	0
 8037 003c 00       		.byte	0
 8038 003d 06       		.uleb128 0x6
 8039 003e 0F       		.uleb128 0xf
 8040 003f 00       		.byte	0
 8041 0040 0B       		.uleb128 0xb
 8042 0041 0B       		.uleb128 0xb
 8043 0042 49       		.uleb128 0x49
 8044 0043 13       		.uleb128 0x13
 8045 0044 00       		.byte	0
 8046 0045 00       		.byte	0
 8047 0046 07       		.uleb128 0x7
 8048 0047 26       		.uleb128 0x26
 8049 0048 00       		.byte	0
 8050 0049 49       		.uleb128 0x49
 8051 004a 13       		.uleb128 0x13
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 232


 8052 004b 00       		.byte	0
 8053 004c 00       		.byte	0
 8054 004d 08       		.uleb128 0x8
 8055 004e 35       		.uleb128 0x35
 8056 004f 00       		.byte	0
 8057 0050 49       		.uleb128 0x49
 8058 0051 13       		.uleb128 0x13
 8059 0052 00       		.byte	0
 8060 0053 00       		.byte	0
 8061 0054 09       		.uleb128 0x9
 8062 0055 15       		.uleb128 0x15
 8063 0056 01       		.byte	0x1
 8064 0057 27       		.uleb128 0x27
 8065 0058 19       		.uleb128 0x19
 8066 0059 01       		.uleb128 0x1
 8067 005a 13       		.uleb128 0x13
 8068 005b 00       		.byte	0
 8069 005c 00       		.byte	0
 8070 005d 0A       		.uleb128 0xa
 8071 005e 05       		.uleb128 0x5
 8072 005f 00       		.byte	0
 8073 0060 49       		.uleb128 0x49
 8074 0061 13       		.uleb128 0x13
 8075 0062 00       		.byte	0
 8076 0063 00       		.byte	0
 8077 0064 0B       		.uleb128 0xb
 8078 0065 13       		.uleb128 0x13
 8079 0066 01       		.byte	0x1
 8080 0067 03       		.uleb128 0x3
 8081 0068 0E       		.uleb128 0xe
 8082 0069 0B       		.uleb128 0xb
 8083 006a 0B       		.uleb128 0xb
 8084 006b 3A       		.uleb128 0x3a
 8085 006c 0B       		.uleb128 0xb
 8086 006d 3B       		.uleb128 0x3b
 8087 006e 0B       		.uleb128 0xb
 8088 006f 01       		.uleb128 0x1
 8089 0070 13       		.uleb128 0x13
 8090 0071 00       		.byte	0
 8091 0072 00       		.byte	0
 8092 0073 0C       		.uleb128 0xc
 8093 0074 0D       		.uleb128 0xd
 8094 0075 00       		.byte	0
 8095 0076 03       		.uleb128 0x3
 8096 0077 0E       		.uleb128 0xe
 8097 0078 3A       		.uleb128 0x3a
 8098 0079 0B       		.uleb128 0xb
 8099 007a 3B       		.uleb128 0x3b
 8100 007b 0B       		.uleb128 0xb
 8101 007c 49       		.uleb128 0x49
 8102 007d 13       		.uleb128 0x13
 8103 007e 38       		.uleb128 0x38
 8104 007f 0B       		.uleb128 0xb
 8105 0080 00       		.byte	0
 8106 0081 00       		.byte	0
 8107 0082 0D       		.uleb128 0xd
 8108 0083 04       		.uleb128 0x4
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 233


 8109 0084 01       		.byte	0x1
 8110 0085 0B       		.uleb128 0xb
 8111 0086 0B       		.uleb128 0xb
 8112 0087 3A       		.uleb128 0x3a
 8113 0088 0B       		.uleb128 0xb
 8114 0089 3B       		.uleb128 0x3b
 8115 008a 0B       		.uleb128 0xb
 8116 008b 01       		.uleb128 0x1
 8117 008c 13       		.uleb128 0x13
 8118 008d 00       		.byte	0
 8119 008e 00       		.byte	0
 8120 008f 0E       		.uleb128 0xe
 8121 0090 28       		.uleb128 0x28
 8122 0091 00       		.byte	0
 8123 0092 03       		.uleb128 0x3
 8124 0093 0E       		.uleb128 0xe
 8125 0094 1C       		.uleb128 0x1c
 8126 0095 0D       		.uleb128 0xd
 8127 0096 00       		.byte	0
 8128 0097 00       		.byte	0
 8129 0098 0F       		.uleb128 0xf
 8130 0099 13       		.uleb128 0x13
 8131 009a 01       		.byte	0x1
 8132 009b 03       		.uleb128 0x3
 8133 009c 0E       		.uleb128 0xe
 8134 009d 0B       		.uleb128 0xb
 8135 009e 0B       		.uleb128 0xb
 8136 009f 3A       		.uleb128 0x3a
 8137 00a0 0B       		.uleb128 0xb
 8138 00a1 3B       		.uleb128 0x3b
 8139 00a2 05       		.uleb128 0x5
 8140 00a3 01       		.uleb128 0x1
 8141 00a4 13       		.uleb128 0x13
 8142 00a5 00       		.byte	0
 8143 00a6 00       		.byte	0
 8144 00a7 10       		.uleb128 0x10
 8145 00a8 0D       		.uleb128 0xd
 8146 00a9 00       		.byte	0
 8147 00aa 03       		.uleb128 0x3
 8148 00ab 0E       		.uleb128 0xe
 8149 00ac 3A       		.uleb128 0x3a
 8150 00ad 0B       		.uleb128 0xb
 8151 00ae 3B       		.uleb128 0x3b
 8152 00af 05       		.uleb128 0x5
 8153 00b0 49       		.uleb128 0x49
 8154 00b1 13       		.uleb128 0x13
 8155 00b2 38       		.uleb128 0x38
 8156 00b3 0B       		.uleb128 0xb
 8157 00b4 00       		.byte	0
 8158 00b5 00       		.byte	0
 8159 00b6 11       		.uleb128 0x11
 8160 00b7 01       		.uleb128 0x1
 8161 00b8 01       		.byte	0x1
 8162 00b9 49       		.uleb128 0x49
 8163 00ba 13       		.uleb128 0x13
 8164 00bb 01       		.uleb128 0x1
 8165 00bc 13       		.uleb128 0x13
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 234


 8166 00bd 00       		.byte	0
 8167 00be 00       		.byte	0
 8168 00bf 12       		.uleb128 0x12
 8169 00c0 21       		.uleb128 0x21
 8170 00c1 00       		.byte	0
 8171 00c2 49       		.uleb128 0x49
 8172 00c3 13       		.uleb128 0x13
 8173 00c4 2F       		.uleb128 0x2f
 8174 00c5 0B       		.uleb128 0xb
 8175 00c6 00       		.byte	0
 8176 00c7 00       		.byte	0
 8177 00c8 13       		.uleb128 0x13
 8178 00c9 16       		.uleb128 0x16
 8179 00ca 00       		.byte	0
 8180 00cb 03       		.uleb128 0x3
 8181 00cc 0E       		.uleb128 0xe
 8182 00cd 3A       		.uleb128 0x3a
 8183 00ce 0B       		.uleb128 0xb
 8184 00cf 3B       		.uleb128 0x3b
 8185 00d0 05       		.uleb128 0x5
 8186 00d1 49       		.uleb128 0x49
 8187 00d2 13       		.uleb128 0x13
 8188 00d3 00       		.byte	0
 8189 00d4 00       		.byte	0
 8190 00d5 14       		.uleb128 0x14
 8191 00d6 2E       		.uleb128 0x2e
 8192 00d7 01       		.byte	0x1
 8193 00d8 03       		.uleb128 0x3
 8194 00d9 0E       		.uleb128 0xe
 8195 00da 3A       		.uleb128 0x3a
 8196 00db 0B       		.uleb128 0xb
 8197 00dc 3B       		.uleb128 0x3b
 8198 00dd 0B       		.uleb128 0xb
 8199 00de 27       		.uleb128 0x27
 8200 00df 19       		.uleb128 0x19
 8201 00e0 49       		.uleb128 0x49
 8202 00e1 13       		.uleb128 0x13
 8203 00e2 20       		.uleb128 0x20
 8204 00e3 0B       		.uleb128 0xb
 8205 00e4 01       		.uleb128 0x1
 8206 00e5 13       		.uleb128 0x13
 8207 00e6 00       		.byte	0
 8208 00e7 00       		.byte	0
 8209 00e8 15       		.uleb128 0x15
 8210 00e9 34       		.uleb128 0x34
 8211 00ea 00       		.byte	0
 8212 00eb 03       		.uleb128 0x3
 8213 00ec 0E       		.uleb128 0xe
 8214 00ed 3A       		.uleb128 0x3a
 8215 00ee 0B       		.uleb128 0xb
 8216 00ef 3B       		.uleb128 0x3b
 8217 00f0 0B       		.uleb128 0xb
 8218 00f1 49       		.uleb128 0x49
 8219 00f2 13       		.uleb128 0x13
 8220 00f3 00       		.byte	0
 8221 00f4 00       		.byte	0
 8222 00f5 16       		.uleb128 0x16
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 235


 8223 00f6 2E       		.uleb128 0x2e
 8224 00f7 01       		.byte	0x1
 8225 00f8 03       		.uleb128 0x3
 8226 00f9 0E       		.uleb128 0xe
 8227 00fa 3A       		.uleb128 0x3a
 8228 00fb 0B       		.uleb128 0xb
 8229 00fc 3B       		.uleb128 0x3b
 8230 00fd 05       		.uleb128 0x5
 8231 00fe 27       		.uleb128 0x27
 8232 00ff 19       		.uleb128 0x19
 8233 0100 20       		.uleb128 0x20
 8234 0101 0B       		.uleb128 0xb
 8235 0102 01       		.uleb128 0x1
 8236 0103 13       		.uleb128 0x13
 8237 0104 00       		.byte	0
 8238 0105 00       		.byte	0
 8239 0106 17       		.uleb128 0x17
 8240 0107 05       		.uleb128 0x5
 8241 0108 00       		.byte	0
 8242 0109 03       		.uleb128 0x3
 8243 010a 0E       		.uleb128 0xe
 8244 010b 3A       		.uleb128 0x3a
 8245 010c 0B       		.uleb128 0xb
 8246 010d 3B       		.uleb128 0x3b
 8247 010e 05       		.uleb128 0x5
 8248 010f 49       		.uleb128 0x49
 8249 0110 13       		.uleb128 0x13
 8250 0111 00       		.byte	0
 8251 0112 00       		.byte	0
 8252 0113 18       		.uleb128 0x18
 8253 0114 2E       		.uleb128 0x2e
 8254 0115 01       		.byte	0x1
 8255 0116 03       		.uleb128 0x3
 8256 0117 0E       		.uleb128 0xe
 8257 0118 3A       		.uleb128 0x3a
 8258 0119 0B       		.uleb128 0xb
 8259 011a 3B       		.uleb128 0x3b
 8260 011b 0B       		.uleb128 0xb
 8261 011c 27       		.uleb128 0x27
 8262 011d 19       		.uleb128 0x19
 8263 011e 20       		.uleb128 0x20
 8264 011f 0B       		.uleb128 0xb
 8265 0120 01       		.uleb128 0x1
 8266 0121 13       		.uleb128 0x13
 8267 0122 00       		.byte	0
 8268 0123 00       		.byte	0
 8269 0124 19       		.uleb128 0x19
 8270 0125 05       		.uleb128 0x5
 8271 0126 00       		.byte	0
 8272 0127 03       		.uleb128 0x3
 8273 0128 0E       		.uleb128 0xe
 8274 0129 3A       		.uleb128 0x3a
 8275 012a 0B       		.uleb128 0xb
 8276 012b 3B       		.uleb128 0x3b
 8277 012c 0B       		.uleb128 0xb
 8278 012d 49       		.uleb128 0x49
 8279 012e 13       		.uleb128 0x13
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 236


 8280 012f 00       		.byte	0
 8281 0130 00       		.byte	0
 8282 0131 1A       		.uleb128 0x1a
 8283 0132 2E       		.uleb128 0x2e
 8284 0133 01       		.byte	0x1
 8285 0134 3F       		.uleb128 0x3f
 8286 0135 19       		.uleb128 0x19
 8287 0136 03       		.uleb128 0x3
 8288 0137 0E       		.uleb128 0xe
 8289 0138 3A       		.uleb128 0x3a
 8290 0139 0B       		.uleb128 0xb
 8291 013a 3B       		.uleb128 0x3b
 8292 013b 05       		.uleb128 0x5
 8293 013c 27       		.uleb128 0x27
 8294 013d 19       		.uleb128 0x19
 8295 013e 49       		.uleb128 0x49
 8296 013f 13       		.uleb128 0x13
 8297 0140 11       		.uleb128 0x11
 8298 0141 01       		.uleb128 0x1
 8299 0142 12       		.uleb128 0x12
 8300 0143 06       		.uleb128 0x6
 8301 0144 40       		.uleb128 0x40
 8302 0145 18       		.uleb128 0x18
 8303 0146 9642     		.uleb128 0x2116
 8304 0148 19       		.uleb128 0x19
 8305 0149 01       		.uleb128 0x1
 8306 014a 13       		.uleb128 0x13
 8307 014b 00       		.byte	0
 8308 014c 00       		.byte	0
 8309 014d 1B       		.uleb128 0x1b
 8310 014e 05       		.uleb128 0x5
 8311 014f 00       		.byte	0
 8312 0150 03       		.uleb128 0x3
 8313 0151 0E       		.uleb128 0xe
 8314 0152 3A       		.uleb128 0x3a
 8315 0153 0B       		.uleb128 0xb
 8316 0154 3B       		.uleb128 0x3b
 8317 0155 05       		.uleb128 0x5
 8318 0156 49       		.uleb128 0x49
 8319 0157 13       		.uleb128 0x13
 8320 0158 02       		.uleb128 0x2
 8321 0159 18       		.uleb128 0x18
 8322 015a 00       		.byte	0
 8323 015b 00       		.byte	0
 8324 015c 1C       		.uleb128 0x1c
 8325 015d 34       		.uleb128 0x34
 8326 015e 00       		.byte	0
 8327 015f 03       		.uleb128 0x3
 8328 0160 0E       		.uleb128 0xe
 8329 0161 3A       		.uleb128 0x3a
 8330 0162 0B       		.uleb128 0xb
 8331 0163 3B       		.uleb128 0x3b
 8332 0164 05       		.uleb128 0x5
 8333 0165 49       		.uleb128 0x49
 8334 0166 13       		.uleb128 0x13
 8335 0167 02       		.uleb128 0x2
 8336 0168 18       		.uleb128 0x18
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 237


 8337 0169 00       		.byte	0
 8338 016a 00       		.byte	0
 8339 016b 1D       		.uleb128 0x1d
 8340 016c 0B       		.uleb128 0xb
 8341 016d 01       		.byte	0x1
 8342 016e 11       		.uleb128 0x11
 8343 016f 01       		.uleb128 0x1
 8344 0170 12       		.uleb128 0x12
 8345 0171 06       		.uleb128 0x6
 8346 0172 00       		.byte	0
 8347 0173 00       		.byte	0
 8348 0174 1E       		.uleb128 0x1e
 8349 0175 2E       		.uleb128 0x2e
 8350 0176 01       		.byte	0x1
 8351 0177 03       		.uleb128 0x3
 8352 0178 0E       		.uleb128 0xe
 8353 0179 3A       		.uleb128 0x3a
 8354 017a 0B       		.uleb128 0xb
 8355 017b 3B       		.uleb128 0x3b
 8356 017c 05       		.uleb128 0x5
 8357 017d 27       		.uleb128 0x27
 8358 017e 19       		.uleb128 0x19
 8359 017f 11       		.uleb128 0x11
 8360 0180 01       		.uleb128 0x1
 8361 0181 12       		.uleb128 0x12
 8362 0182 06       		.uleb128 0x6
 8363 0183 40       		.uleb128 0x40
 8364 0184 18       		.uleb128 0x18
 8365 0185 9642     		.uleb128 0x2116
 8366 0187 19       		.uleb128 0x19
 8367 0188 01       		.uleb128 0x1
 8368 0189 13       		.uleb128 0x13
 8369 018a 00       		.byte	0
 8370 018b 00       		.byte	0
 8371 018c 1F       		.uleb128 0x1f
 8372 018d 34       		.uleb128 0x34
 8373 018e 00       		.byte	0
 8374 018f 03       		.uleb128 0x3
 8375 0190 08       		.uleb128 0x8
 8376 0191 3A       		.uleb128 0x3a
 8377 0192 0B       		.uleb128 0xb
 8378 0193 3B       		.uleb128 0x3b
 8379 0194 05       		.uleb128 0x5
 8380 0195 49       		.uleb128 0x49
 8381 0196 13       		.uleb128 0x13
 8382 0197 02       		.uleb128 0x2
 8383 0198 18       		.uleb128 0x18
 8384 0199 00       		.byte	0
 8385 019a 00       		.byte	0
 8386 019b 20       		.uleb128 0x20
 8387 019c 2E       		.uleb128 0x2e
 8388 019d 01       		.byte	0x1
 8389 019e 3F       		.uleb128 0x3f
 8390 019f 19       		.uleb128 0x19
 8391 01a0 03       		.uleb128 0x3
 8392 01a1 0E       		.uleb128 0xe
 8393 01a2 3A       		.uleb128 0x3a
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 238


 8394 01a3 0B       		.uleb128 0xb
 8395 01a4 3B       		.uleb128 0x3b
 8396 01a5 05       		.uleb128 0x5
 8397 01a6 27       		.uleb128 0x27
 8398 01a7 19       		.uleb128 0x19
 8399 01a8 11       		.uleb128 0x11
 8400 01a9 01       		.uleb128 0x1
 8401 01aa 12       		.uleb128 0x12
 8402 01ab 06       		.uleb128 0x6
 8403 01ac 40       		.uleb128 0x40
 8404 01ad 18       		.uleb128 0x18
 8405 01ae 9642     		.uleb128 0x2116
 8406 01b0 19       		.uleb128 0x19
 8407 01b1 01       		.uleb128 0x1
 8408 01b2 13       		.uleb128 0x13
 8409 01b3 00       		.byte	0
 8410 01b4 00       		.byte	0
 8411 01b5 21       		.uleb128 0x21
 8412 01b6 2E       		.uleb128 0x2e
 8413 01b7 01       		.byte	0x1
 8414 01b8 3F       		.uleb128 0x3f
 8415 01b9 19       		.uleb128 0x19
 8416 01ba 03       		.uleb128 0x3
 8417 01bb 0E       		.uleb128 0xe
 8418 01bc 3A       		.uleb128 0x3a
 8419 01bd 0B       		.uleb128 0xb
 8420 01be 3B       		.uleb128 0x3b
 8421 01bf 05       		.uleb128 0x5
 8422 01c0 27       		.uleb128 0x27
 8423 01c1 19       		.uleb128 0x19
 8424 01c2 49       		.uleb128 0x49
 8425 01c3 13       		.uleb128 0x13
 8426 01c4 11       		.uleb128 0x11
 8427 01c5 01       		.uleb128 0x1
 8428 01c6 12       		.uleb128 0x12
 8429 01c7 06       		.uleb128 0x6
 8430 01c8 40       		.uleb128 0x40
 8431 01c9 18       		.uleb128 0x18
 8432 01ca 9742     		.uleb128 0x2117
 8433 01cc 19       		.uleb128 0x19
 8434 01cd 01       		.uleb128 0x1
 8435 01ce 13       		.uleb128 0x13
 8436 01cf 00       		.byte	0
 8437 01d0 00       		.byte	0
 8438 01d1 22       		.uleb128 0x22
 8439 01d2 1D       		.uleb128 0x1d
 8440 01d3 01       		.byte	0x1
 8441 01d4 31       		.uleb128 0x31
 8442 01d5 13       		.uleb128 0x13
 8443 01d6 11       		.uleb128 0x11
 8444 01d7 01       		.uleb128 0x1
 8445 01d8 12       		.uleb128 0x12
 8446 01d9 06       		.uleb128 0x6
 8447 01da 58       		.uleb128 0x58
 8448 01db 0B       		.uleb128 0xb
 8449 01dc 59       		.uleb128 0x59
 8450 01dd 05       		.uleb128 0x5
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 239


 8451 01de 01       		.uleb128 0x1
 8452 01df 13       		.uleb128 0x13
 8453 01e0 00       		.byte	0
 8454 01e1 00       		.byte	0
 8455 01e2 23       		.uleb128 0x23
 8456 01e3 34       		.uleb128 0x34
 8457 01e4 00       		.byte	0
 8458 01e5 31       		.uleb128 0x31
 8459 01e6 13       		.uleb128 0x13
 8460 01e7 02       		.uleb128 0x2
 8461 01e8 18       		.uleb128 0x18
 8462 01e9 00       		.byte	0
 8463 01ea 00       		.byte	0
 8464 01eb 24       		.uleb128 0x24
 8465 01ec 1D       		.uleb128 0x1d
 8466 01ed 01       		.byte	0x1
 8467 01ee 31       		.uleb128 0x31
 8468 01ef 13       		.uleb128 0x13
 8469 01f0 11       		.uleb128 0x11
 8470 01f1 01       		.uleb128 0x1
 8471 01f2 12       		.uleb128 0x12
 8472 01f3 06       		.uleb128 0x6
 8473 01f4 58       		.uleb128 0x58
 8474 01f5 0B       		.uleb128 0xb
 8475 01f6 59       		.uleb128 0x59
 8476 01f7 05       		.uleb128 0x5
 8477 01f8 00       		.byte	0
 8478 01f9 00       		.byte	0
 8479 01fa 25       		.uleb128 0x25
 8480 01fb 05       		.uleb128 0x5
 8481 01fc 00       		.byte	0
 8482 01fd 31       		.uleb128 0x31
 8483 01fe 13       		.uleb128 0x13
 8484 01ff 02       		.uleb128 0x2
 8485 0200 18       		.uleb128 0x18
 8486 0201 00       		.byte	0
 8487 0202 00       		.byte	0
 8488 0203 26       		.uleb128 0x26
 8489 0204 2E       		.uleb128 0x2e
 8490 0205 01       		.byte	0x1
 8491 0206 03       		.uleb128 0x3
 8492 0207 0E       		.uleb128 0xe
 8493 0208 3A       		.uleb128 0x3a
 8494 0209 0B       		.uleb128 0xb
 8495 020a 3B       		.uleb128 0x3b
 8496 020b 05       		.uleb128 0x5
 8497 020c 27       		.uleb128 0x27
 8498 020d 19       		.uleb128 0x19
 8499 020e 49       		.uleb128 0x49
 8500 020f 13       		.uleb128 0x13
 8501 0210 11       		.uleb128 0x11
 8502 0211 01       		.uleb128 0x1
 8503 0212 12       		.uleb128 0x12
 8504 0213 06       		.uleb128 0x6
 8505 0214 40       		.uleb128 0x40
 8506 0215 18       		.uleb128 0x18
 8507 0216 9742     		.uleb128 0x2117
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 240


 8508 0218 19       		.uleb128 0x19
 8509 0219 01       		.uleb128 0x1
 8510 021a 13       		.uleb128 0x13
 8511 021b 00       		.byte	0
 8512 021c 00       		.byte	0
 8513 021d 27       		.uleb128 0x27
 8514 021e 2E       		.uleb128 0x2e
 8515 021f 00       		.byte	0
 8516 0220 3F       		.uleb128 0x3f
 8517 0221 19       		.uleb128 0x19
 8518 0222 03       		.uleb128 0x3
 8519 0223 0E       		.uleb128 0xe
 8520 0224 3A       		.uleb128 0x3a
 8521 0225 0B       		.uleb128 0xb
 8522 0226 3B       		.uleb128 0x3b
 8523 0227 05       		.uleb128 0x5
 8524 0228 27       		.uleb128 0x27
 8525 0229 19       		.uleb128 0x19
 8526 022a 11       		.uleb128 0x11
 8527 022b 01       		.uleb128 0x1
 8528 022c 12       		.uleb128 0x12
 8529 022d 06       		.uleb128 0x6
 8530 022e 40       		.uleb128 0x40
 8531 022f 18       		.uleb128 0x18
 8532 0230 9742     		.uleb128 0x2117
 8533 0232 19       		.uleb128 0x19
 8534 0233 00       		.byte	0
 8535 0234 00       		.byte	0
 8536 0235 28       		.uleb128 0x28
 8537 0236 2E       		.uleb128 0x2e
 8538 0237 00       		.byte	0
 8539 0238 3F       		.uleb128 0x3f
 8540 0239 19       		.uleb128 0x19
 8541 023a 03       		.uleb128 0x3
 8542 023b 0E       		.uleb128 0xe
 8543 023c 3A       		.uleb128 0x3a
 8544 023d 0B       		.uleb128 0xb
 8545 023e 3B       		.uleb128 0x3b
 8546 023f 05       		.uleb128 0x5
 8547 0240 27       		.uleb128 0x27
 8548 0241 19       		.uleb128 0x19
 8549 0242 49       		.uleb128 0x49
 8550 0243 13       		.uleb128 0x13
 8551 0244 11       		.uleb128 0x11
 8552 0245 01       		.uleb128 0x1
 8553 0246 12       		.uleb128 0x12
 8554 0247 06       		.uleb128 0x6
 8555 0248 40       		.uleb128 0x40
 8556 0249 18       		.uleb128 0x18
 8557 024a 9742     		.uleb128 0x2117
 8558 024c 19       		.uleb128 0x19
 8559 024d 00       		.byte	0
 8560 024e 00       		.byte	0
 8561 024f 29       		.uleb128 0x29
 8562 0250 0B       		.uleb128 0xb
 8563 0251 01       		.byte	0x1
 8564 0252 11       		.uleb128 0x11
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 241


 8565 0253 01       		.uleb128 0x1
 8566 0254 12       		.uleb128 0x12
 8567 0255 06       		.uleb128 0x6
 8568 0256 01       		.uleb128 0x1
 8569 0257 13       		.uleb128 0x13
 8570 0258 00       		.byte	0
 8571 0259 00       		.byte	0
 8572 025a 2A       		.uleb128 0x2a
 8573 025b 2E       		.uleb128 0x2e
 8574 025c 01       		.byte	0x1
 8575 025d 3F       		.uleb128 0x3f
 8576 025e 19       		.uleb128 0x19
 8577 025f 03       		.uleb128 0x3
 8578 0260 0E       		.uleb128 0xe
 8579 0261 3A       		.uleb128 0x3a
 8580 0262 0B       		.uleb128 0xb
 8581 0263 3B       		.uleb128 0x3b
 8582 0264 05       		.uleb128 0x5
 8583 0265 27       		.uleb128 0x27
 8584 0266 19       		.uleb128 0x19
 8585 0267 11       		.uleb128 0x11
 8586 0268 01       		.uleb128 0x1
 8587 0269 12       		.uleb128 0x12
 8588 026a 06       		.uleb128 0x6
 8589 026b 40       		.uleb128 0x40
 8590 026c 18       		.uleb128 0x18
 8591 026d 9742     		.uleb128 0x2117
 8592 026f 19       		.uleb128 0x19
 8593 0270 01       		.uleb128 0x1
 8594 0271 13       		.uleb128 0x13
 8595 0272 00       		.byte	0
 8596 0273 00       		.byte	0
 8597 0274 2B       		.uleb128 0x2b
 8598 0275 2E       		.uleb128 0x2e
 8599 0276 01       		.byte	0x1
 8600 0277 03       		.uleb128 0x3
 8601 0278 0E       		.uleb128 0xe
 8602 0279 3A       		.uleb128 0x3a
 8603 027a 0B       		.uleb128 0xb
 8604 027b 3B       		.uleb128 0x3b
 8605 027c 05       		.uleb128 0x5
 8606 027d 27       		.uleb128 0x27
 8607 027e 19       		.uleb128 0x19
 8608 027f 11       		.uleb128 0x11
 8609 0280 01       		.uleb128 0x1
 8610 0281 12       		.uleb128 0x12
 8611 0282 06       		.uleb128 0x6
 8612 0283 40       		.uleb128 0x40
 8613 0284 18       		.uleb128 0x18
 8614 0285 9742     		.uleb128 0x2117
 8615 0287 19       		.uleb128 0x19
 8616 0288 01       		.uleb128 0x1
 8617 0289 13       		.uleb128 0x13
 8618 028a 00       		.byte	0
 8619 028b 00       		.byte	0
 8620 028c 2C       		.uleb128 0x2c
 8621 028d 34       		.uleb128 0x34
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 242


 8622 028e 00       		.byte	0
 8623 028f 03       		.uleb128 0x3
 8624 0290 0E       		.uleb128 0xe
 8625 0291 3A       		.uleb128 0x3a
 8626 0292 0B       		.uleb128 0xb
 8627 0293 3B       		.uleb128 0x3b
 8628 0294 05       		.uleb128 0x5
 8629 0295 49       		.uleb128 0x49
 8630 0296 13       		.uleb128 0x13
 8631 0297 3F       		.uleb128 0x3f
 8632 0298 19       		.uleb128 0x19
 8633 0299 3C       		.uleb128 0x3c
 8634 029a 19       		.uleb128 0x19
 8635 029b 00       		.byte	0
 8636 029c 00       		.byte	0
 8637 029d 2D       		.uleb128 0x2d
 8638 029e 34       		.uleb128 0x34
 8639 029f 00       		.byte	0
 8640 02a0 03       		.uleb128 0x3
 8641 02a1 0E       		.uleb128 0xe
 8642 02a2 3A       		.uleb128 0x3a
 8643 02a3 0B       		.uleb128 0xb
 8644 02a4 3B       		.uleb128 0x3b
 8645 02a5 05       		.uleb128 0x5
 8646 02a6 49       		.uleb128 0x49
 8647 02a7 13       		.uleb128 0x13
 8648 02a8 3F       		.uleb128 0x3f
 8649 02a9 19       		.uleb128 0x19
 8650 02aa 02       		.uleb128 0x2
 8651 02ab 18       		.uleb128 0x18
 8652 02ac 00       		.byte	0
 8653 02ad 00       		.byte	0
 8654 02ae 00       		.byte	0
 8655              		.section	.debug_aranges,"",%progbits
 8656 0000 A4010000 		.4byte	0x1a4
 8657 0004 0200     		.2byte	0x2
 8658 0006 00000000 		.4byte	.Ldebug_info0
 8659 000a 04       		.byte	0x4
 8660 000b 00       		.byte	0
 8661 000c 0000     		.2byte	0
 8662 000e 0000     		.2byte	0
 8663 0010 00000000 		.4byte	.LFB68
 8664 0014 82000000 		.4byte	.LFE68-.LFB68
 8665 0018 00000000 		.4byte	.LFB69
 8666 001c EC000000 		.4byte	.LFE69-.LFB69
 8667 0020 00000000 		.4byte	.LFB70
 8668 0024 D8000000 		.4byte	.LFE70-.LFB70
 8669 0028 00000000 		.4byte	.LFB71
 8670 002c FC000000 		.4byte	.LFE71-.LFB71
 8671 0030 00000000 		.4byte	.LFB72
 8672 0034 A0000000 		.4byte	.LFE72-.LFB72
 8673 0038 00000000 		.4byte	.LFB73
 8674 003c 44000000 		.4byte	.LFE73-.LFB73
 8675 0040 00000000 		.4byte	.LFB74
 8676 0044 98000000 		.4byte	.LFE74-.LFB74
 8677 0048 00000000 		.4byte	.LFB75
 8678 004c 34000000 		.4byte	.LFE75-.LFB75
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 243


 8679 0050 00000000 		.4byte	.LFB76
 8680 0054 58000000 		.4byte	.LFE76-.LFB76
 8681 0058 00000000 		.4byte	.LFB77
 8682 005c 44010000 		.4byte	.LFE77-.LFB77
 8683 0060 00000000 		.4byte	.LFB78
 8684 0064 EC000000 		.4byte	.LFE78-.LFB78
 8685 0068 00000000 		.4byte	.LFB79
 8686 006c 5C000000 		.4byte	.LFE79-.LFB79
 8687 0070 00000000 		.4byte	.LFB80
 8688 0074 A0000000 		.4byte	.LFE80-.LFB80
 8689 0078 00000000 		.4byte	.LFB81
 8690 007c C4000000 		.4byte	.LFE81-.LFB81
 8691 0080 00000000 		.4byte	.LFB82
 8692 0084 6C000000 		.4byte	.LFE82-.LFB82
 8693 0088 00000000 		.4byte	.LFB83
 8694 008c 2C000000 		.4byte	.LFE83-.LFB83
 8695 0090 00000000 		.4byte	.LFB84
 8696 0094 1C000000 		.4byte	.LFE84-.LFB84
 8697 0098 00000000 		.4byte	.LFB85
 8698 009c 20010000 		.4byte	.LFE85-.LFB85
 8699 00a0 00000000 		.4byte	.LFB86
 8700 00a4 20000000 		.4byte	.LFE86-.LFB86
 8701 00a8 00000000 		.4byte	.LFB87
 8702 00ac 24000000 		.4byte	.LFE87-.LFB87
 8703 00b0 00000000 		.4byte	.LFB88
 8704 00b4 18000000 		.4byte	.LFE88-.LFB88
 8705 00b8 00000000 		.4byte	.LFB89
 8706 00bc 2C000000 		.4byte	.LFE89-.LFB89
 8707 00c0 00000000 		.4byte	.LFB90
 8708 00c4 5C010000 		.4byte	.LFE90-.LFB90
 8709 00c8 00000000 		.4byte	.LFB91
 8710 00cc D4000000 		.4byte	.LFE91-.LFB91
 8711 00d0 00000000 		.4byte	.LFB92
 8712 00d4 2C000000 		.4byte	.LFE92-.LFB92
 8713 00d8 00000000 		.4byte	.LFB93
 8714 00dc 38000000 		.4byte	.LFE93-.LFB93
 8715 00e0 00000000 		.4byte	.LFB94
 8716 00e4 AC000000 		.4byte	.LFE94-.LFB94
 8717 00e8 00000000 		.4byte	.LFB95
 8718 00ec 94000000 		.4byte	.LFE95-.LFB95
 8719 00f0 00000000 		.4byte	.LFB96
 8720 00f4 2C000000 		.4byte	.LFE96-.LFB96
 8721 00f8 00000000 		.4byte	.LFB97
 8722 00fc 88000000 		.4byte	.LFE97-.LFB97
 8723 0100 00000000 		.4byte	.LFB98
 8724 0104 18000000 		.4byte	.LFE98-.LFB98
 8725 0108 00000000 		.4byte	.LFB99
 8726 010c 0E000000 		.4byte	.LFE99-.LFB99
 8727 0110 00000000 		.4byte	.LFB100
 8728 0114 7C000000 		.4byte	.LFE100-.LFB100
 8729 0118 00000000 		.4byte	.LFB101
 8730 011c 74000000 		.4byte	.LFE101-.LFB101
 8731 0120 00000000 		.4byte	.LFB102
 8732 0124 38000000 		.4byte	.LFE102-.LFB102
 8733 0128 00000000 		.4byte	.LFB103
 8734 012c 38000000 		.4byte	.LFE103-.LFB103
 8735 0130 00000000 		.4byte	.LFB104
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 244


 8736 0134 1E000000 		.4byte	.LFE104-.LFB104
 8737 0138 00000000 		.4byte	.LFB105
 8738 013c 48000000 		.4byte	.LFE105-.LFB105
 8739 0140 00000000 		.4byte	.LFB106
 8740 0144 20000000 		.4byte	.LFE106-.LFB106
 8741 0148 00000000 		.4byte	.LFB107
 8742 014c F0000000 		.4byte	.LFE107-.LFB107
 8743 0150 00000000 		.4byte	.LFB108
 8744 0154 CC000000 		.4byte	.LFE108-.LFB108
 8745 0158 00000000 		.4byte	.LFB109
 8746 015c 30000000 		.4byte	.LFE109-.LFB109
 8747 0160 00000000 		.4byte	.LFB110
 8748 0164 28000000 		.4byte	.LFE110-.LFB110
 8749 0168 00000000 		.4byte	.LFB111
 8750 016c 90000000 		.4byte	.LFE111-.LFB111
 8751 0170 00000000 		.4byte	.LFB112
 8752 0174 B4000000 		.4byte	.LFE112-.LFB112
 8753 0178 00000000 		.4byte	.LFB113
 8754 017c 10010000 		.4byte	.LFE113-.LFB113
 8755 0180 00000000 		.4byte	.LFB114
 8756 0184 54010000 		.4byte	.LFE114-.LFB114
 8757 0188 00000000 		.4byte	.LFB115
 8758 018c E8000000 		.4byte	.LFE115-.LFB115
 8759 0190 00000000 		.4byte	.LFB116
 8760 0194 4C000000 		.4byte	.LFE116-.LFB116
 8761 0198 00000000 		.4byte	.LFB117
 8762 019c C8000000 		.4byte	.LFE117-.LFB117
 8763 01a0 00000000 		.4byte	0
 8764 01a4 00000000 		.4byte	0
 8765              		.section	.debug_ranges,"",%progbits
 8766              	.Ldebug_ranges0:
 8767 0000 00000000 		.4byte	.LFB68
 8768 0004 82000000 		.4byte	.LFE68
 8769 0008 00000000 		.4byte	.LFB69
 8770 000c EC000000 		.4byte	.LFE69
 8771 0010 00000000 		.4byte	.LFB70
 8772 0014 D8000000 		.4byte	.LFE70
 8773 0018 00000000 		.4byte	.LFB71
 8774 001c FC000000 		.4byte	.LFE71
 8775 0020 00000000 		.4byte	.LFB72
 8776 0024 A0000000 		.4byte	.LFE72
 8777 0028 00000000 		.4byte	.LFB73
 8778 002c 44000000 		.4byte	.LFE73
 8779 0030 00000000 		.4byte	.LFB74
 8780 0034 98000000 		.4byte	.LFE74
 8781 0038 00000000 		.4byte	.LFB75
 8782 003c 34000000 		.4byte	.LFE75
 8783 0040 00000000 		.4byte	.LFB76
 8784 0044 58000000 		.4byte	.LFE76
 8785 0048 00000000 		.4byte	.LFB77
 8786 004c 44010000 		.4byte	.LFE77
 8787 0050 00000000 		.4byte	.LFB78
 8788 0054 EC000000 		.4byte	.LFE78
 8789 0058 00000000 		.4byte	.LFB79
 8790 005c 5C000000 		.4byte	.LFE79
 8791 0060 00000000 		.4byte	.LFB80
 8792 0064 A0000000 		.4byte	.LFE80
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 245


 8793 0068 00000000 		.4byte	.LFB81
 8794 006c C4000000 		.4byte	.LFE81
 8795 0070 00000000 		.4byte	.LFB82
 8796 0074 6C000000 		.4byte	.LFE82
 8797 0078 00000000 		.4byte	.LFB83
 8798 007c 2C000000 		.4byte	.LFE83
 8799 0080 00000000 		.4byte	.LFB84
 8800 0084 1C000000 		.4byte	.LFE84
 8801 0088 00000000 		.4byte	.LFB85
 8802 008c 20010000 		.4byte	.LFE85
 8803 0090 00000000 		.4byte	.LFB86
 8804 0094 20000000 		.4byte	.LFE86
 8805 0098 00000000 		.4byte	.LFB87
 8806 009c 24000000 		.4byte	.LFE87
 8807 00a0 00000000 		.4byte	.LFB88
 8808 00a4 18000000 		.4byte	.LFE88
 8809 00a8 00000000 		.4byte	.LFB89
 8810 00ac 2C000000 		.4byte	.LFE89
 8811 00b0 00000000 		.4byte	.LFB90
 8812 00b4 5C010000 		.4byte	.LFE90
 8813 00b8 00000000 		.4byte	.LFB91
 8814 00bc D4000000 		.4byte	.LFE91
 8815 00c0 00000000 		.4byte	.LFB92
 8816 00c4 2C000000 		.4byte	.LFE92
 8817 00c8 00000000 		.4byte	.LFB93
 8818 00cc 38000000 		.4byte	.LFE93
 8819 00d0 00000000 		.4byte	.LFB94
 8820 00d4 AC000000 		.4byte	.LFE94
 8821 00d8 00000000 		.4byte	.LFB95
 8822 00dc 94000000 		.4byte	.LFE95
 8823 00e0 00000000 		.4byte	.LFB96
 8824 00e4 2C000000 		.4byte	.LFE96
 8825 00e8 00000000 		.4byte	.LFB97
 8826 00ec 88000000 		.4byte	.LFE97
 8827 00f0 00000000 		.4byte	.LFB98
 8828 00f4 18000000 		.4byte	.LFE98
 8829 00f8 00000000 		.4byte	.LFB99
 8830 00fc 0E000000 		.4byte	.LFE99
 8831 0100 00000000 		.4byte	.LFB100
 8832 0104 7C000000 		.4byte	.LFE100
 8833 0108 00000000 		.4byte	.LFB101
 8834 010c 74000000 		.4byte	.LFE101
 8835 0110 00000000 		.4byte	.LFB102
 8836 0114 38000000 		.4byte	.LFE102
 8837 0118 00000000 		.4byte	.LFB103
 8838 011c 38000000 		.4byte	.LFE103
 8839 0120 00000000 		.4byte	.LFB104
 8840 0124 1E000000 		.4byte	.LFE104
 8841 0128 00000000 		.4byte	.LFB105
 8842 012c 48000000 		.4byte	.LFE105
 8843 0130 00000000 		.4byte	.LFB106
 8844 0134 20000000 		.4byte	.LFE106
 8845 0138 00000000 		.4byte	.LFB107
 8846 013c F0000000 		.4byte	.LFE107
 8847 0140 00000000 		.4byte	.LFB108
 8848 0144 CC000000 		.4byte	.LFE108
 8849 0148 00000000 		.4byte	.LFB109
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 246


 8850 014c 30000000 		.4byte	.LFE109
 8851 0150 00000000 		.4byte	.LFB110
 8852 0154 28000000 		.4byte	.LFE110
 8853 0158 00000000 		.4byte	.LFB111
 8854 015c 90000000 		.4byte	.LFE111
 8855 0160 00000000 		.4byte	.LFB112
 8856 0164 B4000000 		.4byte	.LFE112
 8857 0168 00000000 		.4byte	.LFB113
 8858 016c 10010000 		.4byte	.LFE113
 8859 0170 00000000 		.4byte	.LFB114
 8860 0174 54010000 		.4byte	.LFE114
 8861 0178 00000000 		.4byte	.LFB115
 8862 017c E8000000 		.4byte	.LFE115
 8863 0180 00000000 		.4byte	.LFB116
 8864 0184 4C000000 		.4byte	.LFE116
 8865 0188 00000000 		.4byte	.LFB117
 8866 018c C8000000 		.4byte	.LFE117
 8867 0190 00000000 		.4byte	0
 8868 0194 00000000 		.4byte	0
 8869              		.section	.debug_line,"",%progbits
 8870              	.Ldebug_line0:
 8871 0000 730A0000 		.section	.debug_str,"MS",%progbits,1
 8871      02002902 
 8871      00000201 
 8871      FB0E0D00 
 8871      01010101 
 8872              	.LASF70:
 8873 0000 70635461 		.ascii	"pcTaskName\000"
 8873      736B4E61 
 8873      6D6500
 8874              	.LASF37:
 8875 000b 75784E75 		.ascii	"uxNumberOfItems\000"
 8875      6D626572 
 8875      4F664974 
 8875      656D7300 
 8876              	.LASF68:
 8877 001b 75785072 		.ascii	"uxPriority\000"
 8877      696F7269 
 8877      747900
 8878              	.LASF145:
 8879 0026 7078436F 		.ascii	"pxConstList\000"
 8879      6E73744C 
 8879      69737400 
 8880              	.LASF113:
 8881 0032 70785374 		.ascii	"pxStateList\000"
 8881      6174654C 
 8881      69737400 
 8882              	.LASF45:
 8883 003e 65537573 		.ascii	"eSuspended\000"
 8883      70656E64 
 8883      656400
 8884              	.LASF47:
 8885 0049 65496E76 		.ascii	"eInvalid\000"
 8885      616C6964 
 8885      00
 8886              	.LASF132:
 8887 0052 75785065 		.ascii	"uxPendedCounts\000"
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 247


 8887      6E646564 
 8887      436F756E 
 8887      747300
 8888              	.LASF184:
 8889 0061 756C4269 		.ascii	"ulBitsToClearOnExit\000"
 8889      7473546F 
 8889      436C6561 
 8889      724F6E45 
 8889      78697400 
 8890              	.LASF95:
 8891 0075 70727649 		.ascii	"prvInitialiseNewTask\000"
 8891      6E697469 
 8891      616C6973 
 8891      654E6577 
 8891      5461736B 
 8892              	.LASF193:
 8893 008a 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 8893      67686572 
 8893      5072696F 
 8893      72697479 
 8893      5461736B 
 8894              	.LASF49:
 8895 00a4 654E6F41 		.ascii	"eNoAction\000"
 8895      6374696F 
 8895      6E00
 8896              	.LASF209:
 8897 00ae 7578546F 		.ascii	"uxTopReadyPriority\000"
 8897      70526561 
 8897      64795072 
 8897      696F7269 
 8897      747900
 8898              	.LASF0:
 8899 00c1 756E7369 		.ascii	"unsigned int\000"
 8899      676E6564 
 8899      20696E74 
 8899      00
 8900              	.LASF147:
 8901 00ce 70784576 		.ascii	"pxEventList\000"
 8901      656E744C 
 8901      69737400 
 8902              	.LASF210:
 8903 00da 78536368 		.ascii	"xSchedulerRunning\000"
 8903      6564756C 
 8903      65725275 
 8903      6E6E696E 
 8903      6700
 8904              	.LASF38:
 8905 00ec 7078496E 		.ascii	"pxIndex\000"
 8905      64657800 
 8906              	.LASF173:
 8907 00f4 76546173 		.ascii	"vTaskPriorityInherit\000"
 8907      6B507269 
 8907      6F726974 
 8907      79496E68 
 8907      65726974 
 8908              	.LASF23:
 8909 0109 53746163 		.ascii	"StackType_t\000"
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 248


 8909      6B547970 
 8909      655F7400 
 8910              	.LASF55:
 8911 0115 7854494D 		.ascii	"xTIME_OUT\000"
 8911      455F4F55 
 8911      5400
 8912              	.LASF205:
 8913 011f 75784465 		.ascii	"uxDeletedTasksWaitingCleanUp\000"
 8913      6C657465 
 8913      64546173 
 8913      6B735761 
 8913      6974696E 
 8914              	.LASF8:
 8915 013c 5F5F696E 		.ascii	"__int32_t\000"
 8915      7433325F 
 8915      7400
 8916              	.LASF33:
 8917 0146 784C4953 		.ascii	"xLIST_ITEM\000"
 8917      545F4954 
 8917      454D00
 8918              	.LASF198:
 8919 0151 70785265 		.ascii	"pxReadyTasksLists\000"
 8919      61647954 
 8919      61736B73 
 8919      4C697374 
 8919      7300
 8920              	.LASF191:
 8921 0163 75634F72 		.ascii	"ucOriginalNotifyState\000"
 8921      6967696E 
 8921      616C4E6F 
 8921      74696679 
 8921      53746174 
 8922              	.LASF154:
 8923 0179 76546173 		.ascii	"vTaskSetTimeOutState\000"
 8923      6B536574 
 8923      54696D65 
 8923      4F757453 
 8923      74617465 
 8924              	.LASF192:
 8925 018e 78546173 		.ascii	"xTaskGenericNotifyFromISR\000"
 8925      6B47656E 
 8925      65726963 
 8925      4E6F7469 
 8925      66794672 
 8926              	.LASF138:
 8927 01a8 78546173 		.ascii	"xTaskIncrementTick\000"
 8927      6B496E63 
 8927      72656D65 
 8927      6E745469 
 8927      636B00
 8928              	.LASF84:
 8929 01bb 756C4269 		.ascii	"ulBitmap\000"
 8929      746D6170 
 8929      00
 8930              	.LASF199:
 8931 01c4 7844656C 		.ascii	"xDelayedTaskList1\000"
 8931      61796564 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 249


 8931      5461736B 
 8931      4C697374 
 8931      3100
 8932              	.LASF200:
 8933 01d6 7844656C 		.ascii	"xDelayedTaskList2\000"
 8933      61796564 
 8933      5461736B 
 8933      4C697374 
 8933      3200
 8934              	.LASF56:
 8935 01e8 784F7665 		.ascii	"xOverflowCount\000"
 8935      72666C6F 
 8935      77436F75 
 8935      6E7400
 8936              	.LASF222:
 8937 01f7 433A5C55 		.ascii	"C:\\Users\\bmt\\Documents\\GitHub\\FreeRTOS_CY8CKIT"
 8937      73657273 
 8937      5C626D74 
 8937      5C446F63 
 8937      756D656E 
 8938 0225 5F303539 		.ascii	"_059\\FreeRTOS_Demo.cydsn\000"
 8938      5C467265 
 8938      6552544F 
 8938      535F4465 
 8938      6D6F2E63 
 8939              	.LASF62:
 8940 023e 756C5061 		.ascii	"ulParameters\000"
 8940      72616D65 
 8940      74657273 
 8940      00
 8941              	.LASF112:
 8942 024b 65526574 		.ascii	"eReturn\000"
 8942      75726E00 
 8943              	.LASF126:
 8944 0253 78546173 		.ascii	"xTaskToResume\000"
 8944      6B546F52 
 8944      6573756D 
 8944      6500
 8945              	.LASF115:
 8946 0261 75785265 		.ascii	"uxReturn\000"
 8946      7475726E 
 8946      00
 8947              	.LASF177:
 8948 026a 75785461 		.ascii	"uxTaskGetNumberOfTasks\000"
 8948      736B4765 
 8948      744E756D 
 8948      6265724F 
 8948      66546173 
 8949              	.LASF87:
 8950 0281 70634E61 		.ascii	"pcName\000"
 8950      6D6500
 8951              	.LASF75:
 8952 0288 74736B54 		.ascii	"tskTCB\000"
 8952      434200
 8953              	.LASF128:
 8954 028f 75785361 		.ascii	"uxSavedInterruptStatus\000"
 8954      76656449 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 250


 8954      6E746572 
 8954      72757074 
 8954      53746174 
 8955              	.LASF19:
 8956 02a6 75696E74 		.ascii	"uint32_t\000"
 8956      33325F74 
 8956      00
 8957              	.LASF74:
 8958 02af 75634E6F 		.ascii	"ucNotifyState\000"
 8958      74696679 
 8958      53746174 
 8958      6500
 8959              	.LASF122:
 8960 02bd 78596965 		.ascii	"xYieldRequired\000"
 8960      6C645265 
 8960      71756972 
 8960      656400
 8961              	.LASF77:
 8962 02cc 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 8962      6967696E 
 8962      616C4241 
 8962      53455052 
 8962      4900
 8963              	.LASF186:
 8964 02de 78546173 		.ascii	"xTaskGenericNotify\000"
 8964      6B47656E 
 8964      65726963 
 8964      4E6F7469 
 8964      667900
 8965              	.LASF20:
 8966 02f1 666C6F61 		.ascii	"float\000"
 8966      7400
 8967              	.LASF151:
 8968 02f7 7078556E 		.ascii	"pxUnblockedTCB\000"
 8968      626C6F63 
 8968      6B656454 
 8968      434200
 8969              	.LASF88:
 8970 0306 75735374 		.ascii	"usStackDepth\000"
 8970      61636B44 
 8970      65707468 
 8970      00
 8971              	.LASF180:
 8972 0313 78436C65 		.ascii	"xClearCountOnExit\000"
 8972      6172436F 
 8972      756E744F 
 8972      6E457869 
 8972      7400
 8973              	.LASF52:
 8974 0325 65536574 		.ascii	"eSetValueWithOverwrite\000"
 8974      56616C75 
 8974      65576974 
 8974      684F7665 
 8974      72777269 
 8975              	.LASF13:
 8976 033c 6C6F6E67 		.ascii	"long long unsigned int\000"
 8976      206C6F6E 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 251


 8976      6720756E 
 8976      7369676E 
 8976      65642069 
 8977              	.LASF135:
 8978 0353 78546173 		.ascii	"xTaskGetTickCountFromISR\000"
 8978      6B476574 
 8978      5469636B 
 8978      436F756E 
 8978      7446726F 
 8979              	.LASF117:
 8980 036c 75785361 		.ascii	"uxSavedInterruptState\000"
 8980      76656449 
 8980      6E746572 
 8980      72757074 
 8980      53746174 
 8981              	.LASF183:
 8982 0382 756C4269 		.ascii	"ulBitsToClearOnEntry\000"
 8982      7473546F 
 8982      436C6561 
 8982      724F6E45 
 8982      6E747279 
 8983              	.LASF203:
 8984 0397 7850656E 		.ascii	"xPendingReadyList\000"
 8984      64696E67 
 8984      52656164 
 8984      794C6973 
 8984      7400
 8985              	.LASF29:
 8986 03a9 70785072 		.ascii	"pxPrevious\000"
 8986      6576696F 
 8986      757300
 8987              	.LASF204:
 8988 03b4 78546173 		.ascii	"xTasksWaitingTermination\000"
 8988      6B735761 
 8988      6974696E 
 8988      67546572 
 8988      6D696E61 
 8989              	.LASF6:
 8990 03cd 5F5F7569 		.ascii	"__uint16_t\000"
 8990      6E743136 
 8990      5F7400
 8991              	.LASF127:
 8992 03d8 78546173 		.ascii	"xTaskResumeFromISR\000"
 8992      6B526573 
 8992      756D6546 
 8992      726F6D49 
 8992      535200
 8993              	.LASF158:
 8994 03eb 76546173 		.ascii	"vTaskSuspendAll\000"
 8994      6B537573 
 8994      70656E64 
 8994      416C6C00 
 8995              	.LASF168:
 8996 03fb 75785461 		.ascii	"uxTaskGetStackHighWaterMark\000"
 8996      736B4765 
 8996      74537461 
 8996      636B4869 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 252


 8996      67685761 
 8997              	.LASF54:
 8998 0417 654E6F74 		.ascii	"eNotifyAction\000"
 8998      69667941 
 8998      6374696F 
 8998      6E00
 8999              	.LASF2:
 9000 0425 73697A65 		.ascii	"size_t\000"
 9000      5F7400
 9001              	.LASF51:
 9002 042c 65496E63 		.ascii	"eIncrement\000"
 9002      72656D65 
 9002      6E7400
 9003              	.LASF34:
 9004 0437 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 9004      495F4C49 
 9004      53545F49 
 9004      54454D00 
 9005              	.LASF166:
 9006 0447 70756353 		.ascii	"pucStackByte\000"
 9006      7461636B 
 9006      42797465 
 9006      00
 9007              	.LASF36:
 9008 0454 784C4953 		.ascii	"xLIST\000"
 9008      5400
 9009              	.LASF130:
 9010 045a 76546173 		.ascii	"vTaskEndScheduler\000"
 9010      6B456E64 
 9010      53636865 
 9010      64756C65 
 9010      7200
 9011              	.LASF114:
 9012 046c 75785461 		.ascii	"uxTaskPriorityGet\000"
 9012      736B5072 
 9012      696F7269 
 9012      74794765 
 9012      7400
 9013              	.LASF106:
 9014 047e 78436F6E 		.ascii	"xConstTickCount\000"
 9014      73745469 
 9014      636B436F 
 9014      756E7400 
 9015              	.LASF206:
 9016 048e 78537573 		.ascii	"xSuspendedTaskList\000"
 9016      70656E64 
 9016      65645461 
 9016      736B4C69 
 9016      737400
 9017              	.LASF79:
 9018 04a1 76506F72 		.ascii	"vPortSetBASEPRI\000"
 9018      74536574 
 9018      42415345 
 9018      50524900 
 9019              	.LASF167:
 9020 04b1 756C436F 		.ascii	"ulCount\000"
 9020      756E7400 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 253


 9021              	.LASF64:
 9022 04b9 74736B54 		.ascii	"tskTaskControlBlock\000"
 9022      61736B43 
 9022      6F6E7472 
 9022      6F6C426C 
 9022      6F636B00 
 9023              	.LASF202:
 9024 04cd 70784F76 		.ascii	"pxOverflowDelayedTaskList\000"
 9024      6572666C 
 9024      6F774465 
 9024      6C617965 
 9024      64546173 
 9025              	.LASF140:
 9026 04e7 70785465 		.ascii	"pxTemp\000"
 9026      6D7000
 9027              	.LASF146:
 9028 04ee 76546173 		.ascii	"vTaskPlaceOnEventList\000"
 9028      6B506C61 
 9028      63654F6E 
 9028      4576656E 
 9028      744C6973 
 9029              	.LASF107:
 9030 0504 76546173 		.ascii	"vTaskDelay\000"
 9030      6B44656C 
 9030      617900
 9031              	.LASF178:
 9032 050f 70765461 		.ascii	"pvTaskIncrementMutexHeldCount\000"
 9032      736B496E 
 9032      6372656D 
 9032      656E744D 
 9032      75746578 
 9033              	.LASF73:
 9034 052d 756C4E6F 		.ascii	"ulNotifiedValue\000"
 9034      74696669 
 9034      65645661 
 9034      6C756500 
 9035              	.LASF72:
 9036 053d 75784D75 		.ascii	"uxMutexesHeld\000"
 9036      74657865 
 9036      7348656C 
 9036      6400
 9037              	.LASF175:
 9038 054b 78546173 		.ascii	"xTaskPriorityDisinherit\000"
 9038      6B507269 
 9038      6F726974 
 9038      79446973 
 9038      696E6865 
 9039              	.LASF150:
 9040 0563 78546173 		.ascii	"xTaskRemoveFromEventList\000"
 9040      6B52656D 
 9040      6F766546 
 9040      726F6D45 
 9040      76656E74 
 9041              	.LASF15:
 9042 057c 63686172 		.ascii	"char\000"
 9042      00
 9043              	.LASF32:
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 254


 9044 0581 4C697374 		.ascii	"ListItem_t\000"
 9044      4974656D 
 9044      5F7400
 9045              	.LASF53:
 9046 058c 65536574 		.ascii	"eSetValueWithoutOverwrite\000"
 9046      56616C75 
 9046      65576974 
 9046      686F7574 
 9046      4F766572 
 9047              	.LASF78:
 9048 05a6 756C4E65 		.ascii	"ulNewBASEPRI\000"
 9048      77424153 
 9048      45505249 
 9048      00
 9049              	.LASF25:
 9050 05b3 55426173 		.ascii	"UBaseType_t\000"
 9050      65547970 
 9050      655F7400 
 9051              	.LASF93:
 9052 05bf 756C5374 		.ascii	"ulStackDepth\000"
 9052      61636B44 
 9052      65707468 
 9052      00
 9053              	.LASF105:
 9054 05cc 7853686F 		.ascii	"xShouldDelay\000"
 9054      756C6444 
 9054      656C6179 
 9054      00
 9055              	.LASF160:
 9056 05d9 70727649 		.ascii	"prvIdleTask\000"
 9056      646C6554 
 9056      61736B00 
 9057              	.LASF39:
 9058 05e5 784C6973 		.ascii	"xListEnd\000"
 9058      74456E64 
 9058      00
 9059              	.LASF163:
 9060 05ee 784C6973 		.ascii	"xListIsEmpty\000"
 9060      74497345 
 9060      6D707479 
 9060      00
 9061              	.LASF179:
 9062 05fb 756C5461 		.ascii	"ulTaskNotifyTake\000"
 9062      736B4E6F 
 9062      74696679 
 9062      54616B65 
 9062      00
 9063              	.LASF35:
 9064 060c 4D696E69 		.ascii	"MiniListItem_t\000"
 9064      4C697374 
 9064      4974656D 
 9064      5F7400
 9065              	.LASF182:
 9066 061b 78546173 		.ascii	"xTaskNotifyWait\000"
 9066      6B4E6F74 
 9066      69667957 
 9066      61697400 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 255


 9067              	.LASF109:
 9068 062b 78546173 		.ascii	"xTaskCreate\000"
 9068      6B437265 
 9068      61746500 
 9069              	.LASF96:
 9070 0637 70727641 		.ascii	"prvAddNewTaskToReadyList\000"
 9070      64644E65 
 9070      77546173 
 9070      6B546F52 
 9070      65616479 
 9071              	.LASF16:
 9072 0650 75696E74 		.ascii	"uint8_t\000"
 9072      385F7400 
 9073              	.LASF43:
 9074 0658 65526561 		.ascii	"eReady\000"
 9074      647900
 9075              	.LASF110:
 9076 065f 65546173 		.ascii	"eTaskGetState\000"
 9076      6B476574 
 9076      53746174 
 9076      6500
 9077              	.LASF91:
 9078 066d 70784E65 		.ascii	"pxNewTCB\000"
 9078      77544342 
 9078      00
 9079              	.LASF86:
 9080 0676 70785461 		.ascii	"pxTaskCode\000"
 9080      736B436F 
 9080      646500
 9081              	.LASF63:
 9082 0681 4D656D6F 		.ascii	"MemoryRegion_t\000"
 9082      72795265 
 9082      67696F6E 
 9082      5F7400
 9083              	.LASF215:
 9084 0690 784E6578 		.ascii	"xNextTaskUnblockTime\000"
 9084      74546173 
 9084      6B556E62 
 9084      6C6F636B 
 9084      54696D65 
 9085              	.LASF81:
 9086 06a5 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 9086      72745261 
 9086      69736542 
 9086      41534550 
 9086      524900
 9087              	.LASF208:
 9088 06b8 78546963 		.ascii	"xTickCount\000"
 9088      6B436F75 
 9088      6E7400
 9089              	.LASF12:
 9090 06c3 6C6F6E67 		.ascii	"long long int\000"
 9090      206C6F6E 
 9090      6720696E 
 9090      7400
 9091              	.LASF46:
 9092 06d1 6544656C 		.ascii	"eDeleted\000"
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 256


 9092      65746564 
 9092      00
 9093              	.LASF82:
 9094 06da 7563506F 		.ascii	"ucPortCountLeadingZeros\000"
 9094      7274436F 
 9094      756E744C 
 9094      65616469 
 9094      6E675A65 
 9095              	.LASF61:
 9096 06f2 756C4C65 		.ascii	"ulLengthInBytes\000"
 9096      6E677468 
 9096      496E4279 
 9096      74657300 
 9097              	.LASF24:
 9098 0702 42617365 		.ascii	"BaseType_t\000"
 9098      54797065 
 9098      5F7400
 9099              	.LASF143:
 9100 070d 756C4368 		.ascii	"ulCheckValue\000"
 9100      65636B56 
 9100      616C7565 
 9100      00
 9101              	.LASF171:
 9102 071a 70727652 		.ascii	"prvResetNextTaskUnblockTime\000"
 9102      65736574 
 9102      4E657874 
 9102      5461736B 
 9102      556E626C 
 9103              	.LASF57:
 9104 0736 7854696D 		.ascii	"xTimeOnEntering\000"
 9104      654F6E45 
 9104      6E746572 
 9104      696E6700 
 9105              	.LASF119:
 9106 0746 75784E65 		.ascii	"uxNewPriority\000"
 9106      77507269 
 9106      6F726974 
 9106      7900
 9107              	.LASF22:
 9108 0754 5461736B 		.ascii	"TaskFunction_t\000"
 9108      46756E63 
 9108      74696F6E 
 9108      5F7400
 9109              	.LASF28:
 9110 0763 70784E65 		.ascii	"pxNext\000"
 9110      787400
 9111              	.LASF220:
 9112 076a 474E5520 		.ascii	"GNU C 4.9.3 20150303 (release) [ARM/embedded-4_9-br"
 9112      4320342E 
 9112      392E3320 
 9112      32303135 
 9112      30333033 
 9113 079d 616E6368 		.ascii	"anch revision 221220] -mcpu=cortex-m3 -mthumb -g -O"
 9113      20726576 
 9113      6973696F 
 9113      6E203232 
 9113      31323230 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 257


 9114 07d0 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 9114      66756E63 
 9114      74696F6E 
 9114      2D736563 
 9114      74696F6E 
 9115              	.LASF155:
 9116 07f8 70785469 		.ascii	"pxTimeOut\000"
 9116      6D654F75 
 9116      7400
 9117              	.LASF116:
 9118 0802 75785461 		.ascii	"uxTaskPriorityGetFromISR\000"
 9118      736B5072 
 9118      696F7269 
 9118      74794765 
 9118      7446726F 
 9119              	.LASF133:
 9120 081b 78546173 		.ascii	"xTaskGetTickCount\000"
 9120      6B476574 
 9120      5469636B 
 9120      436F756E 
 9120      7400
 9121              	.LASF58:
 9122 082d 54696D65 		.ascii	"TimeOut_t\000"
 9122      4F75745F 
 9122      7400
 9123              	.LASF214:
 9124 0837 75785461 		.ascii	"uxTaskNumber\000"
 9124      736B4E75 
 9124      6D626572 
 9124      00
 9125              	.LASF41:
 9126 0844 5461736B 		.ascii	"TaskHandle_t\000"
 9126      48616E64 
 9126      6C655F74 
 9126      00
 9127              	.LASF189:
 9128 0851 65416374 		.ascii	"eAction\000"
 9128      696F6E00 
 9129              	.LASF83:
 9130 0859 756C4E65 		.ascii	"ulNewMaskValue\000"
 9130      774D6173 
 9130      6B56616C 
 9130      756500
 9131              	.LASF176:
 9132 0868 75785461 		.ascii	"uxTaskResetEventItemValue\000"
 9132      736B5265 
 9132      73657445 
 9132      76656E74 
 9132      4974656D 
 9133              	.LASF118:
 9134 0882 76546173 		.ascii	"vTaskPrioritySet\000"
 9134      6B507269 
 9134      6F726974 
 9134      79536574 
 9134      00
 9135              	.LASF48:
 9136 0893 65546173 		.ascii	"eTaskState\000"
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 258


 9136      6B537461 
 9136      746500
 9137              	.LASF40:
 9138 089e 4C697374 		.ascii	"List_t\000"
 9138      5F7400
 9139              	.LASF137:
 9140 08a5 78546173 		.ascii	"xTaskToQuery\000"
 9140      6B546F51 
 9140      75657279 
 9140      00
 9141              	.LASF26:
 9142 08b2 5469636B 		.ascii	"TickType_t\000"
 9142      54797065 
 9142      5F7400
 9143              	.LASF187:
 9144 08bd 78546173 		.ascii	"xTaskToNotify\000"
 9144      6B546F4E 
 9144      6F746966 
 9144      7900
 9145              	.LASF111:
 9146 08cb 78546173 		.ascii	"xTask\000"
 9146      6B00
 9147              	.LASF50:
 9148 08d1 65536574 		.ascii	"eSetBits\000"
 9148      42697473 
 9148      00
 9149              	.LASF59:
 9150 08da 784D454D 		.ascii	"xMEMORY_REGION\000"
 9150      4F52595F 
 9150      52454749 
 9150      4F4E00
 9151              	.LASF17:
 9152 08e9 75696E74 		.ascii	"uint16_t\000"
 9152      31365F74 
 9152      00
 9153              	.LASF99:
 9154 08f2 76546173 		.ascii	"vTaskDelete\000"
 9154      6B44656C 
 9154      65746500 
 9155              	.LASF141:
 9156 08fe 76546173 		.ascii	"vTaskSwitchContext\000"
 9156      6B537769 
 9156      74636843 
 9156      6F6E7465 
 9156      787400
 9157              	.LASF213:
 9158 0911 784E756D 		.ascii	"xNumOfOverflows\000"
 9158      4F664F76 
 9158      6572666C 
 9158      6F777300 
 9159              	.LASF31:
 9160 0921 7076436F 		.ascii	"pvContainer\000"
 9160      6E746169 
 9160      6E657200 
 9161              	.LASF216:
 9162 092d 7849646C 		.ascii	"xIdleTaskHandle\000"
 9162      65546173 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 259


 9162      6B48616E 
 9162      646C6500 
 9163              	.LASF5:
 9164 093d 73686F72 		.ascii	"short int\000"
 9164      7420696E 
 9164      7400
 9165              	.LASF89:
 9166 0947 70765061 		.ascii	"pvParameters\000"
 9166      72616D65 
 9166      74657273 
 9166      00
 9167              	.LASF27:
 9168 0954 78497465 		.ascii	"xItemValue\000"
 9168      6D56616C 
 9168      756500
 9169              	.LASF9:
 9170 095f 6C6F6E67 		.ascii	"long int\000"
 9170      20696E74 
 9170      00
 9171              	.LASF218:
 9172 0968 49544D5F 		.ascii	"ITM_RxBuffer\000"
 9172      52784275 
 9172      66666572 
 9172      00
 9173              	.LASF131:
 9174 0975 78546173 		.ascii	"xTaskResumeAll\000"
 9174      6B526573 
 9174      756D6541 
 9174      6C6C00
 9175              	.LASF194:
 9176 0984 76546173 		.ascii	"vTaskNotifyGiveFromISR\000"
 9176      6B4E6F74 
 9176      69667947 
 9176      69766546 
 9176      726F6D49 
 9177              	.LASF201:
 9178 099b 70784465 		.ascii	"pxDelayedTaskList\000"
 9178      6C617965 
 9178      64546173 
 9178      6B4C6973 
 9178      7400
 9179              	.LASF164:
 9180 09ad 70727654 		.ascii	"prvTaskIsTaskSuspended\000"
 9180      61736B49 
 9180      73546173 
 9180      6B537573 
 9180      70656E64 
 9181              	.LASF139:
 9182 09c4 78537769 		.ascii	"xSwitchRequired\000"
 9182      74636852 
 9182      65717569 
 9182      72656400 
 9183              	.LASF174:
 9184 09d4 70784D75 		.ascii	"pxMutexHolder\000"
 9184      74657848 
 9184      6F6C6465 
 9184      7200
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 260


 9185              	.LASF69:
 9186 09e2 70785374 		.ascii	"pxStack\000"
 9186      61636B00 
 9187              	.LASF97:
 9188 09ea 78546173 		.ascii	"xTaskToDelete\000"
 9188      6B546F44 
 9188      656C6574 
 9188      6500
 9189              	.LASF188:
 9190 09f8 756C5661 		.ascii	"ulValue\000"
 9190      6C756500 
 9191              	.LASF124:
 9192 0a00 78546173 		.ascii	"xTaskToSuspend\000"
 9192      6B546F53 
 9192      75737065 
 9192      6E6400
 9193              	.LASF156:
 9194 0a0f 78546173 		.ascii	"xTaskCheckForTimeOut\000"
 9194      6B436865 
 9194      636B466F 
 9194      7254696D 
 9194      654F7574 
 9195              	.LASF101:
 9196 0a24 70785072 		.ascii	"pxPreviousWakeTime\000"
 9196      6576696F 
 9196      75735761 
 9196      6B655469 
 9196      6D6500
 9197              	.LASF3:
 9198 0a37 5F5F7569 		.ascii	"__uint8_t\000"
 9198      6E74385F 
 9198      7400
 9199              	.LASF85:
 9200 0a41 75635265 		.ascii	"ucReturn\000"
 9200      7475726E 
 9200      00
 9201              	.LASF190:
 9202 0a4a 70756C50 		.ascii	"pulPreviousNotificationValue\000"
 9202      72657669 
 9202      6F75734E 
 9202      6F746966 
 9202      69636174 
 9203              	.LASF185:
 9204 0a67 70756C4E 		.ascii	"pulNotificationValue\000"
 9204      6F746966 
 9204      69636174 
 9204      696F6E56 
 9204      616C7565 
 9205              	.LASF92:
 9206 0a7c 78526574 		.ascii	"xReturn\000"
 9206      75726E00 
 9207              	.LASF14:
 9208 0a84 73697A65 		.ascii	"sizetype\000"
 9208      74797065 
 9208      00
 9209              	.LASF159:
 9210 0a8d 76546173 		.ascii	"vTaskMissedYield\000"
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 261


 9210      6B4D6973 
 9210      73656459 
 9210      69656C64 
 9210      00
 9211              	.LASF211:
 9212 0a9e 75785065 		.ascii	"uxPendedTicks\000"
 9212      6E646564 
 9212      5469636B 
 9212      7300
 9213              	.LASF11:
 9214 0aac 6C6F6E67 		.ascii	"long unsigned int\000"
 9214      20756E73 
 9214      69676E65 
 9214      6420696E 
 9214      7400
 9215              	.LASF80:
 9216 0abe 76506F72 		.ascii	"vPortRaiseBASEPRI\000"
 9216      74526169 
 9216      73654241 
 9216      53455052 
 9216      4900
 9217              	.LASF221:
 9218 0ad0 2E2E5C53 		.ascii	"..\\Source\\tasks.c\000"
 9218      6F757263 
 9218      655C7461 
 9218      736B732E 
 9218      6300
 9219              	.LASF169:
 9220 0ae2 70756345 		.ascii	"pucEndOfStack\000"
 9220      6E644F66 
 9220      53746163 
 9220      6B00
 9221              	.LASF136:
 9222 0af0 70635461 		.ascii	"pcTaskGetName\000"
 9222      736B4765 
 9222      744E616D 
 9222      6500
 9223              	.LASF18:
 9224 0afe 696E7433 		.ascii	"int32_t\000"
 9224      325F7400 
 9225              	.LASF134:
 9226 0b06 78546963 		.ascii	"xTicks\000"
 9226      6B7300
 9227              	.LASF129:
 9228 0b0d 76546173 		.ascii	"vTaskStartScheduler\000"
 9228      6B537461 
 9228      72745363 
 9228      68656475 
 9228      6C657200 
 9229              	.LASF197:
 9230 0b21 7843616E 		.ascii	"xCanBlockIndefinitely\000"
 9230      426C6F63 
 9230      6B496E64 
 9230      6566696E 
 9230      6974656C 
 9231              	.LASF42:
 9232 0b37 6552756E 		.ascii	"eRunning\000"
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 262


 9232      6E696E67 
 9232      00
 9233              	.LASF142:
 9234 0b40 70756C53 		.ascii	"pulStack\000"
 9234      7461636B 
 9234      00
 9235              	.LASF60:
 9236 0b49 70764261 		.ascii	"pvBaseAddress\000"
 9236      73654164 
 9236      64726573 
 9236      7300
 9237              	.LASF108:
 9238 0b57 78546963 		.ascii	"xTicksToDelay\000"
 9238      6B73546F 
 9238      44656C61 
 9238      7900
 9239              	.LASF4:
 9240 0b65 756E7369 		.ascii	"unsigned char\000"
 9240      676E6564 
 9240      20636861 
 9240      7200
 9241              	.LASF149:
 9242 0b73 76546173 		.ascii	"vTaskPlaceOnUnorderedEventList\000"
 9242      6B506C61 
 9242      63654F6E 
 9242      556E6F72 
 9242      64657265 
 9243              	.LASF152:
 9244 0b92 78546173 		.ascii	"xTaskRemoveFromUnorderedEventList\000"
 9244      6B52656D 
 9244      6F766546 
 9244      726F6D55 
 9244      6E6F7264 
 9245              	.LASF10:
 9246 0bb4 5F5F7569 		.ascii	"__uint32_t\000"
 9246      6E743332 
 9246      5F7400
 9247              	.LASF195:
 9248 0bbf 78546173 		.ascii	"xTaskNotifyStateClear\000"
 9248      6B4E6F74 
 9248      69667953 
 9248      74617465 
 9248      436C6561 
 9249              	.LASF157:
 9250 0bd5 70785469 		.ascii	"pxTicksToWait\000"
 9250      636B7354 
 9250      6F576169 
 9250      7400
 9251              	.LASF144:
 9252 0be3 7578546F 		.ascii	"uxTopPriority\000"
 9252      70507269 
 9252      6F726974 
 9252      7900
 9253              	.LASF71:
 9254 0bf1 75784261 		.ascii	"uxBasePriority\000"
 9254      73655072 
 9254      696F7269 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 263


 9254      747900
 9255              	.LASF100:
 9256 0c00 76546173 		.ascii	"vTaskDelayUntil\000"
 9256      6B44656C 
 9256      6179556E 
 9256      74696C00 
 9257              	.LASF67:
 9258 0c10 78457665 		.ascii	"xEventListItem\000"
 9258      6E744C69 
 9258      73744974 
 9258      656D00
 9259              	.LASF121:
 9260 0c1f 75785072 		.ascii	"uxPriorityUsedOnEntry\000"
 9260      696F7269 
 9260      74795573 
 9260      65644F6E 
 9260      456E7472 
 9261              	.LASF76:
 9262 0c35 5443425F 		.ascii	"TCB_t\000"
 9262      7400
 9263              	.LASF148:
 9264 0c3b 78546963 		.ascii	"xTicksToWait\000"
 9264      6B73546F 
 9264      57616974 
 9264      00
 9265              	.LASF30:
 9266 0c48 70764F77 		.ascii	"pvOwner\000"
 9266      6E657200 
 9267              	.LASF170:
 9268 0c50 70727644 		.ascii	"prvDeleteTCB\000"
 9268      656C6574 
 9268      65544342 
 9268      00
 9269              	.LASF44:
 9270 0c5d 65426C6F 		.ascii	"eBlocked\000"
 9270      636B6564 
 9270      00
 9271              	.LASF123:
 9272 0c66 76546173 		.ascii	"vTaskSuspend\000"
 9272      6B537573 
 9272      70656E64 
 9272      00
 9273              	.LASF104:
 9274 0c73 78416C72 		.ascii	"xAlreadyYielded\000"
 9274      65616479 
 9274      5969656C 
 9274      64656400 
 9275              	.LASF172:
 9276 0c83 78546173 		.ascii	"xTaskGetCurrentTaskHandle\000"
 9276      6B476574 
 9276      43757272 
 9276      656E7454 
 9276      61736B48 
 9277              	.LASF165:
 9278 0c9d 70727654 		.ascii	"prvTaskCheckFreeStackSpace\000"
 9278      61736B43 
 9278      6865636B 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 264


 9278      46726565 
 9278      53746163 
 9279              	.LASF94:
 9280 0cb8 78526567 		.ascii	"xRegions\000"
 9280      696F6E73 
 9280      00
 9281              	.LASF196:
 9282 0cc1 70727641 		.ascii	"prvAddCurrentTaskToDelayedList\000"
 9282      64644375 
 9282      7272656E 
 9282      74546173 
 9282      6B546F44 
 9283              	.LASF219:
 9284 0ce0 70784375 		.ascii	"pxCurrentTCB\000"
 9284      7272656E 
 9284      74544342 
 9284      00
 9285              	.LASF207:
 9286 0ced 75784375 		.ascii	"uxCurrentNumberOfTasks\000"
 9286      7272656E 
 9286      744E756D 
 9286      6265724F 
 9286      66546173 
 9287              	.LASF102:
 9288 0d04 7854696D 		.ascii	"xTimeIncrement\000"
 9288      65496E63 
 9288      72656D65 
 9288      6E7400
 9289              	.LASF1:
 9290 0d13 7369676E 		.ascii	"signed char\000"
 9290      65642063 
 9290      68617200 
 9291              	.LASF7:
 9292 0d1f 73686F72 		.ascii	"short unsigned int\000"
 9292      7420756E 
 9292      7369676E 
 9292      65642069 
 9292      6E7400
 9293              	.LASF103:
 9294 0d32 7854696D 		.ascii	"xTimeToWake\000"
 9294      65546F57 
 9294      616B6500 
 9295              	.LASF66:
 9296 0d3e 78537461 		.ascii	"xStateListItem\000"
 9296      74654C69 
 9296      73744974 
 9296      656D00
 9297              	.LASF98:
 9298 0d4d 70785443 		.ascii	"pxTCB\000"
 9298      4200
 9299              	.LASF21:
 9300 0d53 646F7562 		.ascii	"double\000"
 9300      6C6500
 9301              	.LASF217:
 9302 0d5a 75785363 		.ascii	"uxSchedulerSuspended\000"
 9302      68656475 
 9302      6C657253 
ARM GAS  C:\Users\bmt\AppData\Local\Temp\ccld84Qq.s 			page 265


 9302      75737065 
 9302      6E646564 
 9303              	.LASF65:
 9304 0d6f 7078546F 		.ascii	"pxTopOfStack\000"
 9304      704F6653 
 9304      7461636B 
 9304      00
 9305              	.LASF125:
 9306 0d7c 76546173 		.ascii	"vTaskResume\000"
 9306      6B526573 
 9306      756D6500 
 9307              	.LASF161:
 9308 0d88 70727649 		.ascii	"prvInitialiseTaskLists\000"
 9308      6E697469 
 9308      616C6973 
 9308      65546173 
 9308      6B4C6973 
 9309              	.LASF153:
 9310 0d9f 70784576 		.ascii	"pxEventListItem\000"
 9310      656E744C 
 9310      69737449 
 9310      74656D00 
 9311              	.LASF90:
 9312 0daf 70784372 		.ascii	"pxCreatedTask\000"
 9312      65617465 
 9312      64546173 
 9312      6B00
 9313              	.LASF162:
 9314 0dbd 70727643 		.ascii	"prvCheckTasksWaitingTermination\000"
 9314      6865636B 
 9314      5461736B 
 9314      73576169 
 9314      74696E67 
 9315              	.LASF181:
 9316 0ddd 756C5265 		.ascii	"ulReturn\000"
 9316      7475726E 
 9316      00
 9317              	.LASF120:
 9318 0de6 75784375 		.ascii	"uxCurrentBasePriority\000"
 9318      7272656E 
 9318      74426173 
 9318      65507269 
 9318      6F726974 
 9319              	.LASF212:
 9320 0dfc 78596965 		.ascii	"xYieldPending\000"
 9320      6C645065 
 9320      6E64696E 
 9320      6700
 9321              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.9.3 20150303 (release) [ARM/embedded-4_9-br
