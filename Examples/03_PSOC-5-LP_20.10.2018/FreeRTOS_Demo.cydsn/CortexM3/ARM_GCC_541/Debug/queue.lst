ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"queue.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.comm	sniffIDFilter,13,4
  20              		.comm	buffer,4098,4
  21              		.comm	objectList,1704,4
  22              		.comm	xQueueRegistry,80,4
  23              		.section	.text.xQueueGenericReset,"ax",%progbits
  24              		.align	2
  25              		.global	xQueueGenericReset
  26              		.thumb
  27              		.thumb_func
  28              		.type	xQueueGenericReset, %function
  29              	xQueueGenericReset:
  30              	.LFB68:
  31              		.file 1 "..\\Source\\queue.c"
   1:..\Source/queue.c **** /*
   2:..\Source/queue.c ****     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:..\Source/queue.c ****     All rights reserved
   4:..\Source/queue.c **** 
   5:..\Source/queue.c ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:..\Source/queue.c **** 
   7:..\Source/queue.c ****     This file is part of the FreeRTOS distribution.
   8:..\Source/queue.c **** 
   9:..\Source/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:..\Source/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  11:..\Source/queue.c ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:..\Source/queue.c **** 
  13:..\Source/queue.c ****     ***************************************************************************
  14:..\Source/queue.c ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:..\Source/queue.c ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:..\Source/queue.c ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:..\Source/queue.c ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:..\Source/queue.c ****     ***************************************************************************
  19:..\Source/queue.c **** 
  20:..\Source/queue.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:..\Source/queue.c ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:..\Source/queue.c ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:..\Source/queue.c ****     link: http://www.freertos.org/a00114.html
  24:..\Source/queue.c **** 
  25:..\Source/queue.c ****     ***************************************************************************
  26:..\Source/queue.c ****      *                                                                       *
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 2


  27:..\Source/queue.c ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:..\Source/queue.c ****      *    robust, strictly quality controlled, supported, and cross          *
  29:..\Source/queue.c ****      *    platform software that is more than just the market leader, it     *
  30:..\Source/queue.c ****      *    is the industry's de facto standard.                               *
  31:..\Source/queue.c ****      *                                                                       *
  32:..\Source/queue.c ****      *    Help yourself get started quickly while simultaneously helping     *
  33:..\Source/queue.c ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:..\Source/queue.c ****      *    tutorial book, reference manual, or both:                          *
  35:..\Source/queue.c ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:..\Source/queue.c ****      *                                                                       *
  37:..\Source/queue.c ****     ***************************************************************************
  38:..\Source/queue.c **** 
  39:..\Source/queue.c ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:..\Source/queue.c ****     the FAQ page "My application does not run, what could be wrong?".  Have you
  41:..\Source/queue.c ****     defined configASSERT()?
  42:..\Source/queue.c **** 
  43:..\Source/queue.c ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:..\Source/queue.c ****     embedded software for free we request you assist our global community by
  45:..\Source/queue.c ****     participating in the support forum.
  46:..\Source/queue.c **** 
  47:..\Source/queue.c ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:..\Source/queue.c ****     be as productive as possible as early as possible.  Now you can receive
  49:..\Source/queue.c ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:..\Source/queue.c ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:..\Source/queue.c **** 
  52:..\Source/queue.c ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:..\Source/queue.c ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:..\Source/queue.c ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:..\Source/queue.c **** 
  56:..\Source/queue.c ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:..\Source/queue.c ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:..\Source/queue.c **** 
  59:..\Source/queue.c ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:..\Source/queue.c ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:..\Source/queue.c ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:..\Source/queue.c **** 
  63:..\Source/queue.c ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:..\Source/queue.c ****     engineered and independently SIL3 certified version for use in safety and
  65:..\Source/queue.c ****     mission critical applications that require provable dependability.
  66:..\Source/queue.c **** 
  67:..\Source/queue.c ****     1 tab == 4 spaces!
  68:..\Source/queue.c **** */
  69:..\Source/queue.c **** 
  70:..\Source/queue.c **** #include <stdlib.h>
  71:..\Source/queue.c **** #include <string.h>
  72:..\Source/queue.c **** 
  73:..\Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  74:..\Source/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  75:..\Source/queue.c **** task.h is included from an application file. */
  76:..\Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  77:..\Source/queue.c **** 
  78:..\Source/queue.c **** #include "FreeRTOS.h"
  79:..\Source/queue.c **** #include "task.h"
  80:..\Source/queue.c **** #include "queue.h"
  81:..\Source/queue.c **** 
  82:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  83:..\Source/queue.c **** 	#include "croutine.h"
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 3


  84:..\Source/queue.c **** #endif
  85:..\Source/queue.c **** 
  86:..\Source/queue.c **** /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
  87:..\Source/queue.c **** MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
  88:..\Source/queue.c **** header files above, but not in this file, in order to generate the correct
  89:..\Source/queue.c **** privileged Vs unprivileged linkage and placement. */
  90:..\Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
  91:..\Source/queue.c **** 
  92:..\Source/queue.c **** 
  93:..\Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  94:..\Source/queue.c **** #define queueUNLOCKED					( ( int8_t ) -1 )
  95:..\Source/queue.c **** #define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
  96:..\Source/queue.c **** 
  97:..\Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  98:..\Source/queue.c **** pcTail members are used as pointers into the queue storage area.  When the
  99:..\Source/queue.c **** Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
 100:..\Source/queue.c **** not necessary, and the pcHead pointer is set to NULL to indicate that the
 101:..\Source/queue.c **** pcTail pointer actually points to the mutex holder (if any).  Map alternative
 102:..\Source/queue.c **** names to the pcHead and pcTail structure members to ensure the readability of
 103:..\Source/queue.c **** the code is maintained despite this dual use of two structure members.  An
 104:..\Source/queue.c **** alternative implementation would be to use a union, but use of a union is
 105:..\Source/queue.c **** against the coding standard (although an exception to the standard has been
 106:..\Source/queue.c **** permitted where the dual use also significantly changes the type of the
 107:..\Source/queue.c **** structure member). */
 108:..\Source/queue.c **** #define pxMutexHolder					pcTail
 109:..\Source/queue.c **** #define uxQueueType						pcHead
 110:..\Source/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
 111:..\Source/queue.c **** 
 112:..\Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
 113:..\Source/queue.c **** zero. */
 114:..\Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
 115:..\Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
 116:..\Source/queue.c **** 
 117:..\Source/queue.c **** #if( configUSE_PREEMPTION == 0 )
 118:..\Source/queue.c **** 	/* If the cooperative scheduler is being used then a yield should not be
 119:..\Source/queue.c **** 	performed just because a higher priority task has been woken. */
 120:..\Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION()
 121:..\Source/queue.c **** #else
 122:..\Source/queue.c **** 	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
 123:..\Source/queue.c **** #endif
 124:..\Source/queue.c **** 
 125:..\Source/queue.c **** /*
 126:..\Source/queue.c ****  * Definition of the queue used by the scheduler.
 127:..\Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
 128:..\Source/queue.c ****  * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
 129:..\Source/queue.c ****  */
 130:..\Source/queue.c **** typedef struct QueueDefinition
 131:..\Source/queue.c **** {
 132:..\Source/queue.c **** 	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
 133:..\Source/queue.c **** 	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte i
 134:..\Source/queue.c **** 	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
 135:..\Source/queue.c **** 
 136:..\Source/queue.c **** 	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclus
 137:..\Source/queue.c **** 	{
 138:..\Source/queue.c **** 		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the stru
 139:..\Source/queue.c **** 		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex h
 140:..\Source/queue.c **** 	} u;
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 4


 141:..\Source/queue.c **** 
 142:..\Source/queue.c **** 	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  
 143:..\Source/queue.c **** 	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.
 144:..\Source/queue.c **** 
 145:..\Source/queue.c **** 	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
 146:..\Source/queue.c **** 	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, n
 147:..\Source/queue.c **** 	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
 148:..\Source/queue.c **** 
 149:..\Source/queue.c **** 	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the
 150:..\Source/queue.c **** 	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the qu
 151:..\Source/queue.c **** 
 152:..\Source/queue.c **** 	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 153:..\Source/queue.c **** 		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically a
 154:..\Source/queue.c **** 	#endif
 155:..\Source/queue.c **** 
 156:..\Source/queue.c **** 	#if ( configUSE_QUEUE_SETS == 1 )
 157:..\Source/queue.c **** 		struct QueueDefinition *pxQueueSetContainer;
 158:..\Source/queue.c **** 	#endif
 159:..\Source/queue.c **** 
 160:..\Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 161:..\Source/queue.c **** 		UBaseType_t uxQueueNumber;
 162:..\Source/queue.c **** 		uint8_t ucQueueType;
 163:..\Source/queue.c **** 	#endif
 164:..\Source/queue.c **** 
 165:..\Source/queue.c **** } xQUEUE;
 166:..\Source/queue.c **** 
 167:..\Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 168:..\Source/queue.c **** name below to enable the use of older kernel aware debuggers. */
 169:..\Source/queue.c **** typedef xQUEUE Queue_t;
 170:..\Source/queue.c **** 
 171:..\Source/queue.c **** /*-----------------------------------------------------------*/
 172:..\Source/queue.c **** 
 173:..\Source/queue.c **** /*
 174:..\Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 175:..\Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 176:..\Source/queue.c ****  */
 177:..\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 178:..\Source/queue.c **** 
 179:..\Source/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 180:..\Source/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 181:..\Source/queue.c **** 	more user friendly. */
 182:..\Source/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 183:..\Source/queue.c **** 	{
 184:..\Source/queue.c **** 		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single c
 185:..\Source/queue.c **** 		QueueHandle_t xHandle;
 186:..\Source/queue.c **** 	} xQueueRegistryItem;
 187:..\Source/queue.c **** 
 188:..\Source/queue.c **** 	/* The old xQueueRegistryItem name is maintained above then typedefed to the
 189:..\Source/queue.c **** 	new xQueueRegistryItem name below to enable the use of older kernel aware
 190:..\Source/queue.c **** 	debuggers. */
 191:..\Source/queue.c **** 	typedef xQueueRegistryItem QueueRegistryItem_t;
 192:..\Source/queue.c **** 
 193:..\Source/queue.c **** 	/* The queue registry is simply an array of QueueRegistryItem_t structures.
 194:..\Source/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:..\Source/queue.c **** 	array position being vacant. */
 196:..\Source/queue.c **** 	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:..\Source/queue.c **** 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 5


 198:..\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 199:..\Source/queue.c **** 
 200:..\Source/queue.c **** /*
 201:..\Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 202:..\Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 203:..\Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 204:..\Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 205:..\Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 206:..\Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 207:..\Source/queue.c ****  */
 208:..\Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
 209:..\Source/queue.c **** 
 210:..\Source/queue.c **** /*
 211:..\Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 212:..\Source/queue.c ****  *
 213:..\Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 214:..\Source/queue.c ****  */
 215:..\Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 216:..\Source/queue.c **** 
 217:..\Source/queue.c **** /*
 218:..\Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 219:..\Source/queue.c ****  *
 220:..\Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 221:..\Source/queue.c ****  */
 222:..\Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
 223:..\Source/queue.c **** 
 224:..\Source/queue.c **** /*
 225:..\Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 226:..\Source/queue.c ****  * back of the queue.
 227:..\Source/queue.c ****  */
 228:..\Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
 229:..\Source/queue.c **** 
 230:..\Source/queue.c **** /*
 231:..\Source/queue.c ****  * Copies an item out of a queue.
 232:..\Source/queue.c ****  */
 233:..\Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCT
 234:..\Source/queue.c **** 
 235:..\Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 236:..\Source/queue.c **** 	/*
 237:..\Source/queue.c **** 	 * Checks to see if a queue is a member of a queue set, and if so, notifies
 238:..\Source/queue.c **** 	 * the queue set that the queue contains data.
 239:..\Source/queue.c **** 	 */
 240:..\Source/queue.c **** 	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCop
 241:..\Source/queue.c **** #endif
 242:..\Source/queue.c **** 
 243:..\Source/queue.c **** /*
 244:..\Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 245:..\Source/queue.c ****  * dynamically to fill in the structure's members.
 246:..\Source/queue.c ****  */
 247:..\Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 248:..\Source/queue.c **** 
 249:..\Source/queue.c **** /*
 250:..\Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 251:..\Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 252:..\Source/queue.c ****  * as a mutex.
 253:..\Source/queue.c ****  */
 254:..\Source/queue.c **** #if( configUSE_MUTEXES == 1 )
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 6


 255:..\Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
 256:..\Source/queue.c **** #endif
 257:..\Source/queue.c **** 
 258:..\Source/queue.c **** /*-----------------------------------------------------------*/
 259:..\Source/queue.c **** 
 260:..\Source/queue.c **** /*
 261:..\Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 262:..\Source/queue.c ****  * accessing the queue event lists.
 263:..\Source/queue.c ****  */
 264:..\Source/queue.c **** #define prvLockQueue( pxQueue )								\
 265:..\Source/queue.c **** 	taskENTER_CRITICAL();									\
 266:..\Source/queue.c **** 	{														\
 267:..\Source/queue.c **** 		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
 268:..\Source/queue.c **** 		{													\
 269:..\Source/queue.c **** 			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
 270:..\Source/queue.c **** 		}													\
 271:..\Source/queue.c **** 		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
 272:..\Source/queue.c **** 		{													\
 273:..\Source/queue.c **** 			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
 274:..\Source/queue.c **** 		}													\
 275:..\Source/queue.c **** 	}														\
 276:..\Source/queue.c **** 	taskEXIT_CRITICAL()
 277:..\Source/queue.c **** /*-----------------------------------------------------------*/
 278:..\Source/queue.c **** 
 279:..\Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
 280:..\Source/queue.c **** {
  32              		.loc 1 280 0
  33              		.cfi_startproc
  34              		@ args = 0, pretend = 0, frame = 16
  35              		@ frame_needed = 1, uses_anonymous_args = 0
  36 0000 80B5     		push	{r7, lr}
  37              		.cfi_def_cfa_offset 8
  38              		.cfi_offset 7, -8
  39              		.cfi_offset 14, -4
  40 0002 84B0     		sub	sp, sp, #16
  41              		.cfi_def_cfa_offset 24
  42 0004 00AF     		add	r7, sp, #0
  43              		.cfi_def_cfa_register 7
  44 0006 7860     		str	r0, [r7, #4]
  45 0008 3960     		str	r1, [r7]
 281:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
  46              		.loc 1 281 0
  47 000a 7B68     		ldr	r3, [r7, #4]
  48 000c FB60     		str	r3, [r7, #12]
 282:..\Source/queue.c **** 
 283:..\Source/queue.c **** 	configASSERT( pxQueue );
 284:..\Source/queue.c **** 
 285:..\Source/queue.c **** 	taskENTER_CRITICAL();
  49              		.loc 1 285 0
  50 000e FFF7FEFF 		bl	vPortEnterCritical
 286:..\Source/queue.c **** 	{
 287:..\Source/queue.c **** 		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  51              		.loc 1 287 0
  52 0012 FB68     		ldr	r3, [r7, #12]
  53 0014 1A68     		ldr	r2, [r3]
  54 0016 FB68     		ldr	r3, [r7, #12]
  55 0018 DB6B     		ldr	r3, [r3, #60]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 7


  56 001a F968     		ldr	r1, [r7, #12]
  57 001c 096C     		ldr	r1, [r1, #64]
  58 001e 01FB03F3 		mul	r3, r1, r3
  59 0022 1A44     		add	r2, r2, r3
  60 0024 FB68     		ldr	r3, [r7, #12]
  61 0026 5A60     		str	r2, [r3, #4]
 288:..\Source/queue.c **** 		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  62              		.loc 1 288 0
  63 0028 FB68     		ldr	r3, [r7, #12]
  64 002a 0022     		movs	r2, #0
  65 002c 9A63     		str	r2, [r3, #56]
 289:..\Source/queue.c **** 		pxQueue->pcWriteTo = pxQueue->pcHead;
  66              		.loc 1 289 0
  67 002e FB68     		ldr	r3, [r7, #12]
  68 0030 1A68     		ldr	r2, [r3]
  69 0032 FB68     		ldr	r3, [r7, #12]
  70 0034 9A60     		str	r2, [r3, #8]
 290:..\Source/queue.c **** 		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue-
  71              		.loc 1 290 0
  72 0036 FB68     		ldr	r3, [r7, #12]
  73 0038 1A68     		ldr	r2, [r3]
  74 003a FB68     		ldr	r3, [r7, #12]
  75 003c DB6B     		ldr	r3, [r3, #60]
  76 003e 013B     		subs	r3, r3, #1
  77 0040 F968     		ldr	r1, [r7, #12]
  78 0042 096C     		ldr	r1, [r1, #64]
  79 0044 01FB03F3 		mul	r3, r1, r3
  80 0048 1A44     		add	r2, r2, r3
  81 004a FB68     		ldr	r3, [r7, #12]
  82 004c DA60     		str	r2, [r3, #12]
 291:..\Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
  83              		.loc 1 291 0
  84 004e FB68     		ldr	r3, [r7, #12]
  85 0050 FF22     		movs	r2, #255
  86 0052 83F84420 		strb	r2, [r3, #68]
 292:..\Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
  87              		.loc 1 292 0
  88 0056 FB68     		ldr	r3, [r7, #12]
  89 0058 FF22     		movs	r2, #255
  90 005a 83F84520 		strb	r2, [r3, #69]
 293:..\Source/queue.c **** 
 294:..\Source/queue.c **** 		if( xNewQueue == pdFALSE )
  91              		.loc 1 294 0
  92 005e 3B68     		ldr	r3, [r7]
  93 0060 002B     		cmp	r3, #0
  94 0062 14D1     		bne	.L2
 295:..\Source/queue.c **** 		{
 296:..\Source/queue.c **** 			/* If there are tasks blocked waiting to read from the queue, then
 297:..\Source/queue.c **** 			the tasks will remain blocked as after this function exits the queue
 298:..\Source/queue.c **** 			will still be empty.  If there are tasks blocked waiting to write to
 299:..\Source/queue.c **** 			the queue, then one should be unblocked as after this function exits
 300:..\Source/queue.c **** 			it will be possible to write to it. */
 301:..\Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  95              		.loc 1 301 0
  96 0064 FB68     		ldr	r3, [r7, #12]
  97 0066 1B69     		ldr	r3, [r3, #16]
  98 0068 002B     		cmp	r3, #0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 8


  99 006a 1AD0     		beq	.L3
 302:..\Source/queue.c **** 			{
 303:..\Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 100              		.loc 1 303 0
 101 006c FB68     		ldr	r3, [r7, #12]
 102 006e 1033     		adds	r3, r3, #16
 103 0070 1846     		mov	r0, r3
 104 0072 FFF7FEFF 		bl	xTaskRemoveFromEventList
 105 0076 0346     		mov	r3, r0
 106 0078 002B     		cmp	r3, #0
 107 007a 12D0     		beq	.L3
 304:..\Source/queue.c **** 				{
 305:..\Source/queue.c **** 					queueYIELD_IF_USING_PREEMPTION();
 108              		.loc 1 305 0
 109 007c 0C4B     		ldr	r3, .L5
 110 007e 4FF08052 		mov	r2, #268435456
 111 0082 1A60     		str	r2, [r3]
 112              		.syntax unified
 113              	@ 305 "..\Source\queue.c" 1
 114 0084 BFF34F8F 		dsb
 115              	@ 0 "" 2
 116              	@ 305 "..\Source\queue.c" 1
 117 0088 BFF36F8F 		isb
 118              	@ 0 "" 2
 119              		.thumb
 120              		.syntax unified
 121 008c 09E0     		b	.L3
 122              	.L2:
 306:..\Source/queue.c **** 				}
 307:..\Source/queue.c **** 				else
 308:..\Source/queue.c **** 				{
 309:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 310:..\Source/queue.c **** 				}
 311:..\Source/queue.c **** 			}
 312:..\Source/queue.c **** 			else
 313:..\Source/queue.c **** 			{
 314:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 315:..\Source/queue.c **** 			}
 316:..\Source/queue.c **** 		}
 317:..\Source/queue.c **** 		else
 318:..\Source/queue.c **** 		{
 319:..\Source/queue.c **** 			/* Ensure the event queues start in the correct state. */
 320:..\Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 123              		.loc 1 320 0
 124 008e FB68     		ldr	r3, [r7, #12]
 125 0090 1033     		adds	r3, r3, #16
 126 0092 1846     		mov	r0, r3
 127 0094 FFF7FEFF 		bl	vListInitialise
 321:..\Source/queue.c **** 			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 128              		.loc 1 321 0
 129 0098 FB68     		ldr	r3, [r7, #12]
 130 009a 2433     		adds	r3, r3, #36
 131 009c 1846     		mov	r0, r3
 132 009e FFF7FEFF 		bl	vListInitialise
 133              	.L3:
 322:..\Source/queue.c **** 		}
 323:..\Source/queue.c **** 	}
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 9


 324:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 134              		.loc 1 324 0
 135 00a2 FFF7FEFF 		bl	vPortExitCritical
 325:..\Source/queue.c **** 
 326:..\Source/queue.c **** 	/* A value is returned for calling semantic consistency with previous
 327:..\Source/queue.c **** 	versions. */
 328:..\Source/queue.c **** 	return pdPASS;
 136              		.loc 1 328 0
 137 00a6 0123     		movs	r3, #1
 329:..\Source/queue.c **** }
 138              		.loc 1 329 0
 139 00a8 1846     		mov	r0, r3
 140 00aa 1037     		adds	r7, r7, #16
 141              		.cfi_def_cfa_offset 8
 142 00ac BD46     		mov	sp, r7
 143              		.cfi_def_cfa_register 13
 144              		@ sp needed
 145 00ae 80BD     		pop	{r7, pc}
 146              	.L6:
 147              		.align	2
 148              	.L5:
 149 00b0 04ED00E0 		.word	-536810236
 150              		.cfi_endproc
 151              	.LFE68:
 152              		.size	xQueueGenericReset, .-xQueueGenericReset
 153              		.section	.text.xQueueGenericCreate,"ax",%progbits
 154              		.align	2
 155              		.global	xQueueGenericCreate
 156              		.thumb
 157              		.thumb_func
 158              		.type	xQueueGenericCreate, %function
 159              	xQueueGenericCreate:
 160              	.LFB69:
 330:..\Source/queue.c **** /*-----------------------------------------------------------*/
 331:..\Source/queue.c **** 
 332:..\Source/queue.c **** #if( configSUPPORT_STATIC_ALLOCATION == 1 )
 333:..\Source/queue.c **** 
 334:..\Source/queue.c **** 	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItem
 335:..\Source/queue.c **** 	{
 336:..\Source/queue.c **** 	Queue_t *pxNewQueue;
 337:..\Source/queue.c **** 
 338:..\Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 339:..\Source/queue.c **** 
 340:..\Source/queue.c **** 		/* The StaticQueue_t structure and the queue storage area must be
 341:..\Source/queue.c **** 		supplied. */
 342:..\Source/queue.c **** 		configASSERT( pxStaticQueue != NULL );
 343:..\Source/queue.c **** 
 344:..\Source/queue.c **** 		/* A queue storage area should be provided if the item size is not 0, and
 345:..\Source/queue.c **** 		should not be provided if the item size is 0. */
 346:..\Source/queue.c **** 		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 347:..\Source/queue.c **** 		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 348:..\Source/queue.c **** 
 349:..\Source/queue.c **** 		#if( configASSERT_DEFINED == 1 )
 350:..\Source/queue.c **** 		{
 351:..\Source/queue.c **** 			/* Sanity check that the size of the structure used to declare a
 352:..\Source/queue.c **** 			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 353:..\Source/queue.c **** 			the real queue and semaphore structures. */
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 10


 354:..\Source/queue.c **** 			volatile size_t xSize = sizeof( StaticQueue_t );
 355:..\Source/queue.c **** 			configASSERT( xSize == sizeof( Queue_t ) );
 356:..\Source/queue.c **** 		}
 357:..\Source/queue.c **** 		#endif /* configASSERT_DEFINED */
 358:..\Source/queue.c **** 
 359:..\Source/queue.c **** 		/* The address of a statically allocated queue was passed in, use it.
 360:..\Source/queue.c **** 		The address of a statically allocated storage area was also passed in
 361:..\Source/queue.c **** 		but is already set. */
 362:..\Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are d
 363:..\Source/queue.c **** 
 364:..\Source/queue.c **** 		if( pxNewQueue != NULL )
 365:..\Source/queue.c **** 		{
 366:..\Source/queue.c **** 			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 367:..\Source/queue.c **** 			{
 368:..\Source/queue.c **** 				/* Queues can be allocated wither statically or dynamically, so
 369:..\Source/queue.c **** 				note this queue was allocated statically in case the queue is
 370:..\Source/queue.c **** 				later deleted. */
 371:..\Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 372:..\Source/queue.c **** 			}
 373:..\Source/queue.c **** 			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 374:..\Source/queue.c **** 
 375:..\Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 376:..\Source/queue.c **** 		}
 377:..\Source/queue.c **** 
 378:..\Source/queue.c **** 		return pxNewQueue;
 379:..\Source/queue.c **** 	}
 380:..\Source/queue.c **** 
 381:..\Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 382:..\Source/queue.c **** /*-----------------------------------------------------------*/
 383:..\Source/queue.c **** 
 384:..\Source/queue.c **** #if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 385:..\Source/queue.c **** 
 386:..\Source/queue.c **** 	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, 
 387:..\Source/queue.c **** 	{
 161              		.loc 1 387 0
 162              		.cfi_startproc
 163              		@ args = 0, pretend = 0, frame = 32
 164              		@ frame_needed = 1, uses_anonymous_args = 0
 165 0000 80B5     		push	{r7, lr}
 166              		.cfi_def_cfa_offset 8
 167              		.cfi_offset 7, -8
 168              		.cfi_offset 14, -4
 169 0002 8AB0     		sub	sp, sp, #40
 170              		.cfi_def_cfa_offset 48
 171 0004 02AF     		add	r7, sp, #8
 172              		.cfi_def_cfa 7, 40
 173 0006 F860     		str	r0, [r7, #12]
 174 0008 B960     		str	r1, [r7, #8]
 175 000a 1346     		mov	r3, r2
 176 000c FB71     		strb	r3, [r7, #7]
 388:..\Source/queue.c **** 	Queue_t *pxNewQueue;
 389:..\Source/queue.c **** 	size_t xQueueSizeInBytes;
 390:..\Source/queue.c **** 	uint8_t *pucQueueStorage;
 391:..\Source/queue.c **** 
 392:..\Source/queue.c **** 		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 393:..\Source/queue.c **** 
 394:..\Source/queue.c **** 		if( uxItemSize == ( UBaseType_t ) 0 )
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 11


 177              		.loc 1 394 0
 178 000e BB68     		ldr	r3, [r7, #8]
 179 0010 002B     		cmp	r3, #0
 180 0012 02D1     		bne	.L8
 395:..\Source/queue.c **** 		{
 396:..\Source/queue.c **** 			/* There is not going to be a queue storage area. */
 397:..\Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) 0;
 181              		.loc 1 397 0
 182 0014 0023     		movs	r3, #0
 183 0016 FB61     		str	r3, [r7, #28]
 184 0018 04E0     		b	.L9
 185              	.L8:
 398:..\Source/queue.c **** 		}
 399:..\Source/queue.c **** 		else
 400:..\Source/queue.c **** 		{
 401:..\Source/queue.c **** 			/* Allocate enough space to hold the maximum number of items that
 402:..\Source/queue.c **** 			can be in the queue at any time. */
 403:..\Source/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as t
 186              		.loc 1 403 0
 187 001a FB68     		ldr	r3, [r7, #12]
 188 001c BA68     		ldr	r2, [r7, #8]
 189 001e 02FB03F3 		mul	r3, r2, r3
 190 0022 FB61     		str	r3, [r7, #28]
 191              	.L9:
 404:..\Source/queue.c **** 		}
 405:..\Source/queue.c **** 
 406:..\Source/queue.c **** 		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 192              		.loc 1 406 0
 193 0024 FB69     		ldr	r3, [r7, #28]
 194 0026 5033     		adds	r3, r3, #80
 195 0028 1846     		mov	r0, r3
 196 002a FFF7FEFF 		bl	pvPortMalloc
 197 002e B861     		str	r0, [r7, #24]
 407:..\Source/queue.c **** 
 408:..\Source/queue.c **** 		if( pxNewQueue != NULL )
 198              		.loc 1 408 0
 199 0030 BB69     		ldr	r3, [r7, #24]
 200 0032 002B     		cmp	r3, #0
 201 0034 0BD0     		beq	.L10
 409:..\Source/queue.c **** 		{
 410:..\Source/queue.c **** 			/* Jump past the queue structure to find the location of the queue
 411:..\Source/queue.c **** 			storage area. */
 412:..\Source/queue.c **** 			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 202              		.loc 1 412 0
 203 0036 BB69     		ldr	r3, [r7, #24]
 204 0038 5033     		adds	r3, r3, #80
 205 003a 7B61     		str	r3, [r7, #20]
 413:..\Source/queue.c **** 
 414:..\Source/queue.c **** 			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
 415:..\Source/queue.c **** 			{
 416:..\Source/queue.c **** 				/* Queues can be created either statically or dynamically, so
 417:..\Source/queue.c **** 				note this task was created dynamically in case it is later
 418:..\Source/queue.c **** 				deleted. */
 419:..\Source/queue.c **** 				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 420:..\Source/queue.c **** 			}
 421:..\Source/queue.c **** 			#endif /* configSUPPORT_STATIC_ALLOCATION */
 422:..\Source/queue.c **** 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 12


 423:..\Source/queue.c **** 			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 206              		.loc 1 423 0
 207 003c FA79     		ldrb	r2, [r7, #7]	@ zero_extendqisi2
 208 003e BB69     		ldr	r3, [r7, #24]
 209 0040 0093     		str	r3, [sp]
 210 0042 1346     		mov	r3, r2
 211 0044 7A69     		ldr	r2, [r7, #20]
 212 0046 B968     		ldr	r1, [r7, #8]
 213 0048 F868     		ldr	r0, [r7, #12]
 214 004a FFF7FEFF 		bl	prvInitialiseNewQueue
 215              	.L10:
 424:..\Source/queue.c **** 		}
 425:..\Source/queue.c **** 
 426:..\Source/queue.c **** 		return pxNewQueue;
 216              		.loc 1 426 0
 217 004e BB69     		ldr	r3, [r7, #24]
 427:..\Source/queue.c **** 	}
 218              		.loc 1 427 0
 219 0050 1846     		mov	r0, r3
 220 0052 2037     		adds	r7, r7, #32
 221              		.cfi_def_cfa_offset 8
 222 0054 BD46     		mov	sp, r7
 223              		.cfi_def_cfa_register 13
 224              		@ sp needed
 225 0056 80BD     		pop	{r7, pc}
 226              		.cfi_endproc
 227              	.LFE69:
 228              		.size	xQueueGenericCreate, .-xQueueGenericCreate
 229              		.section	.rodata
 230              		.align	2
 231              	.LC0:
 232 0000 51756575 		.ascii	"Queue\000"
 232      6500
 233              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 234              		.align	2
 235              		.thumb
 236              		.thumb_func
 237              		.type	prvInitialiseNewQueue, %function
 238              	prvInitialiseNewQueue:
 239              	.LFB70:
 428:..\Source/queue.c **** 
 429:..\Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 430:..\Source/queue.c **** /*-----------------------------------------------------------*/
 431:..\Source/queue.c **** 
 432:..\Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, u
 433:..\Source/queue.c **** {
 240              		.loc 1 433 0
 241              		.cfi_startproc
 242              		@ args = 4, pretend = 0, frame = 16
 243              		@ frame_needed = 1, uses_anonymous_args = 0
 244 0000 80B5     		push	{r7, lr}
 245              		.cfi_def_cfa_offset 8
 246              		.cfi_offset 7, -8
 247              		.cfi_offset 14, -4
 248 0002 84B0     		sub	sp, sp, #16
 249              		.cfi_def_cfa_offset 24
 250 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 13


 251              		.cfi_def_cfa_register 7
 252 0006 F860     		str	r0, [r7, #12]
 253 0008 B960     		str	r1, [r7, #8]
 254 000a 7A60     		str	r2, [r7, #4]
 255 000c FB70     		strb	r3, [r7, #3]
 434:..\Source/queue.c **** 	/* Remove compiler warnings about unused parameters should
 435:..\Source/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 436:..\Source/queue.c **** 	( void ) ucQueueType;
 437:..\Source/queue.c **** 
 438:..\Source/queue.c **** 	if( uxItemSize == ( UBaseType_t ) 0 )
 256              		.loc 1 438 0
 257 000e BB68     		ldr	r3, [r7, #8]
 258 0010 002B     		cmp	r3, #0
 259 0012 03D1     		bne	.L13
 439:..\Source/queue.c **** 	{
 440:..\Source/queue.c **** 		/* No RAM was allocated for the queue storage area, but PC head cannot
 441:..\Source/queue.c **** 		be set to NULL because NULL is used as a key to say the queue is used as
 442:..\Source/queue.c **** 		a mutex.  Therefore just set pcHead to point to the queue as a benign
 443:..\Source/queue.c **** 		value that is known to be within the memory map. */
 444:..\Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 260              		.loc 1 444 0
 261 0014 BB69     		ldr	r3, [r7, #24]
 262 0016 BA69     		ldr	r2, [r7, #24]
 263 0018 1A60     		str	r2, [r3]
 264 001a 02E0     		b	.L14
 265              	.L13:
 445:..\Source/queue.c **** 	}
 446:..\Source/queue.c **** 	else
 447:..\Source/queue.c **** 	{
 448:..\Source/queue.c **** 		/* Set the head to the start of the queue storage area. */
 449:..\Source/queue.c **** 		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 266              		.loc 1 449 0
 267 001c BB69     		ldr	r3, [r7, #24]
 268 001e 7A68     		ldr	r2, [r7, #4]
 269 0020 1A60     		str	r2, [r3]
 270              	.L14:
 450:..\Source/queue.c **** 	}
 451:..\Source/queue.c **** 
 452:..\Source/queue.c **** 	/* Initialise the queue members as described where the queue type is
 453:..\Source/queue.c **** 	defined. */
 454:..\Source/queue.c **** 	pxNewQueue->uxLength = uxQueueLength;
 271              		.loc 1 454 0
 272 0022 BB69     		ldr	r3, [r7, #24]
 273 0024 FA68     		ldr	r2, [r7, #12]
 274 0026 DA63     		str	r2, [r3, #60]
 455:..\Source/queue.c **** 	pxNewQueue->uxItemSize = uxItemSize;
 275              		.loc 1 455 0
 276 0028 BB69     		ldr	r3, [r7, #24]
 277 002a BA68     		ldr	r2, [r7, #8]
 278 002c 1A64     		str	r2, [r3, #64]
 456:..\Source/queue.c **** 	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 279              		.loc 1 456 0
 280 002e 0121     		movs	r1, #1
 281 0030 B869     		ldr	r0, [r7, #24]
 282 0032 FFF7FEFF 		bl	xQueueGenericReset
 457:..\Source/queue.c **** 
 458:..\Source/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 14


 459:..\Source/queue.c **** 	{
 460:..\Source/queue.c **** 		pxNewQueue->ucQueueType = ucQueueType;
 283              		.loc 1 460 0
 284 0036 BB69     		ldr	r3, [r7, #24]
 285 0038 FA78     		ldrb	r2, [r7, #3]
 286 003a 83F84C20 		strb	r2, [r3, #76]
 461:..\Source/queue.c **** 	}
 462:..\Source/queue.c **** 	#endif /* configUSE_TRACE_FACILITY */
 463:..\Source/queue.c **** 
 464:..\Source/queue.c **** 	#if( configUSE_QUEUE_SETS == 1 )
 465:..\Source/queue.c **** 	{
 466:..\Source/queue.c **** 		pxNewQueue->pxQueueSetContainer = NULL;
 467:..\Source/queue.c **** 	}
 468:..\Source/queue.c **** 	#endif /* configUSE_QUEUE_SETS */
 469:..\Source/queue.c **** 
 470:..\Source/queue.c **** 	traceQUEUE_CREATE( pxNewQueue );
 287              		.loc 1 470 0
 288 003e BB69     		ldr	r3, [r7, #24]
 289 0040 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
 290 0044 0849     		ldr	r1, .L15
 291 0046 1846     		mov	r0, r3
 292 0048 FFF7FEFF 		bl	updateObjectList
 293 004c 0246     		mov	r2, r0
 294 004e BB69     		ldr	r3, [r7, #24]
 295 0050 9A64     		str	r2, [r3, #72]
 296 0052 BB69     		ldr	r3, [r7, #24]
 297 0054 9B6C     		ldr	r3, [r3, #72]
 298 0056 DBB2     		uxtb	r3, r3
 299 0058 1946     		mov	r1, r3
 300 005a 0D20     		movs	r0, #13
 301 005c FFF7FEFF 		bl	packPayload1
 471:..\Source/queue.c **** }
 302              		.loc 1 471 0
 303 0060 00BF     		nop
 304 0062 1037     		adds	r7, r7, #16
 305              		.cfi_def_cfa_offset 8
 306 0064 BD46     		mov	sp, r7
 307              		.cfi_def_cfa_register 13
 308              		@ sp needed
 309 0066 80BD     		pop	{r7, pc}
 310              	.L16:
 311              		.align	2
 312              	.L15:
 313 0068 00000000 		.word	.LC0
 314              		.cfi_endproc
 315              	.LFE70:
 316              		.size	prvInitialiseNewQueue, .-prvInitialiseNewQueue
 317              		.section	.text.prvInitialiseMutex,"ax",%progbits
 318              		.align	2
 319              		.thumb
 320              		.thumb_func
 321              		.type	prvInitialiseMutex, %function
 322              	prvInitialiseMutex:
 323              	.LFB71:
 472:..\Source/queue.c **** /*-----------------------------------------------------------*/
 473:..\Source/queue.c **** 
 474:..\Source/queue.c **** #if( configUSE_MUTEXES == 1 )
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 15


 475:..\Source/queue.c **** 
 476:..\Source/queue.c **** 	static void prvInitialiseMutex( Queue_t *pxNewQueue )
 477:..\Source/queue.c **** 	{
 324              		.loc 1 477 0
 325              		.cfi_startproc
 326              		@ args = 0, pretend = 0, frame = 8
 327              		@ frame_needed = 1, uses_anonymous_args = 0
 328 0000 80B5     		push	{r7, lr}
 329              		.cfi_def_cfa_offset 8
 330              		.cfi_offset 7, -8
 331              		.cfi_offset 14, -4
 332 0002 82B0     		sub	sp, sp, #8
 333              		.cfi_def_cfa_offset 16
 334 0004 00AF     		add	r7, sp, #0
 335              		.cfi_def_cfa_register 7
 336 0006 7860     		str	r0, [r7, #4]
 478:..\Source/queue.c **** 		if( pxNewQueue != NULL )
 337              		.loc 1 478 0
 338 0008 7B68     		ldr	r3, [r7, #4]
 339 000a 002B     		cmp	r3, #0
 340 000c 16D0     		beq	.L18
 479:..\Source/queue.c **** 		{
 480:..\Source/queue.c **** 			/* The queue create function will set all the queue structure members
 481:..\Source/queue.c **** 			correctly for a generic queue, but this function is creating a
 482:..\Source/queue.c **** 			mutex.  Overwrite those members that need to be set differently -
 483:..\Source/queue.c **** 			in particular the information required for priority inheritance. */
 484:..\Source/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 341              		.loc 1 484 0
 342 000e 7B68     		ldr	r3, [r7, #4]
 343 0010 0022     		movs	r2, #0
 344 0012 5A60     		str	r2, [r3, #4]
 485:..\Source/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 345              		.loc 1 485 0
 346 0014 7B68     		ldr	r3, [r7, #4]
 347 0016 0022     		movs	r2, #0
 348 0018 1A60     		str	r2, [r3]
 486:..\Source/queue.c **** 
 487:..\Source/queue.c **** 			/* In case this is a recursive mutex. */
 488:..\Source/queue.c **** 			pxNewQueue->u.uxRecursiveCallCount = 0;
 349              		.loc 1 488 0
 350 001a 7B68     		ldr	r3, [r7, #4]
 351 001c 0022     		movs	r2, #0
 352 001e DA60     		str	r2, [r3, #12]
 489:..\Source/queue.c **** 
 490:..\Source/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 353              		.loc 1 490 0
 354 0020 7B68     		ldr	r3, [r7, #4]
 355 0022 9B6C     		ldr	r3, [r3, #72]
 356 0024 DBB2     		uxtb	r3, r3
 357 0026 1946     		mov	r1, r3
 358 0028 0F20     		movs	r0, #15
 359 002a FFF7FEFF 		bl	packPayload1
 491:..\Source/queue.c **** 
 492:..\Source/queue.c **** 			/* Start with the semaphore in the expected state. */
 493:..\Source/queue.c **** 			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 360              		.loc 1 493 0
 361 002e 0023     		movs	r3, #0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 16


 362 0030 0022     		movs	r2, #0
 363 0032 0021     		movs	r1, #0
 364 0034 7868     		ldr	r0, [r7, #4]
 365 0036 FFF7FEFF 		bl	xQueueGenericSend
 494:..\Source/queue.c **** 		}
 495:..\Source/queue.c **** 		else
 496:..\Source/queue.c **** 		{
 497:..\Source/queue.c **** 			traceCREATE_MUTEX_FAILED();
 498:..\Source/queue.c **** 		}
 499:..\Source/queue.c **** 	}
 366              		.loc 1 499 0
 367 003a 02E0     		b	.L20
 368              	.L18:
 497:..\Source/queue.c **** 		}
 369              		.loc 1 497 0
 370 003c 1020     		movs	r0, #16
 371 003e FFF7FEFF 		bl	packPayload0
 372              	.L20:
 373              		.loc 1 499 0
 374 0042 00BF     		nop
 375 0044 0837     		adds	r7, r7, #8
 376              		.cfi_def_cfa_offset 8
 377 0046 BD46     		mov	sp, r7
 378              		.cfi_def_cfa_register 13
 379              		@ sp needed
 380 0048 80BD     		pop	{r7, pc}
 381              		.cfi_endproc
 382              	.LFE71:
 383              		.size	prvInitialiseMutex, .-prvInitialiseMutex
 384 004a 00BF     		.section	.text.xQueueCreateMutex,"ax",%progbits
 385              		.align	2
 386              		.global	xQueueCreateMutex
 387              		.thumb
 388              		.thumb_func
 389              		.type	xQueueCreateMutex, %function
 390              	xQueueCreateMutex:
 391              	.LFB72:
 500:..\Source/queue.c **** 
 501:..\Source/queue.c **** #endif /* configUSE_MUTEXES */
 502:..\Source/queue.c **** /*-----------------------------------------------------------*/
 503:..\Source/queue.c **** 
 504:..\Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 505:..\Source/queue.c **** 
 506:..\Source/queue.c **** 	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 507:..\Source/queue.c **** 	{
 392              		.loc 1 507 0
 393              		.cfi_startproc
 394              		@ args = 0, pretend = 0, frame = 24
 395              		@ frame_needed = 1, uses_anonymous_args = 0
 396 0000 80B5     		push	{r7, lr}
 397              		.cfi_def_cfa_offset 8
 398              		.cfi_offset 7, -8
 399              		.cfi_offset 14, -4
 400 0002 86B0     		sub	sp, sp, #24
 401              		.cfi_def_cfa_offset 32
 402 0004 00AF     		add	r7, sp, #0
 403              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 17


 404 0006 0346     		mov	r3, r0
 405 0008 FB71     		strb	r3, [r7, #7]
 508:..\Source/queue.c **** 	Queue_t *pxNewQueue;
 509:..\Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 406              		.loc 1 509 0
 407 000a 0123     		movs	r3, #1
 408 000c 7B61     		str	r3, [r7, #20]
 409 000e 0023     		movs	r3, #0
 410 0010 3B61     		str	r3, [r7, #16]
 510:..\Source/queue.c **** 
 511:..\Source/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 411              		.loc 1 511 0
 412 0012 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 413 0014 1A46     		mov	r2, r3
 414 0016 3969     		ldr	r1, [r7, #16]
 415 0018 7869     		ldr	r0, [r7, #20]
 416 001a FFF7FEFF 		bl	xQueueGenericCreate
 417 001e F860     		str	r0, [r7, #12]
 512:..\Source/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 418              		.loc 1 512 0
 419 0020 F868     		ldr	r0, [r7, #12]
 420 0022 FFF7FEFF 		bl	prvInitialiseMutex
 513:..\Source/queue.c **** 
 514:..\Source/queue.c **** 		return pxNewQueue;
 421              		.loc 1 514 0
 422 0026 FB68     		ldr	r3, [r7, #12]
 515:..\Source/queue.c **** 	}
 423              		.loc 1 515 0
 424 0028 1846     		mov	r0, r3
 425 002a 1837     		adds	r7, r7, #24
 426              		.cfi_def_cfa_offset 8
 427 002c BD46     		mov	sp, r7
 428              		.cfi_def_cfa_register 13
 429              		@ sp needed
 430 002e 80BD     		pop	{r7, pc}
 431              		.cfi_endproc
 432              	.LFE72:
 433              		.size	xQueueCreateMutex, .-xQueueCreateMutex
 434              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 435              		.align	2
 436              		.global	xQueueGiveMutexRecursive
 437              		.thumb
 438              		.thumb_func
 439              		.type	xQueueGiveMutexRecursive, %function
 440              	xQueueGiveMutexRecursive:
 441              	.LFB73:
 516:..\Source/queue.c **** 
 517:..\Source/queue.c **** #endif /* configUSE_MUTEXES */
 518:..\Source/queue.c **** /*-----------------------------------------------------------*/
 519:..\Source/queue.c **** 
 520:..\Source/queue.c **** #if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 521:..\Source/queue.c **** 
 522:..\Source/queue.c **** 	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
 523:..\Source/queue.c **** 	{
 524:..\Source/queue.c **** 	Queue_t *pxNewQueue;
 525:..\Source/queue.c **** 	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 526:..\Source/queue.c **** 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 18


 527:..\Source/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 528:..\Source/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 529:..\Source/queue.c **** 		( void ) ucQueueType;
 530:..\Source/queue.c **** 
 531:..\Source/queue.c **** 		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQ
 532:..\Source/queue.c **** 		prvInitialiseMutex( pxNewQueue );
 533:..\Source/queue.c **** 
 534:..\Source/queue.c **** 		return pxNewQueue;
 535:..\Source/queue.c **** 	}
 536:..\Source/queue.c **** 
 537:..\Source/queue.c **** #endif /* configUSE_MUTEXES */
 538:..\Source/queue.c **** /*-----------------------------------------------------------*/
 539:..\Source/queue.c **** 
 540:..\Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 541:..\Source/queue.c **** 
 542:..\Source/queue.c **** 	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 543:..\Source/queue.c **** 	{
 544:..\Source/queue.c **** 	void *pxReturn;
 545:..\Source/queue.c **** 
 546:..\Source/queue.c **** 		/* This function is called by xSemaphoreGetMutexHolder(), and should not
 547:..\Source/queue.c **** 		be called directly.  Note:  This is a good way of determining if the
 548:..\Source/queue.c **** 		calling task is the mutex holder, but not a good way of determining the
 549:..\Source/queue.c **** 		identity of the mutex holder, as the holder may change between the
 550:..\Source/queue.c **** 		following critical section exiting and the function returning. */
 551:..\Source/queue.c **** 		taskENTER_CRITICAL();
 552:..\Source/queue.c **** 		{
 553:..\Source/queue.c **** 			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 554:..\Source/queue.c **** 			{
 555:..\Source/queue.c **** 				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
 556:..\Source/queue.c **** 			}
 557:..\Source/queue.c **** 			else
 558:..\Source/queue.c **** 			{
 559:..\Source/queue.c **** 				pxReturn = NULL;
 560:..\Source/queue.c **** 			}
 561:..\Source/queue.c **** 		}
 562:..\Source/queue.c **** 		taskEXIT_CRITICAL();
 563:..\Source/queue.c **** 
 564:..\Source/queue.c **** 		return pxReturn;
 565:..\Source/queue.c **** 	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 566:..\Source/queue.c **** 
 567:..\Source/queue.c **** #endif
 568:..\Source/queue.c **** /*-----------------------------------------------------------*/
 569:..\Source/queue.c **** 
 570:..\Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 571:..\Source/queue.c **** 
 572:..\Source/queue.c **** 	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 573:..\Source/queue.c **** 	{
 442              		.loc 1 573 0
 443              		.cfi_startproc
 444              		@ args = 0, pretend = 0, frame = 16
 445              		@ frame_needed = 1, uses_anonymous_args = 0
 446 0000 90B5     		push	{r4, r7, lr}
 447              		.cfi_def_cfa_offset 12
 448              		.cfi_offset 4, -12
 449              		.cfi_offset 7, -8
 450              		.cfi_offset 14, -4
 451 0002 85B0     		sub	sp, sp, #20
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 19


 452              		.cfi_def_cfa_offset 32
 453 0004 00AF     		add	r7, sp, #0
 454              		.cfi_def_cfa_register 7
 455 0006 7860     		str	r0, [r7, #4]
 574:..\Source/queue.c **** 	BaseType_t xReturn;
 575:..\Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 456              		.loc 1 575 0
 457 0008 7B68     		ldr	r3, [r7, #4]
 458 000a BB60     		str	r3, [r7, #8]
 576:..\Source/queue.c **** 
 577:..\Source/queue.c **** 		configASSERT( pxMutex );
 578:..\Source/queue.c **** 
 579:..\Source/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 580:..\Source/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 581:..\Source/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 582:..\Source/queue.c **** 		this is the only condition we are interested in it does not matter if
 583:..\Source/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 584:..\Source/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 585:..\Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redunda
 459              		.loc 1 585 0
 460 000c BB68     		ldr	r3, [r7, #8]
 461 000e 5C68     		ldr	r4, [r3, #4]
 462 0010 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 463 0014 0346     		mov	r3, r0
 464 0016 9C42     		cmp	r4, r3
 465 0018 1BD1     		bne	.L24
 586:..\Source/queue.c **** 		{
 587:..\Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 466              		.loc 1 587 0
 467 001a BB68     		ldr	r3, [r7, #8]
 468 001c 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 469 0020 BB68     		ldr	r3, [r7, #8]
 470 0022 9B6C     		ldr	r3, [r3, #72]
 471 0024 DBB2     		uxtb	r3, r3
 472 0026 1A46     		mov	r2, r3
 473 0028 1120     		movs	r0, #17
 474 002a FFF7FEFF 		bl	packPayload2
 588:..\Source/queue.c **** 
 589:..\Source/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 590:..\Source/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 591:..\Source/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 592:..\Source/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 593:..\Source/queue.c **** 			uxRecursiveCallCount member. */
 594:..\Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )--;
 475              		.loc 1 594 0
 476 002e BB68     		ldr	r3, [r7, #8]
 477 0030 DB68     		ldr	r3, [r3, #12]
 478 0032 5A1E     		subs	r2, r3, #1
 479 0034 BB68     		ldr	r3, [r7, #8]
 480 0036 DA60     		str	r2, [r3, #12]
 595:..\Source/queue.c **** 
 596:..\Source/queue.c **** 			/* Has the recursive call count unwound to 0? */
 597:..\Source/queue.c **** 			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 481              		.loc 1 597 0
 482 0038 BB68     		ldr	r3, [r7, #8]
 483 003a DB68     		ldr	r3, [r3, #12]
 484 003c 002B     		cmp	r3, #0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 20


 485 003e 05D1     		bne	.L25
 598:..\Source/queue.c **** 			{
 599:..\Source/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 600:..\Source/queue.c **** 				task that might be waiting to access the mutex. */
 601:..\Source/queue.c **** 				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 486              		.loc 1 601 0
 487 0040 0023     		movs	r3, #0
 488 0042 0022     		movs	r2, #0
 489 0044 0021     		movs	r1, #0
 490 0046 B868     		ldr	r0, [r7, #8]
 491 0048 FFF7FEFF 		bl	xQueueGenericSend
 492              	.L25:
 602:..\Source/queue.c **** 			}
 603:..\Source/queue.c **** 			else
 604:..\Source/queue.c **** 			{
 605:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
 606:..\Source/queue.c **** 			}
 607:..\Source/queue.c **** 
 608:..\Source/queue.c **** 			xReturn = pdPASS;
 493              		.loc 1 608 0
 494 004c 0123     		movs	r3, #1
 495 004e FB60     		str	r3, [r7, #12]
 496 0050 0BE0     		b	.L26
 497              	.L24:
 609:..\Source/queue.c **** 		}
 610:..\Source/queue.c **** 		else
 611:..\Source/queue.c **** 		{
 612:..\Source/queue.c **** 			/* The mutex cannot be given because the calling task is not the
 613:..\Source/queue.c **** 			holder. */
 614:..\Source/queue.c **** 			xReturn = pdFAIL;
 498              		.loc 1 614 0
 499 0052 0023     		movs	r3, #0
 500 0054 FB60     		str	r3, [r7, #12]
 615:..\Source/queue.c **** 
 616:..\Source/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 501              		.loc 1 616 0
 502 0056 BB68     		ldr	r3, [r7, #8]
 503 0058 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 504 005c BB68     		ldr	r3, [r7, #8]
 505 005e 9B6C     		ldr	r3, [r3, #72]
 506 0060 DBB2     		uxtb	r3, r3
 507 0062 1A46     		mov	r2, r3
 508 0064 1220     		movs	r0, #18
 509 0066 FFF7FEFF 		bl	packPayload2
 510              	.L26:
 617:..\Source/queue.c **** 		}
 618:..\Source/queue.c **** 
 619:..\Source/queue.c **** 		return xReturn;
 511              		.loc 1 619 0
 512 006a FB68     		ldr	r3, [r7, #12]
 620:..\Source/queue.c **** 	}
 513              		.loc 1 620 0
 514 006c 1846     		mov	r0, r3
 515 006e 1437     		adds	r7, r7, #20
 516              		.cfi_def_cfa_offset 12
 517 0070 BD46     		mov	sp, r7
 518              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 21


 519              		@ sp needed
 520 0072 90BD     		pop	{r4, r7, pc}
 521              		.cfi_endproc
 522              	.LFE73:
 523              		.size	xQueueGiveMutexRecursive, .-xQueueGiveMutexRecursive
 524              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 525              		.align	2
 526              		.global	xQueueTakeMutexRecursive
 527              		.thumb
 528              		.thumb_func
 529              		.type	xQueueTakeMutexRecursive, %function
 530              	xQueueTakeMutexRecursive:
 531              	.LFB74:
 621:..\Source/queue.c **** 
 622:..\Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 623:..\Source/queue.c **** /*-----------------------------------------------------------*/
 624:..\Source/queue.c **** 
 625:..\Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 626:..\Source/queue.c **** 
 627:..\Source/queue.c **** 	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
 628:..\Source/queue.c **** 	{
 532              		.loc 1 628 0
 533              		.cfi_startproc
 534              		@ args = 0, pretend = 0, frame = 16
 535              		@ frame_needed = 1, uses_anonymous_args = 0
 536 0000 90B5     		push	{r4, r7, lr}
 537              		.cfi_def_cfa_offset 12
 538              		.cfi_offset 4, -12
 539              		.cfi_offset 7, -8
 540              		.cfi_offset 14, -4
 541 0002 85B0     		sub	sp, sp, #20
 542              		.cfi_def_cfa_offset 32
 543 0004 00AF     		add	r7, sp, #0
 544              		.cfi_def_cfa_register 7
 545 0006 7860     		str	r0, [r7, #4]
 546 0008 3960     		str	r1, [r7]
 629:..\Source/queue.c **** 	BaseType_t xReturn;
 630:..\Source/queue.c **** 	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 547              		.loc 1 630 0
 548 000a 7B68     		ldr	r3, [r7, #4]
 549 000c BB60     		str	r3, [r7, #8]
 631:..\Source/queue.c **** 
 632:..\Source/queue.c **** 		configASSERT( pxMutex );
 633:..\Source/queue.c **** 
 634:..\Source/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 635:..\Source/queue.c **** 		xQueueGiveMutexRecursive(). */
 636:..\Source/queue.c **** 
 637:..\Source/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 550              		.loc 1 637 0
 551 000e BB68     		ldr	r3, [r7, #8]
 552 0010 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 553 0014 BB68     		ldr	r3, [r7, #8]
 554 0016 9B6C     		ldr	r3, [r3, #72]
 555 0018 DBB2     		uxtb	r3, r3
 556 001a 1A46     		mov	r2, r3
 557 001c 1320     		movs	r0, #19
 558 001e FFF7FEFF 		bl	packPayload2
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 22


 638:..\Source/queue.c **** 
 639:..\Source/queue.c **** 		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not r
 559              		.loc 1 639 0
 560 0022 BB68     		ldr	r3, [r7, #8]
 561 0024 5C68     		ldr	r4, [r3, #4]
 562 0026 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 563 002a 0346     		mov	r3, r0
 564 002c 9C42     		cmp	r4, r3
 565 002e 07D1     		bne	.L29
 640:..\Source/queue.c **** 		{
 641:..\Source/queue.c **** 			( pxMutex->u.uxRecursiveCallCount )++;
 566              		.loc 1 641 0
 567 0030 BB68     		ldr	r3, [r7, #8]
 568 0032 DB68     		ldr	r3, [r3, #12]
 569 0034 5A1C     		adds	r2, r3, #1
 570 0036 BB68     		ldr	r3, [r7, #8]
 571 0038 DA60     		str	r2, [r3, #12]
 642:..\Source/queue.c **** 			xReturn = pdPASS;
 572              		.loc 1 642 0
 573 003a 0123     		movs	r3, #1
 574 003c FB60     		str	r3, [r7, #12]
 575 003e 19E0     		b	.L30
 576              	.L29:
 643:..\Source/queue.c **** 		}
 644:..\Source/queue.c **** 		else
 645:..\Source/queue.c **** 		{
 646:..\Source/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 577              		.loc 1 646 0
 578 0040 0023     		movs	r3, #0
 579 0042 3A68     		ldr	r2, [r7]
 580 0044 0021     		movs	r1, #0
 581 0046 B868     		ldr	r0, [r7, #8]
 582 0048 FFF7FEFF 		bl	xQueueGenericReceive
 583 004c F860     		str	r0, [r7, #12]
 647:..\Source/queue.c **** 
 648:..\Source/queue.c **** 			/* pdPASS will only be returned if the mutex was successfully
 649:..\Source/queue.c **** 			obtained.  The calling task may have entered the Blocked state
 650:..\Source/queue.c **** 			before reaching here. */
 651:..\Source/queue.c **** 			if( xReturn != pdFAIL )
 584              		.loc 1 651 0
 585 004e FB68     		ldr	r3, [r7, #12]
 586 0050 002B     		cmp	r3, #0
 587 0052 05D0     		beq	.L31
 652:..\Source/queue.c **** 			{
 653:..\Source/queue.c **** 				( pxMutex->u.uxRecursiveCallCount )++;
 588              		.loc 1 653 0
 589 0054 BB68     		ldr	r3, [r7, #8]
 590 0056 DB68     		ldr	r3, [r3, #12]
 591 0058 5A1C     		adds	r2, r3, #1
 592 005a BB68     		ldr	r3, [r7, #8]
 593 005c DA60     		str	r2, [r3, #12]
 594 005e 09E0     		b	.L30
 595              	.L31:
 654:..\Source/queue.c **** 			}
 655:..\Source/queue.c **** 			else
 656:..\Source/queue.c **** 			{
 657:..\Source/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 23


 596              		.loc 1 657 0
 597 0060 BB68     		ldr	r3, [r7, #8]
 598 0062 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 599 0066 BB68     		ldr	r3, [r7, #8]
 600 0068 9B6C     		ldr	r3, [r3, #72]
 601 006a DBB2     		uxtb	r3, r3
 602 006c 1A46     		mov	r2, r3
 603 006e 1420     		movs	r0, #20
 604 0070 FFF7FEFF 		bl	packPayload2
 605              	.L30:
 658:..\Source/queue.c **** 			}
 659:..\Source/queue.c **** 		}
 660:..\Source/queue.c **** 
 661:..\Source/queue.c **** 		return xReturn;
 606              		.loc 1 661 0
 607 0074 FB68     		ldr	r3, [r7, #12]
 662:..\Source/queue.c **** 	}
 608              		.loc 1 662 0
 609 0076 1846     		mov	r0, r3
 610 0078 1437     		adds	r7, r7, #20
 611              		.cfi_def_cfa_offset 12
 612 007a BD46     		mov	sp, r7
 613              		.cfi_def_cfa_register 13
 614              		@ sp needed
 615 007c 90BD     		pop	{r4, r7, pc}
 616              		.cfi_endproc
 617              	.LFE74:
 618              		.size	xQueueTakeMutexRecursive, .-xQueueTakeMutexRecursive
 619 007e 00BF     		.section	.text.xQueueCreateCountingSemaphore,"ax",%progbits
 620              		.align	2
 621              		.global	xQueueCreateCountingSemaphore
 622              		.thumb
 623              		.thumb_func
 624              		.type	xQueueCreateCountingSemaphore, %function
 625              	xQueueCreateCountingSemaphore:
 626              	.LFB75:
 663:..\Source/queue.c **** 
 664:..\Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 665:..\Source/queue.c **** /*-----------------------------------------------------------*/
 666:..\Source/queue.c **** 
 667:..\Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 668:..\Source/queue.c **** 
 669:..\Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t
 670:..\Source/queue.c **** 	{
 671:..\Source/queue.c **** 	QueueHandle_t xHandle;
 672:..\Source/queue.c **** 
 673:..\Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 674:..\Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 675:..\Source/queue.c **** 
 676:..\Source/queue.c **** 		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStatic
 677:..\Source/queue.c **** 
 678:..\Source/queue.c **** 		if( xHandle != NULL )
 679:..\Source/queue.c **** 		{
 680:..\Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 681:..\Source/queue.c **** 
 682:..\Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 683:..\Source/queue.c **** 		}
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 24


 684:..\Source/queue.c **** 		else
 685:..\Source/queue.c **** 		{
 686:..\Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 687:..\Source/queue.c **** 		}
 688:..\Source/queue.c **** 
 689:..\Source/queue.c **** 		return xHandle;
 690:..\Source/queue.c **** 	}
 691:..\Source/queue.c **** 
 692:..\Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 693:..\Source/queue.c **** /*-----------------------------------------------------------*/
 694:..\Source/queue.c **** 
 695:..\Source/queue.c **** #if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 696:..\Source/queue.c **** 
 697:..\Source/queue.c **** 	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxIni
 698:..\Source/queue.c **** 	{
 627              		.loc 1 698 0
 628              		.cfi_startproc
 629              		@ args = 0, pretend = 0, frame = 16
 630              		@ frame_needed = 1, uses_anonymous_args = 0
 631 0000 80B5     		push	{r7, lr}
 632              		.cfi_def_cfa_offset 8
 633              		.cfi_offset 7, -8
 634              		.cfi_offset 14, -4
 635 0002 84B0     		sub	sp, sp, #16
 636              		.cfi_def_cfa_offset 24
 637 0004 00AF     		add	r7, sp, #0
 638              		.cfi_def_cfa_register 7
 639 0006 7860     		str	r0, [r7, #4]
 640 0008 3960     		str	r1, [r7]
 699:..\Source/queue.c **** 	QueueHandle_t xHandle;
 700:..\Source/queue.c **** 
 701:..\Source/queue.c **** 		configASSERT( uxMaxCount != 0 );
 702:..\Source/queue.c **** 		configASSERT( uxInitialCount <= uxMaxCount );
 703:..\Source/queue.c **** 
 704:..\Source/queue.c **** 		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUN
 641              		.loc 1 704 0
 642 000a 0222     		movs	r2, #2
 643 000c 0021     		movs	r1, #0
 644 000e 7868     		ldr	r0, [r7, #4]
 645 0010 FFF7FEFF 		bl	xQueueGenericCreate
 646 0014 F860     		str	r0, [r7, #12]
 705:..\Source/queue.c **** 
 706:..\Source/queue.c **** 		if( xHandle != NULL )
 647              		.loc 1 706 0
 648 0016 FB68     		ldr	r3, [r7, #12]
 649 0018 002B     		cmp	r3, #0
 650 001a 06D0     		beq	.L34
 707:..\Source/queue.c **** 		{
 708:..\Source/queue.c **** 			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 651              		.loc 1 708 0
 652 001c FB68     		ldr	r3, [r7, #12]
 653 001e 3A68     		ldr	r2, [r7]
 654 0020 9A63     		str	r2, [r3, #56]
 709:..\Source/queue.c **** 
 710:..\Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 655              		.loc 1 710 0
 656 0022 1520     		movs	r0, #21
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 25


 657 0024 FFF7FEFF 		bl	packPayload0
 658 0028 02E0     		b	.L35
 659              	.L34:
 711:..\Source/queue.c **** 		}
 712:..\Source/queue.c **** 		else
 713:..\Source/queue.c **** 		{
 714:..\Source/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 660              		.loc 1 714 0
 661 002a 1620     		movs	r0, #22
 662 002c FFF7FEFF 		bl	packPayload0
 663              	.L35:
 715:..\Source/queue.c **** 		}
 716:..\Source/queue.c **** 
 717:..\Source/queue.c **** 		return xHandle;
 664              		.loc 1 717 0
 665 0030 FB68     		ldr	r3, [r7, #12]
 718:..\Source/queue.c **** 	}
 666              		.loc 1 718 0
 667 0032 1846     		mov	r0, r3
 668 0034 1037     		adds	r7, r7, #16
 669              		.cfi_def_cfa_offset 8
 670 0036 BD46     		mov	sp, r7
 671              		.cfi_def_cfa_register 13
 672              		@ sp needed
 673 0038 80BD     		pop	{r7, pc}
 674              		.cfi_endproc
 675              	.LFE75:
 676              		.size	xQueueCreateCountingSemaphore, .-xQueueCreateCountingSemaphore
 677 003a 00BF     		.section	.text.xQueueGenericSend,"ax",%progbits
 678              		.align	2
 679              		.global	xQueueGenericSend
 680              		.thumb
 681              		.thumb_func
 682              		.type	xQueueGenericSend, %function
 683              	xQueueGenericSend:
 684              	.LFB76:
 719:..\Source/queue.c **** 
 720:..\Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 721:..\Source/queue.c **** /*-----------------------------------------------------------*/
 722:..\Source/queue.c **** 
 723:..\Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xT
 724:..\Source/queue.c **** {
 685              		.loc 1 724 0
 686              		.cfi_startproc
 687              		@ args = 0, pretend = 0, frame = 40
 688              		@ frame_needed = 1, uses_anonymous_args = 0
 689 0000 80B5     		push	{r7, lr}
 690              		.cfi_def_cfa_offset 8
 691              		.cfi_offset 7, -8
 692              		.cfi_offset 14, -4
 693 0002 8AB0     		sub	sp, sp, #40
 694              		.cfi_def_cfa_offset 48
 695 0004 00AF     		add	r7, sp, #0
 696              		.cfi_def_cfa_register 7
 697 0006 F860     		str	r0, [r7, #12]
 698 0008 B960     		str	r1, [r7, #8]
 699 000a 7A60     		str	r2, [r7, #4]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 26


 700 000c 3B60     		str	r3, [r7]
 725:..\Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 701              		.loc 1 725 0
 702 000e 0023     		movs	r3, #0
 703 0010 7B62     		str	r3, [r7, #36]
 726:..\Source/queue.c **** TimeOut_t xTimeOut;
 727:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 704              		.loc 1 727 0
 705 0012 FB68     		ldr	r3, [r7, #12]
 706 0014 3B62     		str	r3, [r7, #32]
 707              	.L52:
 728:..\Source/queue.c **** 
 729:..\Source/queue.c **** 	configASSERT( pxQueue );
 730:..\Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 731:..\Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 732:..\Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 733:..\Source/queue.c **** 	{
 734:..\Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
 735:..\Source/queue.c **** 	}
 736:..\Source/queue.c **** 	#endif
 737:..\Source/queue.c **** 
 738:..\Source/queue.c **** 
 739:..\Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 740:..\Source/queue.c **** 	statements within the function itself.  This is done in the interest
 741:..\Source/queue.c **** 	of execution time efficiency. */
 742:..\Source/queue.c **** 	for( ;; )
 743:..\Source/queue.c **** 	{
 744:..\Source/queue.c **** 		taskENTER_CRITICAL();
 708              		.loc 1 744 0
 709 0016 FFF7FEFF 		bl	vPortEnterCritical
 745:..\Source/queue.c **** 		{
 746:..\Source/queue.c **** 			/* Is there room on the queue now?  The running task must be the
 747:..\Source/queue.c **** 			highest priority task wanting to access the queue.  If the head item
 748:..\Source/queue.c **** 			in the queue is to be overwritten then it does not matter if the
 749:..\Source/queue.c **** 			queue is full. */
 750:..\Source/queue.c **** 			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 710              		.loc 1 750 0
 711 001a 3B6A     		ldr	r3, [r7, #32]
 712 001c 9A6B     		ldr	r2, [r3, #56]
 713 001e 3B6A     		ldr	r3, [r7, #32]
 714 0020 DB6B     		ldr	r3, [r3, #60]
 715 0022 9A42     		cmp	r2, r3
 716 0024 02D3     		bcc	.L38
 717              		.loc 1 750 0 is_stmt 0 discriminator 1
 718 0026 3B68     		ldr	r3, [r7]
 719 0028 022B     		cmp	r3, #2
 720 002a 33D1     		bne	.L39
 721              	.L38:
 751:..\Source/queue.c **** 			{
 752:..\Source/queue.c **** 				traceQUEUE_SEND( pxQueue );
 722              		.loc 1 752 0 is_stmt 1
 723 002c 3B6A     		ldr	r3, [r7, #32]
 724 002e 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 725 0032 3B6A     		ldr	r3, [r7, #32]
 726 0034 9B6C     		ldr	r3, [r3, #72]
 727 0036 DBB2     		uxtb	r3, r3
 728 0038 1A46     		mov	r2, r3
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 27


 729 003a 1720     		movs	r0, #23
 730 003c FFF7FEFF 		bl	packPayload2
 753:..\Source/queue.c **** 				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 731              		.loc 1 753 0
 732 0040 3A68     		ldr	r2, [r7]
 733 0042 B968     		ldr	r1, [r7, #8]
 734 0044 386A     		ldr	r0, [r7, #32]
 735 0046 FFF7FEFF 		bl	prvCopyDataToQueue
 736 004a F861     		str	r0, [r7, #28]
 754:..\Source/queue.c **** 
 755:..\Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 756:..\Source/queue.c **** 				{
 757:..\Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 758:..\Source/queue.c **** 					{
 759:..\Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 760:..\Source/queue.c **** 						{
 761:..\Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 762:..\Source/queue.c **** 							to the queue set caused a higher priority task to
 763:..\Source/queue.c **** 							unblock. A context switch is required. */
 764:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 765:..\Source/queue.c **** 						}
 766:..\Source/queue.c **** 						else
 767:..\Source/queue.c **** 						{
 768:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 769:..\Source/queue.c **** 						}
 770:..\Source/queue.c **** 					}
 771:..\Source/queue.c **** 					else
 772:..\Source/queue.c **** 					{
 773:..\Source/queue.c **** 						/* If there was a task waiting for data to arrive on the
 774:..\Source/queue.c **** 						queue then unblock it now. */
 775:..\Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 776:..\Source/queue.c **** 						{
 777:..\Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 778:..\Source/queue.c **** 							{
 779:..\Source/queue.c **** 								/* The unblocked task has a priority higher than
 780:..\Source/queue.c **** 								our own so yield immediately.  Yes it is ok to
 781:..\Source/queue.c **** 								do this from within the critical section - the
 782:..\Source/queue.c **** 								kernel takes care of that. */
 783:..\Source/queue.c **** 								queueYIELD_IF_USING_PREEMPTION();
 784:..\Source/queue.c **** 							}
 785:..\Source/queue.c **** 							else
 786:..\Source/queue.c **** 							{
 787:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 788:..\Source/queue.c **** 							}
 789:..\Source/queue.c **** 						}
 790:..\Source/queue.c **** 						else if( xYieldRequired != pdFALSE )
 791:..\Source/queue.c **** 						{
 792:..\Source/queue.c **** 							/* This path is a special case that will only get
 793:..\Source/queue.c **** 							executed if the task was holding multiple mutexes
 794:..\Source/queue.c **** 							and the mutexes were given back in an order that is
 795:..\Source/queue.c **** 							different to that in which they were taken. */
 796:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 797:..\Source/queue.c **** 						}
 798:..\Source/queue.c **** 						else
 799:..\Source/queue.c **** 						{
 800:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 801:..\Source/queue.c **** 						}
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 28


 802:..\Source/queue.c **** 					}
 803:..\Source/queue.c **** 				}
 804:..\Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
 805:..\Source/queue.c **** 				{
 806:..\Source/queue.c **** 					/* If there was a task waiting for data to arrive on the
 807:..\Source/queue.c **** 					queue then unblock it now. */
 808:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 737              		.loc 1 808 0
 738 004c 3B6A     		ldr	r3, [r7, #32]
 739 004e 5B6A     		ldr	r3, [r3, #36]
 740 0050 002B     		cmp	r3, #0
 741 0052 10D0     		beq	.L40
 809:..\Source/queue.c **** 					{
 810:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 742              		.loc 1 810 0
 743 0054 3B6A     		ldr	r3, [r7, #32]
 744 0056 2433     		adds	r3, r3, #36
 745 0058 1846     		mov	r0, r3
 746 005a FFF7FEFF 		bl	xTaskRemoveFromEventList
 747 005e 0346     		mov	r3, r0
 748 0060 002B     		cmp	r3, #0
 749 0062 13D0     		beq	.L41
 811:..\Source/queue.c **** 						{
 812:..\Source/queue.c **** 							/* The unblocked task has a priority higher than
 813:..\Source/queue.c **** 							our own so yield immediately.  Yes it is ok to do
 814:..\Source/queue.c **** 							this from within the critical section - the kernel
 815:..\Source/queue.c **** 							takes care of that. */
 816:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 750              		.loc 1 816 0
 751 0064 4E4B     		ldr	r3, .L54
 752 0066 4FF08052 		mov	r2, #268435456
 753 006a 1A60     		str	r2, [r3]
 754              		.syntax unified
 755              	@ 816 "..\Source\queue.c" 1
 756 006c BFF34F8F 		dsb
 757              	@ 0 "" 2
 758              	@ 816 "..\Source\queue.c" 1
 759 0070 BFF36F8F 		isb
 760              	@ 0 "" 2
 761              		.thumb
 762              		.syntax unified
 763 0074 0AE0     		b	.L41
 764              	.L40:
 817:..\Source/queue.c **** 						}
 818:..\Source/queue.c **** 						else
 819:..\Source/queue.c **** 						{
 820:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 821:..\Source/queue.c **** 						}
 822:..\Source/queue.c **** 					}
 823:..\Source/queue.c **** 					else if( xYieldRequired != pdFALSE )
 765              		.loc 1 823 0
 766 0076 FB69     		ldr	r3, [r7, #28]
 767 0078 002B     		cmp	r3, #0
 768 007a 07D0     		beq	.L41
 824:..\Source/queue.c **** 					{
 825:..\Source/queue.c **** 						/* This path is a special case that will only get
 826:..\Source/queue.c **** 						executed if the task was holding multiple mutexes and
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 29


 827:..\Source/queue.c **** 						the mutexes were given back in an order that is
 828:..\Source/queue.c **** 						different to that in which they were taken. */
 829:..\Source/queue.c **** 						queueYIELD_IF_USING_PREEMPTION();
 769              		.loc 1 829 0
 770 007c 484B     		ldr	r3, .L54
 771 007e 4FF08052 		mov	r2, #268435456
 772 0082 1A60     		str	r2, [r3]
 773              		.syntax unified
 774              	@ 829 "..\Source\queue.c" 1
 775 0084 BFF34F8F 		dsb
 776              	@ 0 "" 2
 777              	@ 829 "..\Source\queue.c" 1
 778 0088 BFF36F8F 		isb
 779              	@ 0 "" 2
 780              		.thumb
 781              		.syntax unified
 782              	.L41:
 830:..\Source/queue.c **** 					}
 831:..\Source/queue.c **** 					else
 832:..\Source/queue.c **** 					{
 833:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
 834:..\Source/queue.c **** 					}
 835:..\Source/queue.c **** 				}
 836:..\Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
 837:..\Source/queue.c **** 
 838:..\Source/queue.c **** 				taskEXIT_CRITICAL();
 783              		.loc 1 838 0
 784 008c FFF7FEFF 		bl	vPortExitCritical
 839:..\Source/queue.c **** 				return pdPASS;
 785              		.loc 1 839 0
 786 0090 0123     		movs	r3, #1
 787 0092 81E0     		b	.L53
 788              	.L39:
 840:..\Source/queue.c **** 			}
 841:..\Source/queue.c **** 			else
 842:..\Source/queue.c **** 			{
 843:..\Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 789              		.loc 1 843 0
 790 0094 7B68     		ldr	r3, [r7, #4]
 791 0096 002B     		cmp	r3, #0
 792 0098 0DD1     		bne	.L43
 844:..\Source/queue.c **** 				{
 845:..\Source/queue.c **** 					/* The queue was full and no block time is specified (or
 846:..\Source/queue.c **** 					the block time has expired) so leave now. */
 847:..\Source/queue.c **** 					taskEXIT_CRITICAL();
 793              		.loc 1 847 0
 794 009a FFF7FEFF 		bl	vPortExitCritical
 848:..\Source/queue.c **** 
 849:..\Source/queue.c **** 					/* Return to the original privilege level before exiting
 850:..\Source/queue.c **** 					the function. */
 851:..\Source/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 795              		.loc 1 851 0
 796 009e 3B6A     		ldr	r3, [r7, #32]
 797 00a0 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 798 00a4 3B6A     		ldr	r3, [r7, #32]
 799 00a6 9B6C     		ldr	r3, [r3, #72]
 800 00a8 DBB2     		uxtb	r3, r3
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 30


 801 00aa 1A46     		mov	r2, r3
 802 00ac 1820     		movs	r0, #24
 803 00ae FFF7FEFF 		bl	packPayload2
 852:..\Source/queue.c **** 					return errQUEUE_FULL;
 804              		.loc 1 852 0
 805 00b2 0023     		movs	r3, #0
 806 00b4 70E0     		b	.L53
 807              	.L43:
 853:..\Source/queue.c **** 				}
 854:..\Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 808              		.loc 1 854 0
 809 00b6 7B6A     		ldr	r3, [r7, #36]
 810 00b8 002B     		cmp	r3, #0
 811 00ba 06D1     		bne	.L44
 855:..\Source/queue.c **** 				{
 856:..\Source/queue.c **** 					/* The queue was full and a block time was specified so
 857:..\Source/queue.c **** 					configure the timeout structure. */
 858:..\Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 812              		.loc 1 858 0
 813 00bc 07F11403 		add	r3, r7, #20
 814 00c0 1846     		mov	r0, r3
 815 00c2 FFF7FEFF 		bl	vTaskSetTimeOutState
 859:..\Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 816              		.loc 1 859 0
 817 00c6 0123     		movs	r3, #1
 818 00c8 7B62     		str	r3, [r7, #36]
 819              	.L44:
 860:..\Source/queue.c **** 				}
 861:..\Source/queue.c **** 				else
 862:..\Source/queue.c **** 				{
 863:..\Source/queue.c **** 					/* Entry time was already set. */
 864:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
 865:..\Source/queue.c **** 				}
 866:..\Source/queue.c **** 			}
 867:..\Source/queue.c **** 		}
 868:..\Source/queue.c **** 		taskEXIT_CRITICAL();
 820              		.loc 1 868 0
 821 00ca FFF7FEFF 		bl	vPortExitCritical
 869:..\Source/queue.c **** 
 870:..\Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 871:..\Source/queue.c **** 		now the critical section has been exited. */
 872:..\Source/queue.c **** 
 873:..\Source/queue.c **** 		vTaskSuspendAll();
 822              		.loc 1 873 0
 823 00ce FFF7FEFF 		bl	vTaskSuspendAll
 874:..\Source/queue.c **** 		prvLockQueue( pxQueue );
 824              		.loc 1 874 0
 825 00d2 FFF7FEFF 		bl	vPortEnterCritical
 826 00d6 3B6A     		ldr	r3, [r7, #32]
 827 00d8 93F84430 		ldrb	r3, [r3, #68]
 828 00dc 5BB2     		sxtb	r3, r3
 829 00de B3F1FF3F 		cmp	r3, #-1
 830 00e2 03D1     		bne	.L45
 831              		.loc 1 874 0 is_stmt 0 discriminator 1
 832 00e4 3B6A     		ldr	r3, [r7, #32]
 833 00e6 0022     		movs	r2, #0
 834 00e8 83F84420 		strb	r2, [r3, #68]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 31


 835              	.L45:
 836              		.loc 1 874 0 discriminator 3
 837 00ec 3B6A     		ldr	r3, [r7, #32]
 838 00ee 93F84530 		ldrb	r3, [r3, #69]
 839 00f2 5BB2     		sxtb	r3, r3
 840 00f4 B3F1FF3F 		cmp	r3, #-1
 841 00f8 03D1     		bne	.L46
 842              		.loc 1 874 0 discriminator 4
 843 00fa 3B6A     		ldr	r3, [r7, #32]
 844 00fc 0022     		movs	r2, #0
 845 00fe 83F84520 		strb	r2, [r3, #69]
 846              	.L46:
 847              		.loc 1 874 0 discriminator 6
 848 0102 FFF7FEFF 		bl	vPortExitCritical
 875:..\Source/queue.c **** 
 876:..\Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 877:..\Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 849              		.loc 1 877 0 is_stmt 1 discriminator 6
 850 0106 3A1D     		adds	r2, r7, #4
 851 0108 07F11403 		add	r3, r7, #20
 852 010c 1146     		mov	r1, r2
 853 010e 1846     		mov	r0, r3
 854 0110 FFF7FEFF 		bl	xTaskCheckForTimeOut
 855 0114 0346     		mov	r3, r0
 856 0116 002B     		cmp	r3, #0
 857 0118 2ED1     		bne	.L47
 878:..\Source/queue.c **** 		{
 879:..\Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 858              		.loc 1 879 0
 859 011a 386A     		ldr	r0, [r7, #32]
 860 011c FFF7FEFF 		bl	prvIsQueueFull
 861 0120 0346     		mov	r3, r0
 862 0122 002B     		cmp	r3, #0
 863 0124 22D0     		beq	.L48
 880:..\Source/queue.c **** 			{
 881:..\Source/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 864              		.loc 1 881 0
 865 0126 3B6A     		ldr	r3, [r7, #32]
 866 0128 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 867 012c 3B6A     		ldr	r3, [r7, #32]
 868 012e 9B6C     		ldr	r3, [r3, #72]
 869 0130 DBB2     		uxtb	r3, r3
 870 0132 1A46     		mov	r2, r3
 871 0134 0A20     		movs	r0, #10
 872 0136 FFF7FEFF 		bl	packPayload2
 882:..\Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 873              		.loc 1 882 0
 874 013a 3B6A     		ldr	r3, [r7, #32]
 875 013c 1033     		adds	r3, r3, #16
 876 013e 7A68     		ldr	r2, [r7, #4]
 877 0140 1146     		mov	r1, r2
 878 0142 1846     		mov	r0, r3
 879 0144 FFF7FEFF 		bl	vTaskPlaceOnEventList
 883:..\Source/queue.c **** 
 884:..\Source/queue.c **** 				/* Unlocking the queue means queue events can effect the
 885:..\Source/queue.c **** 				event list.  It is possible	that interrupts occurring now
 886:..\Source/queue.c **** 				remove this task from the event	list again - but as the
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 32


 887:..\Source/queue.c **** 				scheduler is suspended the task will go onto the pending
 888:..\Source/queue.c **** 				ready last instead of the actual ready list. */
 889:..\Source/queue.c **** 				prvUnlockQueue( pxQueue );
 880              		.loc 1 889 0
 881 0148 386A     		ldr	r0, [r7, #32]
 882 014a FFF7FEFF 		bl	prvUnlockQueue
 890:..\Source/queue.c **** 
 891:..\Source/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 892:..\Source/queue.c **** 				ready list into the ready list - so it is feasible that this
 893:..\Source/queue.c **** 				task is already in a ready list before it yields - in which
 894:..\Source/queue.c **** 				case the yield will not cause a context switch unless there
 895:..\Source/queue.c **** 				is also a higher priority task in the pending ready list. */
 896:..\Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 883              		.loc 1 896 0
 884 014e FFF7FEFF 		bl	xTaskResumeAll
 885 0152 0346     		mov	r3, r0
 886 0154 002B     		cmp	r3, #0
 887 0156 7FF45EAF 		bne	.L52
 897:..\Source/queue.c **** 				{
 898:..\Source/queue.c **** 					portYIELD_WITHIN_API();
 888              		.loc 1 898 0
 889 015a 114B     		ldr	r3, .L54
 890 015c 4FF08052 		mov	r2, #268435456
 891 0160 1A60     		str	r2, [r3]
 892              		.syntax unified
 893              	@ 898 "..\Source\queue.c" 1
 894 0162 BFF34F8F 		dsb
 895              	@ 0 "" 2
 896              	@ 898 "..\Source\queue.c" 1
 897 0166 BFF36F8F 		isb
 898              	@ 0 "" 2
 899              		.thumb
 900              		.syntax unified
 901 016a 54E7     		b	.L52
 902              	.L48:
 899:..\Source/queue.c **** 				}
 900:..\Source/queue.c **** 			}
 901:..\Source/queue.c **** 			else
 902:..\Source/queue.c **** 			{
 903:..\Source/queue.c **** 				/* Try again. */
 904:..\Source/queue.c **** 				prvUnlockQueue( pxQueue );
 903              		.loc 1 904 0
 904 016c 386A     		ldr	r0, [r7, #32]
 905 016e FFF7FEFF 		bl	prvUnlockQueue
 905:..\Source/queue.c **** 				( void ) xTaskResumeAll();
 906              		.loc 1 905 0
 907 0172 FFF7FEFF 		bl	xTaskResumeAll
 908 0176 4EE7     		b	.L52
 909              	.L47:
 906:..\Source/queue.c **** 			}
 907:..\Source/queue.c **** 		}
 908:..\Source/queue.c **** 		else
 909:..\Source/queue.c **** 		{
 910:..\Source/queue.c **** 			/* The timeout has expired. */
 911:..\Source/queue.c **** 			prvUnlockQueue( pxQueue );
 910              		.loc 1 911 0
 911 0178 386A     		ldr	r0, [r7, #32]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 33


 912 017a FFF7FEFF 		bl	prvUnlockQueue
 912:..\Source/queue.c **** 			( void ) xTaskResumeAll();
 913              		.loc 1 912 0
 914 017e FFF7FEFF 		bl	xTaskResumeAll
 913:..\Source/queue.c **** 
 914:..\Source/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 915              		.loc 1 914 0
 916 0182 3B6A     		ldr	r3, [r7, #32]
 917 0184 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 918 0188 3B6A     		ldr	r3, [r7, #32]
 919 018a 9B6C     		ldr	r3, [r3, #72]
 920 018c DBB2     		uxtb	r3, r3
 921 018e 1A46     		mov	r2, r3
 922 0190 1820     		movs	r0, #24
 923 0192 FFF7FEFF 		bl	packPayload2
 915:..\Source/queue.c **** 			return errQUEUE_FULL;
 924              		.loc 1 915 0
 925 0196 0023     		movs	r3, #0
 926              	.L53:
 916:..\Source/queue.c **** 		}
 917:..\Source/queue.c **** 	}
 918:..\Source/queue.c **** }
 927              		.loc 1 918 0 discriminator 3
 928 0198 1846     		mov	r0, r3
 929 019a 2837     		adds	r7, r7, #40
 930              		.cfi_def_cfa_offset 8
 931 019c BD46     		mov	sp, r7
 932              		.cfi_def_cfa_register 13
 933              		@ sp needed
 934 019e 80BD     		pop	{r7, pc}
 935              	.L55:
 936              		.align	2
 937              	.L54:
 938 01a0 04ED00E0 		.word	-536810236
 939              		.cfi_endproc
 940              	.LFE76:
 941              		.size	xQueueGenericSend, .-xQueueGenericSend
 942              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 943              		.align	2
 944              		.global	xQueueGenericSendFromISR
 945              		.thumb
 946              		.thumb_func
 947              		.type	xQueueGenericSendFromISR, %function
 948              	xQueueGenericSendFromISR:
 949              	.LFB77:
 919:..\Source/queue.c **** /*-----------------------------------------------------------*/
 920:..\Source/queue.c **** 
 921:..\Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseTy
 922:..\Source/queue.c **** {
 950              		.loc 1 922 0
 951              		.cfi_startproc
 952              		@ args = 0, pretend = 0, frame = 48
 953              		@ frame_needed = 1, uses_anonymous_args = 0
 954 0000 80B5     		push	{r7, lr}
 955              		.cfi_def_cfa_offset 8
 956              		.cfi_offset 7, -8
 957              		.cfi_offset 14, -4
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 34


 958 0002 8CB0     		sub	sp, sp, #48
 959              		.cfi_def_cfa_offset 56
 960 0004 00AF     		add	r7, sp, #0
 961              		.cfi_def_cfa_register 7
 962 0006 F860     		str	r0, [r7, #12]
 963 0008 B960     		str	r1, [r7, #8]
 964 000a 7A60     		str	r2, [r7, #4]
 965 000c 3B60     		str	r3, [r7]
 923:..\Source/queue.c **** BaseType_t xReturn;
 924:..\Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
 925:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 966              		.loc 1 925 0
 967 000e FB68     		ldr	r3, [r7, #12]
 968 0010 BB62     		str	r3, [r7, #40]
 969              	.LBB23:
 970              	.LBB24:
 971              		.file 2 "..\\Source\\portable\\GCC\\ARM_CM3/portmacro.h"
   1:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*
   2:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS V9.0.0 - Copyright (C) 2016 Real Time Engineers Ltd.
   3:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     All rights reserved
   4:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
   5:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
   6:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
   7:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     This file is part of the FreeRTOS distribution.
   8:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
   9:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  10:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     the terms of the GNU General Public License (version 2) as published by the
  11:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
  12:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  13:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  14:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   NOTE: The modification to the GPL is included to allow you to     !<<
  15:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   distribute a combined work that includes FreeRTOS without being   !<<
  16:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   obliged to provide the source code for proprietary components     !<<
  17:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     >>!   outside of the FreeRTOS kernel.                                   !<<
  18:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  19:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  20:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
  21:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  22:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FOR A PARTICULAR PURPOSE.  Full license text is available on the following
  23:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     link: http://www.freertos.org/a00114.html
  24:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  25:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  26:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  27:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    FreeRTOS provides completely free yet professionally developed,    *
  28:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    robust, strictly quality controlled, supported, and cross          *
  29:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    platform software that is more than just the market leader, it     *
  30:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    is the industry's de facto standard.                               *
  31:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  32:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    Help yourself get started quickly while simultaneously helping     *
  33:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    to support the FreeRTOS project by purchasing a FreeRTOS           *
  34:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    tutorial book, reference manual, or both:                          *
  35:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *    http://www.FreeRTOS.org/Documentation                              *
  36:..\Source\portable\GCC\ARM_CM3/portmacro.h ****      *                                                                       *
  37:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     ***************************************************************************
  38:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  39:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
  40:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     the FAQ page "My application does not run, what could be wrong?".  Have you
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 35


  41:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     defined configASSERT()?
  42:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  43:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/support - In return for receiving this top quality
  44:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     embedded software for free we request you assist our global community by
  45:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     participating in the support forum.
  46:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  47:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/training - Investing in training allows your team to
  48:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     be as productive as possible as early as possible.  Now you can receive
  49:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
  50:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Ltd, and the world's leading authority on the world's leading RTOS.
  51:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  52:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
  53:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     including FreeRTOS+Trace - an indispensable productivity tool, a DOS
  54:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     compatible FAT file system, and our tiny thread aware UDP/IP stack.
  55:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  56:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
  57:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
  58:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  59:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
  60:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
  61:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     licenses offer ticketed support, indemnification and commercial middleware.
  62:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  63:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     http://www.SafeRTOS.com - High Integrity Systems also provide a safety
  64:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     engineered and independently SIL3 certified version for use in safety and
  65:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     mission critical applications that require provable dependability.
  66:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  67:..\Source\portable\GCC\ARM_CM3/portmacro.h ****     1 tab == 4 spaces!
  68:..\Source\portable\GCC\ARM_CM3/portmacro.h **** */
  69:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  70:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  71:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef PORTMACRO_H
  72:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define PORTMACRO_H
  73:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  74:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef __cplusplus
  75:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern "C" {
  76:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
  77:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  78:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------
  79:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * Port specific definitions.
  80:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  81:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * The settings in this file configure FreeRTOS correctly for the
  82:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * given hardware and compiler.
  83:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *
  84:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  * These settings should not be altered.
  85:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  *-----------------------------------------------------------
  86:..\Source\portable\GCC\ARM_CM3/portmacro.h ****  */
  87:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  88:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Type definitions. */
  89:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCHAR		char
  90:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portFLOAT		float
  91:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDOUBLE		double
  92:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portLONG		long
  93:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSHORT		short
  94:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_TYPE	uint32_t
  95:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBASE_TYPE	long
  96:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
  97:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef portSTACK_TYPE StackType_t;
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 36


  98:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef long BaseType_t;
  99:..\Source\portable\GCC\ARM_CM3/portmacro.h **** typedef unsigned long UBaseType_t;
 100:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 101:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #if( configUSE_16_BIT_TICKS == 1 )
 102:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint16_t TickType_t;
 103:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffff
 104:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #else
 105:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	typedef uint32_t TickType_t;
 106:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
 107:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 108:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
 109:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	not need to be guarded with a critical section. */
 110:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portTICK_TYPE_IS_ATOMIC 1
 111:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 112:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 113:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 114:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specifics. */
 115:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSTACK_GROWTH			( -1 )
 116:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
 117:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portBYTE_ALIGNMENT			8
 118:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 119:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 120:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Scheduler utilities. */
 121:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD() 															\
 122:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {																				\
 123:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Set a PendSV to request a context switch. */								\
 124:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;								\
 125:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 																				\
 126:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Barriers are normally not required but do ensure the code is completely	\
 127:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	within the specified behaviour for the architecture. */						\
 128:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "dsb" );													\
 129:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "isb" );													\
 130:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 131:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 132:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
 133:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
 134:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired != pdFALSE ) portYIELD()
 135:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
 136:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 137:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 138:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Critical section management. */
 139:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortEnterCritical( void );
 140:..\Source\portable\GCC\ARM_CM3/portmacro.h **** extern void vPortExitCritical( void );
 141:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portSET_INTERRUPT_MASK_FROM_ISR()		ulPortRaiseBASEPRI()
 142:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vPortSetBASEPRI(x)
 143:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portDISABLE_INTERRUPTS()				vPortRaiseBASEPRI()
 144:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENABLE_INTERRUPTS()					vPortSetBASEPRI(0)
 145:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portENTER_CRITICAL()					vPortEnterCritical()
 146:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portEXIT_CRITICAL()						vPortExitCritical()
 147:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 148:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 149:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 150:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Task function macros as described on the FreeRTOS.org WEB site.  These are
 151:..\Source\portable\GCC\ARM_CM3/portmacro.h **** not necessary for to use this port.  They are defined so the common demo files
 152:..\Source\portable\GCC\ARM_CM3/portmacro.h **** (which build with all the ports) will build. */
 153:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 154:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 37


 155:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 156:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 157:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Tickless idle/low power functionality. */
 158:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portSUPPRESS_TICKS_AND_SLEEP
 159:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	extern void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime );
 160:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime ) vPortSuppressTicksAndSleep( xExpectedIdl
 161:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 162:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 163:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 164:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* Architecture specific optimisations. */
 165:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
 166:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
 167:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 168:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 169:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #if configUSE_PORT_OPTIMISED_TASK_SELECTION == 1
 170:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 171:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Generic helper function. */
 172:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitma
 173:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 174:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	uint8_t ucReturn;
 175:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 176:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 177:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		return ucReturn;
 178:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 179:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 180:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Check the configuration. */
 181:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#if( configMAX_PRIORITIES > 32 )
 182:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is 
 183:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#endif
 184:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 185:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Store/clear the ready priorities in a bit map. */
 186:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) |= ( 1UL 
 187:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) &= ~( 1UL 
 188:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 189:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/*-----------------------------------------------------------*/
 190:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 191:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority = ( 31UL - ( ui
 192:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 193:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 194:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 195:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 196:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 197:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifdef configASSERT
 198:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	void vPortValidateInterruptPriority( void );
 199:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 	vPortValidateInterruptPriority()
 200:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 201:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 202:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /* portNOP() is not required by this port. */
 203:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portNOP()
 204:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 205:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #define portINLINE	__inline
 206:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 207:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #ifndef portFORCE_INLINE
 208:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	#define portFORCE_INLINE inline __attribute__(( always_inline))
 209:..\Source\portable\GCC\ARM_CM3/portmacro.h **** #endif
 210:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 211:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static BaseType_t xPortIsInsideInterrupt( void )
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 38


 212:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 213:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulCurrentInterrupt;
 214:..\Source\portable\GCC\ARM_CM3/portmacro.h **** BaseType_t xReturn;
 215:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 216:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* Obtain the number of the currently executing interrupt. */
 217:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 218:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 219:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	if( ulCurrentInterrupt == 0 )
 220:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 221:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdFALSE;
 222:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 223:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	else
 224:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	{
 225:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		xReturn = pdTRUE;
 226:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	}
 227:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 228:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return xReturn;
 229:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 230:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 231:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 232:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 233:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortRaiseBASEPRI( void )
 234:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 235:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulNewBASEPRI;
 236:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 237:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 238:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 239:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %0, %1												\n"	\
 240:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %0											\n" \
 241:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 242:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 243:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 244:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 245:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 246:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 247:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 248:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 249:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
 250:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 251:..\Source\portable\GCC\ARM_CM3/portmacro.h **** uint32_t ulOriginalBASEPRI, ulNewBASEPRI;
 252:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 972              		.loc 2 253 0
 973              		.syntax unified
 974              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 975 0012 EFF31182 			mrs r2, basepri											
 976 0016 4FF0A003 		mov r3, #160												
 977 001a 83F31188 		msr basepri, r3											
 978 001e BFF36F8F 		isb														
 979 0022 BFF34F8F 		dsb														
 980              	
 981              	@ 0 "" 2
 982              		.thumb
 983              		.syntax unified
 984 0026 BA61     		str	r2, [r7, #24]
 985 0028 7B61     		str	r3, [r7, #20]
 254:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 39


 255:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mrs %0, basepri											\n" \
 256:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	mov %1, %2												\n"	\
 257:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	msr basepri, %1											\n" \
 258:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	isb														\n" \
 259:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		"	dsb														\n" \
 260:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
 261:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	);
 262:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 263:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	/* This return will not be reached but is necessary to prevent compiler
 264:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	warnings. */
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	return ulOriginalBASEPRI;
 986              		.loc 2 265 0
 987 002a BB69     		ldr	r3, [r7, #24]
 988              	.LBE24:
 989              	.LBE23:
 926:..\Source/queue.c **** 
 927:..\Source/queue.c **** 	configASSERT( pxQueue );
 928:..\Source/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 929:..\Source/queue.c **** 	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 930:..\Source/queue.c **** 
 931:..\Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
 932:..\Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
 933:..\Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
 934:..\Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
 935:..\Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
 936:..\Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
 937:..\Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
 938:..\Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
 939:..\Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
 940:..\Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
 941:..\Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
 942:..\Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
 943:..\Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
 944:..\Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
 945:..\Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 946:..\Source/queue.c **** 
 947:..\Source/queue.c **** 	/* Similar to xQueueGenericSend, except without blocking if there is no room
 948:..\Source/queue.c **** 	in the queue.  Also don't directly wake a task that was blocked on a queue
 949:..\Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
 950:..\Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
 951:..\Source/queue.c **** 	post). */
 952:..\Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 990              		.loc 1 952 0
 991 002c 3B62     		str	r3, [r7, #32]
 953:..\Source/queue.c **** 	{
 954:..\Source/queue.c **** 		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 992              		.loc 1 954 0
 993 002e BB6A     		ldr	r3, [r7, #40]
 994 0030 9A6B     		ldr	r2, [r3, #56]
 995 0032 BB6A     		ldr	r3, [r7, #40]
 996 0034 DB6B     		ldr	r3, [r3, #60]
 997 0036 9A42     		cmp	r2, r3
 998 0038 02D3     		bcc	.L58
 999              		.loc 1 954 0 is_stmt 0 discriminator 1
 1000 003a 3B68     		ldr	r3, [r7]
 1001 003c 022B     		cmp	r3, #2
 1002 003e 34D1     		bne	.L59
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 40


 1003              	.L58:
 1004              	.LBB25:
 955:..\Source/queue.c **** 		{
 956:..\Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1005              		.loc 1 956 0 is_stmt 1
 1006 0040 BB6A     		ldr	r3, [r7, #40]
 1007 0042 93F84530 		ldrb	r3, [r3, #69]
 1008 0046 FB77     		strb	r3, [r7, #31]
 957:..\Source/queue.c **** 
 958:..\Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 1009              		.loc 1 958 0
 1010 0048 BB6A     		ldr	r3, [r7, #40]
 1011 004a 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1012 004e BB6A     		ldr	r3, [r7, #40]
 1013 0050 9B6C     		ldr	r3, [r3, #72]
 1014 0052 DBB2     		uxtb	r3, r3
 1015 0054 1A46     		mov	r2, r3
 1016 0056 1D20     		movs	r0, #29
 1017 0058 FFF7FEFF 		bl	packPayload2
 959:..\Source/queue.c **** 
 960:..\Source/queue.c **** 			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
 961:..\Source/queue.c **** 			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
 962:..\Source/queue.c **** 			in a task disinheriting a priority and prvCopyDataToQueue() can be
 963:..\Source/queue.c **** 			called here even though the disinherit function does not check if
 964:..\Source/queue.c **** 			the scheduler is suspended before accessing the ready lists. */
 965:..\Source/queue.c **** 			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1018              		.loc 1 965 0
 1019 005c 3A68     		ldr	r2, [r7]
 1020 005e B968     		ldr	r1, [r7, #8]
 1021 0060 B86A     		ldr	r0, [r7, #40]
 1022 0062 FFF7FEFF 		bl	prvCopyDataToQueue
 966:..\Source/queue.c **** 
 967:..\Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
 968:..\Source/queue.c **** 			be done when the queue is unlocked later. */
 969:..\Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1023              		.loc 1 969 0
 1024 0066 97F91F30 		ldrsb	r3, [r7, #31]
 1025 006a B3F1FF3F 		cmp	r3, #-1
 1026 006e 12D1     		bne	.L60
 970:..\Source/queue.c **** 			{
 971:..\Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
 972:..\Source/queue.c **** 				{
 973:..\Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
 974:..\Source/queue.c **** 					{
 975:..\Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
 976:..\Source/queue.c **** 						{
 977:..\Source/queue.c **** 							/* The queue is a member of a queue set, and posting
 978:..\Source/queue.c **** 							to the queue set caused a higher priority task to
 979:..\Source/queue.c **** 							unblock.  A context switch is required. */
 980:..\Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 981:..\Source/queue.c **** 							{
 982:..\Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 983:..\Source/queue.c **** 							}
 984:..\Source/queue.c **** 							else
 985:..\Source/queue.c **** 							{
 986:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
 987:..\Source/queue.c **** 							}
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 41


 988:..\Source/queue.c **** 						}
 989:..\Source/queue.c **** 						else
 990:..\Source/queue.c **** 						{
 991:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
 992:..\Source/queue.c **** 						}
 993:..\Source/queue.c **** 					}
 994:..\Source/queue.c **** 					else
 995:..\Source/queue.c **** 					{
 996:..\Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 997:..\Source/queue.c **** 						{
 998:..\Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 999:..\Source/queue.c **** 							{
1000:..\Source/queue.c **** 								/* The task waiting has a higher priority so
1001:..\Source/queue.c **** 								record that a context switch is required. */
1002:..\Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1003:..\Source/queue.c **** 								{
1004:..\Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1005:..\Source/queue.c **** 								}
1006:..\Source/queue.c **** 								else
1007:..\Source/queue.c **** 								{
1008:..\Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1009:..\Source/queue.c **** 								}
1010:..\Source/queue.c **** 							}
1011:..\Source/queue.c **** 							else
1012:..\Source/queue.c **** 							{
1013:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1014:..\Source/queue.c **** 							}
1015:..\Source/queue.c **** 						}
1016:..\Source/queue.c **** 						else
1017:..\Source/queue.c **** 						{
1018:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1019:..\Source/queue.c **** 						}
1020:..\Source/queue.c **** 					}
1021:..\Source/queue.c **** 				}
1022:..\Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1023:..\Source/queue.c **** 				{
1024:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1027              		.loc 1 1024 0
 1028 0070 BB6A     		ldr	r3, [r7, #40]
 1029 0072 5B6A     		ldr	r3, [r3, #36]
 1030 0074 002B     		cmp	r3, #0
 1031 0076 15D0     		beq	.L61
1025:..\Source/queue.c **** 					{
1026:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1032              		.loc 1 1026 0
 1033 0078 BB6A     		ldr	r3, [r7, #40]
 1034 007a 2433     		adds	r3, r3, #36
 1035 007c 1846     		mov	r0, r3
 1036 007e FFF7FEFF 		bl	xTaskRemoveFromEventList
 1037 0082 0346     		mov	r3, r0
 1038 0084 002B     		cmp	r3, #0
 1039 0086 0DD0     		beq	.L61
1027:..\Source/queue.c **** 						{
1028:..\Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1029:..\Source/queue.c **** 							context	switch is required. */
1030:..\Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1040              		.loc 1 1030 0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 42


 1041 0088 7B68     		ldr	r3, [r7, #4]
 1042 008a 002B     		cmp	r3, #0
 1043 008c 0AD0     		beq	.L61
1031:..\Source/queue.c **** 							{
1032:..\Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1044              		.loc 1 1032 0
 1045 008e 7B68     		ldr	r3, [r7, #4]
 1046 0090 0122     		movs	r2, #1
 1047 0092 1A60     		str	r2, [r3]
 1048 0094 06E0     		b	.L61
 1049              	.L60:
1033:..\Source/queue.c **** 							}
1034:..\Source/queue.c **** 							else
1035:..\Source/queue.c **** 							{
1036:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1037:..\Source/queue.c **** 							}
1038:..\Source/queue.c **** 						}
1039:..\Source/queue.c **** 						else
1040:..\Source/queue.c **** 						{
1041:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1042:..\Source/queue.c **** 						}
1043:..\Source/queue.c **** 					}
1044:..\Source/queue.c **** 					else
1045:..\Source/queue.c **** 					{
1046:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1047:..\Source/queue.c **** 					}
1048:..\Source/queue.c **** 				}
1049:..\Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1050:..\Source/queue.c **** 			}
1051:..\Source/queue.c **** 			else
1052:..\Source/queue.c **** 			{
1053:..\Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1054:..\Source/queue.c **** 				knows that data was posted while it was locked. */
1055:..\Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1050              		.loc 1 1055 0
 1051 0096 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 1052 0098 0133     		adds	r3, r3, #1
 1053 009a DBB2     		uxtb	r3, r3
 1054 009c 5AB2     		sxtb	r2, r3
 1055 009e BB6A     		ldr	r3, [r7, #40]
 1056 00a0 83F84520 		strb	r2, [r3, #69]
 1057              	.L61:
1056:..\Source/queue.c **** 			}
1057:..\Source/queue.c **** 
1058:..\Source/queue.c **** 			xReturn = pdPASS;
 1058              		.loc 1 1058 0
 1059 00a4 0123     		movs	r3, #1
 1060 00a6 FB62     		str	r3, [r7, #44]
 1061              	.LBE25:
 955:..\Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1062              		.loc 1 955 0
 1063 00a8 0BE0     		b	.L62
 1064              	.L59:
1059:..\Source/queue.c **** 		}
1060:..\Source/queue.c **** 		else
1061:..\Source/queue.c **** 		{
1062:..\Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 43


 1065              		.loc 1 1062 0
 1066 00aa BB6A     		ldr	r3, [r7, #40]
 1067 00ac 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1068 00b0 BB6A     		ldr	r3, [r7, #40]
 1069 00b2 9B6C     		ldr	r3, [r3, #72]
 1070 00b4 DBB2     		uxtb	r3, r3
 1071 00b6 1A46     		mov	r2, r3
 1072 00b8 1E20     		movs	r0, #30
 1073 00ba FFF7FEFF 		bl	packPayload2
1063:..\Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1074              		.loc 1 1063 0
 1075 00be 0023     		movs	r3, #0
 1076 00c0 FB62     		str	r3, [r7, #44]
 1077              	.L62:
 1078 00c2 3B6A     		ldr	r3, [r7, #32]
 1079 00c4 7B62     		str	r3, [r7, #36]
 1080              	.LBB26:
 1081              	.LBB27:
 266:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 267:..\Source\portable\GCC\ARM_CM3/portmacro.h **** /*-----------------------------------------------------------*/
 268:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 
 269:..\Source\portable\GCC\ARM_CM3/portmacro.h **** portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
 270:..\Source\portable\GCC\ARM_CM3/portmacro.h **** {
 271:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	__asm volatile
 1082              		.loc 2 271 0
 1083 00c6 7B6A     		ldr	r3, [r7, #36]
 1084              		.syntax unified
 1085              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1086 00c8 83F31188 			msr basepri, r3	
 1087              	@ 0 "" 2
 1088              		.thumb
 1089              		.syntax unified
 1090              	.LBE27:
 1091              	.LBE26:
1064:..\Source/queue.c **** 		}
1065:..\Source/queue.c **** 	}
1066:..\Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1067:..\Source/queue.c **** 
1068:..\Source/queue.c **** 	return xReturn;
 1092              		.loc 1 1068 0
 1093 00cc FB6A     		ldr	r3, [r7, #44]
1069:..\Source/queue.c **** }
 1094              		.loc 1 1069 0
 1095 00ce 1846     		mov	r0, r3
 1096 00d0 3037     		adds	r7, r7, #48
 1097              		.cfi_def_cfa_offset 8
 1098 00d2 BD46     		mov	sp, r7
 1099              		.cfi_def_cfa_register 13
 1100              		@ sp needed
 1101 00d4 80BD     		pop	{r7, pc}
 1102              		.cfi_endproc
 1103              	.LFE77:
 1104              		.size	xQueueGenericSendFromISR, .-xQueueGenericSendFromISR
 1105 00d6 00BF     		.section	.text.xQueueGiveFromISR,"ax",%progbits
 1106              		.align	2
 1107              		.global	xQueueGiveFromISR
 1108              		.thumb
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 44


 1109              		.thumb_func
 1110              		.type	xQueueGiveFromISR, %function
 1111              	xQueueGiveFromISR:
 1112              	.LFB78:
1070:..\Source/queue.c **** /*-----------------------------------------------------------*/
1071:..\Source/queue.c **** 
1072:..\Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
1073:..\Source/queue.c **** {
 1113              		.loc 1 1073 0
 1114              		.cfi_startproc
 1115              		@ args = 0, pretend = 0, frame = 40
 1116              		@ frame_needed = 1, uses_anonymous_args = 0
 1117 0000 80B5     		push	{r7, lr}
 1118              		.cfi_def_cfa_offset 8
 1119              		.cfi_offset 7, -8
 1120              		.cfi_offset 14, -4
 1121 0002 8AB0     		sub	sp, sp, #40
 1122              		.cfi_def_cfa_offset 48
 1123 0004 00AF     		add	r7, sp, #0
 1124              		.cfi_def_cfa_register 7
 1125 0006 7860     		str	r0, [r7, #4]
 1126 0008 3960     		str	r1, [r7]
1074:..\Source/queue.c **** BaseType_t xReturn;
1075:..\Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1076:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1127              		.loc 1 1076 0
 1128 000a 7B68     		ldr	r3, [r7, #4]
 1129 000c 3B62     		str	r3, [r7, #32]
 1130              	.LBB28:
 1131              	.LBB29:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1132              		.loc 2 253 0
 1133              		.syntax unified
 1134              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1135 000e EFF31182 			mrs r2, basepri											
 1136 0012 4FF0A003 		mov r3, #160												
 1137 0016 83F31188 		msr basepri, r3											
 1138 001a BFF36F8F 		isb														
 1139 001e BFF34F8F 		dsb														
 1140              	
 1141              	@ 0 "" 2
 1142              		.thumb
 1143              		.syntax unified
 1144 0022 FA60     		str	r2, [r7, #12]
 1145 0024 BB60     		str	r3, [r7, #8]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1146              		.loc 2 265 0
 1147 0026 FB68     		ldr	r3, [r7, #12]
 1148              	.LBE29:
 1149              	.LBE28:
1077:..\Source/queue.c **** 
1078:..\Source/queue.c **** 	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1079:..\Source/queue.c **** 	item size is 0.  Don't directly wake a task that was blocked on a queue
1080:..\Source/queue.c **** 	read, instead return a flag to say whether a context switch is required or
1081:..\Source/queue.c **** 	not (i.e. has a task with a higher priority than us been woken by this
1082:..\Source/queue.c **** 	post). */
1083:..\Source/queue.c **** 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 45


1084:..\Source/queue.c **** 	configASSERT( pxQueue );
1085:..\Source/queue.c **** 
1086:..\Source/queue.c **** 	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1087:..\Source/queue.c **** 	if the item size is not 0. */
1088:..\Source/queue.c **** 	configASSERT( pxQueue->uxItemSize == 0 );
1089:..\Source/queue.c **** 
1090:..\Source/queue.c **** 	/* Normally a mutex would not be given from an interrupt, especially if
1091:..\Source/queue.c **** 	there is a mutex holder, as priority inheritance makes no sense for an
1092:..\Source/queue.c **** 	interrupts, only tasks. */
1093:..\Source/queue.c **** 	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NU
1094:..\Source/queue.c **** 
1095:..\Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1096:..\Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1097:..\Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1098:..\Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1099:..\Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1100:..\Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1101:..\Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1102:..\Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1103:..\Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1104:..\Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1105:..\Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1106:..\Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1107:..\Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1108:..\Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1109:..\Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1110:..\Source/queue.c **** 
1111:..\Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1150              		.loc 1 1111 0
 1151 0028 BB61     		str	r3, [r7, #24]
 1152              	.LBB30:
1112:..\Source/queue.c **** 	{
1113:..\Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1153              		.loc 1 1113 0
 1154 002a 3B6A     		ldr	r3, [r7, #32]
 1155 002c 9B6B     		ldr	r3, [r3, #56]
 1156 002e 7B61     		str	r3, [r7, #20]
1114:..\Source/queue.c **** 
1115:..\Source/queue.c **** 		/* When the queue is used to implement a semaphore no data is ever
1116:..\Source/queue.c **** 		moved through the queue but it is still valid to see if the queue 'has
1117:..\Source/queue.c **** 		space'. */
1118:..\Source/queue.c **** 		if( uxMessagesWaiting < pxQueue->uxLength )
 1157              		.loc 1 1118 0
 1158 0030 3B6A     		ldr	r3, [r7, #32]
 1159 0032 DA6B     		ldr	r2, [r3, #60]
 1160 0034 7B69     		ldr	r3, [r7, #20]
 1161 0036 9A42     		cmp	r2, r3
 1162 0038 33D9     		bls	.L66
 1163              	.LBB31:
1119:..\Source/queue.c **** 		{
1120:..\Source/queue.c **** 			const int8_t cTxLock = pxQueue->cTxLock;
 1164              		.loc 1 1120 0
 1165 003a 3B6A     		ldr	r3, [r7, #32]
 1166 003c 93F84530 		ldrb	r3, [r3, #69]
 1167 0040 FB74     		strb	r3, [r7, #19]
1121:..\Source/queue.c **** 
1122:..\Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 46


 1168              		.loc 1 1122 0
 1169 0042 3B6A     		ldr	r3, [r7, #32]
 1170 0044 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1171 0048 3B6A     		ldr	r3, [r7, #32]
 1172 004a 9B6C     		ldr	r3, [r3, #72]
 1173 004c DBB2     		uxtb	r3, r3
 1174 004e 1A46     		mov	r2, r3
 1175 0050 1D20     		movs	r0, #29
 1176 0052 FFF7FEFF 		bl	packPayload2
1123:..\Source/queue.c **** 
1124:..\Source/queue.c **** 			/* A task can only have an inherited priority if it is a mutex
1125:..\Source/queue.c **** 			holder - and if there is a mutex holder then the mutex cannot be
1126:..\Source/queue.c **** 			given from an ISR.  As this is the ISR version of the function it
1127:..\Source/queue.c **** 			can be assumed there is no mutex holder and no need to determine if
1128:..\Source/queue.c **** 			priority disinheritance is needed.  Simply increase the count of
1129:..\Source/queue.c **** 			messages (semaphores) available. */
1130:..\Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 1177              		.loc 1 1130 0
 1178 0056 7B69     		ldr	r3, [r7, #20]
 1179 0058 5A1C     		adds	r2, r3, #1
 1180 005a 3B6A     		ldr	r3, [r7, #32]
 1181 005c 9A63     		str	r2, [r3, #56]
1131:..\Source/queue.c **** 
1132:..\Source/queue.c **** 			/* The event list is not altered if the queue is locked.  This will
1133:..\Source/queue.c **** 			be done when the queue is unlocked later. */
1134:..\Source/queue.c **** 			if( cTxLock == queueUNLOCKED )
 1182              		.loc 1 1134 0
 1183 005e 97F91330 		ldrsb	r3, [r7, #19]
 1184 0062 B3F1FF3F 		cmp	r3, #-1
 1185 0066 12D1     		bne	.L67
1135:..\Source/queue.c **** 			{
1136:..\Source/queue.c **** 				#if ( configUSE_QUEUE_SETS == 1 )
1137:..\Source/queue.c **** 				{
1138:..\Source/queue.c **** 					if( pxQueue->pxQueueSetContainer != NULL )
1139:..\Source/queue.c **** 					{
1140:..\Source/queue.c **** 						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1141:..\Source/queue.c **** 						{
1142:..\Source/queue.c **** 							/* The semaphore is a member of a queue set, and
1143:..\Source/queue.c **** 							posting	to the queue set caused a higher priority
1144:..\Source/queue.c **** 							task to	unblock.  A context switch is required. */
1145:..\Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
1146:..\Source/queue.c **** 							{
1147:..\Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
1148:..\Source/queue.c **** 							}
1149:..\Source/queue.c **** 							else
1150:..\Source/queue.c **** 							{
1151:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1152:..\Source/queue.c **** 							}
1153:..\Source/queue.c **** 						}
1154:..\Source/queue.c **** 						else
1155:..\Source/queue.c **** 						{
1156:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1157:..\Source/queue.c **** 						}
1158:..\Source/queue.c **** 					}
1159:..\Source/queue.c **** 					else
1160:..\Source/queue.c **** 					{
1161:..\Source/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 47


1162:..\Source/queue.c **** 						{
1163:..\Source/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1164:..\Source/queue.c **** 							{
1165:..\Source/queue.c **** 								/* The task waiting has a higher priority so
1166:..\Source/queue.c **** 								record that a context switch is required. */
1167:..\Source/queue.c **** 								if( pxHigherPriorityTaskWoken != NULL )
1168:..\Source/queue.c **** 								{
1169:..\Source/queue.c **** 									*pxHigherPriorityTaskWoken = pdTRUE;
1170:..\Source/queue.c **** 								}
1171:..\Source/queue.c **** 								else
1172:..\Source/queue.c **** 								{
1173:..\Source/queue.c **** 									mtCOVERAGE_TEST_MARKER();
1174:..\Source/queue.c **** 								}
1175:..\Source/queue.c **** 							}
1176:..\Source/queue.c **** 							else
1177:..\Source/queue.c **** 							{
1178:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1179:..\Source/queue.c **** 							}
1180:..\Source/queue.c **** 						}
1181:..\Source/queue.c **** 						else
1182:..\Source/queue.c **** 						{
1183:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1184:..\Source/queue.c **** 						}
1185:..\Source/queue.c **** 					}
1186:..\Source/queue.c **** 				}
1187:..\Source/queue.c **** 				#else /* configUSE_QUEUE_SETS */
1188:..\Source/queue.c **** 				{
1189:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1186              		.loc 1 1189 0
 1187 0068 3B6A     		ldr	r3, [r7, #32]
 1188 006a 5B6A     		ldr	r3, [r3, #36]
 1189 006c 002B     		cmp	r3, #0
 1190 006e 15D0     		beq	.L68
1190:..\Source/queue.c **** 					{
1191:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1191              		.loc 1 1191 0
 1192 0070 3B6A     		ldr	r3, [r7, #32]
 1193 0072 2433     		adds	r3, r3, #36
 1194 0074 1846     		mov	r0, r3
 1195 0076 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1196 007a 0346     		mov	r3, r0
 1197 007c 002B     		cmp	r3, #0
 1198 007e 0DD0     		beq	.L68
1192:..\Source/queue.c **** 						{
1193:..\Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1194:..\Source/queue.c **** 							context	switch is required. */
1195:..\Source/queue.c **** 							if( pxHigherPriorityTaskWoken != NULL )
 1199              		.loc 1 1195 0
 1200 0080 3B68     		ldr	r3, [r7]
 1201 0082 002B     		cmp	r3, #0
 1202 0084 0AD0     		beq	.L68
1196:..\Source/queue.c **** 							{
1197:..\Source/queue.c **** 								*pxHigherPriorityTaskWoken = pdTRUE;
 1203              		.loc 1 1197 0
 1204 0086 3B68     		ldr	r3, [r7]
 1205 0088 0122     		movs	r2, #1
 1206 008a 1A60     		str	r2, [r3]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 48


 1207 008c 06E0     		b	.L68
 1208              	.L67:
1198:..\Source/queue.c **** 							}
1199:..\Source/queue.c **** 							else
1200:..\Source/queue.c **** 							{
1201:..\Source/queue.c **** 								mtCOVERAGE_TEST_MARKER();
1202:..\Source/queue.c **** 							}
1203:..\Source/queue.c **** 						}
1204:..\Source/queue.c **** 						else
1205:..\Source/queue.c **** 						{
1206:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1207:..\Source/queue.c **** 						}
1208:..\Source/queue.c **** 					}
1209:..\Source/queue.c **** 					else
1210:..\Source/queue.c **** 					{
1211:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1212:..\Source/queue.c **** 					}
1213:..\Source/queue.c **** 				}
1214:..\Source/queue.c **** 				#endif /* configUSE_QUEUE_SETS */
1215:..\Source/queue.c **** 			}
1216:..\Source/queue.c **** 			else
1217:..\Source/queue.c **** 			{
1218:..\Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1219:..\Source/queue.c **** 				knows that data was posted while it was locked. */
1220:..\Source/queue.c **** 				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1209              		.loc 1 1220 0
 1210 008e FB7C     		ldrb	r3, [r7, #19]	@ zero_extendqisi2
 1211 0090 0133     		adds	r3, r3, #1
 1212 0092 DBB2     		uxtb	r3, r3
 1213 0094 5AB2     		sxtb	r2, r3
 1214 0096 3B6A     		ldr	r3, [r7, #32]
 1215 0098 83F84520 		strb	r2, [r3, #69]
 1216              	.L68:
1221:..\Source/queue.c **** 			}
1222:..\Source/queue.c **** 
1223:..\Source/queue.c **** 			xReturn = pdPASS;
 1217              		.loc 1 1223 0
 1218 009c 0123     		movs	r3, #1
 1219 009e 7B62     		str	r3, [r7, #36]
 1220              	.LBE31:
 1221 00a0 0BE0     		b	.L69
 1222              	.L66:
1224:..\Source/queue.c **** 		}
1225:..\Source/queue.c **** 		else
1226:..\Source/queue.c **** 		{
1227:..\Source/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 1223              		.loc 1 1227 0
 1224 00a2 3B6A     		ldr	r3, [r7, #32]
 1225 00a4 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1226 00a8 3B6A     		ldr	r3, [r7, #32]
 1227 00aa 9B6C     		ldr	r3, [r3, #72]
 1228 00ac DBB2     		uxtb	r3, r3
 1229 00ae 1A46     		mov	r2, r3
 1230 00b0 1E20     		movs	r0, #30
 1231 00b2 FFF7FEFF 		bl	packPayload2
1228:..\Source/queue.c **** 			xReturn = errQUEUE_FULL;
 1232              		.loc 1 1228 0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 49


 1233 00b6 0023     		movs	r3, #0
 1234 00b8 7B62     		str	r3, [r7, #36]
 1235              	.L69:
 1236 00ba BB69     		ldr	r3, [r7, #24]
 1237 00bc FB61     		str	r3, [r7, #28]
 1238              	.LBE30:
 1239              	.LBB32:
 1240              	.LBB33:
 1241              		.loc 2 271 0
 1242 00be FB69     		ldr	r3, [r7, #28]
 1243              		.syntax unified
 1244              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1245 00c0 83F31188 			msr basepri, r3	
 1246              	@ 0 "" 2
 1247              		.thumb
 1248              		.syntax unified
 1249              	.LBE33:
 1250              	.LBE32:
1229:..\Source/queue.c **** 		}
1230:..\Source/queue.c **** 	}
1231:..\Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1232:..\Source/queue.c **** 
1233:..\Source/queue.c **** 	return xReturn;
 1251              		.loc 1 1233 0
 1252 00c4 7B6A     		ldr	r3, [r7, #36]
1234:..\Source/queue.c **** }
 1253              		.loc 1 1234 0
 1254 00c6 1846     		mov	r0, r3
 1255 00c8 2837     		adds	r7, r7, #40
 1256              		.cfi_def_cfa_offset 8
 1257 00ca BD46     		mov	sp, r7
 1258              		.cfi_def_cfa_register 13
 1259              		@ sp needed
 1260 00cc 80BD     		pop	{r7, pc}
 1261              		.cfi_endproc
 1262              	.LFE78:
 1263              		.size	xQueueGiveFromISR, .-xQueueGiveFromISR
 1264 00ce 00BF     		.section	.text.xQueueGenericReceive,"ax",%progbits
 1265              		.align	2
 1266              		.global	xQueueGenericReceive
 1267              		.thumb
 1268              		.thumb_func
 1269              		.type	xQueueGenericReceive, %function
 1270              	xQueueGenericReceive:
 1271              	.LFB79:
1235:..\Source/queue.c **** /*-----------------------------------------------------------*/
1236:..\Source/queue.c **** 
1237:..\Source/queue.c **** BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWa
1238:..\Source/queue.c **** {
 1272              		.loc 1 1238 0
 1273              		.cfi_startproc
 1274              		@ args = 0, pretend = 0, frame = 40
 1275              		@ frame_needed = 1, uses_anonymous_args = 0
 1276 0000 80B5     		push	{r7, lr}
 1277              		.cfi_def_cfa_offset 8
 1278              		.cfi_offset 7, -8
 1279              		.cfi_offset 14, -4
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 50


 1280 0002 8AB0     		sub	sp, sp, #40
 1281              		.cfi_def_cfa_offset 48
 1282 0004 00AF     		add	r7, sp, #0
 1283              		.cfi_def_cfa_register 7
 1284 0006 F860     		str	r0, [r7, #12]
 1285 0008 B960     		str	r1, [r7, #8]
 1286 000a 7A60     		str	r2, [r7, #4]
 1287 000c 3B60     		str	r3, [r7]
1239:..\Source/queue.c **** BaseType_t xEntryTimeSet = pdFALSE;
 1288              		.loc 1 1239 0
 1289 000e 0023     		movs	r3, #0
 1290 0010 7B62     		str	r3, [r7, #36]
1240:..\Source/queue.c **** TimeOut_t xTimeOut;
1241:..\Source/queue.c **** int8_t *pcOriginalReadPosition;
1242:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1291              		.loc 1 1242 0
 1292 0012 FB68     		ldr	r3, [r7, #12]
 1293 0014 3B62     		str	r3, [r7, #32]
 1294              	.L86:
1243:..\Source/queue.c **** 
1244:..\Source/queue.c **** 	configASSERT( pxQueue );
1245:..\Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1246:..\Source/queue.c **** 	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1247:..\Source/queue.c **** 	{
1248:..\Source/queue.c **** 		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 )
1249:..\Source/queue.c **** 	}
1250:..\Source/queue.c **** 	#endif
1251:..\Source/queue.c **** 
1252:..\Source/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
1253:..\Source/queue.c **** 	statements within the function itself.  This is done in the interest
1254:..\Source/queue.c **** 	of execution time efficiency. */
1255:..\Source/queue.c **** 
1256:..\Source/queue.c **** 	for( ;; )
1257:..\Source/queue.c **** 	{
1258:..\Source/queue.c **** 		taskENTER_CRITICAL();
 1295              		.loc 1 1258 0
 1296 0016 FFF7FEFF 		bl	vPortEnterCritical
 1297              	.LBB34:
1259:..\Source/queue.c **** 		{
1260:..\Source/queue.c **** 			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1298              		.loc 1 1260 0
 1299 001a 3B6A     		ldr	r3, [r7, #32]
 1300 001c 9B6B     		ldr	r3, [r3, #56]
 1301 001e FB61     		str	r3, [r7, #28]
1261:..\Source/queue.c **** 
1262:..\Source/queue.c **** 			/* Is there data in the queue now?  To be running the calling task
1263:..\Source/queue.c **** 			must be the highest priority task wanting to access the queue. */
1264:..\Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1302              		.loc 1 1264 0
 1303 0020 FB69     		ldr	r3, [r7, #28]
 1304 0022 002B     		cmp	r3, #0
 1305 0024 5AD0     		beq	.L72
1265:..\Source/queue.c **** 			{
1266:..\Source/queue.c **** 				/* Remember the read position in case the queue is only being
1267:..\Source/queue.c **** 				peeked. */
1268:..\Source/queue.c **** 				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1306              		.loc 1 1268 0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 51


 1307 0026 3B6A     		ldr	r3, [r7, #32]
 1308 0028 DB68     		ldr	r3, [r3, #12]
 1309 002a BB61     		str	r3, [r7, #24]
1269:..\Source/queue.c **** 
1270:..\Source/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1310              		.loc 1 1270 0
 1311 002c B968     		ldr	r1, [r7, #8]
 1312 002e 386A     		ldr	r0, [r7, #32]
 1313 0030 FFF7FEFF 		bl	prvCopyDataFromQueue
1271:..\Source/queue.c **** 
1272:..\Source/queue.c **** 				if( xJustPeeking == pdFALSE )
 1314              		.loc 1 1272 0
 1315 0034 3B68     		ldr	r3, [r7]
 1316 0036 002B     		cmp	r3, #0
 1317 0038 2BD1     		bne	.L73
1273:..\Source/queue.c **** 				{
1274:..\Source/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 1318              		.loc 1 1274 0
 1319 003a 3B6A     		ldr	r3, [r7, #32]
 1320 003c 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1321 0040 3B6A     		ldr	r3, [r7, #32]
 1322 0042 9B6C     		ldr	r3, [r3, #72]
 1323 0044 DBB2     		uxtb	r3, r3
 1324 0046 1A46     		mov	r2, r3
 1325 0048 1920     		movs	r0, #25
 1326 004a FFF7FEFF 		bl	packPayload2
1275:..\Source/queue.c **** 
1276:..\Source/queue.c **** 					/* Actually removing data, not just peeking. */
1277:..\Source/queue.c **** 					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1327              		.loc 1 1277 0
 1328 004e FB69     		ldr	r3, [r7, #28]
 1329 0050 5A1E     		subs	r2, r3, #1
 1330 0052 3B6A     		ldr	r3, [r7, #32]
 1331 0054 9A63     		str	r2, [r3, #56]
1278:..\Source/queue.c **** 
1279:..\Source/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
1280:..\Source/queue.c **** 					{
1281:..\Source/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1332              		.loc 1 1281 0
 1333 0056 3B6A     		ldr	r3, [r7, #32]
 1334 0058 1B68     		ldr	r3, [r3]
 1335 005a 002B     		cmp	r3, #0
 1336 005c 04D1     		bne	.L74
1282:..\Source/queue.c **** 						{
1283:..\Source/queue.c **** 							/* Record the information required to implement
1284:..\Source/queue.c **** 							priority inheritance should it become necessary. */
1285:..\Source/queue.c **** 							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is 
 1337              		.loc 1 1285 0
 1338 005e FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 1339 0062 0246     		mov	r2, r0
 1340 0064 3B6A     		ldr	r3, [r7, #32]
 1341 0066 5A60     		str	r2, [r3, #4]
 1342              	.L74:
1286:..\Source/queue.c **** 						}
1287:..\Source/queue.c **** 						else
1288:..\Source/queue.c **** 						{
1289:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 52


1290:..\Source/queue.c **** 						}
1291:..\Source/queue.c **** 					}
1292:..\Source/queue.c **** 					#endif /* configUSE_MUTEXES */
1293:..\Source/queue.c **** 
1294:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1343              		.loc 1 1294 0
 1344 0068 3B6A     		ldr	r3, [r7, #32]
 1345 006a 1B69     		ldr	r3, [r3, #16]
 1346 006c 002B     		cmp	r3, #0
 1347 006e 31D0     		beq	.L75
1295:..\Source/queue.c **** 					{
1296:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1348              		.loc 1 1296 0
 1349 0070 3B6A     		ldr	r3, [r7, #32]
 1350 0072 1033     		adds	r3, r3, #16
 1351 0074 1846     		mov	r0, r3
 1352 0076 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1353 007a 0346     		mov	r3, r0
 1354 007c 002B     		cmp	r3, #0
 1355 007e 29D0     		beq	.L75
1297:..\Source/queue.c **** 						{
1298:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1356              		.loc 1 1298 0
 1357 0080 634B     		ldr	r3, .L88
 1358 0082 4FF08052 		mov	r2, #268435456
 1359 0086 1A60     		str	r2, [r3]
 1360              		.syntax unified
 1361              	@ 1298 "..\Source\queue.c" 1
 1362 0088 BFF34F8F 		dsb
 1363              	@ 0 "" 2
 1364              	@ 1298 "..\Source\queue.c" 1
 1365 008c BFF36F8F 		isb
 1366              	@ 0 "" 2
 1367              		.thumb
 1368              		.syntax unified
 1369 0090 20E0     		b	.L75
 1370              	.L73:
1299:..\Source/queue.c **** 						}
1300:..\Source/queue.c **** 						else
1301:..\Source/queue.c **** 						{
1302:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1303:..\Source/queue.c **** 						}
1304:..\Source/queue.c **** 					}
1305:..\Source/queue.c **** 					else
1306:..\Source/queue.c **** 					{
1307:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1308:..\Source/queue.c **** 					}
1309:..\Source/queue.c **** 				}
1310:..\Source/queue.c **** 				else
1311:..\Source/queue.c **** 				{
1312:..\Source/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 1371              		.loc 1 1312 0
 1372 0092 3B6A     		ldr	r3, [r7, #32]
 1373 0094 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1374 0098 3B6A     		ldr	r3, [r7, #32]
 1375 009a 9B6C     		ldr	r3, [r3, #72]
 1376 009c DBB2     		uxtb	r3, r3
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 53


 1377 009e 1A46     		mov	r2, r3
 1378 00a0 1A20     		movs	r0, #26
 1379 00a2 FFF7FEFF 		bl	packPayload2
1313:..\Source/queue.c **** 
1314:..\Source/queue.c **** 					/* The data is not being removed, so reset the read
1315:..\Source/queue.c **** 					pointer. */
1316:..\Source/queue.c **** 					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1380              		.loc 1 1316 0
 1381 00a6 3B6A     		ldr	r3, [r7, #32]
 1382 00a8 BA69     		ldr	r2, [r7, #24]
 1383 00aa DA60     		str	r2, [r3, #12]
1317:..\Source/queue.c **** 
1318:..\Source/queue.c **** 					/* The data is being left in the queue, so see if there are
1319:..\Source/queue.c **** 					any other tasks waiting for the data. */
1320:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1384              		.loc 1 1320 0
 1385 00ac 3B6A     		ldr	r3, [r7, #32]
 1386 00ae 5B6A     		ldr	r3, [r3, #36]
 1387 00b0 002B     		cmp	r3, #0
 1388 00b2 0FD0     		beq	.L75
1321:..\Source/queue.c **** 					{
1322:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1389              		.loc 1 1322 0
 1390 00b4 3B6A     		ldr	r3, [r7, #32]
 1391 00b6 2433     		adds	r3, r3, #36
 1392 00b8 1846     		mov	r0, r3
 1393 00ba FFF7FEFF 		bl	xTaskRemoveFromEventList
 1394 00be 0346     		mov	r3, r0
 1395 00c0 002B     		cmp	r3, #0
 1396 00c2 07D0     		beq	.L75
1323:..\Source/queue.c **** 						{
1324:..\Source/queue.c **** 							/* The task waiting has a higher priority than this task. */
1325:..\Source/queue.c **** 							queueYIELD_IF_USING_PREEMPTION();
 1397              		.loc 1 1325 0
 1398 00c4 524B     		ldr	r3, .L88
 1399 00c6 4FF08052 		mov	r2, #268435456
 1400 00ca 1A60     		str	r2, [r3]
 1401              		.syntax unified
 1402              	@ 1325 "..\Source\queue.c" 1
 1403 00cc BFF34F8F 		dsb
 1404              	@ 0 "" 2
 1405              	@ 1325 "..\Source\queue.c" 1
 1406 00d0 BFF36F8F 		isb
 1407              	@ 0 "" 2
 1408              		.thumb
 1409              		.syntax unified
 1410              	.L75:
1326:..\Source/queue.c **** 						}
1327:..\Source/queue.c **** 						else
1328:..\Source/queue.c **** 						{
1329:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1330:..\Source/queue.c **** 						}
1331:..\Source/queue.c **** 					}
1332:..\Source/queue.c **** 					else
1333:..\Source/queue.c **** 					{
1334:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1335:..\Source/queue.c **** 					}
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 54


1336:..\Source/queue.c **** 				}
1337:..\Source/queue.c **** 
1338:..\Source/queue.c **** 				taskEXIT_CRITICAL();
 1411              		.loc 1 1338 0
 1412 00d4 FFF7FEFF 		bl	vPortExitCritical
1339:..\Source/queue.c **** 				return pdPASS;
 1413              		.loc 1 1339 0
 1414 00d8 0123     		movs	r3, #1
 1415 00da 95E0     		b	.L87
 1416              	.L72:
1340:..\Source/queue.c **** 			}
1341:..\Source/queue.c **** 			else
1342:..\Source/queue.c **** 			{
1343:..\Source/queue.c **** 				if( xTicksToWait == ( TickType_t ) 0 )
 1417              		.loc 1 1343 0
 1418 00dc 7B68     		ldr	r3, [r7, #4]
 1419 00de 002B     		cmp	r3, #0
 1420 00e0 0DD1     		bne	.L77
1344:..\Source/queue.c **** 				{
1345:..\Source/queue.c **** 					/* The queue was empty and no block time is specified (or
1346:..\Source/queue.c **** 					the block time has expired) so leave now. */
1347:..\Source/queue.c **** 					taskEXIT_CRITICAL();
 1421              		.loc 1 1347 0
 1422 00e2 FFF7FEFF 		bl	vPortExitCritical
1348:..\Source/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 1423              		.loc 1 1348 0
 1424 00e6 3B6A     		ldr	r3, [r7, #32]
 1425 00e8 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1426 00ec 3B6A     		ldr	r3, [r7, #32]
 1427 00ee 9B6C     		ldr	r3, [r3, #72]
 1428 00f0 DBB2     		uxtb	r3, r3
 1429 00f2 1A46     		mov	r2, r3
 1430 00f4 1C20     		movs	r0, #28
 1431 00f6 FFF7FEFF 		bl	packPayload2
1349:..\Source/queue.c **** 					return errQUEUE_EMPTY;
 1432              		.loc 1 1349 0
 1433 00fa 0023     		movs	r3, #0
 1434 00fc 84E0     		b	.L87
 1435              	.L77:
1350:..\Source/queue.c **** 				}
1351:..\Source/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 1436              		.loc 1 1351 0
 1437 00fe 7B6A     		ldr	r3, [r7, #36]
 1438 0100 002B     		cmp	r3, #0
 1439 0102 06D1     		bne	.L78
1352:..\Source/queue.c **** 				{
1353:..\Source/queue.c **** 					/* The queue was empty and a block time was specified so
1354:..\Source/queue.c **** 					configure the timeout structure. */
1355:..\Source/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 1440              		.loc 1 1355 0
 1441 0104 07F11003 		add	r3, r7, #16
 1442 0108 1846     		mov	r0, r3
 1443 010a FFF7FEFF 		bl	vTaskSetTimeOutState
1356:..\Source/queue.c **** 					xEntryTimeSet = pdTRUE;
 1444              		.loc 1 1356 0
 1445 010e 0123     		movs	r3, #1
 1446 0110 7B62     		str	r3, [r7, #36]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 55


 1447              	.L78:
 1448              	.LBE34:
1357:..\Source/queue.c **** 				}
1358:..\Source/queue.c **** 				else
1359:..\Source/queue.c **** 				{
1360:..\Source/queue.c **** 					/* Entry time was already set. */
1361:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1362:..\Source/queue.c **** 				}
1363:..\Source/queue.c **** 			}
1364:..\Source/queue.c **** 		}
1365:..\Source/queue.c **** 		taskEXIT_CRITICAL();
 1449              		.loc 1 1365 0
 1450 0112 FFF7FEFF 		bl	vPortExitCritical
1366:..\Source/queue.c **** 
1367:..\Source/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
1368:..\Source/queue.c **** 		now the critical section has been exited. */
1369:..\Source/queue.c **** 
1370:..\Source/queue.c **** 		vTaskSuspendAll();
 1451              		.loc 1 1370 0
 1452 0116 FFF7FEFF 		bl	vTaskSuspendAll
1371:..\Source/queue.c **** 		prvLockQueue( pxQueue );
 1453              		.loc 1 1371 0
 1454 011a FFF7FEFF 		bl	vPortEnterCritical
 1455 011e 3B6A     		ldr	r3, [r7, #32]
 1456 0120 93F84430 		ldrb	r3, [r3, #68]
 1457 0124 5BB2     		sxtb	r3, r3
 1458 0126 B3F1FF3F 		cmp	r3, #-1
 1459 012a 03D1     		bne	.L79
 1460              		.loc 1 1371 0 is_stmt 0 discriminator 1
 1461 012c 3B6A     		ldr	r3, [r7, #32]
 1462 012e 0022     		movs	r2, #0
 1463 0130 83F84420 		strb	r2, [r3, #68]
 1464              	.L79:
 1465              		.loc 1 1371 0 discriminator 3
 1466 0134 3B6A     		ldr	r3, [r7, #32]
 1467 0136 93F84530 		ldrb	r3, [r3, #69]
 1468 013a 5BB2     		sxtb	r3, r3
 1469 013c B3F1FF3F 		cmp	r3, #-1
 1470 0140 03D1     		bne	.L80
 1471              		.loc 1 1371 0 discriminator 4
 1472 0142 3B6A     		ldr	r3, [r7, #32]
 1473 0144 0022     		movs	r2, #0
 1474 0146 83F84520 		strb	r2, [r3, #69]
 1475              	.L80:
 1476              		.loc 1 1371 0 discriminator 6
 1477 014a FFF7FEFF 		bl	vPortExitCritical
1372:..\Source/queue.c **** 
1373:..\Source/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
1374:..\Source/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1478              		.loc 1 1374 0 is_stmt 1 discriminator 6
 1479 014e 3A1D     		adds	r2, r7, #4
 1480 0150 07F11003 		add	r3, r7, #16
 1481 0154 1146     		mov	r1, r2
 1482 0156 1846     		mov	r0, r3
 1483 0158 FFF7FEFF 		bl	xTaskCheckForTimeOut
 1484 015c 0346     		mov	r3, r0
 1485 015e 002B     		cmp	r3, #0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 56


 1486 0160 3BD1     		bne	.L81
1375:..\Source/queue.c **** 		{
1376:..\Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1487              		.loc 1 1376 0
 1488 0162 386A     		ldr	r0, [r7, #32]
 1489 0164 FFF7FEFF 		bl	prvIsQueueEmpty
 1490 0168 0346     		mov	r3, r0
 1491 016a 002B     		cmp	r3, #0
 1492 016c 2FD0     		beq	.L82
1377:..\Source/queue.c **** 			{
1378:..\Source/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 1493              		.loc 1 1378 0
 1494 016e 3B6A     		ldr	r3, [r7, #32]
 1495 0170 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1496 0174 3B6A     		ldr	r3, [r7, #32]
 1497 0176 9B6C     		ldr	r3, [r3, #72]
 1498 0178 DBB2     		uxtb	r3, r3
 1499 017a 1A46     		mov	r2, r3
 1500 017c 0920     		movs	r0, #9
 1501 017e FFF7FEFF 		bl	packPayload2
1379:..\Source/queue.c **** 
1380:..\Source/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
1381:..\Source/queue.c **** 				{
1382:..\Source/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1502              		.loc 1 1382 0
 1503 0182 3B6A     		ldr	r3, [r7, #32]
 1504 0184 1B68     		ldr	r3, [r3]
 1505 0186 002B     		cmp	r3, #0
 1506 0188 08D1     		bne	.L83
1383:..\Source/queue.c **** 					{
1384:..\Source/queue.c **** 						taskENTER_CRITICAL();
 1507              		.loc 1 1384 0
 1508 018a FFF7FEFF 		bl	vPortEnterCritical
1385:..\Source/queue.c **** 						{
1386:..\Source/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1509              		.loc 1 1386 0
 1510 018e 3B6A     		ldr	r3, [r7, #32]
 1511 0190 5B68     		ldr	r3, [r3, #4]
 1512 0192 1846     		mov	r0, r3
 1513 0194 FFF7FEFF 		bl	vTaskPriorityInherit
1387:..\Source/queue.c **** 						}
1388:..\Source/queue.c **** 						taskEXIT_CRITICAL();
 1514              		.loc 1 1388 0
 1515 0198 FFF7FEFF 		bl	vPortExitCritical
 1516              	.L83:
1389:..\Source/queue.c **** 					}
1390:..\Source/queue.c **** 					else
1391:..\Source/queue.c **** 					{
1392:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1393:..\Source/queue.c **** 					}
1394:..\Source/queue.c **** 				}
1395:..\Source/queue.c **** 				#endif
1396:..\Source/queue.c **** 
1397:..\Source/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1517              		.loc 1 1397 0
 1518 019c 3B6A     		ldr	r3, [r7, #32]
 1519 019e 2433     		adds	r3, r3, #36
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 57


 1520 01a0 7A68     		ldr	r2, [r7, #4]
 1521 01a2 1146     		mov	r1, r2
 1522 01a4 1846     		mov	r0, r3
 1523 01a6 FFF7FEFF 		bl	vTaskPlaceOnEventList
1398:..\Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1524              		.loc 1 1398 0
 1525 01aa 386A     		ldr	r0, [r7, #32]
 1526 01ac FFF7FEFF 		bl	prvUnlockQueue
1399:..\Source/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 1527              		.loc 1 1399 0
 1528 01b0 FFF7FEFF 		bl	xTaskResumeAll
 1529 01b4 0346     		mov	r3, r0
 1530 01b6 002B     		cmp	r3, #0
 1531 01b8 7FF42DAF 		bne	.L86
1400:..\Source/queue.c **** 				{
1401:..\Source/queue.c **** 					portYIELD_WITHIN_API();
 1532              		.loc 1 1401 0
 1533 01bc 144B     		ldr	r3, .L88
 1534 01be 4FF08052 		mov	r2, #268435456
 1535 01c2 1A60     		str	r2, [r3]
 1536              		.syntax unified
 1537              	@ 1401 "..\Source\queue.c" 1
 1538 01c4 BFF34F8F 		dsb
 1539              	@ 0 "" 2
 1540              	@ 1401 "..\Source\queue.c" 1
 1541 01c8 BFF36F8F 		isb
 1542              	@ 0 "" 2
 1543              		.thumb
 1544              		.syntax unified
 1545 01cc 23E7     		b	.L86
 1546              	.L82:
1402:..\Source/queue.c **** 				}
1403:..\Source/queue.c **** 				else
1404:..\Source/queue.c **** 				{
1405:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1406:..\Source/queue.c **** 				}
1407:..\Source/queue.c **** 			}
1408:..\Source/queue.c **** 			else
1409:..\Source/queue.c **** 			{
1410:..\Source/queue.c **** 				/* Try again. */
1411:..\Source/queue.c **** 				prvUnlockQueue( pxQueue );
 1547              		.loc 1 1411 0
 1548 01ce 386A     		ldr	r0, [r7, #32]
 1549 01d0 FFF7FEFF 		bl	prvUnlockQueue
1412:..\Source/queue.c **** 				( void ) xTaskResumeAll();
 1550              		.loc 1 1412 0
 1551 01d4 FFF7FEFF 		bl	xTaskResumeAll
 1552 01d8 1DE7     		b	.L86
 1553              	.L81:
1413:..\Source/queue.c **** 			}
1414:..\Source/queue.c **** 		}
1415:..\Source/queue.c **** 		else
1416:..\Source/queue.c **** 		{
1417:..\Source/queue.c **** 			prvUnlockQueue( pxQueue );
 1554              		.loc 1 1417 0
 1555 01da 386A     		ldr	r0, [r7, #32]
 1556 01dc FFF7FEFF 		bl	prvUnlockQueue
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 58


1418:..\Source/queue.c **** 			( void ) xTaskResumeAll();
 1557              		.loc 1 1418 0
 1558 01e0 FFF7FEFF 		bl	xTaskResumeAll
1419:..\Source/queue.c **** 
1420:..\Source/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1559              		.loc 1 1420 0
 1560 01e4 386A     		ldr	r0, [r7, #32]
 1561 01e6 FFF7FEFF 		bl	prvIsQueueEmpty
 1562 01ea 0346     		mov	r3, r0
 1563 01ec 002B     		cmp	r3, #0
 1564 01ee 3FF412AF 		beq	.L86
1421:..\Source/queue.c **** 			{
1422:..\Source/queue.c **** 				traceQUEUE_RECEIVE_FAILED( pxQueue );
 1565              		.loc 1 1422 0
 1566 01f2 3B6A     		ldr	r3, [r7, #32]
 1567 01f4 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1568 01f8 3B6A     		ldr	r3, [r7, #32]
 1569 01fa 9B6C     		ldr	r3, [r3, #72]
 1570 01fc DBB2     		uxtb	r3, r3
 1571 01fe 1A46     		mov	r2, r3
 1572 0200 1C20     		movs	r0, #28
 1573 0202 FFF7FEFF 		bl	packPayload2
1423:..\Source/queue.c **** 				return errQUEUE_EMPTY;
 1574              		.loc 1 1423 0
 1575 0206 0023     		movs	r3, #0
 1576              	.L87:
1424:..\Source/queue.c **** 			}
1425:..\Source/queue.c **** 			else
1426:..\Source/queue.c **** 			{
1427:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1428:..\Source/queue.c **** 			}
1429:..\Source/queue.c **** 		}
1430:..\Source/queue.c **** 	}
1431:..\Source/queue.c **** }
 1577              		.loc 1 1431 0 discriminator 4
 1578 0208 1846     		mov	r0, r3
 1579 020a 2837     		adds	r7, r7, #40
 1580              		.cfi_def_cfa_offset 8
 1581 020c BD46     		mov	sp, r7
 1582              		.cfi_def_cfa_register 13
 1583              		@ sp needed
 1584 020e 80BD     		pop	{r7, pc}
 1585              	.L89:
 1586              		.align	2
 1587              	.L88:
 1588 0210 04ED00E0 		.word	-536810236
 1589              		.cfi_endproc
 1590              	.LFE79:
 1591              		.size	xQueueGenericReceive, .-xQueueGenericReceive
 1592              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 1593              		.align	2
 1594              		.global	xQueueReceiveFromISR
 1595              		.thumb
 1596              		.thumb_func
 1597              		.type	xQueueReceiveFromISR, %function
 1598              	xQueueReceiveFromISR:
 1599              	.LFB80:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 59


1432:..\Source/queue.c **** /*-----------------------------------------------------------*/
1433:..\Source/queue.c **** 
1434:..\Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const px
1435:..\Source/queue.c **** {
 1600              		.loc 1 1435 0
 1601              		.cfi_startproc
 1602              		@ args = 0, pretend = 0, frame = 48
 1603              		@ frame_needed = 1, uses_anonymous_args = 0
 1604 0000 80B5     		push	{r7, lr}
 1605              		.cfi_def_cfa_offset 8
 1606              		.cfi_offset 7, -8
 1607              		.cfi_offset 14, -4
 1608 0002 8CB0     		sub	sp, sp, #48
 1609              		.cfi_def_cfa_offset 56
 1610 0004 00AF     		add	r7, sp, #0
 1611              		.cfi_def_cfa_register 7
 1612 0006 F860     		str	r0, [r7, #12]
 1613 0008 B960     		str	r1, [r7, #8]
 1614 000a 7A60     		str	r2, [r7, #4]
1436:..\Source/queue.c **** BaseType_t xReturn;
1437:..\Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1438:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1615              		.loc 1 1438 0
 1616 000c FB68     		ldr	r3, [r7, #12]
 1617 000e BB62     		str	r3, [r7, #40]
 1618              	.LBB35:
 1619              	.LBB36:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1620              		.loc 2 253 0
 1621              		.syntax unified
 1622              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1623 0010 EFF31182 			mrs r2, basepri											
 1624 0014 4FF0A003 		mov r3, #160												
 1625 0018 83F31188 		msr basepri, r3											
 1626 001c BFF36F8F 		isb														
 1627 0020 BFF34F8F 		dsb														
 1628              	
 1629              	@ 0 "" 2
 1630              		.thumb
 1631              		.syntax unified
 1632 0024 7A61     		str	r2, [r7, #20]
 1633 0026 3B61     		str	r3, [r7, #16]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1634              		.loc 2 265 0
 1635 0028 7B69     		ldr	r3, [r7, #20]
 1636              	.LBE36:
 1637              	.LBE35:
1439:..\Source/queue.c **** 
1440:..\Source/queue.c **** 	configASSERT( pxQueue );
1441:..\Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1442:..\Source/queue.c **** 
1443:..\Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1444:..\Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1445:..\Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1446:..\Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1447:..\Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1448:..\Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 60


1449:..\Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1450:..\Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1451:..\Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1452:..\Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1453:..\Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1454:..\Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1455:..\Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1456:..\Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1457:..\Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1458:..\Source/queue.c **** 
1459:..\Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1638              		.loc 1 1459 0
 1639 002a 3B62     		str	r3, [r7, #32]
 1640              	.LBB37:
1460:..\Source/queue.c **** 	{
1461:..\Source/queue.c **** 		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1641              		.loc 1 1461 0
 1642 002c BB6A     		ldr	r3, [r7, #40]
 1643 002e 9B6B     		ldr	r3, [r3, #56]
 1644 0030 FB61     		str	r3, [r7, #28]
1462:..\Source/queue.c **** 
1463:..\Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1464:..\Source/queue.c **** 		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1645              		.loc 1 1464 0
 1646 0032 FB69     		ldr	r3, [r7, #28]
 1647 0034 002B     		cmp	r3, #0
 1648 0036 37D0     		beq	.L92
 1649              	.LBB38:
1465:..\Source/queue.c **** 		{
1466:..\Source/queue.c **** 			const int8_t cRxLock = pxQueue->cRxLock;
 1650              		.loc 1 1466 0
 1651 0038 BB6A     		ldr	r3, [r7, #40]
 1652 003a 93F84430 		ldrb	r3, [r3, #68]
 1653 003e FB76     		strb	r3, [r7, #27]
1467:..\Source/queue.c **** 
1468:..\Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
 1654              		.loc 1 1468 0
 1655 0040 BB6A     		ldr	r3, [r7, #40]
 1656 0042 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1657 0046 BB6A     		ldr	r3, [r7, #40]
 1658 0048 9B6C     		ldr	r3, [r3, #72]
 1659 004a DBB2     		uxtb	r3, r3
 1660 004c 1A46     		mov	r2, r3
 1661 004e 1F20     		movs	r0, #31
 1662 0050 FFF7FEFF 		bl	packPayload2
1469:..\Source/queue.c **** 
1470:..\Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1663              		.loc 1 1470 0
 1664 0054 B968     		ldr	r1, [r7, #8]
 1665 0056 B86A     		ldr	r0, [r7, #40]
 1666 0058 FFF7FEFF 		bl	prvCopyDataFromQueue
1471:..\Source/queue.c **** 			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1667              		.loc 1 1471 0
 1668 005c FB69     		ldr	r3, [r7, #28]
 1669 005e 5A1E     		subs	r2, r3, #1
 1670 0060 BB6A     		ldr	r3, [r7, #40]
 1671 0062 9A63     		str	r2, [r3, #56]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 61


1472:..\Source/queue.c **** 
1473:..\Source/queue.c **** 			/* If the queue is locked the event list will not be modified.
1474:..\Source/queue.c **** 			Instead update the lock count so the task that unlocks the queue
1475:..\Source/queue.c **** 			will know that an ISR has removed data while the queue was
1476:..\Source/queue.c **** 			locked. */
1477:..\Source/queue.c **** 			if( cRxLock == queueUNLOCKED )
 1672              		.loc 1 1477 0
 1673 0064 97F91B30 		ldrsb	r3, [r7, #27]
 1674 0068 B3F1FF3F 		cmp	r3, #-1
 1675 006c 12D1     		bne	.L93
1478:..\Source/queue.c **** 			{
1479:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1676              		.loc 1 1479 0
 1677 006e BB6A     		ldr	r3, [r7, #40]
 1678 0070 1B69     		ldr	r3, [r3, #16]
 1679 0072 002B     		cmp	r3, #0
 1680 0074 15D0     		beq	.L94
1480:..\Source/queue.c **** 				{
1481:..\Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1681              		.loc 1 1481 0
 1682 0076 BB6A     		ldr	r3, [r7, #40]
 1683 0078 1033     		adds	r3, r3, #16
 1684 007a 1846     		mov	r0, r3
 1685 007c FFF7FEFF 		bl	xTaskRemoveFromEventList
 1686 0080 0346     		mov	r3, r0
 1687 0082 002B     		cmp	r3, #0
 1688 0084 0DD0     		beq	.L94
1482:..\Source/queue.c **** 					{
1483:..\Source/queue.c **** 						/* The task waiting has a higher priority than us so
1484:..\Source/queue.c **** 						force a context switch. */
1485:..\Source/queue.c **** 						if( pxHigherPriorityTaskWoken != NULL )
 1689              		.loc 1 1485 0
 1690 0086 7B68     		ldr	r3, [r7, #4]
 1691 0088 002B     		cmp	r3, #0
 1692 008a 0AD0     		beq	.L94
1486:..\Source/queue.c **** 						{
1487:..\Source/queue.c **** 							*pxHigherPriorityTaskWoken = pdTRUE;
 1693              		.loc 1 1487 0
 1694 008c 7B68     		ldr	r3, [r7, #4]
 1695 008e 0122     		movs	r2, #1
 1696 0090 1A60     		str	r2, [r3]
 1697 0092 06E0     		b	.L94
 1698              	.L93:
1488:..\Source/queue.c **** 						}
1489:..\Source/queue.c **** 						else
1490:..\Source/queue.c **** 						{
1491:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1492:..\Source/queue.c **** 						}
1493:..\Source/queue.c **** 					}
1494:..\Source/queue.c **** 					else
1495:..\Source/queue.c **** 					{
1496:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1497:..\Source/queue.c **** 					}
1498:..\Source/queue.c **** 				}
1499:..\Source/queue.c **** 				else
1500:..\Source/queue.c **** 				{
1501:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 62


1502:..\Source/queue.c **** 				}
1503:..\Source/queue.c **** 			}
1504:..\Source/queue.c **** 			else
1505:..\Source/queue.c **** 			{
1506:..\Source/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1507:..\Source/queue.c **** 				knows that data was removed while it was locked. */
1508:..\Source/queue.c **** 				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 1699              		.loc 1 1508 0
 1700 0094 FB7E     		ldrb	r3, [r7, #27]	@ zero_extendqisi2
 1701 0096 0133     		adds	r3, r3, #1
 1702 0098 DBB2     		uxtb	r3, r3
 1703 009a 5AB2     		sxtb	r2, r3
 1704 009c BB6A     		ldr	r3, [r7, #40]
 1705 009e 83F84420 		strb	r2, [r3, #68]
 1706              	.L94:
1509:..\Source/queue.c **** 			}
1510:..\Source/queue.c **** 
1511:..\Source/queue.c **** 			xReturn = pdPASS;
 1707              		.loc 1 1511 0
 1708 00a2 0123     		movs	r3, #1
 1709 00a4 FB62     		str	r3, [r7, #44]
 1710              	.LBE38:
 1711 00a6 0BE0     		b	.L95
 1712              	.L92:
1512:..\Source/queue.c **** 		}
1513:..\Source/queue.c **** 		else
1514:..\Source/queue.c **** 		{
1515:..\Source/queue.c **** 			xReturn = pdFAIL;
 1713              		.loc 1 1515 0
 1714 00a8 0023     		movs	r3, #0
 1715 00aa FB62     		str	r3, [r7, #44]
1516:..\Source/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
 1716              		.loc 1 1516 0
 1717 00ac BB6A     		ldr	r3, [r7, #40]
 1718 00ae 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1719 00b2 BB6A     		ldr	r3, [r7, #40]
 1720 00b4 9B6C     		ldr	r3, [r3, #72]
 1721 00b6 DBB2     		uxtb	r3, r3
 1722 00b8 1A46     		mov	r2, r3
 1723 00ba 2020     		movs	r0, #32
 1724 00bc FFF7FEFF 		bl	packPayload2
 1725              	.L95:
 1726 00c0 3B6A     		ldr	r3, [r7, #32]
 1727 00c2 7B62     		str	r3, [r7, #36]
 1728              	.LBE37:
 1729              	.LBB39:
 1730              	.LBB40:
 1731              		.loc 2 271 0
 1732 00c4 7B6A     		ldr	r3, [r7, #36]
 1733              		.syntax unified
 1734              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1735 00c6 83F31188 			msr basepri, r3	
 1736              	@ 0 "" 2
 1737              		.thumb
 1738              		.syntax unified
 1739              	.LBE40:
 1740              	.LBE39:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 63


1517:..\Source/queue.c **** 		}
1518:..\Source/queue.c **** 	}
1519:..\Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1520:..\Source/queue.c **** 
1521:..\Source/queue.c **** 	return xReturn;
 1741              		.loc 1 1521 0
 1742 00ca FB6A     		ldr	r3, [r7, #44]
1522:..\Source/queue.c **** }
 1743              		.loc 1 1522 0
 1744 00cc 1846     		mov	r0, r3
 1745 00ce 3037     		adds	r7, r7, #48
 1746              		.cfi_def_cfa_offset 8
 1747 00d0 BD46     		mov	sp, r7
 1748              		.cfi_def_cfa_register 13
 1749              		@ sp needed
 1750 00d2 80BD     		pop	{r7, pc}
 1751              		.cfi_endproc
 1752              	.LFE80:
 1753              		.size	xQueueReceiveFromISR, .-xQueueReceiveFromISR
 1754              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 1755              		.align	2
 1756              		.global	xQueuePeekFromISR
 1757              		.thumb
 1758              		.thumb_func
 1759              		.type	xQueuePeekFromISR, %function
 1760              	xQueuePeekFromISR:
 1761              	.LFB81:
1523:..\Source/queue.c **** /*-----------------------------------------------------------*/
1524:..\Source/queue.c **** 
1525:..\Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1526:..\Source/queue.c **** {
 1762              		.loc 1 1526 0
 1763              		.cfi_startproc
 1764              		@ args = 0, pretend = 0, frame = 40
 1765              		@ frame_needed = 1, uses_anonymous_args = 0
 1766 0000 80B5     		push	{r7, lr}
 1767              		.cfi_def_cfa_offset 8
 1768              		.cfi_offset 7, -8
 1769              		.cfi_offset 14, -4
 1770 0002 8AB0     		sub	sp, sp, #40
 1771              		.cfi_def_cfa_offset 48
 1772 0004 00AF     		add	r7, sp, #0
 1773              		.cfi_def_cfa_register 7
 1774 0006 7860     		str	r0, [r7, #4]
 1775 0008 3960     		str	r1, [r7]
1527:..\Source/queue.c **** BaseType_t xReturn;
1528:..\Source/queue.c **** UBaseType_t uxSavedInterruptStatus;
1529:..\Source/queue.c **** int8_t *pcOriginalReadPosition;
1530:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1776              		.loc 1 1530 0
 1777 000a 7B68     		ldr	r3, [r7, #4]
 1778 000c 3B62     		str	r3, [r7, #32]
 1779              	.LBB41:
 1780              	.LBB42:
 253:..\Source\portable\GCC\ARM_CM3/portmacro.h **** 	(
 1781              		.loc 2 253 0
 1782              		.syntax unified
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 64


 1783              	@ 253 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1784 000e EFF31182 			mrs r2, basepri											
 1785 0012 4FF0A003 		mov r3, #160												
 1786 0016 83F31188 		msr basepri, r3											
 1787 001a BFF36F8F 		isb														
 1788 001e BFF34F8F 		dsb														
 1789              	
 1790              	@ 0 "" 2
 1791              		.thumb
 1792              		.syntax unified
 1793 0022 3A61     		str	r2, [r7, #16]
 1794 0024 FB60     		str	r3, [r7, #12]
 265:..\Source\portable\GCC\ARM_CM3/portmacro.h **** }
 1795              		.loc 2 265 0
 1796 0026 3B69     		ldr	r3, [r7, #16]
 1797              	.LBE42:
 1798              	.LBE41:
1531:..\Source/queue.c **** 
1532:..\Source/queue.c **** 	configASSERT( pxQueue );
1533:..\Source/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1534:..\Source/queue.c **** 	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
1535:..\Source/queue.c **** 
1536:..\Source/queue.c **** 	/* RTOS ports that support interrupt nesting have the concept of a maximum
1537:..\Source/queue.c **** 	system call (or maximum API call) interrupt priority.  Interrupts that are
1538:..\Source/queue.c **** 	above the maximum system call priority are kept permanently enabled, even
1539:..\Source/queue.c **** 	when the RTOS kernel is in a critical section, but cannot make any calls to
1540:..\Source/queue.c **** 	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1541:..\Source/queue.c **** 	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1542:..\Source/queue.c **** 	failure if a FreeRTOS API function is called from an interrupt that has been
1543:..\Source/queue.c **** 	assigned a priority above the configured maximum system call priority.
1544:..\Source/queue.c **** 	Only FreeRTOS functions that end in FromISR can be called from interrupts
1545:..\Source/queue.c **** 	that have been assigned a priority at or (logically) below the maximum
1546:..\Source/queue.c **** 	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1547:..\Source/queue.c **** 	safe API to ensure interrupt entry is as fast and as simple as possible.
1548:..\Source/queue.c **** 	More information (albeit Cortex-M specific) is provided on the following
1549:..\Source/queue.c **** 	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1550:..\Source/queue.c **** 	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1551:..\Source/queue.c **** 
1552:..\Source/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1799              		.loc 1 1552 0
 1800 0028 BB61     		str	r3, [r7, #24]
1553:..\Source/queue.c **** 	{
1554:..\Source/queue.c **** 		/* Cannot block in an ISR, so check there is data available. */
1555:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1801              		.loc 1 1555 0
 1802 002a 3B6A     		ldr	r3, [r7, #32]
 1803 002c 9B6B     		ldr	r3, [r3, #56]
 1804 002e 002B     		cmp	r3, #0
 1805 0030 16D0     		beq	.L99
1556:..\Source/queue.c **** 		{
1557:..\Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR( pxQueue );
 1806              		.loc 1 1557 0
 1807 0032 3B6A     		ldr	r3, [r7, #32]
 1808 0034 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1809 0038 3B6A     		ldr	r3, [r7, #32]
 1810 003a 9B6C     		ldr	r3, [r3, #72]
 1811 003c DBB2     		uxtb	r3, r3
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 65


 1812 003e 1A46     		mov	r2, r3
 1813 0040 1B20     		movs	r0, #27
 1814 0042 FFF7FEFF 		bl	packPayload2
1558:..\Source/queue.c **** 
1559:..\Source/queue.c **** 			/* Remember the read position so it can be reset as nothing is
1560:..\Source/queue.c **** 			actually being removed from the queue. */
1561:..\Source/queue.c **** 			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1815              		.loc 1 1561 0
 1816 0046 3B6A     		ldr	r3, [r7, #32]
 1817 0048 DB68     		ldr	r3, [r3, #12]
 1818 004a 7B61     		str	r3, [r7, #20]
1562:..\Source/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1819              		.loc 1 1562 0
 1820 004c 3968     		ldr	r1, [r7]
 1821 004e 386A     		ldr	r0, [r7, #32]
 1822 0050 FFF7FEFF 		bl	prvCopyDataFromQueue
1563:..\Source/queue.c **** 			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1823              		.loc 1 1563 0
 1824 0054 3B6A     		ldr	r3, [r7, #32]
 1825 0056 7A69     		ldr	r2, [r7, #20]
 1826 0058 DA60     		str	r2, [r3, #12]
1564:..\Source/queue.c **** 
1565:..\Source/queue.c **** 			xReturn = pdPASS;
 1827              		.loc 1 1565 0
 1828 005a 0123     		movs	r3, #1
 1829 005c 7B62     		str	r3, [r7, #36]
 1830 005e 0BE0     		b	.L100
 1831              	.L99:
1566:..\Source/queue.c **** 		}
1567:..\Source/queue.c **** 		else
1568:..\Source/queue.c **** 		{
1569:..\Source/queue.c **** 			xReturn = pdFAIL;
 1832              		.loc 1 1569 0
 1833 0060 0023     		movs	r3, #0
 1834 0062 7B62     		str	r3, [r7, #36]
1570:..\Source/queue.c **** 			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
 1835              		.loc 1 1570 0
 1836 0064 3B6A     		ldr	r3, [r7, #32]
 1837 0066 93F84C10 		ldrb	r1, [r3, #76]	@ zero_extendqisi2
 1838 006a 3B6A     		ldr	r3, [r7, #32]
 1839 006c 9B6C     		ldr	r3, [r3, #72]
 1840 006e DBB2     		uxtb	r3, r3
 1841 0070 1A46     		mov	r2, r3
 1842 0072 2120     		movs	r0, #33
 1843 0074 FFF7FEFF 		bl	packPayload2
 1844              	.L100:
 1845 0078 BB69     		ldr	r3, [r7, #24]
 1846 007a FB61     		str	r3, [r7, #28]
 1847              	.LBB43:
 1848              	.LBB44:
 1849              		.loc 2 271 0
 1850 007c FB69     		ldr	r3, [r7, #28]
 1851              		.syntax unified
 1852              	@ 271 "..\Source\portable\GCC\ARM_CM3/portmacro.h" 1
 1853 007e 83F31188 			msr basepri, r3	
 1854              	@ 0 "" 2
 1855              		.thumb
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 66


 1856              		.syntax unified
 1857              	.LBE44:
 1858              	.LBE43:
1571:..\Source/queue.c **** 		}
1572:..\Source/queue.c **** 	}
1573:..\Source/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1574:..\Source/queue.c **** 
1575:..\Source/queue.c **** 	return xReturn;
 1859              		.loc 1 1575 0
 1860 0082 7B6A     		ldr	r3, [r7, #36]
1576:..\Source/queue.c **** }
 1861              		.loc 1 1576 0
 1862 0084 1846     		mov	r0, r3
 1863 0086 2837     		adds	r7, r7, #40
 1864              		.cfi_def_cfa_offset 8
 1865 0088 BD46     		mov	sp, r7
 1866              		.cfi_def_cfa_register 13
 1867              		@ sp needed
 1868 008a 80BD     		pop	{r7, pc}
 1869              		.cfi_endproc
 1870              	.LFE81:
 1871              		.size	xQueuePeekFromISR, .-xQueuePeekFromISR
 1872              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 1873              		.align	2
 1874              		.global	uxQueueMessagesWaiting
 1875              		.thumb
 1876              		.thumb_func
 1877              		.type	uxQueueMessagesWaiting, %function
 1878              	uxQueueMessagesWaiting:
 1879              	.LFB82:
1577:..\Source/queue.c **** /*-----------------------------------------------------------*/
1578:..\Source/queue.c **** 
1579:..\Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1580:..\Source/queue.c **** {
 1880              		.loc 1 1580 0
 1881              		.cfi_startproc
 1882              		@ args = 0, pretend = 0, frame = 16
 1883              		@ frame_needed = 1, uses_anonymous_args = 0
 1884 0000 80B5     		push	{r7, lr}
 1885              		.cfi_def_cfa_offset 8
 1886              		.cfi_offset 7, -8
 1887              		.cfi_offset 14, -4
 1888 0002 84B0     		sub	sp, sp, #16
 1889              		.cfi_def_cfa_offset 24
 1890 0004 00AF     		add	r7, sp, #0
 1891              		.cfi_def_cfa_register 7
 1892 0006 7860     		str	r0, [r7, #4]
1581:..\Source/queue.c **** UBaseType_t uxReturn;
1582:..\Source/queue.c **** 
1583:..\Source/queue.c **** 	configASSERT( xQueue );
1584:..\Source/queue.c **** 
1585:..\Source/queue.c **** 	taskENTER_CRITICAL();
 1893              		.loc 1 1585 0
 1894 0008 FFF7FEFF 		bl	vPortEnterCritical
1586:..\Source/queue.c **** 	{
1587:..\Source/queue.c **** 		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1895              		.loc 1 1587 0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 67


 1896 000c 7B68     		ldr	r3, [r7, #4]
 1897 000e 9B6B     		ldr	r3, [r3, #56]
 1898 0010 FB60     		str	r3, [r7, #12]
1588:..\Source/queue.c **** 	}
1589:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 1899              		.loc 1 1589 0
 1900 0012 FFF7FEFF 		bl	vPortExitCritical
1590:..\Source/queue.c **** 
1591:..\Source/queue.c **** 	return uxReturn;
 1901              		.loc 1 1591 0
 1902 0016 FB68     		ldr	r3, [r7, #12]
1592:..\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1903              		.loc 1 1592 0
 1904 0018 1846     		mov	r0, r3
 1905 001a 1037     		adds	r7, r7, #16
 1906              		.cfi_def_cfa_offset 8
 1907 001c BD46     		mov	sp, r7
 1908              		.cfi_def_cfa_register 13
 1909              		@ sp needed
 1910 001e 80BD     		pop	{r7, pc}
 1911              		.cfi_endproc
 1912              	.LFE82:
 1913              		.size	uxQueueMessagesWaiting, .-uxQueueMessagesWaiting
 1914              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 1915              		.align	2
 1916              		.global	uxQueueSpacesAvailable
 1917              		.thumb
 1918              		.thumb_func
 1919              		.type	uxQueueSpacesAvailable, %function
 1920              	uxQueueSpacesAvailable:
 1921              	.LFB83:
1593:..\Source/queue.c **** /*-----------------------------------------------------------*/
1594:..\Source/queue.c **** 
1595:..\Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1596:..\Source/queue.c **** {
 1922              		.loc 1 1596 0
 1923              		.cfi_startproc
 1924              		@ args = 0, pretend = 0, frame = 16
 1925              		@ frame_needed = 1, uses_anonymous_args = 0
 1926 0000 80B5     		push	{r7, lr}
 1927              		.cfi_def_cfa_offset 8
 1928              		.cfi_offset 7, -8
 1929              		.cfi_offset 14, -4
 1930 0002 84B0     		sub	sp, sp, #16
 1931              		.cfi_def_cfa_offset 24
 1932 0004 00AF     		add	r7, sp, #0
 1933              		.cfi_def_cfa_register 7
 1934 0006 7860     		str	r0, [r7, #4]
1597:..\Source/queue.c **** UBaseType_t uxReturn;
1598:..\Source/queue.c **** Queue_t *pxQueue;
1599:..\Source/queue.c **** 
1600:..\Source/queue.c **** 	pxQueue = ( Queue_t * ) xQueue;
 1935              		.loc 1 1600 0
 1936 0008 7B68     		ldr	r3, [r7, #4]
 1937 000a FB60     		str	r3, [r7, #12]
1601:..\Source/queue.c **** 	configASSERT( pxQueue );
1602:..\Source/queue.c **** 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 68


1603:..\Source/queue.c **** 	taskENTER_CRITICAL();
 1938              		.loc 1 1603 0
 1939 000c FFF7FEFF 		bl	vPortEnterCritical
1604:..\Source/queue.c **** 	{
1605:..\Source/queue.c **** 		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1940              		.loc 1 1605 0
 1941 0010 FB68     		ldr	r3, [r7, #12]
 1942 0012 DA6B     		ldr	r2, [r3, #60]
 1943 0014 FB68     		ldr	r3, [r7, #12]
 1944 0016 9B6B     		ldr	r3, [r3, #56]
 1945 0018 D31A     		subs	r3, r2, r3
 1946 001a BB60     		str	r3, [r7, #8]
1606:..\Source/queue.c **** 	}
1607:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 1947              		.loc 1 1607 0
 1948 001c FFF7FEFF 		bl	vPortExitCritical
1608:..\Source/queue.c **** 
1609:..\Source/queue.c **** 	return uxReturn;
 1949              		.loc 1 1609 0
 1950 0020 BB68     		ldr	r3, [r7, #8]
1610:..\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1951              		.loc 1 1610 0
 1952 0022 1846     		mov	r0, r3
 1953 0024 1037     		adds	r7, r7, #16
 1954              		.cfi_def_cfa_offset 8
 1955 0026 BD46     		mov	sp, r7
 1956              		.cfi_def_cfa_register 13
 1957              		@ sp needed
 1958 0028 80BD     		pop	{r7, pc}
 1959              		.cfi_endproc
 1960              	.LFE83:
 1961              		.size	uxQueueSpacesAvailable, .-uxQueueSpacesAvailable
 1962 002a 00BF     		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 1963              		.align	2
 1964              		.global	uxQueueMessagesWaitingFromISR
 1965              		.thumb
 1966              		.thumb_func
 1967              		.type	uxQueueMessagesWaitingFromISR, %function
 1968              	uxQueueMessagesWaitingFromISR:
 1969              	.LFB84:
1611:..\Source/queue.c **** /*-----------------------------------------------------------*/
1612:..\Source/queue.c **** 
1613:..\Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1614:..\Source/queue.c **** {
 1970              		.loc 1 1614 0
 1971              		.cfi_startproc
 1972              		@ args = 0, pretend = 0, frame = 16
 1973              		@ frame_needed = 1, uses_anonymous_args = 0
 1974              		@ link register save eliminated.
 1975 0000 80B4     		push	{r7}
 1976              		.cfi_def_cfa_offset 4
 1977              		.cfi_offset 7, -4
 1978 0002 85B0     		sub	sp, sp, #20
 1979              		.cfi_def_cfa_offset 24
 1980 0004 00AF     		add	r7, sp, #0
 1981              		.cfi_def_cfa_register 7
 1982 0006 7860     		str	r0, [r7, #4]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 69


1615:..\Source/queue.c **** UBaseType_t uxReturn;
1616:..\Source/queue.c **** 
1617:..\Source/queue.c **** 	configASSERT( xQueue );
1618:..\Source/queue.c **** 
1619:..\Source/queue.c **** 	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1983              		.loc 1 1619 0
 1984 0008 7B68     		ldr	r3, [r7, #4]
 1985 000a 9B6B     		ldr	r3, [r3, #56]
 1986 000c FB60     		str	r3, [r7, #12]
1620:..\Source/queue.c **** 
1621:..\Source/queue.c **** 	return uxReturn;
 1987              		.loc 1 1621 0
 1988 000e FB68     		ldr	r3, [r7, #12]
1622:..\Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1989              		.loc 1 1622 0
 1990 0010 1846     		mov	r0, r3
 1991 0012 1437     		adds	r7, r7, #20
 1992              		.cfi_def_cfa_offset 4
 1993 0014 BD46     		mov	sp, r7
 1994              		.cfi_def_cfa_register 13
 1995              		@ sp needed
 1996 0016 80BC     		pop	{r7}
 1997              		.cfi_restore 7
 1998              		.cfi_def_cfa_offset 0
 1999 0018 7047     		bx	lr
 2000              		.cfi_endproc
 2001              	.LFE84:
 2002              		.size	uxQueueMessagesWaitingFromISR, .-uxQueueMessagesWaitingFromISR
 2003 001a 00BF     		.section	.text.vQueueDelete,"ax",%progbits
 2004              		.align	2
 2005              		.global	vQueueDelete
 2006              		.thumb
 2007              		.thumb_func
 2008              		.type	vQueueDelete, %function
 2009              	vQueueDelete:
 2010              	.LFB85:
1623:..\Source/queue.c **** /*-----------------------------------------------------------*/
1624:..\Source/queue.c **** 
1625:..\Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
1626:..\Source/queue.c **** {
 2011              		.loc 1 1626 0
 2012              		.cfi_startproc
 2013              		@ args = 0, pretend = 0, frame = 16
 2014              		@ frame_needed = 1, uses_anonymous_args = 0
 2015 0000 80B5     		push	{r7, lr}
 2016              		.cfi_def_cfa_offset 8
 2017              		.cfi_offset 7, -8
 2018              		.cfi_offset 14, -4
 2019 0002 84B0     		sub	sp, sp, #16
 2020              		.cfi_def_cfa_offset 24
 2021 0004 00AF     		add	r7, sp, #0
 2022              		.cfi_def_cfa_register 7
 2023 0006 7860     		str	r0, [r7, #4]
1627:..\Source/queue.c **** Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 2024              		.loc 1 1627 0
 2025 0008 7B68     		ldr	r3, [r7, #4]
 2026 000a FB60     		str	r3, [r7, #12]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 70


1628:..\Source/queue.c **** 
1629:..\Source/queue.c **** 	configASSERT( pxQueue );
1630:..\Source/queue.c **** 	traceQUEUE_DELETE( pxQueue );
 2027              		.loc 1 1630 0
 2028 000c FB68     		ldr	r3, [r7, #12]
 2029 000e 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
 2030 0012 1846     		mov	r0, r3
 2031 0014 FB68     		ldr	r3, [r7, #12]
 2032 0016 9A6C     		ldr	r2, [r3, #72]
 2033 0018 0D49     		ldr	r1, .L109
 2034 001a 1346     		mov	r3, r2
 2035 001c DB00     		lsls	r3, r3, #3
 2036 001e 9B1A     		subs	r3, r3, r2
 2037 0020 5B00     		lsls	r3, r3, #1
 2038 0022 4FF48E72 		mov	r2, #284
 2039 0026 02FB00F2 		mul	r2, r2, r0
 2040 002a 1344     		add	r3, r3, r2
 2041 002c 0B44     		add	r3, r3, r1
 2042 002e 0433     		adds	r3, r3, #4
 2043 0030 0022     		movs	r2, #0
 2044 0032 1A70     		strb	r2, [r3]
 2045 0034 2220     		movs	r0, #34
 2046 0036 FFF7FEFF 		bl	packPayload0
1631:..\Source/queue.c **** 
1632:..\Source/queue.c **** 	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1633:..\Source/queue.c **** 	{
1634:..\Source/queue.c **** 		vQueueUnregisterQueue( pxQueue );
 2047              		.loc 1 1634 0
 2048 003a F868     		ldr	r0, [r7, #12]
 2049 003c FFF7FEFF 		bl	vQueueUnregisterQueue
1635:..\Source/queue.c **** 	}
1636:..\Source/queue.c **** 	#endif
1637:..\Source/queue.c **** 
1638:..\Source/queue.c **** 	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
1639:..\Source/queue.c **** 	{
1640:..\Source/queue.c **** 		/* The queue can only have been allocated dynamically - free it
1641:..\Source/queue.c **** 		again. */
1642:..\Source/queue.c **** 		vPortFree( pxQueue );
 2050              		.loc 1 1642 0
 2051 0040 F868     		ldr	r0, [r7, #12]
 2052 0042 FFF7FEFF 		bl	vPortFree
1643:..\Source/queue.c **** 	}
1644:..\Source/queue.c **** 	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
1645:..\Source/queue.c **** 	{
1646:..\Source/queue.c **** 		/* The queue could have been allocated statically or dynamically, so
1647:..\Source/queue.c **** 		check before attempting to free the memory. */
1648:..\Source/queue.c **** 		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
1649:..\Source/queue.c **** 		{
1650:..\Source/queue.c **** 			vPortFree( pxQueue );
1651:..\Source/queue.c **** 		}
1652:..\Source/queue.c **** 		else
1653:..\Source/queue.c **** 		{
1654:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1655:..\Source/queue.c **** 		}
1656:..\Source/queue.c **** 	}
1657:..\Source/queue.c **** 	#else
1658:..\Source/queue.c **** 	{
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 71


1659:..\Source/queue.c **** 		/* The queue must have been statically allocated, so is not going to be
1660:..\Source/queue.c **** 		deleted.  Avoid compiler warnings about the unused parameter. */
1661:..\Source/queue.c **** 		( void ) pxQueue;
1662:..\Source/queue.c **** 	}
1663:..\Source/queue.c **** 	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
1664:..\Source/queue.c **** }
 2053              		.loc 1 1664 0
 2054 0046 00BF     		nop
 2055 0048 1037     		adds	r7, r7, #16
 2056              		.cfi_def_cfa_offset 8
 2057 004a BD46     		mov	sp, r7
 2058              		.cfi_def_cfa_register 13
 2059              		@ sp needed
 2060 004c 80BD     		pop	{r7, pc}
 2061              	.L110:
 2062 004e 00BF     		.align	2
 2063              	.L109:
 2064 0050 00000000 		.word	objectList
 2065              		.cfi_endproc
 2066              	.LFE85:
 2067              		.size	vQueueDelete, .-vQueueDelete
 2068              		.section	.text.uxQueueGetQueueNumber,"ax",%progbits
 2069              		.align	2
 2070              		.global	uxQueueGetQueueNumber
 2071              		.thumb
 2072              		.thumb_func
 2073              		.type	uxQueueGetQueueNumber, %function
 2074              	uxQueueGetQueueNumber:
 2075              	.LFB86:
1665:..\Source/queue.c **** /*-----------------------------------------------------------*/
1666:..\Source/queue.c **** 
1667:..\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1668:..\Source/queue.c **** 
1669:..\Source/queue.c **** 	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1670:..\Source/queue.c **** 	{
 2076              		.loc 1 1670 0
 2077              		.cfi_startproc
 2078              		@ args = 0, pretend = 0, frame = 8
 2079              		@ frame_needed = 1, uses_anonymous_args = 0
 2080              		@ link register save eliminated.
 2081 0000 80B4     		push	{r7}
 2082              		.cfi_def_cfa_offset 4
 2083              		.cfi_offset 7, -4
 2084 0002 83B0     		sub	sp, sp, #12
 2085              		.cfi_def_cfa_offset 16
 2086 0004 00AF     		add	r7, sp, #0
 2087              		.cfi_def_cfa_register 7
 2088 0006 7860     		str	r0, [r7, #4]
1671:..\Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 2089              		.loc 1 1671 0
 2090 0008 7B68     		ldr	r3, [r7, #4]
 2091 000a 9B6C     		ldr	r3, [r3, #72]
1672:..\Source/queue.c **** 	}
 2092              		.loc 1 1672 0
 2093 000c 1846     		mov	r0, r3
 2094 000e 0C37     		adds	r7, r7, #12
 2095              		.cfi_def_cfa_offset 4
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 72


 2096 0010 BD46     		mov	sp, r7
 2097              		.cfi_def_cfa_register 13
 2098              		@ sp needed
 2099 0012 80BC     		pop	{r7}
 2100              		.cfi_restore 7
 2101              		.cfi_def_cfa_offset 0
 2102 0014 7047     		bx	lr
 2103              		.cfi_endproc
 2104              	.LFE86:
 2105              		.size	uxQueueGetQueueNumber, .-uxQueueGetQueueNumber
 2106 0016 00BF     		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 2107              		.align	2
 2108              		.global	vQueueSetQueueNumber
 2109              		.thumb
 2110              		.thumb_func
 2111              		.type	vQueueSetQueueNumber, %function
 2112              	vQueueSetQueueNumber:
 2113              	.LFB87:
1673:..\Source/queue.c **** 
1674:..\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1675:..\Source/queue.c **** /*-----------------------------------------------------------*/
1676:..\Source/queue.c **** 
1677:..\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1678:..\Source/queue.c **** 
1679:..\Source/queue.c **** 	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1680:..\Source/queue.c **** 	{
 2114              		.loc 1 1680 0
 2115              		.cfi_startproc
 2116              		@ args = 0, pretend = 0, frame = 8
 2117              		@ frame_needed = 1, uses_anonymous_args = 0
 2118              		@ link register save eliminated.
 2119 0000 80B4     		push	{r7}
 2120              		.cfi_def_cfa_offset 4
 2121              		.cfi_offset 7, -4
 2122 0002 83B0     		sub	sp, sp, #12
 2123              		.cfi_def_cfa_offset 16
 2124 0004 00AF     		add	r7, sp, #0
 2125              		.cfi_def_cfa_register 7
 2126 0006 7860     		str	r0, [r7, #4]
 2127 0008 3960     		str	r1, [r7]
1681:..\Source/queue.c **** 		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 2128              		.loc 1 1681 0
 2129 000a 7B68     		ldr	r3, [r7, #4]
 2130 000c 3A68     		ldr	r2, [r7]
 2131 000e 9A64     		str	r2, [r3, #72]
1682:..\Source/queue.c **** 	}
 2132              		.loc 1 1682 0
 2133 0010 00BF     		nop
 2134 0012 0C37     		adds	r7, r7, #12
 2135              		.cfi_def_cfa_offset 4
 2136 0014 BD46     		mov	sp, r7
 2137              		.cfi_def_cfa_register 13
 2138              		@ sp needed
 2139 0016 80BC     		pop	{r7}
 2140              		.cfi_restore 7
 2141              		.cfi_def_cfa_offset 0
 2142 0018 7047     		bx	lr
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 73


 2143              		.cfi_endproc
 2144              	.LFE87:
 2145              		.size	vQueueSetQueueNumber, .-vQueueSetQueueNumber
 2146 001a 00BF     		.section	.text.ucQueueGetQueueType,"ax",%progbits
 2147              		.align	2
 2148              		.global	ucQueueGetQueueType
 2149              		.thumb
 2150              		.thumb_func
 2151              		.type	ucQueueGetQueueType, %function
 2152              	ucQueueGetQueueType:
 2153              	.LFB88:
1683:..\Source/queue.c **** 
1684:..\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1685:..\Source/queue.c **** /*-----------------------------------------------------------*/
1686:..\Source/queue.c **** 
1687:..\Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1688:..\Source/queue.c **** 
1689:..\Source/queue.c **** 	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1690:..\Source/queue.c **** 	{
 2154              		.loc 1 1690 0
 2155              		.cfi_startproc
 2156              		@ args = 0, pretend = 0, frame = 8
 2157              		@ frame_needed = 1, uses_anonymous_args = 0
 2158              		@ link register save eliminated.
 2159 0000 80B4     		push	{r7}
 2160              		.cfi_def_cfa_offset 4
 2161              		.cfi_offset 7, -4
 2162 0002 83B0     		sub	sp, sp, #12
 2163              		.cfi_def_cfa_offset 16
 2164 0004 00AF     		add	r7, sp, #0
 2165              		.cfi_def_cfa_register 7
 2166 0006 7860     		str	r0, [r7, #4]
1691:..\Source/queue.c **** 		return ( ( Queue_t * ) xQueue )->ucQueueType;
 2167              		.loc 1 1691 0
 2168 0008 7B68     		ldr	r3, [r7, #4]
 2169 000a 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
1692:..\Source/queue.c **** 	}
 2170              		.loc 1 1692 0
 2171 000e 1846     		mov	r0, r3
 2172 0010 0C37     		adds	r7, r7, #12
 2173              		.cfi_def_cfa_offset 4
 2174 0012 BD46     		mov	sp, r7
 2175              		.cfi_def_cfa_register 13
 2176              		@ sp needed
 2177 0014 80BC     		pop	{r7}
 2178              		.cfi_restore 7
 2179              		.cfi_def_cfa_offset 0
 2180 0016 7047     		bx	lr
 2181              		.cfi_endproc
 2182              	.LFE88:
 2183              		.size	ucQueueGetQueueType, .-ucQueueGetQueueType
 2184              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 2185              		.align	2
 2186              		.thumb
 2187              		.thumb_func
 2188              		.type	prvCopyDataToQueue, %function
 2189              	prvCopyDataToQueue:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 74


 2190              	.LFB89:
1693:..\Source/queue.c **** 
1694:..\Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
1695:..\Source/queue.c **** /*-----------------------------------------------------------*/
1696:..\Source/queue.c **** 
1697:..\Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const Bas
1698:..\Source/queue.c **** {
 2191              		.loc 1 1698 0
 2192              		.cfi_startproc
 2193              		@ args = 0, pretend = 0, frame = 24
 2194              		@ frame_needed = 1, uses_anonymous_args = 0
 2195 0000 80B5     		push	{r7, lr}
 2196              		.cfi_def_cfa_offset 8
 2197              		.cfi_offset 7, -8
 2198              		.cfi_offset 14, -4
 2199 0002 86B0     		sub	sp, sp, #24
 2200              		.cfi_def_cfa_offset 32
 2201 0004 00AF     		add	r7, sp, #0
 2202              		.cfi_def_cfa_register 7
 2203 0006 F860     		str	r0, [r7, #12]
 2204 0008 B960     		str	r1, [r7, #8]
 2205 000a 7A60     		str	r2, [r7, #4]
1699:..\Source/queue.c **** BaseType_t xReturn = pdFALSE;
 2206              		.loc 1 1699 0
 2207 000c 0023     		movs	r3, #0
 2208 000e 7B61     		str	r3, [r7, #20]
1700:..\Source/queue.c **** UBaseType_t uxMessagesWaiting;
1701:..\Source/queue.c **** 
1702:..\Source/queue.c **** 	/* This function is called from a critical section. */
1703:..\Source/queue.c **** 
1704:..\Source/queue.c **** 	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2209              		.loc 1 1704 0
 2210 0010 FB68     		ldr	r3, [r7, #12]
 2211 0012 9B6B     		ldr	r3, [r3, #56]
 2212 0014 3B61     		str	r3, [r7, #16]
1705:..\Source/queue.c **** 
1706:..\Source/queue.c **** 	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 2213              		.loc 1 1706 0
 2214 0016 FB68     		ldr	r3, [r7, #12]
 2215 0018 1B6C     		ldr	r3, [r3, #64]
 2216 001a 002B     		cmp	r3, #0
 2217 001c 0DD1     		bne	.L117
1707:..\Source/queue.c **** 	{
1708:..\Source/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1709:..\Source/queue.c **** 		{
1710:..\Source/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2218              		.loc 1 1710 0
 2219 001e FB68     		ldr	r3, [r7, #12]
 2220 0020 1B68     		ldr	r3, [r3]
 2221 0022 002B     		cmp	r3, #0
 2222 0024 4DD1     		bne	.L118
1711:..\Source/queue.c **** 			{
1712:..\Source/queue.c **** 				/* The mutex is no longer being held. */
1713:..\Source/queue.c **** 				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 2223              		.loc 1 1713 0
 2224 0026 FB68     		ldr	r3, [r7, #12]
 2225 0028 5B68     		ldr	r3, [r3, #4]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 75


 2226 002a 1846     		mov	r0, r3
 2227 002c FFF7FEFF 		bl	xTaskPriorityDisinherit
 2228 0030 7861     		str	r0, [r7, #20]
1714:..\Source/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 2229              		.loc 1 1714 0
 2230 0032 FB68     		ldr	r3, [r7, #12]
 2231 0034 0022     		movs	r2, #0
 2232 0036 5A60     		str	r2, [r3, #4]
 2233 0038 43E0     		b	.L118
 2234              	.L117:
1715:..\Source/queue.c **** 			}
1716:..\Source/queue.c **** 			else
1717:..\Source/queue.c **** 			{
1718:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1719:..\Source/queue.c **** 			}
1720:..\Source/queue.c **** 		}
1721:..\Source/queue.c **** 		#endif /* configUSE_MUTEXES */
1722:..\Source/queue.c **** 	}
1723:..\Source/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 2235              		.loc 1 1723 0
 2236 003a 7B68     		ldr	r3, [r7, #4]
 2237 003c 002B     		cmp	r3, #0
 2238 003e 19D1     		bne	.L119
1724:..\Source/queue.c **** 	{
1725:..\Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); 
 2239              		.loc 1 1725 0
 2240 0040 FB68     		ldr	r3, [r7, #12]
 2241 0042 9868     		ldr	r0, [r3, #8]
 2242 0044 FB68     		ldr	r3, [r7, #12]
 2243 0046 1B6C     		ldr	r3, [r3, #64]
 2244 0048 1A46     		mov	r2, r3
 2245 004a B968     		ldr	r1, [r7, #8]
 2246 004c FFF7FEFF 		bl	memcpy
1726:..\Source/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 2247              		.loc 1 1726 0
 2248 0050 FB68     		ldr	r3, [r7, #12]
 2249 0052 9A68     		ldr	r2, [r3, #8]
 2250 0054 FB68     		ldr	r3, [r7, #12]
 2251 0056 1B6C     		ldr	r3, [r3, #64]
 2252 0058 1A44     		add	r2, r2, r3
 2253 005a FB68     		ldr	r3, [r7, #12]
 2254 005c 9A60     		str	r2, [r3, #8]
1727:..\Source/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison 
 2255              		.loc 1 1727 0
 2256 005e FB68     		ldr	r3, [r7, #12]
 2257 0060 9A68     		ldr	r2, [r3, #8]
 2258 0062 FB68     		ldr	r3, [r7, #12]
 2259 0064 5B68     		ldr	r3, [r3, #4]
 2260 0066 9A42     		cmp	r2, r3
 2261 0068 2BD3     		bcc	.L118
1728:..\Source/queue.c **** 		{
1729:..\Source/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 2262              		.loc 1 1729 0
 2263 006a FB68     		ldr	r3, [r7, #12]
 2264 006c 1A68     		ldr	r2, [r3]
 2265 006e FB68     		ldr	r3, [r7, #12]
 2266 0070 9A60     		str	r2, [r3, #8]
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 76


 2267 0072 26E0     		b	.L118
 2268              	.L119:
1730:..\Source/queue.c **** 		}
1731:..\Source/queue.c **** 		else
1732:..\Source/queue.c **** 		{
1733:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1734:..\Source/queue.c **** 		}
1735:..\Source/queue.c **** 	}
1736:..\Source/queue.c **** 	else
1737:..\Source/queue.c **** 	{
1738:..\Source/queue.c **** 		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize 
 2269              		.loc 1 1738 0
 2270 0074 FB68     		ldr	r3, [r7, #12]
 2271 0076 D868     		ldr	r0, [r3, #12]
 2272 0078 FB68     		ldr	r3, [r7, #12]
 2273 007a 1B6C     		ldr	r3, [r3, #64]
 2274 007c 1A46     		mov	r2, r3
 2275 007e B968     		ldr	r1, [r7, #8]
 2276 0080 FFF7FEFF 		bl	memcpy
1739:..\Source/queue.c **** 		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 2277              		.loc 1 1739 0
 2278 0084 FB68     		ldr	r3, [r7, #12]
 2279 0086 DA68     		ldr	r2, [r3, #12]
 2280 0088 FB68     		ldr	r3, [r7, #12]
 2281 008a 1B6C     		ldr	r3, [r3, #64]
 2282 008c 5B42     		negs	r3, r3
 2283 008e 1A44     		add	r2, r2, r3
 2284 0090 FB68     		ldr	r3, [r7, #12]
 2285 0092 DA60     		str	r2, [r3, #12]
1740:..\Source/queue.c **** 		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as compariso
 2286              		.loc 1 1740 0
 2287 0094 FB68     		ldr	r3, [r7, #12]
 2288 0096 DA68     		ldr	r2, [r3, #12]
 2289 0098 FB68     		ldr	r3, [r7, #12]
 2290 009a 1B68     		ldr	r3, [r3]
 2291 009c 9A42     		cmp	r2, r3
 2292 009e 07D2     		bcs	.L120
1741:..\Source/queue.c **** 		{
1742:..\Source/queue.c **** 			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 2293              		.loc 1 1742 0
 2294 00a0 FB68     		ldr	r3, [r7, #12]
 2295 00a2 5A68     		ldr	r2, [r3, #4]
 2296 00a4 FB68     		ldr	r3, [r7, #12]
 2297 00a6 1B6C     		ldr	r3, [r3, #64]
 2298 00a8 5B42     		negs	r3, r3
 2299 00aa 1A44     		add	r2, r2, r3
 2300 00ac FB68     		ldr	r3, [r7, #12]
 2301 00ae DA60     		str	r2, [r3, #12]
 2302              	.L120:
1743:..\Source/queue.c **** 		}
1744:..\Source/queue.c **** 		else
1745:..\Source/queue.c **** 		{
1746:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1747:..\Source/queue.c **** 		}
1748:..\Source/queue.c **** 
1749:..\Source/queue.c **** 		if( xPosition == queueOVERWRITE )
 2303              		.loc 1 1749 0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 77


 2304 00b0 7B68     		ldr	r3, [r7, #4]
 2305 00b2 022B     		cmp	r3, #2
 2306 00b4 05D1     		bne	.L118
1750:..\Source/queue.c **** 		{
1751:..\Source/queue.c **** 			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2307              		.loc 1 1751 0
 2308 00b6 3B69     		ldr	r3, [r7, #16]
 2309 00b8 002B     		cmp	r3, #0
 2310 00ba 02D0     		beq	.L118
1752:..\Source/queue.c **** 			{
1753:..\Source/queue.c **** 				/* An item is not being added but overwritten, so subtract
1754:..\Source/queue.c **** 				one from the recorded number of items in the queue so when
1755:..\Source/queue.c **** 				one is added again below the number of recorded items remains
1756:..\Source/queue.c **** 				correct. */
1757:..\Source/queue.c **** 				--uxMessagesWaiting;
 2311              		.loc 1 1757 0
 2312 00bc 3B69     		ldr	r3, [r7, #16]
 2313 00be 013B     		subs	r3, r3, #1
 2314 00c0 3B61     		str	r3, [r7, #16]
 2315              	.L118:
1758:..\Source/queue.c **** 			}
1759:..\Source/queue.c **** 			else
1760:..\Source/queue.c **** 			{
1761:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
1762:..\Source/queue.c **** 			}
1763:..\Source/queue.c **** 		}
1764:..\Source/queue.c **** 		else
1765:..\Source/queue.c **** 		{
1766:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1767:..\Source/queue.c **** 		}
1768:..\Source/queue.c **** 	}
1769:..\Source/queue.c **** 
1770:..\Source/queue.c **** 	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 2316              		.loc 1 1770 0
 2317 00c2 3B69     		ldr	r3, [r7, #16]
 2318 00c4 5A1C     		adds	r2, r3, #1
 2319 00c6 FB68     		ldr	r3, [r7, #12]
 2320 00c8 9A63     		str	r2, [r3, #56]
1771:..\Source/queue.c **** 
1772:..\Source/queue.c **** 	return xReturn;
 2321              		.loc 1 1772 0
 2322 00ca 7B69     		ldr	r3, [r7, #20]
1773:..\Source/queue.c **** }
 2323              		.loc 1 1773 0
 2324 00cc 1846     		mov	r0, r3
 2325 00ce 1837     		adds	r7, r7, #24
 2326              		.cfi_def_cfa_offset 8
 2327 00d0 BD46     		mov	sp, r7
 2328              		.cfi_def_cfa_register 13
 2329              		@ sp needed
 2330 00d2 80BD     		pop	{r7, pc}
 2331              		.cfi_endproc
 2332              	.LFE89:
 2333              		.size	prvCopyDataToQueue, .-prvCopyDataToQueue
 2334              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 2335              		.align	2
 2336              		.thumb
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 78


 2337              		.thumb_func
 2338              		.type	prvCopyDataFromQueue, %function
 2339              	prvCopyDataFromQueue:
 2340              	.LFB90:
1774:..\Source/queue.c **** /*-----------------------------------------------------------*/
1775:..\Source/queue.c **** 
1776:..\Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1777:..\Source/queue.c **** {
 2341              		.loc 1 1777 0
 2342              		.cfi_startproc
 2343              		@ args = 0, pretend = 0, frame = 8
 2344              		@ frame_needed = 1, uses_anonymous_args = 0
 2345 0000 80B5     		push	{r7, lr}
 2346              		.cfi_def_cfa_offset 8
 2347              		.cfi_offset 7, -8
 2348              		.cfi_offset 14, -4
 2349 0002 82B0     		sub	sp, sp, #8
 2350              		.cfi_def_cfa_offset 16
 2351 0004 00AF     		add	r7, sp, #0
 2352              		.cfi_def_cfa_register 7
 2353 0006 7860     		str	r0, [r7, #4]
 2354 0008 3960     		str	r1, [r7]
1778:..\Source/queue.c **** 	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 2355              		.loc 1 1778 0
 2356 000a 7B68     		ldr	r3, [r7, #4]
 2357 000c 1B6C     		ldr	r3, [r3, #64]
 2358 000e 002B     		cmp	r3, #0
 2359 0010 18D0     		beq	.L125
1779:..\Source/queue.c **** 	{
1780:..\Source/queue.c **** 		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 2360              		.loc 1 1780 0
 2361 0012 7B68     		ldr	r3, [r7, #4]
 2362 0014 DA68     		ldr	r2, [r3, #12]
 2363 0016 7B68     		ldr	r3, [r7, #4]
 2364 0018 1B6C     		ldr	r3, [r3, #64]
 2365 001a 1A44     		add	r2, r2, r3
 2366 001c 7B68     		ldr	r3, [r7, #4]
 2367 001e DA60     		str	r2, [r3, #12]
1781:..\Source/queue.c **** 		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of t
 2368              		.loc 1 1781 0
 2369 0020 7B68     		ldr	r3, [r7, #4]
 2370 0022 DA68     		ldr	r2, [r3, #12]
 2371 0024 7B68     		ldr	r3, [r7, #4]
 2372 0026 5B68     		ldr	r3, [r3, #4]
 2373 0028 9A42     		cmp	r2, r3
 2374 002a 03D3     		bcc	.L124
1782:..\Source/queue.c **** 		{
1783:..\Source/queue.c **** 			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 2375              		.loc 1 1783 0
 2376 002c 7B68     		ldr	r3, [r7, #4]
 2377 002e 1A68     		ldr	r2, [r3]
 2378 0030 7B68     		ldr	r3, [r7, #4]
 2379 0032 DA60     		str	r2, [r3, #12]
 2380              	.L124:
1784:..\Source/queue.c **** 		}
1785:..\Source/queue.c **** 		else
1786:..\Source/queue.c **** 		{
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 79


1787:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
1788:..\Source/queue.c **** 		}
1789:..\Source/queue.c **** 		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxIte
 2381              		.loc 1 1789 0
 2382 0034 7B68     		ldr	r3, [r7, #4]
 2383 0036 D968     		ldr	r1, [r3, #12]
 2384 0038 7B68     		ldr	r3, [r7, #4]
 2385 003a 1B6C     		ldr	r3, [r3, #64]
 2386 003c 1A46     		mov	r2, r3
 2387 003e 3868     		ldr	r0, [r7]
 2388 0040 FFF7FEFF 		bl	memcpy
 2389              	.L125:
1790:..\Source/queue.c **** 	}
1791:..\Source/queue.c **** }
 2390              		.loc 1 1791 0
 2391 0044 00BF     		nop
 2392 0046 0837     		adds	r7, r7, #8
 2393              		.cfi_def_cfa_offset 8
 2394 0048 BD46     		mov	sp, r7
 2395              		.cfi_def_cfa_register 13
 2396              		@ sp needed
 2397 004a 80BD     		pop	{r7, pc}
 2398              		.cfi_endproc
 2399              	.LFE90:
 2400              		.size	prvCopyDataFromQueue, .-prvCopyDataFromQueue
 2401              		.section	.text.prvUnlockQueue,"ax",%progbits
 2402              		.align	2
 2403              		.thumb
 2404              		.thumb_func
 2405              		.type	prvUnlockQueue, %function
 2406              	prvUnlockQueue:
 2407              	.LFB91:
1792:..\Source/queue.c **** /*-----------------------------------------------------------*/
1793:..\Source/queue.c **** 
1794:..\Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
1795:..\Source/queue.c **** {
 2408              		.loc 1 1795 0
 2409              		.cfi_startproc
 2410              		@ args = 0, pretend = 0, frame = 16
 2411              		@ frame_needed = 1, uses_anonymous_args = 0
 2412 0000 80B5     		push	{r7, lr}
 2413              		.cfi_def_cfa_offset 8
 2414              		.cfi_offset 7, -8
 2415              		.cfi_offset 14, -4
 2416 0002 84B0     		sub	sp, sp, #16
 2417              		.cfi_def_cfa_offset 24
 2418 0004 00AF     		add	r7, sp, #0
 2419              		.cfi_def_cfa_register 7
 2420 0006 7860     		str	r0, [r7, #4]
1796:..\Source/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1797:..\Source/queue.c **** 
1798:..\Source/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1799:..\Source/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1800:..\Source/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1801:..\Source/queue.c **** 	updated. */
1802:..\Source/queue.c **** 	taskENTER_CRITICAL();
 2421              		.loc 1 1802 0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 80


 2422 0008 FFF7FEFF 		bl	vPortEnterCritical
 2423              	.LBB45:
1803:..\Source/queue.c **** 	{
1804:..\Source/queue.c **** 		int8_t cTxLock = pxQueue->cTxLock;
 2424              		.loc 1 1804 0
 2425 000c 7B68     		ldr	r3, [r7, #4]
 2426 000e 93F84530 		ldrb	r3, [r3, #69]
 2427 0012 FB73     		strb	r3, [r7, #15]
1805:..\Source/queue.c **** 
1806:..\Source/queue.c **** 		/* See if data was added to the queue while it was locked. */
1807:..\Source/queue.c **** 		while( cTxLock > queueLOCKED_UNMODIFIED )
 2428              		.loc 1 1807 0
 2429 0014 11E0     		b	.L127
 2430              	.L131:
1808:..\Source/queue.c **** 		{
1809:..\Source/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1810:..\Source/queue.c **** 			blocked waiting for data to become available? */
1811:..\Source/queue.c **** 			#if ( configUSE_QUEUE_SETS == 1 )
1812:..\Source/queue.c **** 			{
1813:..\Source/queue.c **** 				if( pxQueue->pxQueueSetContainer != NULL )
1814:..\Source/queue.c **** 				{
1815:..\Source/queue.c **** 					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
1816:..\Source/queue.c **** 					{
1817:..\Source/queue.c **** 						/* The queue is a member of a queue set, and posting to
1818:..\Source/queue.c **** 						the queue set caused a higher priority task to unblock.
1819:..\Source/queue.c **** 						A context switch is required. */
1820:..\Source/queue.c **** 						vTaskMissedYield();
1821:..\Source/queue.c **** 					}
1822:..\Source/queue.c **** 					else
1823:..\Source/queue.c **** 					{
1824:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1825:..\Source/queue.c **** 					}
1826:..\Source/queue.c **** 				}
1827:..\Source/queue.c **** 				else
1828:..\Source/queue.c **** 				{
1829:..\Source/queue.c **** 					/* Tasks that are removed from the event list will get
1830:..\Source/queue.c **** 					added to the pending ready list as the scheduler is still
1831:..\Source/queue.c **** 					suspended. */
1832:..\Source/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1833:..\Source/queue.c **** 					{
1834:..\Source/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1835:..\Source/queue.c **** 						{
1836:..\Source/queue.c **** 							/* The task waiting has a higher priority so record that a
1837:..\Source/queue.c **** 							context	switch is required. */
1838:..\Source/queue.c **** 							vTaskMissedYield();
1839:..\Source/queue.c **** 						}
1840:..\Source/queue.c **** 						else
1841:..\Source/queue.c **** 						{
1842:..\Source/queue.c **** 							mtCOVERAGE_TEST_MARKER();
1843:..\Source/queue.c **** 						}
1844:..\Source/queue.c **** 					}
1845:..\Source/queue.c **** 					else
1846:..\Source/queue.c **** 					{
1847:..\Source/queue.c **** 						break;
1848:..\Source/queue.c **** 					}
1849:..\Source/queue.c **** 				}
1850:..\Source/queue.c **** 			}
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 81


1851:..\Source/queue.c **** 			#else /* configUSE_QUEUE_SETS */
1852:..\Source/queue.c **** 			{
1853:..\Source/queue.c **** 				/* Tasks that are removed from the event list will get added to
1854:..\Source/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1855:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2431              		.loc 1 1855 0
 2432 0016 7B68     		ldr	r3, [r7, #4]
 2433 0018 5B6A     		ldr	r3, [r3, #36]
 2434 001a 002B     		cmp	r3, #0
 2435 001c 12D0     		beq	.L137
1856:..\Source/queue.c **** 				{
1857:..\Source/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 2436              		.loc 1 1857 0
 2437 001e 7B68     		ldr	r3, [r7, #4]
 2438 0020 2433     		adds	r3, r3, #36
 2439 0022 1846     		mov	r0, r3
 2440 0024 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2441 0028 0346     		mov	r3, r0
 2442 002a 002B     		cmp	r3, #0
 2443 002c 01D0     		beq	.L129
1858:..\Source/queue.c **** 					{
1859:..\Source/queue.c **** 						/* The task waiting has a higher priority so record that
1860:..\Source/queue.c **** 						a context switch is required. */
1861:..\Source/queue.c **** 						vTaskMissedYield();
 2444              		.loc 1 1861 0
 2445 002e FFF7FEFF 		bl	vTaskMissedYield
 2446              	.L129:
1862:..\Source/queue.c **** 					}
1863:..\Source/queue.c **** 					else
1864:..\Source/queue.c **** 					{
1865:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
1866:..\Source/queue.c **** 					}
1867:..\Source/queue.c **** 				}
1868:..\Source/queue.c **** 				else
1869:..\Source/queue.c **** 				{
1870:..\Source/queue.c **** 					break;
1871:..\Source/queue.c **** 				}
1872:..\Source/queue.c **** 			}
1873:..\Source/queue.c **** 			#endif /* configUSE_QUEUE_SETS */
1874:..\Source/queue.c **** 
1875:..\Source/queue.c **** 			--cTxLock;
 2447              		.loc 1 1875 0
 2448 0032 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2449 0034 013B     		subs	r3, r3, #1
 2450 0036 DBB2     		uxtb	r3, r3
 2451 0038 FB73     		strb	r3, [r7, #15]
 2452              	.L127:
1807:..\Source/queue.c **** 		{
 2453              		.loc 1 1807 0
 2454 003a 97F90F30 		ldrsb	r3, [r7, #15]
 2455 003e 002B     		cmp	r3, #0
 2456 0040 E9DC     		bgt	.L131
 2457 0042 00E0     		b	.L130
 2458              	.L137:
1870:..\Source/queue.c **** 				}
 2459              		.loc 1 1870 0
 2460 0044 00BF     		nop
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 82


 2461              	.L130:
1876:..\Source/queue.c **** 		}
1877:..\Source/queue.c **** 
1878:..\Source/queue.c **** 		pxQueue->cTxLock = queueUNLOCKED;
 2462              		.loc 1 1878 0
 2463 0046 7B68     		ldr	r3, [r7, #4]
 2464 0048 FF22     		movs	r2, #255
 2465 004a 83F84520 		strb	r2, [r3, #69]
 2466              	.LBE45:
1879:..\Source/queue.c **** 	}
1880:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 2467              		.loc 1 1880 0
 2468 004e FFF7FEFF 		bl	vPortExitCritical
1881:..\Source/queue.c **** 
1882:..\Source/queue.c **** 	/* Do the same for the Rx lock. */
1883:..\Source/queue.c **** 	taskENTER_CRITICAL();
 2469              		.loc 1 1883 0
 2470 0052 FFF7FEFF 		bl	vPortEnterCritical
 2471              	.LBB46:
1884:..\Source/queue.c **** 	{
1885:..\Source/queue.c **** 		int8_t cRxLock = pxQueue->cRxLock;
 2472              		.loc 1 1885 0
 2473 0056 7B68     		ldr	r3, [r7, #4]
 2474 0058 93F84430 		ldrb	r3, [r3, #68]
 2475 005c BB73     		strb	r3, [r7, #14]
1886:..\Source/queue.c **** 
1887:..\Source/queue.c **** 		while( cRxLock > queueLOCKED_UNMODIFIED )
 2476              		.loc 1 1887 0
 2477 005e 11E0     		b	.L132
 2478              	.L136:
1888:..\Source/queue.c **** 		{
1889:..\Source/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2479              		.loc 1 1889 0
 2480 0060 7B68     		ldr	r3, [r7, #4]
 2481 0062 1B69     		ldr	r3, [r3, #16]
 2482 0064 002B     		cmp	r3, #0
 2483 0066 12D0     		beq	.L138
1890:..\Source/queue.c **** 			{
1891:..\Source/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2484              		.loc 1 1891 0
 2485 0068 7B68     		ldr	r3, [r7, #4]
 2486 006a 1033     		adds	r3, r3, #16
 2487 006c 1846     		mov	r0, r3
 2488 006e FFF7FEFF 		bl	xTaskRemoveFromEventList
 2489 0072 0346     		mov	r3, r0
 2490 0074 002B     		cmp	r3, #0
 2491 0076 01D0     		beq	.L134
1892:..\Source/queue.c **** 				{
1893:..\Source/queue.c **** 					vTaskMissedYield();
 2492              		.loc 1 1893 0
 2493 0078 FFF7FEFF 		bl	vTaskMissedYield
 2494              	.L134:
1894:..\Source/queue.c **** 				}
1895:..\Source/queue.c **** 				else
1896:..\Source/queue.c **** 				{
1897:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
1898:..\Source/queue.c **** 				}
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 83


1899:..\Source/queue.c **** 
1900:..\Source/queue.c **** 				--cRxLock;
 2495              		.loc 1 1900 0
 2496 007c BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 2497 007e 013B     		subs	r3, r3, #1
 2498 0080 DBB2     		uxtb	r3, r3
 2499 0082 BB73     		strb	r3, [r7, #14]
 2500              	.L132:
1887:..\Source/queue.c **** 		{
 2501              		.loc 1 1887 0
 2502 0084 97F90E30 		ldrsb	r3, [r7, #14]
 2503 0088 002B     		cmp	r3, #0
 2504 008a E9DC     		bgt	.L136
 2505 008c 00E0     		b	.L135
 2506              	.L138:
1901:..\Source/queue.c **** 			}
1902:..\Source/queue.c **** 			else
1903:..\Source/queue.c **** 			{
1904:..\Source/queue.c **** 				break;
 2507              		.loc 1 1904 0
 2508 008e 00BF     		nop
 2509              	.L135:
1905:..\Source/queue.c **** 			}
1906:..\Source/queue.c **** 		}
1907:..\Source/queue.c **** 
1908:..\Source/queue.c **** 		pxQueue->cRxLock = queueUNLOCKED;
 2510              		.loc 1 1908 0
 2511 0090 7B68     		ldr	r3, [r7, #4]
 2512 0092 FF22     		movs	r2, #255
 2513 0094 83F84420 		strb	r2, [r3, #68]
 2514              	.LBE46:
1909:..\Source/queue.c **** 	}
1910:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 2515              		.loc 1 1910 0
 2516 0098 FFF7FEFF 		bl	vPortExitCritical
1911:..\Source/queue.c **** }
 2517              		.loc 1 1911 0
 2518 009c 00BF     		nop
 2519 009e 1037     		adds	r7, r7, #16
 2520              		.cfi_def_cfa_offset 8
 2521 00a0 BD46     		mov	sp, r7
 2522              		.cfi_def_cfa_register 13
 2523              		@ sp needed
 2524 00a2 80BD     		pop	{r7, pc}
 2525              		.cfi_endproc
 2526              	.LFE91:
 2527              		.size	prvUnlockQueue, .-prvUnlockQueue
 2528              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 2529              		.align	2
 2530              		.thumb
 2531              		.thumb_func
 2532              		.type	prvIsQueueEmpty, %function
 2533              	prvIsQueueEmpty:
 2534              	.LFB92:
1912:..\Source/queue.c **** /*-----------------------------------------------------------*/
1913:..\Source/queue.c **** 
1914:..\Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 84


1915:..\Source/queue.c **** {
 2535              		.loc 1 1915 0
 2536              		.cfi_startproc
 2537              		@ args = 0, pretend = 0, frame = 16
 2538              		@ frame_needed = 1, uses_anonymous_args = 0
 2539 0000 80B5     		push	{r7, lr}
 2540              		.cfi_def_cfa_offset 8
 2541              		.cfi_offset 7, -8
 2542              		.cfi_offset 14, -4
 2543 0002 84B0     		sub	sp, sp, #16
 2544              		.cfi_def_cfa_offset 24
 2545 0004 00AF     		add	r7, sp, #0
 2546              		.cfi_def_cfa_register 7
 2547 0006 7860     		str	r0, [r7, #4]
1916:..\Source/queue.c **** BaseType_t xReturn;
1917:..\Source/queue.c **** 
1918:..\Source/queue.c **** 	taskENTER_CRITICAL();
 2548              		.loc 1 1918 0
 2549 0008 FFF7FEFF 		bl	vPortEnterCritical
1919:..\Source/queue.c **** 	{
1920:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 2550              		.loc 1 1920 0
 2551 000c 7B68     		ldr	r3, [r7, #4]
 2552 000e 9B6B     		ldr	r3, [r3, #56]
 2553 0010 002B     		cmp	r3, #0
 2554 0012 02D1     		bne	.L140
1921:..\Source/queue.c **** 		{
1922:..\Source/queue.c **** 			xReturn = pdTRUE;
 2555              		.loc 1 1922 0
 2556 0014 0123     		movs	r3, #1
 2557 0016 FB60     		str	r3, [r7, #12]
 2558 0018 01E0     		b	.L141
 2559              	.L140:
1923:..\Source/queue.c **** 		}
1924:..\Source/queue.c **** 		else
1925:..\Source/queue.c **** 		{
1926:..\Source/queue.c **** 			xReturn = pdFALSE;
 2560              		.loc 1 1926 0
 2561 001a 0023     		movs	r3, #0
 2562 001c FB60     		str	r3, [r7, #12]
 2563              	.L141:
1927:..\Source/queue.c **** 		}
1928:..\Source/queue.c **** 	}
1929:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 2564              		.loc 1 1929 0
 2565 001e FFF7FEFF 		bl	vPortExitCritical
1930:..\Source/queue.c **** 
1931:..\Source/queue.c **** 	return xReturn;
 2566              		.loc 1 1931 0
 2567 0022 FB68     		ldr	r3, [r7, #12]
1932:..\Source/queue.c **** }
 2568              		.loc 1 1932 0
 2569 0024 1846     		mov	r0, r3
 2570 0026 1037     		adds	r7, r7, #16
 2571              		.cfi_def_cfa_offset 8
 2572 0028 BD46     		mov	sp, r7
 2573              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 85


 2574              		@ sp needed
 2575 002a 80BD     		pop	{r7, pc}
 2576              		.cfi_endproc
 2577              	.LFE92:
 2578              		.size	prvIsQueueEmpty, .-prvIsQueueEmpty
 2579              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 2580              		.align	2
 2581              		.global	xQueueIsQueueEmptyFromISR
 2582              		.thumb
 2583              		.thumb_func
 2584              		.type	xQueueIsQueueEmptyFromISR, %function
 2585              	xQueueIsQueueEmptyFromISR:
 2586              	.LFB93:
1933:..\Source/queue.c **** /*-----------------------------------------------------------*/
1934:..\Source/queue.c **** 
1935:..\Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1936:..\Source/queue.c **** {
 2587              		.loc 1 1936 0
 2588              		.cfi_startproc
 2589              		@ args = 0, pretend = 0, frame = 16
 2590              		@ frame_needed = 1, uses_anonymous_args = 0
 2591              		@ link register save eliminated.
 2592 0000 80B4     		push	{r7}
 2593              		.cfi_def_cfa_offset 4
 2594              		.cfi_offset 7, -4
 2595 0002 85B0     		sub	sp, sp, #20
 2596              		.cfi_def_cfa_offset 24
 2597 0004 00AF     		add	r7, sp, #0
 2598              		.cfi_def_cfa_register 7
 2599 0006 7860     		str	r0, [r7, #4]
1937:..\Source/queue.c **** BaseType_t xReturn;
1938:..\Source/queue.c **** 
1939:..\Source/queue.c **** 	configASSERT( xQueue );
1940:..\Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 2600              		.loc 1 1940 0
 2601 0008 7B68     		ldr	r3, [r7, #4]
 2602 000a 9B6B     		ldr	r3, [r3, #56]
 2603 000c 002B     		cmp	r3, #0
 2604 000e 02D1     		bne	.L144
1941:..\Source/queue.c **** 	{
1942:..\Source/queue.c **** 		xReturn = pdTRUE;
 2605              		.loc 1 1942 0
 2606 0010 0123     		movs	r3, #1
 2607 0012 FB60     		str	r3, [r7, #12]
 2608 0014 01E0     		b	.L145
 2609              	.L144:
1943:..\Source/queue.c **** 	}
1944:..\Source/queue.c **** 	else
1945:..\Source/queue.c **** 	{
1946:..\Source/queue.c **** 		xReturn = pdFALSE;
 2610              		.loc 1 1946 0
 2611 0016 0023     		movs	r3, #0
 2612 0018 FB60     		str	r3, [r7, #12]
 2613              	.L145:
1947:..\Source/queue.c **** 	}
1948:..\Source/queue.c **** 
1949:..\Source/queue.c **** 	return xReturn;
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 86


 2614              		.loc 1 1949 0
 2615 001a FB68     		ldr	r3, [r7, #12]
1950:..\Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2616              		.loc 1 1950 0
 2617 001c 1846     		mov	r0, r3
 2618 001e 1437     		adds	r7, r7, #20
 2619              		.cfi_def_cfa_offset 4
 2620 0020 BD46     		mov	sp, r7
 2621              		.cfi_def_cfa_register 13
 2622              		@ sp needed
 2623 0022 80BC     		pop	{r7}
 2624              		.cfi_restore 7
 2625              		.cfi_def_cfa_offset 0
 2626 0024 7047     		bx	lr
 2627              		.cfi_endproc
 2628              	.LFE93:
 2629              		.size	xQueueIsQueueEmptyFromISR, .-xQueueIsQueueEmptyFromISR
 2630 0026 00BF     		.section	.text.prvIsQueueFull,"ax",%progbits
 2631              		.align	2
 2632              		.thumb
 2633              		.thumb_func
 2634              		.type	prvIsQueueFull, %function
 2635              	prvIsQueueFull:
 2636              	.LFB94:
1951:..\Source/queue.c **** /*-----------------------------------------------------------*/
1952:..\Source/queue.c **** 
1953:..\Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1954:..\Source/queue.c **** {
 2637              		.loc 1 1954 0
 2638              		.cfi_startproc
 2639              		@ args = 0, pretend = 0, frame = 16
 2640              		@ frame_needed = 1, uses_anonymous_args = 0
 2641 0000 80B5     		push	{r7, lr}
 2642              		.cfi_def_cfa_offset 8
 2643              		.cfi_offset 7, -8
 2644              		.cfi_offset 14, -4
 2645 0002 84B0     		sub	sp, sp, #16
 2646              		.cfi_def_cfa_offset 24
 2647 0004 00AF     		add	r7, sp, #0
 2648              		.cfi_def_cfa_register 7
 2649 0006 7860     		str	r0, [r7, #4]
1955:..\Source/queue.c **** BaseType_t xReturn;
1956:..\Source/queue.c **** 
1957:..\Source/queue.c **** 	taskENTER_CRITICAL();
 2650              		.loc 1 1957 0
 2651 0008 FFF7FEFF 		bl	vPortEnterCritical
1958:..\Source/queue.c **** 	{
1959:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 2652              		.loc 1 1959 0
 2653 000c 7B68     		ldr	r3, [r7, #4]
 2654 000e 9A6B     		ldr	r2, [r3, #56]
 2655 0010 7B68     		ldr	r3, [r7, #4]
 2656 0012 DB6B     		ldr	r3, [r3, #60]
 2657 0014 9A42     		cmp	r2, r3
 2658 0016 02D1     		bne	.L148
1960:..\Source/queue.c **** 		{
1961:..\Source/queue.c **** 			xReturn = pdTRUE;
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 87


 2659              		.loc 1 1961 0
 2660 0018 0123     		movs	r3, #1
 2661 001a FB60     		str	r3, [r7, #12]
 2662 001c 01E0     		b	.L149
 2663              	.L148:
1962:..\Source/queue.c **** 		}
1963:..\Source/queue.c **** 		else
1964:..\Source/queue.c **** 		{
1965:..\Source/queue.c **** 			xReturn = pdFALSE;
 2664              		.loc 1 1965 0
 2665 001e 0023     		movs	r3, #0
 2666 0020 FB60     		str	r3, [r7, #12]
 2667              	.L149:
1966:..\Source/queue.c **** 		}
1967:..\Source/queue.c **** 	}
1968:..\Source/queue.c **** 	taskEXIT_CRITICAL();
 2668              		.loc 1 1968 0
 2669 0022 FFF7FEFF 		bl	vPortExitCritical
1969:..\Source/queue.c **** 
1970:..\Source/queue.c **** 	return xReturn;
 2670              		.loc 1 1970 0
 2671 0026 FB68     		ldr	r3, [r7, #12]
1971:..\Source/queue.c **** }
 2672              		.loc 1 1971 0
 2673 0028 1846     		mov	r0, r3
 2674 002a 1037     		adds	r7, r7, #16
 2675              		.cfi_def_cfa_offset 8
 2676 002c BD46     		mov	sp, r7
 2677              		.cfi_def_cfa_register 13
 2678              		@ sp needed
 2679 002e 80BD     		pop	{r7, pc}
 2680              		.cfi_endproc
 2681              	.LFE94:
 2682              		.size	prvIsQueueFull, .-prvIsQueueFull
 2683              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 2684              		.align	2
 2685              		.global	xQueueIsQueueFullFromISR
 2686              		.thumb
 2687              		.thumb_func
 2688              		.type	xQueueIsQueueFullFromISR, %function
 2689              	xQueueIsQueueFullFromISR:
 2690              	.LFB95:
1972:..\Source/queue.c **** /*-----------------------------------------------------------*/
1973:..\Source/queue.c **** 
1974:..\Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1975:..\Source/queue.c **** {
 2691              		.loc 1 1975 0
 2692              		.cfi_startproc
 2693              		@ args = 0, pretend = 0, frame = 16
 2694              		@ frame_needed = 1, uses_anonymous_args = 0
 2695              		@ link register save eliminated.
 2696 0000 80B4     		push	{r7}
 2697              		.cfi_def_cfa_offset 4
 2698              		.cfi_offset 7, -4
 2699 0002 85B0     		sub	sp, sp, #20
 2700              		.cfi_def_cfa_offset 24
 2701 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 88


 2702              		.cfi_def_cfa_register 7
 2703 0006 7860     		str	r0, [r7, #4]
1976:..\Source/queue.c **** BaseType_t xReturn;
1977:..\Source/queue.c **** 
1978:..\Source/queue.c **** 	configASSERT( xQueue );
1979:..\Source/queue.c **** 	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 2704              		.loc 1 1979 0
 2705 0008 7B68     		ldr	r3, [r7, #4]
 2706 000a 9A6B     		ldr	r2, [r3, #56]
 2707 000c 7B68     		ldr	r3, [r7, #4]
 2708 000e DB6B     		ldr	r3, [r3, #60]
 2709 0010 9A42     		cmp	r2, r3
 2710 0012 02D1     		bne	.L152
1980:..\Source/queue.c **** 	{
1981:..\Source/queue.c **** 		xReturn = pdTRUE;
 2711              		.loc 1 1981 0
 2712 0014 0123     		movs	r3, #1
 2713 0016 FB60     		str	r3, [r7, #12]
 2714 0018 01E0     		b	.L153
 2715              	.L152:
1982:..\Source/queue.c **** 	}
1983:..\Source/queue.c **** 	else
1984:..\Source/queue.c **** 	{
1985:..\Source/queue.c **** 		xReturn = pdFALSE;
 2716              		.loc 1 1985 0
 2717 001a 0023     		movs	r3, #0
 2718 001c FB60     		str	r3, [r7, #12]
 2719              	.L153:
1986:..\Source/queue.c **** 	}
1987:..\Source/queue.c **** 
1988:..\Source/queue.c **** 	return xReturn;
 2720              		.loc 1 1988 0
 2721 001e FB68     		ldr	r3, [r7, #12]
1989:..\Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2722              		.loc 1 1989 0
 2723 0020 1846     		mov	r0, r3
 2724 0022 1437     		adds	r7, r7, #20
 2725              		.cfi_def_cfa_offset 4
 2726 0024 BD46     		mov	sp, r7
 2727              		.cfi_def_cfa_register 13
 2728              		@ sp needed
 2729 0026 80BC     		pop	{r7}
 2730              		.cfi_restore 7
 2731              		.cfi_def_cfa_offset 0
 2732 0028 7047     		bx	lr
 2733              		.cfi_endproc
 2734              	.LFE95:
 2735              		.size	xQueueIsQueueFullFromISR, .-xQueueIsQueueFullFromISR
 2736 002a 00BF     		.section	.text.vQueueAddToRegistry,"ax",%progbits
 2737              		.align	2
 2738              		.global	vQueueAddToRegistry
 2739              		.thumb
 2740              		.thumb_func
 2741              		.type	vQueueAddToRegistry, %function
 2742              	vQueueAddToRegistry:
 2743              	.LFB96:
1990:..\Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 89


1991:..\Source/queue.c **** 
1992:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
1993:..\Source/queue.c **** 
1994:..\Source/queue.c **** 	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait 
1995:..\Source/queue.c **** 	{
1996:..\Source/queue.c **** 	BaseType_t xReturn;
1997:..\Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1998:..\Source/queue.c **** 
1999:..\Source/queue.c **** 		/* If the queue is already full we may have to block.  A critical section
2000:..\Source/queue.c **** 		is required to prevent an interrupt removing something from the queue
2001:..\Source/queue.c **** 		between the check to see if the queue is full and blocking on the queue. */
2002:..\Source/queue.c **** 		portDISABLE_INTERRUPTS();
2003:..\Source/queue.c **** 		{
2004:..\Source/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
2005:..\Source/queue.c **** 			{
2006:..\Source/queue.c **** 				/* The queue is full - do we want to block or just leave without
2007:..\Source/queue.c **** 				posting? */
2008:..\Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2009:..\Source/queue.c **** 				{
2010:..\Source/queue.c **** 					/* As this is called from a coroutine we cannot block directly, but
2011:..\Source/queue.c **** 					return indicating that we need to block. */
2012:..\Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2013:..\Source/queue.c **** 					portENABLE_INTERRUPTS();
2014:..\Source/queue.c **** 					return errQUEUE_BLOCKED;
2015:..\Source/queue.c **** 				}
2016:..\Source/queue.c **** 				else
2017:..\Source/queue.c **** 				{
2018:..\Source/queue.c **** 					portENABLE_INTERRUPTS();
2019:..\Source/queue.c **** 					return errQUEUE_FULL;
2020:..\Source/queue.c **** 				}
2021:..\Source/queue.c **** 			}
2022:..\Source/queue.c **** 		}
2023:..\Source/queue.c **** 		portENABLE_INTERRUPTS();
2024:..\Source/queue.c **** 
2025:..\Source/queue.c **** 		portDISABLE_INTERRUPTS();
2026:..\Source/queue.c **** 		{
2027:..\Source/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2028:..\Source/queue.c **** 			{
2029:..\Source/queue.c **** 				/* There is room in the queue, copy the data into the queue. */
2030:..\Source/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2031:..\Source/queue.c **** 				xReturn = pdPASS;
2032:..\Source/queue.c **** 
2033:..\Source/queue.c **** 				/* Were any co-routines waiting for data to become available? */
2034:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2035:..\Source/queue.c **** 				{
2036:..\Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2037:..\Source/queue.c **** 					into the ready list as we are within a critical section.
2038:..\Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2039:..\Source/queue.c **** 					the event were caused from within an interrupt. */
2040:..\Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2041:..\Source/queue.c **** 					{
2042:..\Source/queue.c **** 						/* The co-routine waiting has a higher priority so record
2043:..\Source/queue.c **** 						that a yield might be appropriate. */
2044:..\Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2045:..\Source/queue.c **** 					}
2046:..\Source/queue.c **** 					else
2047:..\Source/queue.c **** 					{
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 90


2048:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2049:..\Source/queue.c **** 					}
2050:..\Source/queue.c **** 				}
2051:..\Source/queue.c **** 				else
2052:..\Source/queue.c **** 				{
2053:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2054:..\Source/queue.c **** 				}
2055:..\Source/queue.c **** 			}
2056:..\Source/queue.c **** 			else
2057:..\Source/queue.c **** 			{
2058:..\Source/queue.c **** 				xReturn = errQUEUE_FULL;
2059:..\Source/queue.c **** 			}
2060:..\Source/queue.c **** 		}
2061:..\Source/queue.c **** 		portENABLE_INTERRUPTS();
2062:..\Source/queue.c **** 
2063:..\Source/queue.c **** 		return xReturn;
2064:..\Source/queue.c **** 	}
2065:..\Source/queue.c **** 
2066:..\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2067:..\Source/queue.c **** /*-----------------------------------------------------------*/
2068:..\Source/queue.c **** 
2069:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2070:..\Source/queue.c **** 
2071:..\Source/queue.c **** 	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
2072:..\Source/queue.c **** 	{
2073:..\Source/queue.c **** 	BaseType_t xReturn;
2074:..\Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2075:..\Source/queue.c **** 
2076:..\Source/queue.c **** 		/* If the queue is already empty we may have to block.  A critical section
2077:..\Source/queue.c **** 		is required to prevent an interrupt adding something to the queue
2078:..\Source/queue.c **** 		between the check to see if the queue is empty and blocking on the queue. */
2079:..\Source/queue.c **** 		portDISABLE_INTERRUPTS();
2080:..\Source/queue.c **** 		{
2081:..\Source/queue.c **** 			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2082:..\Source/queue.c **** 			{
2083:..\Source/queue.c **** 				/* There are no messages in the queue, do we want to block or just
2084:..\Source/queue.c **** 				leave with nothing? */
2085:..\Source/queue.c **** 				if( xTicksToWait > ( TickType_t ) 0 )
2086:..\Source/queue.c **** 				{
2087:..\Source/queue.c **** 					/* As this is a co-routine we cannot block directly, but return
2088:..\Source/queue.c **** 					indicating that we need to block. */
2089:..\Source/queue.c **** 					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
2090:..\Source/queue.c **** 					portENABLE_INTERRUPTS();
2091:..\Source/queue.c **** 					return errQUEUE_BLOCKED;
2092:..\Source/queue.c **** 				}
2093:..\Source/queue.c **** 				else
2094:..\Source/queue.c **** 				{
2095:..\Source/queue.c **** 					portENABLE_INTERRUPTS();
2096:..\Source/queue.c **** 					return errQUEUE_FULL;
2097:..\Source/queue.c **** 				}
2098:..\Source/queue.c **** 			}
2099:..\Source/queue.c **** 			else
2100:..\Source/queue.c **** 			{
2101:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2102:..\Source/queue.c **** 			}
2103:..\Source/queue.c **** 		}
2104:..\Source/queue.c **** 		portENABLE_INTERRUPTS();
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 91


2105:..\Source/queue.c **** 
2106:..\Source/queue.c **** 		portDISABLE_INTERRUPTS();
2107:..\Source/queue.c **** 		{
2108:..\Source/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2109:..\Source/queue.c **** 			{
2110:..\Source/queue.c **** 				/* Data is available from the queue. */
2111:..\Source/queue.c **** 				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2112:..\Source/queue.c **** 				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2113:..\Source/queue.c **** 				{
2114:..\Source/queue.c **** 					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2115:..\Source/queue.c **** 				}
2116:..\Source/queue.c **** 				else
2117:..\Source/queue.c **** 				{
2118:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2119:..\Source/queue.c **** 				}
2120:..\Source/queue.c **** 				--( pxQueue->uxMessagesWaiting );
2121:..\Source/queue.c **** 				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->u
2122:..\Source/queue.c **** 
2123:..\Source/queue.c **** 				xReturn = pdPASS;
2124:..\Source/queue.c **** 
2125:..\Source/queue.c **** 				/* Were any co-routines waiting for space to become available? */
2126:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2127:..\Source/queue.c **** 				{
2128:..\Source/queue.c **** 					/* In this instance the co-routine could be placed directly
2129:..\Source/queue.c **** 					into the ready list as we are within a critical section.
2130:..\Source/queue.c **** 					Instead the same pending ready list mechanism is used as if
2131:..\Source/queue.c **** 					the event were caused from within an interrupt. */
2132:..\Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2133:..\Source/queue.c **** 					{
2134:..\Source/queue.c **** 						xReturn = errQUEUE_YIELD;
2135:..\Source/queue.c **** 					}
2136:..\Source/queue.c **** 					else
2137:..\Source/queue.c **** 					{
2138:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2139:..\Source/queue.c **** 					}
2140:..\Source/queue.c **** 				}
2141:..\Source/queue.c **** 				else
2142:..\Source/queue.c **** 				{
2143:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2144:..\Source/queue.c **** 				}
2145:..\Source/queue.c **** 			}
2146:..\Source/queue.c **** 			else
2147:..\Source/queue.c **** 			{
2148:..\Source/queue.c **** 				xReturn = pdFAIL;
2149:..\Source/queue.c **** 			}
2150:..\Source/queue.c **** 		}
2151:..\Source/queue.c **** 		portENABLE_INTERRUPTS();
2152:..\Source/queue.c **** 
2153:..\Source/queue.c **** 		return xReturn;
2154:..\Source/queue.c **** 	}
2155:..\Source/queue.c **** 
2156:..\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2157:..\Source/queue.c **** /*-----------------------------------------------------------*/
2158:..\Source/queue.c **** 
2159:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2160:..\Source/queue.c **** 
2161:..\Source/queue.c **** 	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRou
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 92


2162:..\Source/queue.c **** 	{
2163:..\Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2164:..\Source/queue.c **** 
2165:..\Source/queue.c **** 		/* Cannot block within an ISR so if there is no space on the queue then
2166:..\Source/queue.c **** 		exit without doing anything. */
2167:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2168:..\Source/queue.c **** 		{
2169:..\Source/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2170:..\Source/queue.c **** 
2171:..\Source/queue.c **** 			/* We only want to wake one co-routine per ISR, so check that a
2172:..\Source/queue.c **** 			co-routine has not already been woken. */
2173:..\Source/queue.c **** 			if( xCoRoutinePreviouslyWoken == pdFALSE )
2174:..\Source/queue.c **** 			{
2175:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2176:..\Source/queue.c **** 				{
2177:..\Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2178:..\Source/queue.c **** 					{
2179:..\Source/queue.c **** 						return pdTRUE;
2180:..\Source/queue.c **** 					}
2181:..\Source/queue.c **** 					else
2182:..\Source/queue.c **** 					{
2183:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2184:..\Source/queue.c **** 					}
2185:..\Source/queue.c **** 				}
2186:..\Source/queue.c **** 				else
2187:..\Source/queue.c **** 				{
2188:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2189:..\Source/queue.c **** 				}
2190:..\Source/queue.c **** 			}
2191:..\Source/queue.c **** 			else
2192:..\Source/queue.c **** 			{
2193:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2194:..\Source/queue.c **** 			}
2195:..\Source/queue.c **** 		}
2196:..\Source/queue.c **** 		else
2197:..\Source/queue.c **** 		{
2198:..\Source/queue.c **** 			mtCOVERAGE_TEST_MARKER();
2199:..\Source/queue.c **** 		}
2200:..\Source/queue.c **** 
2201:..\Source/queue.c **** 		return xCoRoutinePreviouslyWoken;
2202:..\Source/queue.c **** 	}
2203:..\Source/queue.c **** 
2204:..\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2205:..\Source/queue.c **** /*-----------------------------------------------------------*/
2206:..\Source/queue.c **** 
2207:..\Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2208:..\Source/queue.c **** 
2209:..\Source/queue.c **** 	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWo
2210:..\Source/queue.c **** 	{
2211:..\Source/queue.c **** 	BaseType_t xReturn;
2212:..\Source/queue.c **** 	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2213:..\Source/queue.c **** 
2214:..\Source/queue.c **** 		/* We cannot block from an ISR, so check there is data available. If
2215:..\Source/queue.c **** 		not then just leave without doing anything. */
2216:..\Source/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2217:..\Source/queue.c **** 		{
2218:..\Source/queue.c **** 			/* Copy the data from the queue. */
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 93


2219:..\Source/queue.c **** 			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2220:..\Source/queue.c **** 			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2221:..\Source/queue.c **** 			{
2222:..\Source/queue.c **** 				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2223:..\Source/queue.c **** 			}
2224:..\Source/queue.c **** 			else
2225:..\Source/queue.c **** 			{
2226:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2227:..\Source/queue.c **** 			}
2228:..\Source/queue.c **** 			--( pxQueue->uxMessagesWaiting );
2229:..\Source/queue.c **** 			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->ux
2230:..\Source/queue.c **** 
2231:..\Source/queue.c **** 			if( ( *pxCoRoutineWoken ) == pdFALSE )
2232:..\Source/queue.c **** 			{
2233:..\Source/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2234:..\Source/queue.c **** 				{
2235:..\Source/queue.c **** 					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2236:..\Source/queue.c **** 					{
2237:..\Source/queue.c **** 						*pxCoRoutineWoken = pdTRUE;
2238:..\Source/queue.c **** 					}
2239:..\Source/queue.c **** 					else
2240:..\Source/queue.c **** 					{
2241:..\Source/queue.c **** 						mtCOVERAGE_TEST_MARKER();
2242:..\Source/queue.c **** 					}
2243:..\Source/queue.c **** 				}
2244:..\Source/queue.c **** 				else
2245:..\Source/queue.c **** 				{
2246:..\Source/queue.c **** 					mtCOVERAGE_TEST_MARKER();
2247:..\Source/queue.c **** 				}
2248:..\Source/queue.c **** 			}
2249:..\Source/queue.c **** 			else
2250:..\Source/queue.c **** 			{
2251:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2252:..\Source/queue.c **** 			}
2253:..\Source/queue.c **** 
2254:..\Source/queue.c **** 			xReturn = pdPASS;
2255:..\Source/queue.c **** 		}
2256:..\Source/queue.c **** 		else
2257:..\Source/queue.c **** 		{
2258:..\Source/queue.c **** 			xReturn = pdFAIL;
2259:..\Source/queue.c **** 		}
2260:..\Source/queue.c **** 
2261:..\Source/queue.c **** 		return xReturn;
2262:..\Source/queue.c **** 	}
2263:..\Source/queue.c **** 
2264:..\Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2265:..\Source/queue.c **** /*-----------------------------------------------------------*/
2266:..\Source/queue.c **** 
2267:..\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2268:..\Source/queue.c **** 
2269:..\Source/queue.c **** 	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified
2270:..\Source/queue.c **** 	{
 2744              		.loc 1 2270 0
 2745              		.cfi_startproc
 2746              		@ args = 0, pretend = 0, frame = 16
 2747              		@ frame_needed = 1, uses_anonymous_args = 0
 2748              		@ link register save eliminated.
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 94


 2749 0000 80B4     		push	{r7}
 2750              		.cfi_def_cfa_offset 4
 2751              		.cfi_offset 7, -4
 2752 0002 85B0     		sub	sp, sp, #20
 2753              		.cfi_def_cfa_offset 24
 2754 0004 00AF     		add	r7, sp, #0
 2755              		.cfi_def_cfa_register 7
 2756 0006 7860     		str	r0, [r7, #4]
 2757 0008 3960     		str	r1, [r7]
2271:..\Source/queue.c **** 	UBaseType_t ux;
2272:..\Source/queue.c **** 
2273:..\Source/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
2274:..\Source/queue.c **** 		a free slot. */
2275:..\Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2758              		.loc 1 2275 0
 2759 000a 0023     		movs	r3, #0
 2760 000c FB60     		str	r3, [r7, #12]
 2761 000e 14E0     		b	.L156
 2762              	.L159:
2276:..\Source/queue.c **** 		{
2277:..\Source/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 2763              		.loc 1 2277 0
 2764 0010 0E4A     		ldr	r2, .L160
 2765 0012 FB68     		ldr	r3, [r7, #12]
 2766 0014 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2767 0018 002B     		cmp	r3, #0
 2768 001a 0BD1     		bne	.L157
2278:..\Source/queue.c **** 			{
2279:..\Source/queue.c **** 				/* Store the information on this queue. */
2280:..\Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 2769              		.loc 1 2280 0
 2770 001c 0B49     		ldr	r1, .L160
 2771 001e FB68     		ldr	r3, [r7, #12]
 2772 0020 3A68     		ldr	r2, [r7]
 2773 0022 41F83320 		str	r2, [r1, r3, lsl #3]
2281:..\Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 2774              		.loc 1 2281 0
 2775 0026 094A     		ldr	r2, .L160
 2776 0028 FB68     		ldr	r3, [r7, #12]
 2777 002a DB00     		lsls	r3, r3, #3
 2778 002c 1344     		add	r3, r3, r2
 2779 002e 7A68     		ldr	r2, [r7, #4]
 2780 0030 5A60     		str	r2, [r3, #4]
2282:..\Source/queue.c **** 
2283:..\Source/queue.c **** 				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2284:..\Source/queue.c **** 				break;
 2781              		.loc 1 2284 0
 2782 0032 05E0     		b	.L158
 2783              	.L157:
2275:..\Source/queue.c **** 		{
 2784              		.loc 1 2275 0 discriminator 2
 2785 0034 FB68     		ldr	r3, [r7, #12]
 2786 0036 0133     		adds	r3, r3, #1
 2787 0038 FB60     		str	r3, [r7, #12]
 2788              	.L156:
2275:..\Source/queue.c **** 		{
 2789              		.loc 1 2275 0 is_stmt 0 discriminator 1
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 95


 2790 003a FB68     		ldr	r3, [r7, #12]
 2791 003c 092B     		cmp	r3, #9
 2792 003e E7D9     		bls	.L159
 2793              	.L158:
2285:..\Source/queue.c **** 			}
2286:..\Source/queue.c **** 			else
2287:..\Source/queue.c **** 			{
2288:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2289:..\Source/queue.c **** 			}
2290:..\Source/queue.c **** 		}
2291:..\Source/queue.c **** 	}
 2794              		.loc 1 2291 0 is_stmt 1
 2795 0040 00BF     		nop
 2796 0042 1437     		adds	r7, r7, #20
 2797              		.cfi_def_cfa_offset 4
 2798 0044 BD46     		mov	sp, r7
 2799              		.cfi_def_cfa_register 13
 2800              		@ sp needed
 2801 0046 80BC     		pop	{r7}
 2802              		.cfi_restore 7
 2803              		.cfi_def_cfa_offset 0
 2804 0048 7047     		bx	lr
 2805              	.L161:
 2806 004a 00BF     		.align	2
 2807              	.L160:
 2808 004c 00000000 		.word	xQueueRegistry
 2809              		.cfi_endproc
 2810              	.LFE96:
 2811              		.size	vQueueAddToRegistry, .-vQueueAddToRegistry
 2812              		.section	.text.pcQueueGetName,"ax",%progbits
 2813              		.align	2
 2814              		.global	pcQueueGetName
 2815              		.thumb
 2816              		.thumb_func
 2817              		.type	pcQueueGetName, %function
 2818              	pcQueueGetName:
 2819              	.LFB97:
2292:..\Source/queue.c **** 
2293:..\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2294:..\Source/queue.c **** /*-----------------------------------------------------------*/
2295:..\Source/queue.c **** 
2296:..\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2297:..\Source/queue.c **** 
2298:..\Source/queue.c **** 	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed
2299:..\Source/queue.c **** 	{
 2820              		.loc 1 2299 0
 2821              		.cfi_startproc
 2822              		@ args = 0, pretend = 0, frame = 16
 2823              		@ frame_needed = 1, uses_anonymous_args = 0
 2824              		@ link register save eliminated.
 2825 0000 80B4     		push	{r7}
 2826              		.cfi_def_cfa_offset 4
 2827              		.cfi_offset 7, -4
 2828 0002 85B0     		sub	sp, sp, #20
 2829              		.cfi_def_cfa_offset 24
 2830 0004 00AF     		add	r7, sp, #0
 2831              		.cfi_def_cfa_register 7
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 96


 2832 0006 7860     		str	r0, [r7, #4]
2300:..\Source/queue.c **** 	UBaseType_t ux;
2301:..\Source/queue.c **** 	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and singl
 2833              		.loc 1 2301 0
 2834 0008 0023     		movs	r3, #0
 2835 000a BB60     		str	r3, [r7, #8]
2302:..\Source/queue.c **** 
2303:..\Source/queue.c **** 		/* Note there is nothing here to protect against another task adding or
2304:..\Source/queue.c **** 		removing entries from the registry while it is being searched. */
2305:..\Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2836              		.loc 1 2305 0
 2837 000c 0023     		movs	r3, #0
 2838 000e FB60     		str	r3, [r7, #12]
 2839 0010 10E0     		b	.L163
 2840              	.L166:
2306:..\Source/queue.c **** 		{
2307:..\Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2841              		.loc 1 2307 0
 2842 0012 0D4A     		ldr	r2, .L168
 2843 0014 FB68     		ldr	r3, [r7, #12]
 2844 0016 DB00     		lsls	r3, r3, #3
 2845 0018 1344     		add	r3, r3, r2
 2846 001a 5A68     		ldr	r2, [r3, #4]
 2847 001c 7B68     		ldr	r3, [r7, #4]
 2848 001e 9A42     		cmp	r2, r3
 2849 0020 05D1     		bne	.L164
2308:..\Source/queue.c **** 			{
2309:..\Source/queue.c **** 				pcReturn = xQueueRegistry[ ux ].pcQueueName;
 2850              		.loc 1 2309 0
 2851 0022 094A     		ldr	r2, .L168
 2852 0024 FB68     		ldr	r3, [r7, #12]
 2853 0026 52F83330 		ldr	r3, [r2, r3, lsl #3]
 2854 002a BB60     		str	r3, [r7, #8]
2310:..\Source/queue.c **** 				break;
 2855              		.loc 1 2310 0
 2856 002c 05E0     		b	.L165
 2857              	.L164:
2305:..\Source/queue.c **** 		{
 2858              		.loc 1 2305 0 discriminator 2
 2859 002e FB68     		ldr	r3, [r7, #12]
 2860 0030 0133     		adds	r3, r3, #1
 2861 0032 FB60     		str	r3, [r7, #12]
 2862              	.L163:
2305:..\Source/queue.c **** 		{
 2863              		.loc 1 2305 0 is_stmt 0 discriminator 1
 2864 0034 FB68     		ldr	r3, [r7, #12]
 2865 0036 092B     		cmp	r3, #9
 2866 0038 EBD9     		bls	.L166
 2867              	.L165:
2311:..\Source/queue.c **** 			}
2312:..\Source/queue.c **** 			else
2313:..\Source/queue.c **** 			{
2314:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2315:..\Source/queue.c **** 			}
2316:..\Source/queue.c **** 		}
2317:..\Source/queue.c **** 
2318:..\Source/queue.c **** 		return pcReturn;
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 97


 2868              		.loc 1 2318 0 is_stmt 1
 2869 003a BB68     		ldr	r3, [r7, #8]
2319:..\Source/queue.c **** 	}
 2870              		.loc 1 2319 0
 2871 003c 1846     		mov	r0, r3
 2872 003e 1437     		adds	r7, r7, #20
 2873              		.cfi_def_cfa_offset 4
 2874 0040 BD46     		mov	sp, r7
 2875              		.cfi_def_cfa_register 13
 2876              		@ sp needed
 2877 0042 80BC     		pop	{r7}
 2878              		.cfi_restore 7
 2879              		.cfi_def_cfa_offset 0
 2880 0044 7047     		bx	lr
 2881              	.L169:
 2882 0046 00BF     		.align	2
 2883              	.L168:
 2884 0048 00000000 		.word	xQueueRegistry
 2885              		.cfi_endproc
 2886              	.LFE97:
 2887              		.size	pcQueueGetName, .-pcQueueGetName
 2888              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 2889              		.align	2
 2890              		.global	vQueueUnregisterQueue
 2891              		.thumb
 2892              		.thumb_func
 2893              		.type	vQueueUnregisterQueue, %function
 2894              	vQueueUnregisterQueue:
 2895              	.LFB98:
2320:..\Source/queue.c **** 
2321:..\Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2322:..\Source/queue.c **** /*-----------------------------------------------------------*/
2323:..\Source/queue.c **** 
2324:..\Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2325:..\Source/queue.c **** 
2326:..\Source/queue.c **** 	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2327:..\Source/queue.c **** 	{
 2896              		.loc 1 2327 0
 2897              		.cfi_startproc
 2898              		@ args = 0, pretend = 0, frame = 16
 2899              		@ frame_needed = 1, uses_anonymous_args = 0
 2900              		@ link register save eliminated.
 2901 0000 80B4     		push	{r7}
 2902              		.cfi_def_cfa_offset 4
 2903              		.cfi_offset 7, -4
 2904 0002 85B0     		sub	sp, sp, #20
 2905              		.cfi_def_cfa_offset 24
 2906 0004 00AF     		add	r7, sp, #0
 2907              		.cfi_def_cfa_register 7
 2908 0006 7860     		str	r0, [r7, #4]
2328:..\Source/queue.c **** 	UBaseType_t ux;
2329:..\Source/queue.c **** 
2330:..\Source/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
2331:..\Source/queue.c **** 		registry. */
2332:..\Source/queue.c **** 		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 2909              		.loc 1 2332 0
 2910 0008 0023     		movs	r3, #0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 98


 2911 000a FB60     		str	r3, [r7, #12]
 2912 000c 16E0     		b	.L171
 2913              	.L174:
2333:..\Source/queue.c **** 		{
2334:..\Source/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 2914              		.loc 1 2334 0
 2915 000e 0F4A     		ldr	r2, .L175
 2916 0010 FB68     		ldr	r3, [r7, #12]
 2917 0012 DB00     		lsls	r3, r3, #3
 2918 0014 1344     		add	r3, r3, r2
 2919 0016 5A68     		ldr	r2, [r3, #4]
 2920 0018 7B68     		ldr	r3, [r7, #4]
 2921 001a 9A42     		cmp	r2, r3
 2922 001c 0BD1     		bne	.L172
2335:..\Source/queue.c **** 			{
2336:..\Source/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
2337:..\Source/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 2923              		.loc 1 2337 0
 2924 001e 0B4A     		ldr	r2, .L175
 2925 0020 FB68     		ldr	r3, [r7, #12]
 2926 0022 0021     		movs	r1, #0
 2927 0024 42F83310 		str	r1, [r2, r3, lsl #3]
2338:..\Source/queue.c **** 
2339:..\Source/queue.c **** 				/* Set the handle to NULL to ensure the same queue handle cannot
2340:..\Source/queue.c **** 				appear in the registry twice if it is added, removed, then
2341:..\Source/queue.c **** 				added again. */
2342:..\Source/queue.c **** 				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 2928              		.loc 1 2342 0
 2929 0028 084A     		ldr	r2, .L175
 2930 002a FB68     		ldr	r3, [r7, #12]
 2931 002c DB00     		lsls	r3, r3, #3
 2932 002e 1344     		add	r3, r3, r2
 2933 0030 0022     		movs	r2, #0
 2934 0032 5A60     		str	r2, [r3, #4]
2343:..\Source/queue.c **** 				break;
 2935              		.loc 1 2343 0
 2936 0034 05E0     		b	.L173
 2937              	.L172:
2332:..\Source/queue.c **** 		{
 2938              		.loc 1 2332 0 discriminator 2
 2939 0036 FB68     		ldr	r3, [r7, #12]
 2940 0038 0133     		adds	r3, r3, #1
 2941 003a FB60     		str	r3, [r7, #12]
 2942              	.L171:
2332:..\Source/queue.c **** 		{
 2943              		.loc 1 2332 0 is_stmt 0 discriminator 1
 2944 003c FB68     		ldr	r3, [r7, #12]
 2945 003e 092B     		cmp	r3, #9
 2946 0040 E5D9     		bls	.L174
 2947              	.L173:
2344:..\Source/queue.c **** 			}
2345:..\Source/queue.c **** 			else
2346:..\Source/queue.c **** 			{
2347:..\Source/queue.c **** 				mtCOVERAGE_TEST_MARKER();
2348:..\Source/queue.c **** 			}
2349:..\Source/queue.c **** 		}
2350:..\Source/queue.c **** 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 99


2351:..\Source/queue.c **** 	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 2948              		.loc 1 2351 0 is_stmt 1
 2949 0042 00BF     		nop
 2950 0044 1437     		adds	r7, r7, #20
 2951              		.cfi_def_cfa_offset 4
 2952 0046 BD46     		mov	sp, r7
 2953              		.cfi_def_cfa_register 13
 2954              		@ sp needed
 2955 0048 80BC     		pop	{r7}
 2956              		.cfi_restore 7
 2957              		.cfi_def_cfa_offset 0
 2958 004a 7047     		bx	lr
 2959              	.L176:
 2960              		.align	2
 2961              	.L175:
 2962 004c 00000000 		.word	xQueueRegistry
 2963              		.cfi_endproc
 2964              	.LFE98:
 2965              		.size	vQueueUnregisterQueue, .-vQueueUnregisterQueue
 2966              		.text
 2967              	.Letext0:
 2968              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 2969              		.file 4 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 2970              		.file 5 "c:\\program files (x86)\\cypress\\psoc creator\\4.2\\psoc creator\\import\\gnu\\arm\\5.4.
 2971              		.file 6 ".\\Tracer/sniffPayload.h"
 2972              		.file 7 ".\\Tracer/selfFIFO.h"
 2973              		.file 8 "..\\Source\\include/list.h"
 2974              		.file 9 "..\\Source\\include/task.h"
 2975              		.file 10 "..\\Source\\include/queue.h"
 2976              		.file 11 "Generated_Source\\PSoC5/core_cm3.h"
 2977              		.file 12 ".\\Tracer/sniffTask.h"
 2978              		.section	.debug_info,"",%progbits
 2979              	.Ldebug_info0:
 2980 0000 EE120000 		.4byte	0x12ee
 2981 0004 0400     		.2byte	0x4
 2982 0006 00000000 		.4byte	.Ldebug_abbrev0
 2983 000a 04       		.byte	0x4
 2984 000b 01       		.uleb128 0x1
 2985 000c 76010000 		.4byte	.LASF235
 2986 0010 0C       		.byte	0xc
 2987 0011 BD080000 		.4byte	.LASF236
 2988 0015 0A0D0000 		.4byte	.LASF237
 2989 0019 00000000 		.4byte	.Ldebug_ranges0+0
 2990 001d 00000000 		.4byte	0
 2991 0021 00000000 		.4byte	.Ldebug_line0
 2992 0025 02       		.uleb128 0x2
 2993 0026 AA000000 		.4byte	.LASF3
 2994 002a 03       		.byte	0x3
 2995 002b D8       		.byte	0xd8
 2996 002c 30000000 		.4byte	0x30
 2997 0030 03       		.uleb128 0x3
 2998 0031 04       		.byte	0x4
 2999 0032 07       		.byte	0x7
 3000 0033 83050000 		.4byte	.LASF0
 3001 0037 04       		.uleb128 0x4
 3002 0038 04       		.byte	0x4
 3003 0039 05       		.byte	0x5
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 100


 3004 003a 696E7400 		.ascii	"int\000"
 3005 003e 03       		.uleb128 0x3
 3006 003f 08       		.byte	0x8
 3007 0040 05       		.byte	0x5
 3008 0041 69040000 		.4byte	.LASF1
 3009 0045 03       		.uleb128 0x3
 3010 0046 08       		.byte	0x8
 3011 0047 04       		.byte	0x4
 3012 0048 FA070000 		.4byte	.LASF2
 3013 004c 02       		.uleb128 0x2
 3014 004d C1030000 		.4byte	.LASF4
 3015 0051 04       		.byte	0x4
 3016 0052 1B       		.byte	0x1b
 3017 0053 57000000 		.4byte	0x57
 3018 0057 03       		.uleb128 0x3
 3019 0058 01       		.byte	0x1
 3020 0059 06       		.byte	0x6
 3021 005a 71030000 		.4byte	.LASF5
 3022 005e 02       		.uleb128 0x2
 3023 005f 21010000 		.4byte	.LASF6
 3024 0063 04       		.byte	0x4
 3025 0064 1D       		.byte	0x1d
 3026 0065 69000000 		.4byte	0x69
 3027 0069 03       		.uleb128 0x3
 3028 006a 01       		.byte	0x1
 3029 006b 08       		.byte	0x8
 3030 006c C3090000 		.4byte	.LASF7
 3031 0070 03       		.uleb128 0x3
 3032 0071 02       		.byte	0x2
 3033 0072 05       		.byte	0x5
 3034 0073 690A0000 		.4byte	.LASF8
 3035 0077 03       		.uleb128 0x3
 3036 0078 02       		.byte	0x2
 3037 0079 07       		.byte	0x7
 3038 007a 9D060000 		.4byte	.LASF9
 3039 007e 02       		.uleb128 0x2
 3040 007f BE020000 		.4byte	.LASF10
 3041 0083 04       		.byte	0x4
 3042 0084 3F       		.byte	0x3f
 3043 0085 89000000 		.4byte	0x89
 3044 0089 03       		.uleb128 0x3
 3045 008a 04       		.byte	0x4
 3046 008b 05       		.byte	0x5
 3047 008c 06040000 		.4byte	.LASF11
 3048 0090 02       		.uleb128 0x2
 3049 0091 01050000 		.4byte	.LASF12
 3050 0095 04       		.byte	0x4
 3051 0096 41       		.byte	0x41
 3052 0097 9B000000 		.4byte	0x9b
 3053 009b 03       		.uleb128 0x3
 3054 009c 04       		.byte	0x4
 3055 009d 07       		.byte	0x7
 3056 009e E0050000 		.4byte	.LASF13
 3057 00a2 03       		.uleb128 0x3
 3058 00a3 08       		.byte	0x8
 3059 00a4 07       		.byte	0x7
 3060 00a5 5D020000 		.4byte	.LASF14
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 101


 3061 00a9 03       		.uleb128 0x3
 3062 00aa 04       		.byte	0x4
 3063 00ab 07       		.byte	0x7
 3064 00ac F1070000 		.4byte	.LASF15
 3065 00b0 05       		.uleb128 0x5
 3066 00b1 04       		.byte	0x4
 3067 00b2 03       		.uleb128 0x3
 3068 00b3 01       		.byte	0x1
 3069 00b4 08       		.byte	0x8
 3070 00b5 1B0C0000 		.4byte	.LASF16
 3071 00b9 06       		.uleb128 0x6
 3072 00ba 04       		.byte	0x4
 3073 00bb BF000000 		.4byte	0xbf
 3074 00bf 07       		.uleb128 0x7
 3075 00c0 B2000000 		.4byte	0xb2
 3076 00c4 06       		.uleb128 0x6
 3077 00c5 04       		.byte	0x4
 3078 00c6 CA000000 		.4byte	0xca
 3079 00ca 08       		.uleb128 0x8
 3080 00cb 02       		.uleb128 0x2
 3081 00cc 0A0E0000 		.4byte	.LASF17
 3082 00d0 05       		.byte	0x5
 3083 00d1 14       		.byte	0x14
 3084 00d2 4C000000 		.4byte	0x4c
 3085 00d6 02       		.uleb128 0x2
 3086 00d7 440F0000 		.4byte	.LASF18
 3087 00db 05       		.byte	0x5
 3088 00dc 18       		.byte	0x18
 3089 00dd 5E000000 		.4byte	0x5e
 3090 00e1 02       		.uleb128 0x2
 3091 00e2 BB090000 		.4byte	.LASF19
 3092 00e6 05       		.byte	0x5
 3093 00e7 2C       		.byte	0x2c
 3094 00e8 7E000000 		.4byte	0x7e
 3095 00ec 02       		.uleb128 0x2
 3096 00ed A60B0000 		.4byte	.LASF20
 3097 00f1 05       		.byte	0x5
 3098 00f2 30       		.byte	0x30
 3099 00f3 90000000 		.4byte	0x90
 3100 00f7 03       		.uleb128 0x3
 3101 00f8 04       		.byte	0x4
 3102 00f9 04       		.byte	0x4
 3103 00fa 64090000 		.4byte	.LASF21
 3104 00fe 03       		.uleb128 0x3
 3105 00ff 08       		.byte	0x8
 3106 0100 04       		.byte	0x4
 3107 0101 77040000 		.4byte	.LASF22
 3108 0105 09       		.uleb128 0x9
 3109 0106 01       		.byte	0x1
 3110 0107 69000000 		.4byte	0x69
 3111 010b 06       		.byte	0x6
 3112 010c 10       		.byte	0x10
 3113 010d 3C010000 		.4byte	0x13c
 3114 0111 0A       		.uleb128 0xa
 3115 0112 65080000 		.4byte	.LASF23
 3116 0116 00       		.byte	0
 3117 0117 0A       		.uleb128 0xa
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 102


 3118 0118 54080000 		.4byte	.LASF24
 3119 011c 01       		.byte	0x1
 3120 011d 0A       		.uleb128 0xa
 3121 011e 51090000 		.4byte	.LASF25
 3122 0122 02       		.byte	0x2
 3123 0123 0A       		.uleb128 0xa
 3124 0124 00000000 		.4byte	.LASF26
 3125 0128 03       		.byte	0x3
 3126 0129 0A       		.uleb128 0xa
 3127 012a 9B090000 		.4byte	.LASF27
 3128 012e 04       		.byte	0x4
 3129 012f 0A       		.uleb128 0xa
 3130 0130 50100000 		.4byte	.LASF28
 3131 0134 05       		.byte	0x5
 3132 0135 0A       		.uleb128 0xa
 3133 0136 9C0E0000 		.4byte	.LASF29
 3134 013a 06       		.byte	0x6
 3135 013b 00       		.byte	0
 3136 013c 02       		.uleb128 0x2
 3137 013d 28030000 		.4byte	.LASF30
 3138 0141 06       		.byte	0x6
 3139 0142 10       		.byte	0x10
 3140 0143 05010000 		.4byte	0x105
 3141 0147 09       		.uleb128 0x9
 3142 0148 01       		.byte	0x1
 3143 0149 69000000 		.4byte	0x69
 3144 014d 06       		.byte	0x6
 3145 014e 15       		.byte	0x15
 3146 014f 28030000 		.4byte	0x328
 3147 0153 0A       		.uleb128 0xa
 3148 0154 60060000 		.4byte	.LASF31
 3149 0158 00       		.byte	0
 3150 0159 0A       		.uleb128 0xa
 3151 015a 5D030000 		.4byte	.LASF32
 3152 015e 01       		.byte	0x1
 3153 015f 0A       		.uleb128 0xa
 3154 0160 250F0000 		.4byte	.LASF33
 3155 0164 02       		.byte	0x2
 3156 0165 0A       		.uleb128 0xa
 3157 0166 43050000 		.4byte	.LASF34
 3158 016a 03       		.byte	0x3
 3159 016b 0A       		.uleb128 0xa
 3160 016c CA030000 		.4byte	.LASF35
 3161 0170 04       		.byte	0x4
 3162 0171 0A       		.uleb128 0xa
 3163 0172 DB070000 		.4byte	.LASF36
 3164 0176 05       		.byte	0x5
 3165 0177 0A       		.uleb128 0xa
 3166 0178 1B020000 		.4byte	.LASF37
 3167 017c 06       		.byte	0x6
 3168 017d 0A       		.uleb128 0xa
 3169 017e 8D0B0000 		.4byte	.LASF38
 3170 0182 07       		.byte	0x7
 3171 0183 0A       		.uleb128 0xa
 3172 0184 560F0000 		.4byte	.LASF39
 3173 0188 08       		.byte	0x8
 3174 0189 0A       		.uleb128 0xa
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 103


 3175 018a 80060000 		.4byte	.LASF40
 3176 018e 09       		.byte	0x9
 3177 018f 0A       		.uleb128 0xa
 3178 0190 15070000 		.4byte	.LASF41
 3179 0194 0A       		.byte	0xa
 3180 0195 0A       		.uleb128 0xa
 3181 0196 0F080000 		.4byte	.LASF42
 3182 019a 0B       		.byte	0xb
 3183 019b 0A       		.uleb128 0xa
 3184 019c 7D0F0000 		.4byte	.LASF43
 3185 01a0 0C       		.byte	0xc
 3186 01a1 0A       		.uleb128 0xa
 3187 01a2 AC040000 		.4byte	.LASF44
 3188 01a6 0D       		.byte	0xd
 3189 01a7 0A       		.uleb128 0xa
 3190 01a8 490E0000 		.4byte	.LASF45
 3191 01ac 0E       		.byte	0xe
 3192 01ad 0A       		.uleb128 0xa
 3193 01ae C0050000 		.4byte	.LASF46
 3194 01b2 0F       		.byte	0xf
 3195 01b3 0A       		.uleb128 0xa
 3196 01b4 520A0000 		.4byte	.LASF47
 3197 01b8 10       		.byte	0x10
 3198 01b9 0A       		.uleb128 0xa
 3199 01ba 2E060000 		.4byte	.LASF48
 3200 01be 11       		.byte	0x11
 3201 01bf 0A       		.uleb128 0xa
 3202 01c0 B20E0000 		.4byte	.LASF49
 3203 01c4 12       		.byte	0x12
 3204 01c5 0A       		.uleb128 0xa
 3205 01c6 88070000 		.4byte	.LASF50
 3206 01ca 13       		.byte	0x13
 3207 01cb 0A       		.uleb128 0xa
 3208 01cc AB0A0000 		.4byte	.LASF51
 3209 01d0 14       		.byte	0x14
 3210 01d1 0A       		.uleb128 0xa
 3211 01d2 A0080000 		.4byte	.LASF52
 3212 01d6 15       		.byte	0x15
 3213 01d7 0A       		.uleb128 0xa
 3214 01d8 9D030000 		.4byte	.LASF53
 3215 01dc 16       		.byte	0x16
 3216 01dd 0A       		.uleb128 0xa
 3217 01de 25050000 		.4byte	.LASF54
 3218 01e2 17       		.byte	0x17
 3219 01e3 0A       		.uleb128 0xa
 3220 01e4 720C0000 		.4byte	.LASF55
 3221 01e8 18       		.byte	0x18
 3222 01e9 0A       		.uleb128 0xa
 3223 01ea EF0B0000 		.4byte	.LASF56
 3224 01ee 19       		.byte	0x19
 3225 01ef 0A       		.uleb128 0xa
 3226 01f0 1D0A0000 		.4byte	.LASF57
 3227 01f4 1A       		.byte	0x1a
 3228 01f5 0A       		.uleb128 0xa
 3229 01f6 AB0D0000 		.4byte	.LASF58
 3230 01fa 1B       		.byte	0x1b
 3231 01fb 0A       		.uleb128 0xa
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 104


 3232 01fc F20C0000 		.4byte	.LASF59
 3233 0200 1C       		.byte	0x1c
 3234 0201 0A       		.uleb128 0xa
 3235 0202 5A050000 		.4byte	.LASF60
 3236 0206 1D       		.byte	0x1d
 3237 0207 0A       		.uleb128 0xa
 3238 0208 D80D0000 		.4byte	.LASF61
 3239 020c 1E       		.byte	0x1e
 3240 020d 0A       		.uleb128 0xa
 3241 020e 790E0000 		.4byte	.LASF62
 3242 0212 1F       		.byte	0x1f
 3243 0213 0A       		.uleb128 0xa
 3244 0214 27040000 		.4byte	.LASF63
 3245 0218 20       		.byte	0x20
 3246 0219 0A       		.uleb128 0xa
 3247 021a 25090000 		.4byte	.LASF64
 3248 021e 21       		.byte	0x21
 3249 021f 0A       		.uleb128 0xa
 3250 0220 110E0000 		.4byte	.LASF65
 3251 0224 22       		.byte	0x22
 3252 0225 0A       		.uleb128 0xa
 3253 0226 F0060000 		.4byte	.LASF66
 3254 022a 23       		.byte	0x23
 3255 022b 0A       		.uleb128 0xa
 3256 022c DF080000 		.4byte	.LASF67
 3257 0230 24       		.byte	0x24
 3258 0231 0A       		.uleb128 0xa
 3259 0232 160F0000 		.4byte	.LASF68
 3260 0236 25       		.byte	0x25
 3261 0237 0A       		.uleb128 0xa
 3262 0238 E6040000 		.4byte	.LASF69
 3263 023c 26       		.byte	0x26
 3264 023d 0A       		.uleb128 0xa
 3265 023e 58070000 		.4byte	.LASF70
 3266 0242 27       		.byte	0x27
 3267 0243 0A       		.uleb128 0xa
 3268 0244 3B100000 		.4byte	.LASF71
 3269 0248 28       		.byte	0x28
 3270 0249 0A       		.uleb128 0xa
 3271 024a 33050000 		.4byte	.LASF72
 3272 024e 29       		.byte	0x29
 3273 024f 0A       		.uleb128 0xa
 3274 0250 55010000 		.4byte	.LASF73
 3275 0254 2A       		.byte	0x2a
 3276 0255 0A       		.uleb128 0xa
 3277 0256 A0070000 		.4byte	.LASF74
 3278 025a 2B       		.byte	0x2b
 3279 025b 0A       		.uleb128 0xa
 3280 025c BF0F0000 		.4byte	.LASF75
 3281 0260 2C       		.byte	0x2c
 3282 0261 0A       		.uleb128 0xa
 3283 0262 530C0000 		.4byte	.LASF76
 3284 0266 2D       		.byte	0x2d
 3285 0267 0A       		.uleb128 0xa
 3286 0268 CF0B0000 		.4byte	.LASF77
 3287 026c 2E       		.byte	0x2e
 3288 026d 0A       		.uleb128 0xa
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 105


 3289 026e BF060000 		.4byte	.LASF78
 3290 0272 2F       		.byte	0x2f
 3291 0273 0A       		.uleb128 0xa
 3292 0274 55100000 		.4byte	.LASF79
 3293 0278 30       		.byte	0x30
 3294 0279 0A       		.uleb128 0xa
 3295 027a A4020000 		.4byte	.LASF80
 3296 027e 31       		.byte	0x31
 3297 027f 0A       		.uleb128 0xa
 3298 0280 96080000 		.4byte	.LASF81
 3299 0284 32       		.byte	0x32
 3300 0285 0A       		.uleb128 0xa
 3301 0286 A60F0000 		.4byte	.LASF82
 3302 028a 33       		.byte	0x33
 3303 028b 0A       		.uleb128 0xa
 3304 028c C20D0000 		.4byte	.LASF83
 3305 0290 34       		.byte	0x34
 3306 0291 0A       		.uleb128 0xa
 3307 0292 B8070000 		.4byte	.LASF84
 3308 0296 35       		.byte	0x35
 3309 0297 0A       		.uleb128 0xa
 3310 0298 46060000 		.4byte	.LASF85
 3311 029c 36       		.byte	0x36
 3312 029d 0A       		.uleb128 0xa
 3313 029e FE0E0000 		.4byte	.LASF86
 3314 02a2 37       		.byte	0x37
 3315 02a3 0A       		.uleb128 0xa
 3316 02a4 C30C0000 		.4byte	.LASF87
 3317 02a8 38       		.byte	0x38
 3318 02a9 0A       		.uleb128 0xa
 3319 02aa 2C0E0000 		.4byte	.LASF88
 3320 02ae 39       		.byte	0x39
 3321 02af 0A       		.uleb128 0xa
 3322 02b0 D60F0000 		.4byte	.LASF89
 3323 02b4 3A       		.byte	0x3a
 3324 02b5 0A       		.uleb128 0xa
 3325 02b6 160B0000 		.4byte	.LASF90
 3326 02ba 3B       		.byte	0x3b
 3327 02bb 0A       		.uleb128 0xa
 3328 02bc 02060000 		.4byte	.LASF91
 3329 02c0 3C       		.byte	0x3c
 3330 02c1 0A       		.uleb128 0xa
 3331 02c2 F7020000 		.4byte	.LASF92
 3332 02c6 3D       		.byte	0x3d
 3333 02c7 0A       		.uleb128 0xa
 3334 02c8 94000000 		.4byte	.LASF93
 3335 02cc 3E       		.byte	0x3e
 3336 02cd 0A       		.uleb128 0xa
 3337 02ce 400A0000 		.4byte	.LASF94
 3338 02d2 3F       		.byte	0x3f
 3339 02d3 0A       		.uleb128 0xa
 3340 02d4 720B0000 		.4byte	.LASF95
 3341 02d8 40       		.byte	0x40
 3342 02d9 0A       		.uleb128 0xa
 3343 02da FF060000 		.4byte	.LASF96
 3344 02de 41       		.byte	0x41
 3345 02df 0A       		.uleb128 0xa
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 106


 3346 02e0 7B0D0000 		.4byte	.LASF97
 3347 02e4 42       		.byte	0x42
 3348 02e5 0A       		.uleb128 0xa
 3349 02e6 1A060000 		.4byte	.LASF98
 3350 02ea 43       		.byte	0x43
 3351 02eb 0A       		.uleb128 0xa
 3352 02ec 6E070000 		.4byte	.LASF99
 3353 02f0 44       		.byte	0x44
 3354 02f1 0A       		.uleb128 0xa
 3355 02f2 AF0C0000 		.4byte	.LASF100
 3356 02f6 45       		.byte	0x45
 3357 02f7 0A       		.uleb128 0xa
 3358 02f8 B1050000 		.4byte	.LASF101
 3359 02fc 46       		.byte	0x46
 3360 02fd 0A       		.uleb128 0xa
 3361 02fe 94040000 		.4byte	.LASF102
 3362 0302 47       		.byte	0x47
 3363 0303 0A       		.uleb128 0xa
 3364 0304 79080000 		.4byte	.LASF103
 3365 0308 48       		.byte	0x48
 3366 0309 0A       		.uleb128 0xa
 3367 030a 7E020000 		.4byte	.LASF104
 3368 030e 49       		.byte	0x49
 3369 030f 0A       		.uleb128 0xa
 3370 0310 D1090000 		.4byte	.LASF105
 3371 0314 4A       		.byte	0x4a
 3372 0315 0A       		.uleb128 0xa
 3373 0316 E4090000 		.4byte	.LASF106
 3374 031a 4B       		.byte	0x4b
 3375 031b 0A       		.uleb128 0xa
 3376 031c F7090000 		.4byte	.LASF107
 3377 0320 4C       		.byte	0x4c
 3378 0321 0A       		.uleb128 0xa
 3379 0322 0A0A0000 		.4byte	.LASF108
 3380 0326 4D       		.byte	0x4d
 3381 0327 00       		.byte	0
 3382 0328 0B       		.uleb128 0xb
 3383 0329 04       		.byte	0x4
 3384 032a 06       		.byte	0x6
 3385 032b 86       		.byte	0x86
 3386 032c 61030000 		.4byte	0x361
 3387 0330 0C       		.uleb128 0xc
 3388 0331 17040000 		.4byte	.LASF109
 3389 0335 06       		.byte	0x6
 3390 0336 87       		.byte	0x87
 3391 0337 D6000000 		.4byte	0xd6
 3392 033b 00       		.byte	0
 3393 033c 0C       		.uleb128 0xc
 3394 033d C10B0000 		.4byte	.LASF110
 3395 0341 06       		.byte	0x6
 3396 0342 88       		.byte	0x88
 3397 0343 D6000000 		.4byte	0xd6
 3398 0347 01       		.byte	0x1
 3399 0348 0C       		.uleb128 0xc
 3400 0349 390F0000 		.4byte	.LASF111
 3401 034d 06       		.byte	0x6
 3402 034e 89       		.byte	0x89
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 107


 3403 034f 3C010000 		.4byte	0x13c
 3404 0353 02       		.byte	0x2
 3405 0354 0C       		.uleb128 0xc
 3406 0355 030E0000 		.4byte	.LASF112
 3407 0359 06       		.byte	0x6
 3408 035a 8A       		.byte	0x8a
 3409 035b D6000000 		.4byte	0xd6
 3410 035f 03       		.byte	0x3
 3411 0360 00       		.byte	0
 3412 0361 02       		.uleb128 0x2
 3413 0362 2B010000 		.4byte	.LASF113
 3414 0366 06       		.byte	0x6
 3415 0367 8B       		.byte	0x8b
 3416 0368 28030000 		.4byte	0x328
 3417 036c 0B       		.uleb128 0xb
 3418 036d 0E       		.byte	0xe
 3419 036e 06       		.byte	0x6
 3420 036f 95       		.byte	0x95
 3421 0370 99030000 		.4byte	0x399
 3422 0374 0C       		.uleb128 0xc
 3423 0375 F9030000 		.4byte	.LASF114
 3424 0379 06       		.byte	0x6
 3425 037a 96       		.byte	0x96
 3426 037b D6000000 		.4byte	0xd6
 3427 037f 00       		.byte	0
 3428 0380 0C       		.uleb128 0xc
 3429 0381 200C0000 		.4byte	.LASF115
 3430 0385 06       		.byte	0x6
 3431 0386 97       		.byte	0x97
 3432 0387 D6000000 		.4byte	0xd6
 3433 038b 01       		.byte	0x1
 3434 038c 0C       		.uleb128 0xc
 3435 038d BC040000 		.4byte	.LASF116
 3436 0391 06       		.byte	0x6
 3437 0392 98       		.byte	0x98
 3438 0393 99030000 		.4byte	0x399
 3439 0397 02       		.byte	0x2
 3440 0398 00       		.byte	0
 3441 0399 0D       		.uleb128 0xd
 3442 039a B2000000 		.4byte	0xb2
 3443 039e A9030000 		.4byte	0x3a9
 3444 03a2 0E       		.uleb128 0xe
 3445 03a3 A9000000 		.4byte	0xa9
 3446 03a7 0B       		.byte	0xb
 3447 03a8 00       		.byte	0
 3448 03a9 02       		.uleb128 0x2
 3449 03aa 20040000 		.4byte	.LASF117
 3450 03ae 06       		.byte	0x6
 3451 03af 99       		.byte	0x99
 3452 03b0 6C030000 		.4byte	0x36c
 3453 03b4 0F       		.uleb128 0xf
 3454 03b5 1C01     		.2byte	0x11c
 3455 03b7 06       		.byte	0x6
 3456 03b8 A3       		.byte	0xa3
 3457 03b9 D6030000 		.4byte	0x3d6
 3458 03bd 0C       		.uleb128 0xc
 3459 03be F60D0000 		.4byte	.LASF118
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 108


 3460 03c2 06       		.byte	0x6
 3461 03c3 A4       		.byte	0xa4
 3462 03c4 61030000 		.4byte	0x361
 3463 03c8 00       		.byte	0
 3464 03c9 0C       		.uleb128 0xc
 3465 03ca B30F0000 		.4byte	.LASF119
 3466 03ce 06       		.byte	0x6
 3467 03cf A5       		.byte	0xa5
 3468 03d0 D6030000 		.4byte	0x3d6
 3469 03d4 04       		.byte	0x4
 3470 03d5 00       		.byte	0
 3471 03d6 0D       		.uleb128 0xd
 3472 03d7 A9030000 		.4byte	0x3a9
 3473 03db E6030000 		.4byte	0x3e6
 3474 03df 0E       		.uleb128 0xe
 3475 03e0 A9000000 		.4byte	0xa9
 3476 03e4 13       		.byte	0x13
 3477 03e5 00       		.byte	0
 3478 03e6 02       		.uleb128 0x2
 3479 03e7 78050000 		.4byte	.LASF120
 3480 03eb 06       		.byte	0x6
 3481 03ec A6       		.byte	0xa6
 3482 03ed B4030000 		.4byte	0x3b4
 3483 03f1 10       		.uleb128 0x10
 3484 03f2 E50E0000 		.4byte	.LASF127
 3485 03f6 0210     		.2byte	0x1002
 3486 03f8 07       		.byte	0x7
 3487 03f9 0C       		.byte	0xc
 3488 03fa 25040000 		.4byte	0x425
 3489 03fe 0C       		.uleb128 0xc
 3490 03ff 7B060000 		.4byte	.LASF121
 3491 0403 07       		.byte	0x7
 3492 0404 0D       		.byte	0xd
 3493 0405 25040000 		.4byte	0x425
 3494 0409 00       		.byte	0
 3495 040a 11       		.uleb128 0x11
 3496 040b AE0F0000 		.4byte	.LASF122
 3497 040f 07       		.byte	0x7
 3498 0410 0E       		.byte	0xe
 3499 0411 D6000000 		.4byte	0xd6
 3500 0415 0010     		.2byte	0x1000
 3501 0417 11       		.uleb128 0x11
 3502 0418 D5070000 		.4byte	.LASF123
 3503 041c 07       		.byte	0x7
 3504 041d 0F       		.byte	0xf
 3505 041e D6000000 		.4byte	0xd6
 3506 0422 0110     		.2byte	0x1001
 3507 0424 00       		.byte	0
 3508 0425 0D       		.uleb128 0xd
 3509 0426 D6000000 		.4byte	0xd6
 3510 042a 36040000 		.4byte	0x436
 3511 042e 12       		.uleb128 0x12
 3512 042f A9000000 		.4byte	0xa9
 3513 0433 FF0F     		.2byte	0xfff
 3514 0435 00       		.byte	0
 3515 0436 02       		.uleb128 0x2
 3516 0437 89040000 		.4byte	.LASF124
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 109


 3517 043b 02       		.byte	0x2
 3518 043c 62       		.byte	0x62
 3519 043d 89000000 		.4byte	0x89
 3520 0441 02       		.uleb128 0x2
 3521 0442 21100000 		.4byte	.LASF125
 3522 0446 02       		.byte	0x2
 3523 0447 63       		.byte	0x63
 3524 0448 9B000000 		.4byte	0x9b
 3525 044c 02       		.uleb128 0x2
 3526 044d 5E040000 		.4byte	.LASF126
 3527 0451 02       		.byte	0x2
 3528 0452 69       		.byte	0x69
 3529 0453 EC000000 		.4byte	0xec
 3530 0457 06       		.uleb128 0x6
 3531 0458 04       		.byte	0x4
 3532 0459 D6000000 		.4byte	0xd6
 3533 045d 13       		.uleb128 0x13
 3534 045e F00F0000 		.4byte	.LASF128
 3535 0462 14       		.byte	0x14
 3536 0463 08       		.byte	0x8
 3537 0464 B5       		.byte	0xb5
 3538 0465 A6040000 		.4byte	0x4a6
 3539 0469 0C       		.uleb128 0xc
 3540 046a 3C0C0000 		.4byte	.LASF129
 3541 046e 08       		.byte	0x8
 3542 046f B8       		.byte	0xb8
 3543 0470 4C040000 		.4byte	0x44c
 3544 0474 00       		.byte	0
 3545 0475 0C       		.uleb128 0xc
 3546 0476 9F0F0000 		.4byte	.LASF130
 3547 047a 08       		.byte	0x8
 3548 047b B9       		.byte	0xb9
 3549 047c A6040000 		.4byte	0x4a6
 3550 0480 04       		.byte	0x4
 3551 0481 0C       		.uleb128 0xc
 3552 0482 FC080000 		.4byte	.LASF131
 3553 0486 08       		.byte	0x8
 3554 0487 BA       		.byte	0xba
 3555 0488 A6040000 		.4byte	0x4a6
 3556 048c 08       		.byte	0x8
 3557 048d 0C       		.uleb128 0xc
 3558 048e 0F040000 		.4byte	.LASF132
 3559 0492 08       		.byte	0x8
 3560 0493 BB       		.byte	0xbb
 3561 0494 B0000000 		.4byte	0xb0
 3562 0498 0C       		.byte	0xc
 3563 0499 0C       		.uleb128 0xc
 3564 049a 79090000 		.4byte	.LASF133
 3565 049e 08       		.byte	0x8
 3566 049f BC       		.byte	0xbc
 3567 04a0 B0000000 		.4byte	0xb0
 3568 04a4 10       		.byte	0x10
 3569 04a5 00       		.byte	0
 3570 04a6 06       		.uleb128 0x6
 3571 04a7 04       		.byte	0x4
 3572 04a8 5D040000 		.4byte	0x45d
 3573 04ac 02       		.uleb128 0x2
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 110


 3574 04ad 960C0000 		.4byte	.LASF134
 3575 04b1 08       		.byte	0x8
 3576 04b2 BF       		.byte	0xbf
 3577 04b3 5D040000 		.4byte	0x45d
 3578 04b7 13       		.uleb128 0x13
 3579 04b8 18030000 		.4byte	.LASF135
 3580 04bc 0C       		.byte	0xc
 3581 04bd 08       		.byte	0x8
 3582 04be C1       		.byte	0xc1
 3583 04bf E8040000 		.4byte	0x4e8
 3584 04c3 0C       		.uleb128 0xc
 3585 04c4 3C0C0000 		.4byte	.LASF129
 3586 04c8 08       		.byte	0x8
 3587 04c9 C4       		.byte	0xc4
 3588 04ca 4C040000 		.4byte	0x44c
 3589 04ce 00       		.byte	0
 3590 04cf 0C       		.uleb128 0xc
 3591 04d0 9F0F0000 		.4byte	.LASF130
 3592 04d4 08       		.byte	0x8
 3593 04d5 C5       		.byte	0xc5
 3594 04d6 A6040000 		.4byte	0x4a6
 3595 04da 04       		.byte	0x4
 3596 04db 0C       		.uleb128 0xc
 3597 04dc FC080000 		.4byte	.LASF131
 3598 04e0 08       		.byte	0x8
 3599 04e1 C6       		.byte	0xc6
 3600 04e2 A6040000 		.4byte	0x4a6
 3601 04e6 08       		.byte	0x8
 3602 04e7 00       		.byte	0
 3603 04e8 02       		.uleb128 0x2
 3604 04e9 B1000000 		.4byte	.LASF136
 3605 04ed 08       		.byte	0x8
 3606 04ee C8       		.byte	0xc8
 3607 04ef B7040000 		.4byte	0x4b7
 3608 04f3 13       		.uleb128 0x13
 3609 04f4 F70A0000 		.4byte	.LASF137
 3610 04f8 14       		.byte	0x14
 3611 04f9 08       		.byte	0x8
 3612 04fa CD       		.byte	0xcd
 3613 04fb 24050000 		.4byte	0x524
 3614 04ff 0C       		.uleb128 0xc
 3615 0500 D0050000 		.4byte	.LASF138
 3616 0504 08       		.byte	0x8
 3617 0505 D0       		.byte	0xd0
 3618 0506 41040000 		.4byte	0x441
 3619 050a 00       		.byte	0
 3620 050b 0C       		.uleb128 0xc
 3621 050c 71090000 		.4byte	.LASF139
 3622 0510 08       		.byte	0x8
 3623 0511 D1       		.byte	0xd1
 3624 0512 24050000 		.4byte	0x524
 3625 0516 04       		.byte	0x4
 3626 0517 0C       		.uleb128 0xc
 3627 0518 90050000 		.4byte	.LASF140
 3628 051c 08       		.byte	0x8
 3629 051d D2       		.byte	0xd2
 3630 051e E8040000 		.4byte	0x4e8
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 111


 3631 0522 08       		.byte	0x8
 3632 0523 00       		.byte	0
 3633 0524 06       		.uleb128 0x6
 3634 0525 04       		.byte	0x4
 3635 0526 AC040000 		.4byte	0x4ac
 3636 052a 02       		.uleb128 0x2
 3637 052b 390B0000 		.4byte	.LASF141
 3638 052f 08       		.byte	0x8
 3639 0530 D4       		.byte	0xd4
 3640 0531 F3040000 		.4byte	0x4f3
 3641 0535 13       		.uleb128 0x13
 3642 0536 1B050000 		.4byte	.LASF142
 3643 053a 08       		.byte	0x8
 3644 053b 09       		.byte	0x9
 3645 053c 87       		.byte	0x87
 3646 053d 5A050000 		.4byte	0x55a
 3647 0541 0C       		.uleb128 0xc
 3648 0542 0C050000 		.4byte	.LASF143
 3649 0546 09       		.byte	0x9
 3650 0547 89       		.byte	0x89
 3651 0548 36040000 		.4byte	0x436
 3652 054c 00       		.byte	0
 3653 054d 0C       		.uleb128 0xc
 3654 054e A1050000 		.4byte	.LASF144
 3655 0552 09       		.byte	0x9
 3656 0553 8A       		.byte	0x8a
 3657 0554 4C040000 		.4byte	0x44c
 3658 0558 04       		.byte	0x4
 3659 0559 00       		.byte	0
 3660 055a 02       		.uleb128 0x2
 3661 055b C0000000 		.4byte	.LASF145
 3662 055f 09       		.byte	0x9
 3663 0560 8B       		.byte	0x8b
 3664 0561 35050000 		.4byte	0x535
 3665 0565 02       		.uleb128 0x2
 3666 0566 DC020000 		.4byte	.LASF146
 3667 056a 0A       		.byte	0xa
 3668 056b 58       		.byte	0x58
 3669 056c B0000000 		.4byte	0xb0
 3670 0570 14       		.uleb128 0x14
 3671 0571 04       		.byte	0x4
 3672 0572 01       		.byte	0x1
 3673 0573 88       		.byte	0x88
 3674 0574 8F050000 		.4byte	0x58f
 3675 0578 15       		.uleb128 0x15
 3676 0579 7E040000 		.4byte	.LASF147
 3677 057d 01       		.byte	0x1
 3678 057e 8A       		.byte	0x8a
 3679 057f 8F050000 		.4byte	0x58f
 3680 0583 15       		.uleb128 0x15
 3681 0584 2B0A0000 		.4byte	.LASF148
 3682 0588 01       		.byte	0x1
 3683 0589 8B       		.byte	0x8b
 3684 058a 41040000 		.4byte	0x441
 3685 058e 00       		.byte	0
 3686 058f 06       		.uleb128 0x6
 3687 0590 04       		.byte	0x4
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 112


 3688 0591 CB000000 		.4byte	0xcb
 3689 0595 13       		.uleb128 0x13
 3690 0596 AB090000 		.4byte	.LASF149
 3691 059a 50       		.byte	0x50
 3692 059b 01       		.byte	0x1
 3693 059c 82       		.byte	0x82
 3694 059d 3C060000 		.4byte	0x63c
 3695 05a1 0C       		.uleb128 0xc
 3696 05a2 71050000 		.4byte	.LASF150
 3697 05a6 01       		.byte	0x1
 3698 05a7 84       		.byte	0x84
 3699 05a8 8F050000 		.4byte	0x58f
 3700 05ac 00       		.byte	0
 3701 05ad 0C       		.uleb128 0xc
 3702 05ae A10C0000 		.4byte	.LASF151
 3703 05b2 01       		.byte	0x1
 3704 05b3 85       		.byte	0x85
 3705 05b4 8F050000 		.4byte	0x58f
 3706 05b8 04       		.byte	0x4
 3707 05b9 0C       		.uleb128 0xc
 3708 05ba 4C0F0000 		.4byte	.LASF152
 3709 05be 01       		.byte	0x1
 3710 05bf 86       		.byte	0x86
 3711 05c0 8F050000 		.4byte	0x58f
 3712 05c4 08       		.byte	0x8
 3713 05c5 16       		.uleb128 0x16
 3714 05c6 7500     		.ascii	"u\000"
 3715 05c8 01       		.byte	0x1
 3716 05c9 8C       		.byte	0x8c
 3717 05ca 70050000 		.4byte	0x570
 3718 05ce 0C       		.byte	0xc
 3719 05cf 0C       		.uleb128 0xc
 3720 05d0 D10E0000 		.4byte	.LASF153
 3721 05d4 01       		.byte	0x1
 3722 05d5 8E       		.byte	0x8e
 3723 05d6 2A050000 		.4byte	0x52a
 3724 05da 10       		.byte	0x10
 3725 05db 0C       		.uleb128 0xc
 3726 05dc 04020000 		.4byte	.LASF154
 3727 05e0 01       		.byte	0x1
 3728 05e1 8F       		.byte	0x8f
 3729 05e2 2A050000 		.4byte	0x52a
 3730 05e6 24       		.byte	0x24
 3731 05e7 0C       		.uleb128 0xc
 3732 05e8 AF0B0000 		.4byte	.LASF155
 3733 05ec 01       		.byte	0x1
 3734 05ed 91       		.byte	0x91
 3735 05ee 3C060000 		.4byte	0x63c
 3736 05f2 38       		.byte	0x38
 3737 05f3 0C       		.uleb128 0xc
 3738 05f4 930E0000 		.4byte	.LASF156
 3739 05f8 01       		.byte	0x1
 3740 05f9 92       		.byte	0x92
 3741 05fa 41040000 		.4byte	0x441
 3742 05fe 3C       		.byte	0x3c
 3743 05ff 0C       		.uleb128 0xc
 3744 0600 720F0000 		.4byte	.LASF157
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 113


 3745 0604 01       		.byte	0x1
 3746 0605 93       		.byte	0x93
 3747 0606 41040000 		.4byte	0x441
 3748 060a 40       		.byte	0x40
 3749 060b 0C       		.uleb128 0xc
 3750 060c 730A0000 		.4byte	.LASF158
 3751 0610 01       		.byte	0x1
 3752 0611 95       		.byte	0x95
 3753 0612 41060000 		.4byte	0x641
 3754 0616 44       		.byte	0x44
 3755 0617 0C       		.uleb128 0xc
 3756 0618 48040000 		.4byte	.LASF159
 3757 061c 01       		.byte	0x1
 3758 061d 96       		.byte	0x96
 3759 061e 41060000 		.4byte	0x641
 3760 0622 45       		.byte	0x45
 3761 0623 0C       		.uleb128 0xc
 3762 0624 50040000 		.4byte	.LASF160
 3763 0628 01       		.byte	0x1
 3764 0629 A1       		.byte	0xa1
 3765 062a 41040000 		.4byte	0x441
 3766 062e 48       		.byte	0x48
 3767 062f 0C       		.uleb128 0xc
 3768 0630 23000000 		.4byte	.LASF161
 3769 0634 01       		.byte	0x1
 3770 0635 A2       		.byte	0xa2
 3771 0636 D6000000 		.4byte	0xd6
 3772 063a 4C       		.byte	0x4c
 3773 063b 00       		.byte	0
 3774 063c 17       		.uleb128 0x17
 3775 063d 41040000 		.4byte	0x441
 3776 0641 17       		.uleb128 0x17
 3777 0642 CB000000 		.4byte	0xcb
 3778 0646 02       		.uleb128 0x2
 3779 0647 6A090000 		.4byte	.LASF162
 3780 064b 01       		.byte	0x1
 3781 064c A5       		.byte	0xa5
 3782 064d 95050000 		.4byte	0x595
 3783 0651 02       		.uleb128 0x2
 3784 0652 4C080000 		.4byte	.LASF163
 3785 0656 01       		.byte	0x1
 3786 0657 A9       		.byte	0xa9
 3787 0658 46060000 		.4byte	0x646
 3788 065c 13       		.uleb128 0x13
 3789 065d C8020000 		.4byte	.LASF164
 3790 0661 08       		.byte	0x8
 3791 0662 01       		.byte	0x1
 3792 0663 B6       		.byte	0xb6
 3793 0664 81060000 		.4byte	0x681
 3794 0668 0C       		.uleb128 0xc
 3795 0669 470C0000 		.4byte	.LASF165
 3796 066d 01       		.byte	0x1
 3797 066e B8       		.byte	0xb8
 3798 066f B9000000 		.4byte	0xb9
 3799 0673 00       		.byte	0
 3800 0674 0C       		.uleb128 0xc
 3801 0675 85090000 		.4byte	.LASF166
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 114


 3802 0679 01       		.byte	0x1
 3803 067a B9       		.byte	0xb9
 3804 067b 65050000 		.4byte	0x565
 3805 067f 04       		.byte	0x4
 3806 0680 00       		.byte	0
 3807 0681 02       		.uleb128 0x2
 3808 0682 7D030000 		.4byte	.LASF167
 3809 0686 01       		.byte	0x1
 3810 0687 BA       		.byte	0xba
 3811 0688 5C060000 		.4byte	0x65c
 3812 068c 02       		.uleb128 0x2
 3813 068d D9000000 		.4byte	.LASF168
 3814 0691 01       		.byte	0x1
 3815 0692 BF       		.byte	0xbf
 3816 0693 81060000 		.4byte	0x681
 3817 0697 18       		.uleb128 0x18
 3818 0698 39080000 		.4byte	.LASF238
 3819 069c 02       		.byte	0x2
 3820 069d F9       		.byte	0xf9
 3821 069e EC000000 		.4byte	0xec
 3822 06a2 03       		.byte	0x3
 3823 06a3 BE060000 		.4byte	0x6be
 3824 06a7 19       		.uleb128 0x19
 3825 06a8 11000000 		.4byte	.LASF169
 3826 06ac 02       		.byte	0x2
 3827 06ad FB       		.byte	0xfb
 3828 06ae EC000000 		.4byte	0xec
 3829 06b2 19       		.uleb128 0x19
 3830 06b3 30020000 		.4byte	.LASF170
 3831 06b7 02       		.byte	0x2
 3832 06b8 FB       		.byte	0xfb
 3833 06b9 EC000000 		.4byte	0xec
 3834 06bd 00       		.byte	0
 3835 06be 1A       		.uleb128 0x1a
 3836 06bf CF080000 		.4byte	.LASF239
 3837 06c3 02       		.byte	0x2
 3838 06c4 0D01     		.2byte	0x10d
 3839 06c6 03       		.byte	0x3
 3840 06c7 D8060000 		.4byte	0x6d8
 3841 06cb 1B       		.uleb128 0x1b
 3842 06cc CA000000 		.4byte	.LASF240
 3843 06d0 02       		.byte	0x2
 3844 06d1 0D01     		.2byte	0x10d
 3845 06d3 EC000000 		.4byte	0xec
 3846 06d7 00       		.byte	0
 3847 06d8 1C       		.uleb128 0x1c
 3848 06d9 080C0000 		.4byte	.LASF173
 3849 06dd 01       		.byte	0x1
 3850 06de 1701     		.2byte	0x117
 3851 06e0 36040000 		.4byte	0x436
 3852 06e4 00000000 		.4byte	.LFB68
 3853 06e8 B4000000 		.4byte	.LFE68-.LFB68
 3854 06ec 01       		.uleb128 0x1
 3855 06ed 9C       		.byte	0x9c
 3856 06ee 20070000 		.4byte	0x720
 3857 06f2 1D       		.uleb128 0x1d
 3858 06f3 F5080000 		.4byte	.LASF171
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 115


 3859 06f7 01       		.byte	0x1
 3860 06f8 1701     		.2byte	0x117
 3861 06fa 65050000 		.4byte	0x565
 3862 06fe 02       		.uleb128 0x2
 3863 06ff 91       		.byte	0x91
 3864 0700 6C       		.sleb128 -20
 3865 0701 1D       		.uleb128 0x1d
 3866 0702 74020000 		.4byte	.LASF172
 3867 0706 01       		.byte	0x1
 3868 0707 1701     		.2byte	0x117
 3869 0709 36040000 		.4byte	0x436
 3870 070d 02       		.uleb128 0x2
 3871 070e 91       		.byte	0x91
 3872 070f 68       		.sleb128 -24
 3873 0710 1E       		.uleb128 0x1e
 3874 0711 000C0000 		.4byte	.LASF176
 3875 0715 01       		.byte	0x1
 3876 0716 1901     		.2byte	0x119
 3877 0718 26070000 		.4byte	0x726
 3878 071c 02       		.uleb128 0x2
 3879 071d 91       		.byte	0x91
 3880 071e 74       		.sleb128 -12
 3881 071f 00       		.byte	0
 3882 0720 06       		.uleb128 0x6
 3883 0721 04       		.byte	0x4
 3884 0722 51060000 		.4byte	0x651
 3885 0726 07       		.uleb128 0x7
 3886 0727 20070000 		.4byte	0x720
 3887 072b 1C       		.uleb128 0x1c
 3888 072c E30A0000 		.4byte	.LASF174
 3889 0730 01       		.byte	0x1
 3890 0731 8201     		.2byte	0x182
 3891 0733 65050000 		.4byte	0x565
 3892 0737 00000000 		.4byte	.LFB69
 3893 073b 58000000 		.4byte	.LFE69-.LFB69
 3894 073f 01       		.uleb128 0x1
 3895 0740 9C       		.byte	0x9c
 3896 0741 A0070000 		.4byte	0x7a0
 3897 0745 1D       		.uleb128 0x1d
 3898 0746 6B080000 		.4byte	.LASF175
 3899 074a 01       		.byte	0x1
 3900 074b 8201     		.2byte	0x182
 3901 074d A0070000 		.4byte	0x7a0
 3902 0751 02       		.uleb128 0x2
 3903 0752 91       		.byte	0x91
 3904 0753 64       		.sleb128 -28
 3905 0754 1D       		.uleb128 0x1d
 3906 0755 720F0000 		.4byte	.LASF157
 3907 0759 01       		.byte	0x1
 3908 075a 8201     		.2byte	0x182
 3909 075c A0070000 		.4byte	0x7a0
 3910 0760 02       		.uleb128 0x2
 3911 0761 91       		.byte	0x91
 3912 0762 60       		.sleb128 -32
 3913 0763 1D       		.uleb128 0x1d
 3914 0764 23000000 		.4byte	.LASF161
 3915 0768 01       		.byte	0x1
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 116


 3916 0769 8201     		.2byte	0x182
 3917 076b A5070000 		.4byte	0x7a5
 3918 076f 02       		.uleb128 0x2
 3919 0770 91       		.byte	0x91
 3920 0771 5F       		.sleb128 -33
 3921 0772 1E       		.uleb128 0x1e
 3922 0773 52020000 		.4byte	.LASF177
 3923 0777 01       		.byte	0x1
 3924 0778 8401     		.2byte	0x184
 3925 077a 20070000 		.4byte	0x720
 3926 077e 02       		.uleb128 0x2
 3927 077f 91       		.byte	0x91
 3928 0780 70       		.sleb128 -16
 3929 0781 1E       		.uleb128 0x1e
 3930 0782 EC0E0000 		.4byte	.LASF178
 3931 0786 01       		.byte	0x1
 3932 0787 8501     		.2byte	0x185
 3933 0789 25000000 		.4byte	0x25
 3934 078d 02       		.uleb128 0x2
 3935 078e 91       		.byte	0x91
 3936 078f 74       		.sleb128 -12
 3937 0790 1E       		.uleb128 0x1e
 3938 0791 E20C0000 		.4byte	.LASF179
 3939 0795 01       		.byte	0x1
 3940 0796 8601     		.2byte	0x186
 3941 0798 57040000 		.4byte	0x457
 3942 079c 02       		.uleb128 0x2
 3943 079d 91       		.byte	0x91
 3944 079e 6C       		.sleb128 -20
 3945 079f 00       		.byte	0
 3946 07a0 07       		.uleb128 0x7
 3947 07a1 41040000 		.4byte	0x441
 3948 07a5 07       		.uleb128 0x7
 3949 07a6 D6000000 		.4byte	0xd6
 3950 07aa 1F       		.uleb128 0x1f
 3951 07ab D0040000 		.4byte	.LASF180
 3952 07af 01       		.byte	0x1
 3953 07b0 B001     		.2byte	0x1b0
 3954 07b2 00000000 		.4byte	.LFB70
 3955 07b6 6C000000 		.4byte	.LFE70-.LFB70
 3956 07ba 01       		.uleb128 0x1
 3957 07bb 9C       		.byte	0x9c
 3958 07bc 0C080000 		.4byte	0x80c
 3959 07c0 1D       		.uleb128 0x1d
 3960 07c1 6B080000 		.4byte	.LASF175
 3961 07c5 01       		.byte	0x1
 3962 07c6 B001     		.2byte	0x1b0
 3963 07c8 A0070000 		.4byte	0x7a0
 3964 07cc 02       		.uleb128 0x2
 3965 07cd 91       		.byte	0x91
 3966 07ce 74       		.sleb128 -12
 3967 07cf 1D       		.uleb128 0x1d
 3968 07d0 720F0000 		.4byte	.LASF157
 3969 07d4 01       		.byte	0x1
 3970 07d5 B001     		.2byte	0x1b0
 3971 07d7 A0070000 		.4byte	0x7a0
 3972 07db 02       		.uleb128 0x2
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 117


 3973 07dc 91       		.byte	0x91
 3974 07dd 70       		.sleb128 -16
 3975 07de 1D       		.uleb128 0x1d
 3976 07df E20C0000 		.4byte	.LASF179
 3977 07e3 01       		.byte	0x1
 3978 07e4 B001     		.2byte	0x1b0
 3979 07e6 57040000 		.4byte	0x457
 3980 07ea 02       		.uleb128 0x2
 3981 07eb 91       		.byte	0x91
 3982 07ec 6C       		.sleb128 -20
 3983 07ed 1D       		.uleb128 0x1d
 3984 07ee 23000000 		.4byte	.LASF161
 3985 07f2 01       		.byte	0x1
 3986 07f3 B001     		.2byte	0x1b0
 3987 07f5 A5070000 		.4byte	0x7a5
 3988 07f9 02       		.uleb128 0x2
 3989 07fa 91       		.byte	0x91
 3990 07fb 6B       		.sleb128 -21
 3991 07fc 1D       		.uleb128 0x1d
 3992 07fd 52020000 		.4byte	.LASF177
 3993 0801 01       		.byte	0x1
 3994 0802 B001     		.2byte	0x1b0
 3995 0804 20070000 		.4byte	0x720
 3996 0808 02       		.uleb128 0x2
 3997 0809 91       		.byte	0x91
 3998 080a 00       		.sleb128 0
 3999 080b 00       		.byte	0
 4000 080c 1F       		.uleb128 0x1f
 4001 080d 48000000 		.4byte	.LASF181
 4002 0811 01       		.byte	0x1
 4003 0812 DC01     		.2byte	0x1dc
 4004 0814 00000000 		.4byte	.LFB71
 4005 0818 4A000000 		.4byte	.LFE71-.LFB71
 4006 081c 01       		.uleb128 0x1
 4007 081d 9C       		.byte	0x9c
 4008 081e 32080000 		.4byte	0x832
 4009 0822 1D       		.uleb128 0x1d
 4010 0823 52020000 		.4byte	.LASF177
 4011 0827 01       		.byte	0x1
 4012 0828 DC01     		.2byte	0x1dc
 4013 082a 20070000 		.4byte	0x720
 4014 082e 02       		.uleb128 0x2
 4015 082f 91       		.byte	0x91
 4016 0830 74       		.sleb128 -12
 4017 0831 00       		.byte	0
 4018 0832 1C       		.uleb128 0x1c
 4019 0833 D5060000 		.4byte	.LASF182
 4020 0837 01       		.byte	0x1
 4021 0838 FA01     		.2byte	0x1fa
 4022 083a 65050000 		.4byte	0x565
 4023 083e 00000000 		.4byte	.LFB72
 4024 0842 30000000 		.4byte	.LFE72-.LFB72
 4025 0846 01       		.uleb128 0x1
 4026 0847 9C       		.byte	0x9c
 4027 0848 89080000 		.4byte	0x889
 4028 084c 1D       		.uleb128 0x1d
 4029 084d 23000000 		.4byte	.LASF161
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 118


 4030 0851 01       		.byte	0x1
 4031 0852 FA01     		.2byte	0x1fa
 4032 0854 A5070000 		.4byte	0x7a5
 4033 0858 02       		.uleb128 0x2
 4034 0859 91       		.byte	0x91
 4035 085a 67       		.sleb128 -25
 4036 085b 1E       		.uleb128 0x1e
 4037 085c 52020000 		.4byte	.LASF177
 4038 0860 01       		.byte	0x1
 4039 0861 FC01     		.2byte	0x1fc
 4040 0863 20070000 		.4byte	0x720
 4041 0867 02       		.uleb128 0x2
 4042 0868 91       		.byte	0x91
 4043 0869 6C       		.sleb128 -20
 4044 086a 1E       		.uleb128 0x1e
 4045 086b 6F000000 		.4byte	.LASF183
 4046 086f 01       		.byte	0x1
 4047 0870 FD01     		.2byte	0x1fd
 4048 0872 A0070000 		.4byte	0x7a0
 4049 0876 02       		.uleb128 0x2
 4050 0877 91       		.byte	0x91
 4051 0878 74       		.sleb128 -12
 4052 0879 1E       		.uleb128 0x1e
 4053 087a 400B0000 		.4byte	.LASF184
 4054 087e 01       		.byte	0x1
 4055 087f FD01     		.2byte	0x1fd
 4056 0881 A0070000 		.4byte	0x7a0
 4057 0885 02       		.uleb128 0x2
 4058 0886 91       		.byte	0x91
 4059 0887 70       		.sleb128 -16
 4060 0888 00       		.byte	0
 4061 0889 1C       		.uleb128 0x1c
 4062 088a FD0A0000 		.4byte	.LASF185
 4063 088e 01       		.byte	0x1
 4064 088f 3C02     		.2byte	0x23c
 4065 0891 36040000 		.4byte	0x436
 4066 0895 00000000 		.4byte	.LFB73
 4067 0899 74000000 		.4byte	.LFE73-.LFB73
 4068 089d 01       		.uleb128 0x1
 4069 089e 9C       		.byte	0x9c
 4070 089f D1080000 		.4byte	0x8d1
 4071 08a3 1D       		.uleb128 0x1d
 4072 08a4 FA040000 		.4byte	.LASF186
 4073 08a8 01       		.byte	0x1
 4074 08a9 3C02     		.2byte	0x23c
 4075 08ab 65050000 		.4byte	0x565
 4076 08af 02       		.uleb128 0x2
 4077 08b0 91       		.byte	0x91
 4078 08b1 64       		.sleb128 -28
 4079 08b2 1E       		.uleb128 0x1e
 4080 08b3 99050000 		.4byte	.LASF187
 4081 08b7 01       		.byte	0x1
 4082 08b8 3E02     		.2byte	0x23e
 4083 08ba 36040000 		.4byte	0x436
 4084 08be 02       		.uleb128 0x2
 4085 08bf 91       		.byte	0x91
 4086 08c0 6C       		.sleb128 -20
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 119


 4087 08c1 1E       		.uleb128 0x1e
 4088 08c2 66070000 		.4byte	.LASF188
 4089 08c6 01       		.byte	0x1
 4090 08c7 3F02     		.2byte	0x23f
 4091 08c9 26070000 		.4byte	0x726
 4092 08cd 02       		.uleb128 0x2
 4093 08ce 91       		.byte	0x91
 4094 08cf 68       		.sleb128 -24
 4095 08d0 00       		.byte	0
 4096 08d1 1C       		.uleb128 0x1c
 4097 08d2 3C010000 		.4byte	.LASF189
 4098 08d6 01       		.byte	0x1
 4099 08d7 7302     		.2byte	0x273
 4100 08d9 36040000 		.4byte	0x436
 4101 08dd 00000000 		.4byte	.LFB74
 4102 08e1 7E000000 		.4byte	.LFE74-.LFB74
 4103 08e5 01       		.uleb128 0x1
 4104 08e6 9C       		.byte	0x9c
 4105 08e7 28090000 		.4byte	0x928
 4106 08eb 1D       		.uleb128 0x1d
 4107 08ec FA040000 		.4byte	.LASF186
 4108 08f0 01       		.byte	0x1
 4109 08f1 7302     		.2byte	0x273
 4110 08f3 65050000 		.4byte	0x565
 4111 08f7 02       		.uleb128 0x2
 4112 08f8 91       		.byte	0x91
 4113 08f9 64       		.sleb128 -28
 4114 08fa 1D       		.uleb128 0x1d
 4115 08fb 90030000 		.4byte	.LASF190
 4116 08ff 01       		.byte	0x1
 4117 0900 7302     		.2byte	0x273
 4118 0902 4C040000 		.4byte	0x44c
 4119 0906 02       		.uleb128 0x2
 4120 0907 91       		.byte	0x91
 4121 0908 60       		.sleb128 -32
 4122 0909 1E       		.uleb128 0x1e
 4123 090a 99050000 		.4byte	.LASF187
 4124 090e 01       		.byte	0x1
 4125 090f 7502     		.2byte	0x275
 4126 0911 36040000 		.4byte	0x436
 4127 0915 02       		.uleb128 0x2
 4128 0916 91       		.byte	0x91
 4129 0917 6C       		.sleb128 -20
 4130 0918 1E       		.uleb128 0x1e
 4131 0919 66070000 		.4byte	.LASF188
 4132 091d 01       		.byte	0x1
 4133 091e 7602     		.2byte	0x276
 4134 0920 26070000 		.4byte	0x726
 4135 0924 02       		.uleb128 0x2
 4136 0925 91       		.byte	0x91
 4137 0926 68       		.sleb128 -24
 4138 0927 00       		.byte	0
 4139 0928 1C       		.uleb128 0x1c
 4140 0929 7B0A0000 		.4byte	.LASF191
 4141 092d 01       		.byte	0x1
 4142 092e B902     		.2byte	0x2b9
 4143 0930 65050000 		.4byte	0x565
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 120


 4144 0934 00000000 		.4byte	.LFB75
 4145 0938 3A000000 		.4byte	.LFE75-.LFB75
 4146 093c 01       		.uleb128 0x1
 4147 093d 9C       		.byte	0x9c
 4148 093e 70090000 		.4byte	0x970
 4149 0942 1D       		.uleb128 0x1d
 4150 0943 5A080000 		.4byte	.LASF192
 4151 0947 01       		.byte	0x1
 4152 0948 B902     		.2byte	0x2b9
 4153 094a A0070000 		.4byte	0x7a0
 4154 094e 02       		.uleb128 0x2
 4155 094f 91       		.byte	0x91
 4156 0950 6C       		.sleb128 -20
 4157 0951 1D       		.uleb128 0x1d
 4158 0952 6A0E0000 		.4byte	.LASF193
 4159 0956 01       		.byte	0x1
 4160 0957 B902     		.2byte	0x2b9
 4161 0959 A0070000 		.4byte	0x7a0
 4162 095d 02       		.uleb128 0x2
 4163 095e 91       		.byte	0x91
 4164 095f 68       		.sleb128 -24
 4165 0960 1E       		.uleb128 0x1e
 4166 0961 85090000 		.4byte	.LASF166
 4167 0965 01       		.byte	0x1
 4168 0966 BB02     		.2byte	0x2bb
 4169 0968 65050000 		.4byte	0x565
 4170 096c 02       		.uleb128 0x2
 4171 096d 91       		.byte	0x91
 4172 096e 74       		.sleb128 -12
 4173 096f 00       		.byte	0
 4174 0970 1C       		.uleb128 0x1c
 4175 0971 69060000 		.4byte	.LASF194
 4176 0975 01       		.byte	0x1
 4177 0976 D302     		.2byte	0x2d3
 4178 0978 36040000 		.4byte	0x436
 4179 097c 00000000 		.4byte	.LFB76
 4180 0980 A4010000 		.4byte	.LFE76-.LFB76
 4181 0984 01       		.uleb128 0x1
 4182 0985 9C       		.byte	0x9c
 4183 0986 030A0000 		.4byte	0xa03
 4184 098a 1D       		.uleb128 0x1d
 4185 098b F5080000 		.4byte	.LASF171
 4186 098f 01       		.byte	0x1
 4187 0990 D302     		.2byte	0x2d3
 4188 0992 65050000 		.4byte	0x565
 4189 0996 02       		.uleb128 0x2
 4190 0997 91       		.byte	0x91
 4191 0998 5C       		.sleb128 -36
 4192 0999 1D       		.uleb128 0x1d
 4193 099a 43090000 		.4byte	.LASF195
 4194 099e 01       		.byte	0x1
 4195 099f D302     		.2byte	0x2d3
 4196 09a1 030A0000 		.4byte	0xa03
 4197 09a5 02       		.uleb128 0x2
 4198 09a6 91       		.byte	0x91
 4199 09a7 58       		.sleb128 -40
 4200 09a8 1D       		.uleb128 0x1d
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 121


 4201 09a9 90030000 		.4byte	.LASF190
 4202 09ad 01       		.byte	0x1
 4203 09ae D302     		.2byte	0x2d3
 4204 09b0 4C040000 		.4byte	0x44c
 4205 09b4 02       		.uleb128 0x2
 4206 09b5 91       		.byte	0x91
 4207 09b6 54       		.sleb128 -44
 4208 09b7 1D       		.uleb128 0x1d
 4209 09b8 2E0C0000 		.4byte	.LASF196
 4210 09bc 01       		.byte	0x1
 4211 09bd D302     		.2byte	0x2d3
 4212 09bf 080A0000 		.4byte	0xa08
 4213 09c3 02       		.uleb128 0x2
 4214 09c4 91       		.byte	0x91
 4215 09c5 50       		.sleb128 -48
 4216 09c6 1E       		.uleb128 0x1e
 4217 09c7 8D090000 		.4byte	.LASF197
 4218 09cb 01       		.byte	0x1
 4219 09cc D502     		.2byte	0x2d5
 4220 09ce 36040000 		.4byte	0x436
 4221 09d2 02       		.uleb128 0x2
 4222 09d3 91       		.byte	0x91
 4223 09d4 74       		.sleb128 -12
 4224 09d5 1E       		.uleb128 0x1e
 4225 09d6 B0060000 		.4byte	.LASF198
 4226 09da 01       		.byte	0x1
 4227 09db D502     		.2byte	0x2d5
 4228 09dd 36040000 		.4byte	0x436
 4229 09e1 02       		.uleb128 0x2
 4230 09e2 91       		.byte	0x91
 4231 09e3 6C       		.sleb128 -20
 4232 09e4 1E       		.uleb128 0x1e
 4233 09e5 C7040000 		.4byte	.LASF199
 4234 09e9 01       		.byte	0x1
 4235 09ea D602     		.2byte	0x2d6
 4236 09ec 5A050000 		.4byte	0x55a
 4237 09f0 02       		.uleb128 0x2
 4238 09f1 91       		.byte	0x91
 4239 09f2 64       		.sleb128 -28
 4240 09f3 1E       		.uleb128 0x1e
 4241 09f4 000C0000 		.4byte	.LASF176
 4242 09f8 01       		.byte	0x1
 4243 09f9 D702     		.2byte	0x2d7
 4244 09fb 26070000 		.4byte	0x726
 4245 09ff 02       		.uleb128 0x2
 4246 0a00 91       		.byte	0x91
 4247 0a01 70       		.sleb128 -16
 4248 0a02 00       		.byte	0
 4249 0a03 07       		.uleb128 0x7
 4250 0a04 C4000000 		.4byte	0xc4
 4251 0a08 07       		.uleb128 0x7
 4252 0a09 36040000 		.4byte	0x436
 4253 0a0d 1C       		.uleb128 0x1c
 4254 0a0e 2F000000 		.4byte	.LASF200
 4255 0a12 01       		.byte	0x1
 4256 0a13 9903     		.2byte	0x399
 4257 0a15 36040000 		.4byte	0x436
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 122


 4258 0a19 00000000 		.4byte	.LFB77
 4259 0a1d D6000000 		.4byte	.LFE77-.LFB77
 4260 0a21 01       		.uleb128 0x1
 4261 0a22 9C       		.byte	0x9c
 4262 0a23 F60A0000 		.4byte	0xaf6
 4263 0a27 1D       		.uleb128 0x1d
 4264 0a28 F5080000 		.4byte	.LASF171
 4265 0a2c 01       		.byte	0x1
 4266 0a2d 9903     		.2byte	0x399
 4267 0a2f 65050000 		.4byte	0x565
 4268 0a33 02       		.uleb128 0x2
 4269 0a34 91       		.byte	0x91
 4270 0a35 54       		.sleb128 -44
 4271 0a36 1D       		.uleb128 0x1d
 4272 0a37 43090000 		.4byte	.LASF195
 4273 0a3b 01       		.byte	0x1
 4274 0a3c 9903     		.2byte	0x399
 4275 0a3e 030A0000 		.4byte	0xa03
 4276 0a42 02       		.uleb128 0x2
 4277 0a43 91       		.byte	0x91
 4278 0a44 50       		.sleb128 -48
 4279 0a45 1D       		.uleb128 0x1d
 4280 0a46 ED000000 		.4byte	.LASF201
 4281 0a4a 01       		.byte	0x1
 4282 0a4b 9903     		.2byte	0x399
 4283 0a4d FC0A0000 		.4byte	0xafc
 4284 0a51 02       		.uleb128 0x2
 4285 0a52 91       		.byte	0x91
 4286 0a53 4C       		.sleb128 -52
 4287 0a54 1D       		.uleb128 0x1d
 4288 0a55 2E0C0000 		.4byte	.LASF196
 4289 0a59 01       		.byte	0x1
 4290 0a5a 9903     		.2byte	0x399
 4291 0a5c 080A0000 		.4byte	0xa08
 4292 0a60 02       		.uleb128 0x2
 4293 0a61 91       		.byte	0x91
 4294 0a62 48       		.sleb128 -56
 4295 0a63 1E       		.uleb128 0x1e
 4296 0a64 99050000 		.4byte	.LASF187
 4297 0a68 01       		.byte	0x1
 4298 0a69 9B03     		.2byte	0x39b
 4299 0a6b 36040000 		.4byte	0x436
 4300 0a6f 02       		.uleb128 0x2
 4301 0a70 91       		.byte	0x91
 4302 0a71 74       		.sleb128 -12
 4303 0a72 1E       		.uleb128 0x1e
 4304 0a73 4C0B0000 		.4byte	.LASF202
 4305 0a77 01       		.byte	0x1
 4306 0a78 9C03     		.2byte	0x39c
 4307 0a7a 41040000 		.4byte	0x441
 4308 0a7e 02       		.uleb128 0x2
 4309 0a7f 91       		.byte	0x91
 4310 0a80 68       		.sleb128 -24
 4311 0a81 1E       		.uleb128 0x1e
 4312 0a82 000C0000 		.4byte	.LASF176
 4313 0a86 01       		.byte	0x1
 4314 0a87 9D03     		.2byte	0x39d
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 123


 4315 0a89 26070000 		.4byte	0x726
 4316 0a8d 02       		.uleb128 0x2
 4317 0a8e 91       		.byte	0x91
 4318 0a8f 70       		.sleb128 -16
 4319 0a90 20       		.uleb128 0x20
 4320 0a91 97060000 		.4byte	0x697
 4321 0a95 12000000 		.4byte	.LBB23
 4322 0a99 1A000000 		.4byte	.LBE23-.LBB23
 4323 0a9d 01       		.byte	0x1
 4324 0a9e B803     		.2byte	0x3b8
 4325 0aa0 BF0A0000 		.4byte	0xabf
 4326 0aa4 21       		.uleb128 0x21
 4327 0aa5 12000000 		.4byte	.LBB24
 4328 0aa9 1A000000 		.4byte	.LBE24-.LBB24
 4329 0aad 22       		.uleb128 0x22
 4330 0aae A7060000 		.4byte	0x6a7
 4331 0ab2 02       		.uleb128 0x2
 4332 0ab3 91       		.byte	0x91
 4333 0ab4 60       		.sleb128 -32
 4334 0ab5 22       		.uleb128 0x22
 4335 0ab6 B2060000 		.4byte	0x6b2
 4336 0aba 02       		.uleb128 0x2
 4337 0abb 91       		.byte	0x91
 4338 0abc 5C       		.sleb128 -36
 4339 0abd 00       		.byte	0
 4340 0abe 00       		.byte	0
 4341 0abf 23       		.uleb128 0x23
 4342 0ac0 40000000 		.4byte	.LBB25
 4343 0ac4 68000000 		.4byte	.LBE25-.LBB25
 4344 0ac8 DC0A0000 		.4byte	0xadc
 4345 0acc 1E       		.uleb128 0x1e
 4346 0acd 48040000 		.4byte	.LASF159
 4347 0ad1 01       		.byte	0x1
 4348 0ad2 BC03     		.2byte	0x3bc
 4349 0ad4 010B0000 		.4byte	0xb01
 4350 0ad8 02       		.uleb128 0x2
 4351 0ad9 91       		.byte	0x91
 4352 0ada 67       		.sleb128 -25
 4353 0adb 00       		.byte	0
 4354 0adc 24       		.uleb128 0x24
 4355 0add BE060000 		.4byte	0x6be
 4356 0ae1 C6000000 		.4byte	.LBB26
 4357 0ae5 06000000 		.4byte	.LBE26-.LBB26
 4358 0ae9 01       		.byte	0x1
 4359 0aea 2A04     		.2byte	0x42a
 4360 0aec 25       		.uleb128 0x25
 4361 0aed CB060000 		.4byte	0x6cb
 4362 0af1 02       		.uleb128 0x2
 4363 0af2 91       		.byte	0x91
 4364 0af3 6C       		.sleb128 -20
 4365 0af4 00       		.byte	0
 4366 0af5 00       		.byte	0
 4367 0af6 06       		.uleb128 0x6
 4368 0af7 04       		.byte	0x4
 4369 0af8 36040000 		.4byte	0x436
 4370 0afc 07       		.uleb128 0x7
 4371 0afd F60A0000 		.4byte	0xaf6
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 124


 4372 0b01 07       		.uleb128 0x7
 4373 0b02 CB000000 		.4byte	0xcb
 4374 0b06 1C       		.uleb128 0x1c
 4375 0b07 990A0000 		.4byte	.LASF203
 4376 0b0b 01       		.byte	0x1
 4377 0b0c 3004     		.2byte	0x430
 4378 0b0e 36040000 		.4byte	0x436
 4379 0b12 00000000 		.4byte	.LFB78
 4380 0b16 CE000000 		.4byte	.LFE78-.LFB78
 4381 0b1a 01       		.uleb128 0x1
 4382 0b1b 9C       		.byte	0x9c
 4383 0b1c EA0B0000 		.4byte	0xbea
 4384 0b20 1D       		.uleb128 0x1d
 4385 0b21 F5080000 		.4byte	.LASF171
 4386 0b25 01       		.byte	0x1
 4387 0b26 3004     		.2byte	0x430
 4388 0b28 65050000 		.4byte	0x565
 4389 0b2c 02       		.uleb128 0x2
 4390 0b2d 91       		.byte	0x91
 4391 0b2e 54       		.sleb128 -44
 4392 0b2f 1D       		.uleb128 0x1d
 4393 0b30 ED000000 		.4byte	.LASF201
 4394 0b34 01       		.byte	0x1
 4395 0b35 3004     		.2byte	0x430
 4396 0b37 FC0A0000 		.4byte	0xafc
 4397 0b3b 02       		.uleb128 0x2
 4398 0b3c 91       		.byte	0x91
 4399 0b3d 50       		.sleb128 -48
 4400 0b3e 1E       		.uleb128 0x1e
 4401 0b3f 99050000 		.4byte	.LASF187
 4402 0b43 01       		.byte	0x1
 4403 0b44 3204     		.2byte	0x432
 4404 0b46 36040000 		.4byte	0x436
 4405 0b4a 02       		.uleb128 0x2
 4406 0b4b 91       		.byte	0x91
 4407 0b4c 74       		.sleb128 -12
 4408 0b4d 1E       		.uleb128 0x1e
 4409 0b4e 4C0B0000 		.4byte	.LASF202
 4410 0b52 01       		.byte	0x1
 4411 0b53 3304     		.2byte	0x433
 4412 0b55 41040000 		.4byte	0x441
 4413 0b59 02       		.uleb128 0x2
 4414 0b5a 91       		.byte	0x91
 4415 0b5b 68       		.sleb128 -24
 4416 0b5c 1E       		.uleb128 0x1e
 4417 0b5d 000C0000 		.4byte	.LASF176
 4418 0b61 01       		.byte	0x1
 4419 0b62 3404     		.2byte	0x434
 4420 0b64 26070000 		.4byte	0x726
 4421 0b68 02       		.uleb128 0x2
 4422 0b69 91       		.byte	0x91
 4423 0b6a 70       		.sleb128 -16
 4424 0b6b 20       		.uleb128 0x20
 4425 0b6c 97060000 		.4byte	0x697
 4426 0b70 0E000000 		.4byte	.LBB28
 4427 0b74 1A000000 		.4byte	.LBE28-.LBB28
 4428 0b78 01       		.byte	0x1
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 125


 4429 0b79 5704     		.2byte	0x457
 4430 0b7b 9A0B0000 		.4byte	0xb9a
 4431 0b7f 21       		.uleb128 0x21
 4432 0b80 0E000000 		.4byte	.LBB29
 4433 0b84 1A000000 		.4byte	.LBE29-.LBB29
 4434 0b88 22       		.uleb128 0x22
 4435 0b89 A7060000 		.4byte	0x6a7
 4436 0b8d 02       		.uleb128 0x2
 4437 0b8e 91       		.byte	0x91
 4438 0b8f 5C       		.sleb128 -36
 4439 0b90 22       		.uleb128 0x22
 4440 0b91 B2060000 		.4byte	0x6b2
 4441 0b95 02       		.uleb128 0x2
 4442 0b96 91       		.byte	0x91
 4443 0b97 58       		.sleb128 -40
 4444 0b98 00       		.byte	0
 4445 0b99 00       		.byte	0
 4446 0b9a 23       		.uleb128 0x23
 4447 0b9b 2A000000 		.4byte	.LBB30
 4448 0b9f 94000000 		.4byte	.LBE30-.LBB30
 4449 0ba3 D00B0000 		.4byte	0xbd0
 4450 0ba7 1E       		.uleb128 0x1e
 4451 0ba8 AF0B0000 		.4byte	.LASF155
 4452 0bac 01       		.byte	0x1
 4453 0bad 5904     		.2byte	0x459
 4454 0baf A0070000 		.4byte	0x7a0
 4455 0bb3 02       		.uleb128 0x2
 4456 0bb4 91       		.byte	0x91
 4457 0bb5 64       		.sleb128 -28
 4458 0bb6 21       		.uleb128 0x21
 4459 0bb7 3A000000 		.4byte	.LBB31
 4460 0bbb 66000000 		.4byte	.LBE31-.LBB31
 4461 0bbf 1E       		.uleb128 0x1e
 4462 0bc0 48040000 		.4byte	.LASF159
 4463 0bc4 01       		.byte	0x1
 4464 0bc5 6004     		.2byte	0x460
 4465 0bc7 010B0000 		.4byte	0xb01
 4466 0bcb 02       		.uleb128 0x2
 4467 0bcc 91       		.byte	0x91
 4468 0bcd 63       		.sleb128 -29
 4469 0bce 00       		.byte	0
 4470 0bcf 00       		.byte	0
 4471 0bd0 24       		.uleb128 0x24
 4472 0bd1 BE060000 		.4byte	0x6be
 4473 0bd5 BE000000 		.4byte	.LBB32
 4474 0bd9 06000000 		.4byte	.LBE32-.LBB32
 4475 0bdd 01       		.byte	0x1
 4476 0bde CF04     		.2byte	0x4cf
 4477 0be0 25       		.uleb128 0x25
 4478 0be1 CB060000 		.4byte	0x6cb
 4479 0be5 02       		.uleb128 0x2
 4480 0be6 91       		.byte	0x91
 4481 0be7 6C       		.sleb128 -20
 4482 0be8 00       		.byte	0
 4483 0be9 00       		.byte	0
 4484 0bea 1C       		.uleb128 0x1c
 4485 0beb 33030000 		.4byte	.LASF204
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 126


 4486 0bef 01       		.byte	0x1
 4487 0bf0 D504     		.2byte	0x4d5
 4488 0bf2 36040000 		.4byte	0x436
 4489 0bf6 00000000 		.4byte	.LFB79
 4490 0bfa 14020000 		.4byte	.LFE79-.LFB79
 4491 0bfe 01       		.uleb128 0x1
 4492 0bff 9C       		.byte	0x9c
 4493 0c00 960C0000 		.4byte	0xc96
 4494 0c04 1D       		.uleb128 0x1d
 4495 0c05 F5080000 		.4byte	.LASF171
 4496 0c09 01       		.byte	0x1
 4497 0c0a D504     		.2byte	0x4d5
 4498 0c0c 65050000 		.4byte	0x565
 4499 0c10 02       		.uleb128 0x2
 4500 0c11 91       		.byte	0x91
 4501 0c12 5C       		.sleb128 -36
 4502 0c13 1D       		.uleb128 0x1d
 4503 0c14 E60B0000 		.4byte	.LASF205
 4504 0c18 01       		.byte	0x1
 4505 0c19 D504     		.2byte	0x4d5
 4506 0c1b 960C0000 		.4byte	0xc96
 4507 0c1f 02       		.uleb128 0x2
 4508 0c20 91       		.byte	0x91
 4509 0c21 58       		.sleb128 -40
 4510 0c22 1D       		.uleb128 0x1d
 4511 0c23 90030000 		.4byte	.LASF190
 4512 0c27 01       		.byte	0x1
 4513 0c28 D504     		.2byte	0x4d5
 4514 0c2a 4C040000 		.4byte	0x44c
 4515 0c2e 02       		.uleb128 0x2
 4516 0c2f 91       		.byte	0x91
 4517 0c30 54       		.sleb128 -44
 4518 0c31 1D       		.uleb128 0x1d
 4519 0c32 64030000 		.4byte	.LASF206
 4520 0c36 01       		.byte	0x1
 4521 0c37 D504     		.2byte	0x4d5
 4522 0c39 080A0000 		.4byte	0xa08
 4523 0c3d 02       		.uleb128 0x2
 4524 0c3e 91       		.byte	0x91
 4525 0c3f 50       		.sleb128 -48
 4526 0c40 1E       		.uleb128 0x1e
 4527 0c41 8D090000 		.4byte	.LASF197
 4528 0c45 01       		.byte	0x1
 4529 0c46 D704     		.2byte	0x4d7
 4530 0c48 36040000 		.4byte	0x436
 4531 0c4c 02       		.uleb128 0x2
 4532 0c4d 91       		.byte	0x91
 4533 0c4e 74       		.sleb128 -12
 4534 0c4f 1E       		.uleb128 0x1e
 4535 0c50 C7040000 		.4byte	.LASF199
 4536 0c54 01       		.byte	0x1
 4537 0c55 D804     		.2byte	0x4d8
 4538 0c57 5A050000 		.4byte	0x55a
 4539 0c5b 02       		.uleb128 0x2
 4540 0c5c 91       		.byte	0x91
 4541 0c5d 60       		.sleb128 -32
 4542 0c5e 1E       		.uleb128 0x1e
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 127


 4543 0c5f E2030000 		.4byte	.LASF207
 4544 0c63 01       		.byte	0x1
 4545 0c64 D904     		.2byte	0x4d9
 4546 0c66 8F050000 		.4byte	0x58f
 4547 0c6a 02       		.uleb128 0x2
 4548 0c6b 91       		.byte	0x91
 4549 0c6c 68       		.sleb128 -24
 4550 0c6d 1E       		.uleb128 0x1e
 4551 0c6e 000C0000 		.4byte	.LASF176
 4552 0c72 01       		.byte	0x1
 4553 0c73 DA04     		.2byte	0x4da
 4554 0c75 26070000 		.4byte	0x726
 4555 0c79 02       		.uleb128 0x2
 4556 0c7a 91       		.byte	0x91
 4557 0c7b 70       		.sleb128 -16
 4558 0c7c 21       		.uleb128 0x21
 4559 0c7d 1A000000 		.4byte	.LBB34
 4560 0c81 F8000000 		.4byte	.LBE34-.LBB34
 4561 0c85 1E       		.uleb128 0x1e
 4562 0c86 AF0B0000 		.4byte	.LASF155
 4563 0c8a 01       		.byte	0x1
 4564 0c8b EC04     		.2byte	0x4ec
 4565 0c8d A0070000 		.4byte	0x7a0
 4566 0c91 02       		.uleb128 0x2
 4567 0c92 91       		.byte	0x91
 4568 0c93 6C       		.sleb128 -20
 4569 0c94 00       		.byte	0
 4570 0c95 00       		.byte	0
 4571 0c96 07       		.uleb128 0x7
 4572 0c97 B0000000 		.4byte	0xb0
 4573 0c9b 1C       		.uleb128 0x1c
 4574 0c9c 43070000 		.4byte	.LASF208
 4575 0ca0 01       		.byte	0x1
 4576 0ca1 9A05     		.2byte	0x59a
 4577 0ca3 36040000 		.4byte	0x436
 4578 0ca7 00000000 		.4byte	.LFB80
 4579 0cab D4000000 		.4byte	.LFE80-.LFB80
 4580 0caf 01       		.uleb128 0x1
 4581 0cb0 9C       		.byte	0x9c
 4582 0cb1 8E0D0000 		.4byte	0xd8e
 4583 0cb5 1D       		.uleb128 0x1d
 4584 0cb6 F5080000 		.4byte	.LASF171
 4585 0cba 01       		.byte	0x1
 4586 0cbb 9A05     		.2byte	0x59a
 4587 0cbd 65050000 		.4byte	0x565
 4588 0cc1 02       		.uleb128 0x2
 4589 0cc2 91       		.byte	0x91
 4590 0cc3 54       		.sleb128 -44
 4591 0cc4 1D       		.uleb128 0x1d
 4592 0cc5 E60B0000 		.4byte	.LASF205
 4593 0cc9 01       		.byte	0x1
 4594 0cca 9A05     		.2byte	0x59a
 4595 0ccc 960C0000 		.4byte	0xc96
 4596 0cd0 02       		.uleb128 0x2
 4597 0cd1 91       		.byte	0x91
 4598 0cd2 50       		.sleb128 -48
 4599 0cd3 1D       		.uleb128 0x1d
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 128


 4600 0cd4 ED000000 		.4byte	.LASF201
 4601 0cd8 01       		.byte	0x1
 4602 0cd9 9A05     		.2byte	0x59a
 4603 0cdb FC0A0000 		.4byte	0xafc
 4604 0cdf 02       		.uleb128 0x2
 4605 0ce0 91       		.byte	0x91
 4606 0ce1 4C       		.sleb128 -52
 4607 0ce2 1E       		.uleb128 0x1e
 4608 0ce3 99050000 		.4byte	.LASF187
 4609 0ce7 01       		.byte	0x1
 4610 0ce8 9C05     		.2byte	0x59c
 4611 0cea 36040000 		.4byte	0x436
 4612 0cee 02       		.uleb128 0x2
 4613 0cef 91       		.byte	0x91
 4614 0cf0 74       		.sleb128 -12
 4615 0cf1 1E       		.uleb128 0x1e
 4616 0cf2 4C0B0000 		.4byte	.LASF202
 4617 0cf6 01       		.byte	0x1
 4618 0cf7 9D05     		.2byte	0x59d
 4619 0cf9 41040000 		.4byte	0x441
 4620 0cfd 02       		.uleb128 0x2
 4621 0cfe 91       		.byte	0x91
 4622 0cff 68       		.sleb128 -24
 4623 0d00 1E       		.uleb128 0x1e
 4624 0d01 000C0000 		.4byte	.LASF176
 4625 0d05 01       		.byte	0x1
 4626 0d06 9E05     		.2byte	0x59e
 4627 0d08 26070000 		.4byte	0x726
 4628 0d0c 02       		.uleb128 0x2
 4629 0d0d 91       		.byte	0x91
 4630 0d0e 70       		.sleb128 -16
 4631 0d0f 20       		.uleb128 0x20
 4632 0d10 97060000 		.4byte	0x697
 4633 0d14 10000000 		.4byte	.LBB35
 4634 0d18 1A000000 		.4byte	.LBE35-.LBB35
 4635 0d1c 01       		.byte	0x1
 4636 0d1d B305     		.2byte	0x5b3
 4637 0d1f 3E0D0000 		.4byte	0xd3e
 4638 0d23 21       		.uleb128 0x21
 4639 0d24 10000000 		.4byte	.LBB36
 4640 0d28 1A000000 		.4byte	.LBE36-.LBB36
 4641 0d2c 22       		.uleb128 0x22
 4642 0d2d A7060000 		.4byte	0x6a7
 4643 0d31 02       		.uleb128 0x2
 4644 0d32 91       		.byte	0x91
 4645 0d33 5C       		.sleb128 -36
 4646 0d34 22       		.uleb128 0x22
 4647 0d35 B2060000 		.4byte	0x6b2
 4648 0d39 02       		.uleb128 0x2
 4649 0d3a 91       		.byte	0x91
 4650 0d3b 58       		.sleb128 -40
 4651 0d3c 00       		.byte	0
 4652 0d3d 00       		.byte	0
 4653 0d3e 23       		.uleb128 0x23
 4654 0d3f 2C000000 		.4byte	.LBB37
 4655 0d43 98000000 		.4byte	.LBE37-.LBB37
 4656 0d47 740D0000 		.4byte	0xd74
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 129


 4657 0d4b 1E       		.uleb128 0x1e
 4658 0d4c AF0B0000 		.4byte	.LASF155
 4659 0d50 01       		.byte	0x1
 4660 0d51 B505     		.2byte	0x5b5
 4661 0d53 A0070000 		.4byte	0x7a0
 4662 0d57 02       		.uleb128 0x2
 4663 0d58 91       		.byte	0x91
 4664 0d59 64       		.sleb128 -28
 4665 0d5a 21       		.uleb128 0x21
 4666 0d5b 38000000 		.4byte	.LBB38
 4667 0d5f 6E000000 		.4byte	.LBE38-.LBB38
 4668 0d63 1E       		.uleb128 0x1e
 4669 0d64 730A0000 		.4byte	.LASF158
 4670 0d68 01       		.byte	0x1
 4671 0d69 BA05     		.2byte	0x5ba
 4672 0d6b 010B0000 		.4byte	0xb01
 4673 0d6f 02       		.uleb128 0x2
 4674 0d70 91       		.byte	0x91
 4675 0d71 63       		.sleb128 -29
 4676 0d72 00       		.byte	0
 4677 0d73 00       		.byte	0
 4678 0d74 24       		.uleb128 0x24
 4679 0d75 BE060000 		.4byte	0x6be
 4680 0d79 C4000000 		.4byte	.LBB39
 4681 0d7d 06000000 		.4byte	.LBE39-.LBB39
 4682 0d81 01       		.byte	0x1
 4683 0d82 EF05     		.2byte	0x5ef
 4684 0d84 25       		.uleb128 0x25
 4685 0d85 CB060000 		.4byte	0x6cb
 4686 0d89 02       		.uleb128 0x2
 4687 0d8a 91       		.byte	0x91
 4688 0d8b 6C       		.sleb128 -20
 4689 0d8c 00       		.byte	0
 4690 0d8d 00       		.byte	0
 4691 0d8e 1C       		.uleb128 0x1c
 4692 0d8f 64010000 		.4byte	.LASF209
 4693 0d93 01       		.byte	0x1
 4694 0d94 F505     		.2byte	0x5f5
 4695 0d96 36040000 		.4byte	0x436
 4696 0d9a 00000000 		.4byte	.LFB81
 4697 0d9e 8C000000 		.4byte	.LFE81-.LFB81
 4698 0da2 01       		.uleb128 0x1
 4699 0da3 9C       		.byte	0x9c
 4700 0da4 4B0E0000 		.4byte	0xe4b
 4701 0da8 1D       		.uleb128 0x1d
 4702 0da9 F5080000 		.4byte	.LASF171
 4703 0dad 01       		.byte	0x1
 4704 0dae F505     		.2byte	0x5f5
 4705 0db0 65050000 		.4byte	0x565
 4706 0db4 02       		.uleb128 0x2
 4707 0db5 91       		.byte	0x91
 4708 0db6 54       		.sleb128 -44
 4709 0db7 1D       		.uleb128 0x1d
 4710 0db8 E60B0000 		.4byte	.LASF205
 4711 0dbc 01       		.byte	0x1
 4712 0dbd F505     		.2byte	0x5f5
 4713 0dbf 960C0000 		.4byte	0xc96
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 130


 4714 0dc3 02       		.uleb128 0x2
 4715 0dc4 91       		.byte	0x91
 4716 0dc5 50       		.sleb128 -48
 4717 0dc6 1E       		.uleb128 0x1e
 4718 0dc7 99050000 		.4byte	.LASF187
 4719 0dcb 01       		.byte	0x1
 4720 0dcc F705     		.2byte	0x5f7
 4721 0dce 36040000 		.4byte	0x436
 4722 0dd2 02       		.uleb128 0x2
 4723 0dd3 91       		.byte	0x91
 4724 0dd4 74       		.sleb128 -12
 4725 0dd5 1E       		.uleb128 0x1e
 4726 0dd6 4C0B0000 		.4byte	.LASF202
 4727 0dda 01       		.byte	0x1
 4728 0ddb F805     		.2byte	0x5f8
 4729 0ddd 41040000 		.4byte	0x441
 4730 0de1 02       		.uleb128 0x2
 4731 0de2 91       		.byte	0x91
 4732 0de3 68       		.sleb128 -24
 4733 0de4 1E       		.uleb128 0x1e
 4734 0de5 E2030000 		.4byte	.LASF207
 4735 0de9 01       		.byte	0x1
 4736 0dea F905     		.2byte	0x5f9
 4737 0dec 8F050000 		.4byte	0x58f
 4738 0df0 02       		.uleb128 0x2
 4739 0df1 91       		.byte	0x91
 4740 0df2 64       		.sleb128 -28
 4741 0df3 1E       		.uleb128 0x1e
 4742 0df4 000C0000 		.4byte	.LASF176
 4743 0df8 01       		.byte	0x1
 4744 0df9 FA05     		.2byte	0x5fa
 4745 0dfb 26070000 		.4byte	0x726
 4746 0dff 02       		.uleb128 0x2
 4747 0e00 91       		.byte	0x91
 4748 0e01 70       		.sleb128 -16
 4749 0e02 20       		.uleb128 0x20
 4750 0e03 97060000 		.4byte	0x697
 4751 0e07 0E000000 		.4byte	.LBB41
 4752 0e0b 1A000000 		.4byte	.LBE41-.LBB41
 4753 0e0f 01       		.byte	0x1
 4754 0e10 1006     		.2byte	0x610
 4755 0e12 310E0000 		.4byte	0xe31
 4756 0e16 21       		.uleb128 0x21
 4757 0e17 0E000000 		.4byte	.LBB42
 4758 0e1b 1A000000 		.4byte	.LBE42-.LBB42
 4759 0e1f 22       		.uleb128 0x22
 4760 0e20 A7060000 		.4byte	0x6a7
 4761 0e24 02       		.uleb128 0x2
 4762 0e25 91       		.byte	0x91
 4763 0e26 60       		.sleb128 -32
 4764 0e27 22       		.uleb128 0x22
 4765 0e28 B2060000 		.4byte	0x6b2
 4766 0e2c 02       		.uleb128 0x2
 4767 0e2d 91       		.byte	0x91
 4768 0e2e 5C       		.sleb128 -36
 4769 0e2f 00       		.byte	0
 4770 0e30 00       		.byte	0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 131


 4771 0e31 24       		.uleb128 0x24
 4772 0e32 BE060000 		.4byte	0x6be
 4773 0e36 7C000000 		.4byte	.LBB43
 4774 0e3a 06000000 		.4byte	.LBE43-.LBB43
 4775 0e3e 01       		.byte	0x1
 4776 0e3f 2506     		.2byte	0x625
 4777 0e41 25       		.uleb128 0x25
 4778 0e42 CB060000 		.4byte	0x6cb
 4779 0e46 02       		.uleb128 0x2
 4780 0e47 91       		.byte	0x91
 4781 0e48 6C       		.sleb128 -20
 4782 0e49 00       		.byte	0
 4783 0e4a 00       		.byte	0
 4784 0e4b 1C       		.uleb128 0x1c
 4785 0e4c 7D000000 		.4byte	.LASF210
 4786 0e50 01       		.byte	0x1
 4787 0e51 2B06     		.2byte	0x62b
 4788 0e53 41040000 		.4byte	0x441
 4789 0e57 00000000 		.4byte	.LFB82
 4790 0e5b 20000000 		.4byte	.LFE82-.LFB82
 4791 0e5f 01       		.uleb128 0x1
 4792 0e60 9C       		.byte	0x9c
 4793 0e61 840E0000 		.4byte	0xe84
 4794 0e65 1D       		.uleb128 0x1d
 4795 0e66 F5080000 		.4byte	.LASF171
 4796 0e6a 01       		.byte	0x1
 4797 0e6b 2B06     		.2byte	0x62b
 4798 0e6d 840E0000 		.4byte	0xe84
 4799 0e71 02       		.uleb128 0x2
 4800 0e72 91       		.byte	0x91
 4801 0e73 6C       		.sleb128 -20
 4802 0e74 1E       		.uleb128 0x1e
 4803 0e75 E7060000 		.4byte	.LASF211
 4804 0e79 01       		.byte	0x1
 4805 0e7a 2D06     		.2byte	0x62d
 4806 0e7c 41040000 		.4byte	0x441
 4807 0e80 02       		.uleb128 0x2
 4808 0e81 91       		.byte	0x91
 4809 0e82 74       		.sleb128 -12
 4810 0e83 00       		.byte	0
 4811 0e84 07       		.uleb128 0x7
 4812 0e85 65050000 		.4byte	0x565
 4813 0e89 1C       		.uleb128 0x1c
 4814 0e8a FB0F0000 		.4byte	.LASF212
 4815 0e8e 01       		.byte	0x1
 4816 0e8f 3B06     		.2byte	0x63b
 4817 0e91 41040000 		.4byte	0x441
 4818 0e95 00000000 		.4byte	.LFB83
 4819 0e99 2A000000 		.4byte	.LFE83-.LFB83
 4820 0e9d 01       		.uleb128 0x1
 4821 0e9e 9C       		.byte	0x9c
 4822 0e9f D10E0000 		.4byte	0xed1
 4823 0ea3 1D       		.uleb128 0x1d
 4824 0ea4 F5080000 		.4byte	.LASF171
 4825 0ea8 01       		.byte	0x1
 4826 0ea9 3B06     		.2byte	0x63b
 4827 0eab 840E0000 		.4byte	0xe84
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 132


 4828 0eaf 02       		.uleb128 0x2
 4829 0eb0 91       		.byte	0x91
 4830 0eb1 6C       		.sleb128 -20
 4831 0eb2 1E       		.uleb128 0x1e
 4832 0eb3 E7060000 		.4byte	.LASF211
 4833 0eb7 01       		.byte	0x1
 4834 0eb8 3D06     		.2byte	0x63d
 4835 0eba 41040000 		.4byte	0x441
 4836 0ebe 02       		.uleb128 0x2
 4837 0ebf 91       		.byte	0x91
 4838 0ec0 70       		.sleb128 -16
 4839 0ec1 1E       		.uleb128 0x1e
 4840 0ec2 000C0000 		.4byte	.LASF176
 4841 0ec6 01       		.byte	0x1
 4842 0ec7 3E06     		.2byte	0x63e
 4843 0ec9 20070000 		.4byte	0x720
 4844 0ecd 02       		.uleb128 0x2
 4845 0ece 91       		.byte	0x91
 4846 0ecf 74       		.sleb128 -12
 4847 0ed0 00       		.byte	0
 4848 0ed1 26       		.uleb128 0x26
 4849 0ed2 07090000 		.4byte	.LASF213
 4850 0ed6 01       		.byte	0x1
 4851 0ed7 4D06     		.2byte	0x64d
 4852 0ed9 41040000 		.4byte	0x441
 4853 0edd 00000000 		.4byte	.LFB84
 4854 0ee1 1A000000 		.4byte	.LFE84-.LFB84
 4855 0ee5 01       		.uleb128 0x1
 4856 0ee6 9C       		.byte	0x9c
 4857 0ee7 0A0F0000 		.4byte	0xf0a
 4858 0eeb 1D       		.uleb128 0x1d
 4859 0eec F5080000 		.4byte	.LASF171
 4860 0ef0 01       		.byte	0x1
 4861 0ef1 4D06     		.2byte	0x64d
 4862 0ef3 840E0000 		.4byte	0xe84
 4863 0ef7 02       		.uleb128 0x2
 4864 0ef8 91       		.byte	0x91
 4865 0ef9 6C       		.sleb128 -20
 4866 0efa 1E       		.uleb128 0x1e
 4867 0efb E7060000 		.4byte	.LASF211
 4868 0eff 01       		.byte	0x1
 4869 0f00 4F06     		.2byte	0x64f
 4870 0f02 41040000 		.4byte	0x441
 4871 0f06 02       		.uleb128 0x2
 4872 0f07 91       		.byte	0x91
 4873 0f08 74       		.sleb128 -12
 4874 0f09 00       		.byte	0
 4875 0f0a 27       		.uleb128 0x27
 4876 0f0b 2C080000 		.4byte	.LASF215
 4877 0f0f 01       		.byte	0x1
 4878 0f10 5906     		.2byte	0x659
 4879 0f12 00000000 		.4byte	.LFB85
 4880 0f16 54000000 		.4byte	.LFE85-.LFB85
 4881 0f1a 01       		.uleb128 0x1
 4882 0f1b 9C       		.byte	0x9c
 4883 0f1c 3F0F0000 		.4byte	0xf3f
 4884 0f20 1D       		.uleb128 0x1d
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 133


 4885 0f21 F5080000 		.4byte	.LASF171
 4886 0f25 01       		.byte	0x1
 4887 0f26 5906     		.2byte	0x659
 4888 0f28 65050000 		.4byte	0x565
 4889 0f2c 02       		.uleb128 0x2
 4890 0f2d 91       		.byte	0x91
 4891 0f2e 6C       		.sleb128 -20
 4892 0f2f 1E       		.uleb128 0x1e
 4893 0f30 000C0000 		.4byte	.LASF176
 4894 0f34 01       		.byte	0x1
 4895 0f35 5B06     		.2byte	0x65b
 4896 0f37 26070000 		.4byte	0x726
 4897 0f3b 02       		.uleb128 0x2
 4898 0f3c 91       		.byte	0x91
 4899 0f3d 74       		.sleb128 -12
 4900 0f3e 00       		.byte	0
 4901 0f3f 26       		.uleb128 0x26
 4902 0f40 650D0000 		.4byte	.LASF214
 4903 0f44 01       		.byte	0x1
 4904 0f45 8506     		.2byte	0x685
 4905 0f47 41040000 		.4byte	0x441
 4906 0f4b 00000000 		.4byte	.LFB86
 4907 0f4f 16000000 		.4byte	.LFE86-.LFB86
 4908 0f53 01       		.uleb128 0x1
 4909 0f54 9C       		.byte	0x9c
 4910 0f55 690F0000 		.4byte	0xf69
 4911 0f59 1D       		.uleb128 0x1d
 4912 0f5a F5080000 		.4byte	.LASF171
 4913 0f5e 01       		.byte	0x1
 4914 0f5f 8506     		.2byte	0x685
 4915 0f61 65050000 		.4byte	0x565
 4916 0f65 02       		.uleb128 0x2
 4917 0f66 91       		.byte	0x91
 4918 0f67 74       		.sleb128 -12
 4919 0f68 00       		.byte	0
 4920 0f69 28       		.uleb128 0x28
 4921 0f6a 48030000 		.4byte	.LASF216
 4922 0f6e 01       		.byte	0x1
 4923 0f6f 8F06     		.2byte	0x68f
 4924 0f71 00000000 		.4byte	.LFB87
 4925 0f75 1A000000 		.4byte	.LFE87-.LFB87
 4926 0f79 01       		.uleb128 0x1
 4927 0f7a 9C       		.byte	0x9c
 4928 0f7b 9E0F0000 		.4byte	0xf9e
 4929 0f7f 1D       		.uleb128 0x1d
 4930 0f80 F5080000 		.4byte	.LASF171
 4931 0f84 01       		.byte	0x1
 4932 0f85 8F06     		.2byte	0x68f
 4933 0f87 65050000 		.4byte	0x565
 4934 0f8b 02       		.uleb128 0x2
 4935 0f8c 91       		.byte	0x91
 4936 0f8d 74       		.sleb128 -12
 4937 0f8e 1D       		.uleb128 0x1d
 4938 0f8f 50040000 		.4byte	.LASF160
 4939 0f93 01       		.byte	0x1
 4940 0f94 8F06     		.2byte	0x68f
 4941 0f96 41040000 		.4byte	0x441
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 134


 4942 0f9a 02       		.uleb128 0x2
 4943 0f9b 91       		.byte	0x91
 4944 0f9c 70       		.sleb128 -16
 4945 0f9d 00       		.byte	0
 4946 0f9e 26       		.uleb128 0x26
 4947 0f9f 5B000000 		.4byte	.LASF217
 4948 0fa3 01       		.byte	0x1
 4949 0fa4 9906     		.2byte	0x699
 4950 0fa6 D6000000 		.4byte	0xd6
 4951 0faa 00000000 		.4byte	.LFB88
 4952 0fae 18000000 		.4byte	.LFE88-.LFB88
 4953 0fb2 01       		.uleb128 0x1
 4954 0fb3 9C       		.byte	0x9c
 4955 0fb4 C80F0000 		.4byte	0xfc8
 4956 0fb8 1D       		.uleb128 0x1d
 4957 0fb9 F5080000 		.4byte	.LASF171
 4958 0fbd 01       		.byte	0x1
 4959 0fbe 9906     		.2byte	0x699
 4960 0fc0 65050000 		.4byte	0x565
 4961 0fc4 02       		.uleb128 0x2
 4962 0fc5 91       		.byte	0x91
 4963 0fc6 74       		.sleb128 -12
 4964 0fc7 00       		.byte	0
 4965 0fc8 29       		.uleb128 0x29
 4966 0fc9 91020000 		.4byte	.LASF221
 4967 0fcd 01       		.byte	0x1
 4968 0fce A106     		.2byte	0x6a1
 4969 0fd0 36040000 		.4byte	0x436
 4970 0fd4 00000000 		.4byte	.LFB89
 4971 0fd8 D4000000 		.4byte	.LFE89-.LFB89
 4972 0fdc 01       		.uleb128 0x1
 4973 0fdd 9C       		.byte	0x9c
 4974 0fde 2E100000 		.4byte	0x102e
 4975 0fe2 1D       		.uleb128 0x1d
 4976 0fe3 000C0000 		.4byte	.LASF176
 4977 0fe7 01       		.byte	0x1
 4978 0fe8 A106     		.2byte	0x6a1
 4979 0fea 26070000 		.4byte	0x726
 4980 0fee 02       		.uleb128 0x2
 4981 0fef 91       		.byte	0x91
 4982 0ff0 6C       		.sleb128 -20
 4983 0ff1 1D       		.uleb128 0x1d
 4984 0ff2 43090000 		.4byte	.LASF195
 4985 0ff6 01       		.byte	0x1
 4986 0ff7 A106     		.2byte	0x6a1
 4987 0ff9 C4000000 		.4byte	0xc4
 4988 0ffd 02       		.uleb128 0x2
 4989 0ffe 91       		.byte	0x91
 4990 0fff 68       		.sleb128 -24
 4991 1000 1D       		.uleb128 0x1d
 4992 1001 600E0000 		.4byte	.LASF218
 4993 1005 01       		.byte	0x1
 4994 1006 A106     		.2byte	0x6a1
 4995 1008 080A0000 		.4byte	0xa08
 4996 100c 02       		.uleb128 0x2
 4997 100d 91       		.byte	0x91
 4998 100e 64       		.sleb128 -28
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 135


 4999 100f 1E       		.uleb128 0x1e
 5000 1010 99050000 		.4byte	.LASF187
 5001 1014 01       		.byte	0x1
 5002 1015 A306     		.2byte	0x6a3
 5003 1017 36040000 		.4byte	0x436
 5004 101b 02       		.uleb128 0x2
 5005 101c 91       		.byte	0x91
 5006 101d 74       		.sleb128 -12
 5007 101e 1E       		.uleb128 0x1e
 5008 101f AF0B0000 		.4byte	.LASF155
 5009 1023 01       		.byte	0x1
 5010 1024 A406     		.2byte	0x6a4
 5011 1026 41040000 		.4byte	0x441
 5012 102a 02       		.uleb128 0x2
 5013 102b 91       		.byte	0x91
 5014 102c 70       		.sleb128 -16
 5015 102d 00       		.byte	0
 5016 102e 1F       		.uleb128 0x1f
 5017 102f 3D020000 		.4byte	.LASF219
 5018 1033 01       		.byte	0x1
 5019 1034 F006     		.2byte	0x6f0
 5020 1036 00000000 		.4byte	.LFB90
 5021 103a 4C000000 		.4byte	.LFE90-.LFB90
 5022 103e 01       		.uleb128 0x1
 5023 103f 9C       		.byte	0x9c
 5024 1040 63100000 		.4byte	0x1063
 5025 1044 1D       		.uleb128 0x1d
 5026 1045 000C0000 		.4byte	.LASF176
 5027 1049 01       		.byte	0x1
 5028 104a F006     		.2byte	0x6f0
 5029 104c 26070000 		.4byte	0x726
 5030 1050 02       		.uleb128 0x2
 5031 1051 91       		.byte	0x91
 5032 1052 74       		.sleb128 -12
 5033 1053 1D       		.uleb128 0x1d
 5034 1054 E60B0000 		.4byte	.LASF205
 5035 1058 01       		.byte	0x1
 5036 1059 F006     		.2byte	0x6f0
 5037 105b 960C0000 		.4byte	0xc96
 5038 105f 02       		.uleb128 0x2
 5039 1060 91       		.byte	0x91
 5040 1061 70       		.sleb128 -16
 5041 1062 00       		.byte	0
 5042 1063 1F       		.uleb128 0x1f
 5043 1064 630C0000 		.4byte	.LASF220
 5044 1068 01       		.byte	0x1
 5045 1069 0207     		.2byte	0x702
 5046 106b 00000000 		.4byte	.LFB91
 5047 106f A4000000 		.4byte	.LFE91-.LFB91
 5048 1073 01       		.uleb128 0x1
 5049 1074 9C       		.byte	0x9c
 5050 1075 BF100000 		.4byte	0x10bf
 5051 1079 1D       		.uleb128 0x1d
 5052 107a 000C0000 		.4byte	.LASF176
 5053 107e 01       		.byte	0x1
 5054 107f 0207     		.2byte	0x702
 5055 1081 26070000 		.4byte	0x726
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 136


 5056 1085 02       		.uleb128 0x2
 5057 1086 91       		.byte	0x91
 5058 1087 6C       		.sleb128 -20
 5059 1088 23       		.uleb128 0x23
 5060 1089 0C000000 		.4byte	.LBB45
 5061 108d 42000000 		.4byte	.LBE45-.LBB45
 5062 1091 A5100000 		.4byte	0x10a5
 5063 1095 1E       		.uleb128 0x1e
 5064 1096 48040000 		.4byte	.LASF159
 5065 109a 01       		.byte	0x1
 5066 109b 0C07     		.2byte	0x70c
 5067 109d CB000000 		.4byte	0xcb
 5068 10a1 02       		.uleb128 0x2
 5069 10a2 91       		.byte	0x91
 5070 10a3 77       		.sleb128 -9
 5071 10a4 00       		.byte	0
 5072 10a5 21       		.uleb128 0x21
 5073 10a6 56000000 		.4byte	.LBB46
 5074 10aa 42000000 		.4byte	.LBE46-.LBB46
 5075 10ae 1E       		.uleb128 0x1e
 5076 10af 730A0000 		.4byte	.LASF158
 5077 10b3 01       		.byte	0x1
 5078 10b4 5D07     		.2byte	0x75d
 5079 10b6 CB000000 		.4byte	0xcb
 5080 10ba 02       		.uleb128 0x2
 5081 10bb 91       		.byte	0x91
 5082 10bc 76       		.sleb128 -10
 5083 10bd 00       		.byte	0
 5084 10be 00       		.byte	0
 5085 10bf 29       		.uleb128 0x29
 5086 10c0 F2050000 		.4byte	.LASF222
 5087 10c4 01       		.byte	0x1
 5088 10c5 7A07     		.2byte	0x77a
 5089 10c7 36040000 		.4byte	0x436
 5090 10cb 00000000 		.4byte	.LFB92
 5091 10cf 2C000000 		.4byte	.LFE92-.LFB92
 5092 10d3 01       		.uleb128 0x1
 5093 10d4 9C       		.byte	0x9c
 5094 10d5 F8100000 		.4byte	0x10f8
 5095 10d9 1D       		.uleb128 0x1d
 5096 10da 000C0000 		.4byte	.LASF176
 5097 10de 01       		.byte	0x1
 5098 10df 7A07     		.2byte	0x77a
 5099 10e1 F8100000 		.4byte	0x10f8
 5100 10e5 02       		.uleb128 0x2
 5101 10e6 91       		.byte	0x91
 5102 10e7 6C       		.sleb128 -20
 5103 10e8 1E       		.uleb128 0x1e
 5104 10e9 99050000 		.4byte	.LASF187
 5105 10ed 01       		.byte	0x1
 5106 10ee 7C07     		.2byte	0x77c
 5107 10f0 36040000 		.4byte	0x436
 5108 10f4 02       		.uleb128 0x2
 5109 10f5 91       		.byte	0x91
 5110 10f6 74       		.sleb128 -12
 5111 10f7 00       		.byte	0
 5112 10f8 06       		.uleb128 0x6
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 137


 5113 10f9 04       		.byte	0x4
 5114 10fa FE100000 		.4byte	0x10fe
 5115 10fe 07       		.uleb128 0x7
 5116 10ff 51060000 		.4byte	0x651
 5117 1103 26       		.uleb128 0x26
 5118 1104 07010000 		.4byte	.LASF223
 5119 1108 01       		.byte	0x1
 5120 1109 8F07     		.2byte	0x78f
 5121 110b 36040000 		.4byte	0x436
 5122 110f 00000000 		.4byte	.LFB93
 5123 1113 26000000 		.4byte	.LFE93-.LFB93
 5124 1117 01       		.uleb128 0x1
 5125 1118 9C       		.byte	0x9c
 5126 1119 3C110000 		.4byte	0x113c
 5127 111d 1D       		.uleb128 0x1d
 5128 111e F5080000 		.4byte	.LASF171
 5129 1122 01       		.byte	0x1
 5130 1123 8F07     		.2byte	0x78f
 5131 1125 840E0000 		.4byte	0xe84
 5132 1129 02       		.uleb128 0x2
 5133 112a 91       		.byte	0x91
 5134 112b 6C       		.sleb128 -20
 5135 112c 1E       		.uleb128 0x1e
 5136 112d 99050000 		.4byte	.LASF187
 5137 1131 01       		.byte	0x1
 5138 1132 9107     		.2byte	0x791
 5139 1134 36040000 		.4byte	0x436
 5140 1138 02       		.uleb128 0x2
 5141 1139 91       		.byte	0x91
 5142 113a 74       		.sleb128 -12
 5143 113b 00       		.byte	0
 5144 113c 29       		.uleb128 0x29
 5145 113d 630B0000 		.4byte	.LASF224
 5146 1141 01       		.byte	0x1
 5147 1142 A107     		.2byte	0x7a1
 5148 1144 36040000 		.4byte	0x436
 5149 1148 00000000 		.4byte	.LFB94
 5150 114c 30000000 		.4byte	.LFE94-.LFB94
 5151 1150 01       		.uleb128 0x1
 5152 1151 9C       		.byte	0x9c
 5153 1152 75110000 		.4byte	0x1175
 5154 1156 1D       		.uleb128 0x1d
 5155 1157 000C0000 		.4byte	.LASF176
 5156 115b 01       		.byte	0x1
 5157 115c A107     		.2byte	0x7a1
 5158 115e F8100000 		.4byte	0x10f8
 5159 1162 02       		.uleb128 0x2
 5160 1163 91       		.byte	0x91
 5161 1164 6C       		.sleb128 -20
 5162 1165 1E       		.uleb128 0x1e
 5163 1166 99050000 		.4byte	.LASF187
 5164 116a 01       		.byte	0x1
 5165 116b A307     		.2byte	0x7a3
 5166 116d 36040000 		.4byte	0x436
 5167 1171 02       		.uleb128 0x2
 5168 1172 91       		.byte	0x91
 5169 1173 74       		.sleb128 -12
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 138


 5170 1174 00       		.byte	0
 5171 1175 26       		.uleb128 0x26
 5172 1176 CA0A0000 		.4byte	.LASF225
 5173 117a 01       		.byte	0x1
 5174 117b B607     		.2byte	0x7b6
 5175 117d 36040000 		.4byte	0x436
 5176 1181 00000000 		.4byte	.LFB95
 5177 1185 2A000000 		.4byte	.LFE95-.LFB95
 5178 1189 01       		.uleb128 0x1
 5179 118a 9C       		.byte	0x9c
 5180 118b AE110000 		.4byte	0x11ae
 5181 118f 1D       		.uleb128 0x1d
 5182 1190 F5080000 		.4byte	.LASF171
 5183 1194 01       		.byte	0x1
 5184 1195 B607     		.2byte	0x7b6
 5185 1197 840E0000 		.4byte	0xe84
 5186 119b 02       		.uleb128 0x2
 5187 119c 91       		.byte	0x91
 5188 119d 6C       		.sleb128 -20
 5189 119e 1E       		.uleb128 0x1e
 5190 119f 99050000 		.4byte	.LASF187
 5191 11a3 01       		.byte	0x1
 5192 11a4 B807     		.2byte	0x7b8
 5193 11a6 36040000 		.4byte	0x436
 5194 11aa 02       		.uleb128 0x2
 5195 11ab 91       		.byte	0x91
 5196 11ac 74       		.sleb128 -12
 5197 11ad 00       		.byte	0
 5198 11ae 28       		.uleb128 0x28
 5199 11af 2F070000 		.4byte	.LASF226
 5200 11b3 01       		.byte	0x1
 5201 11b4 DD08     		.2byte	0x8dd
 5202 11b6 00000000 		.4byte	.LFB96
 5203 11ba 50000000 		.4byte	.LFE96-.LFB96
 5204 11be 01       		.uleb128 0x1
 5205 11bf 9C       		.byte	0x9c
 5206 11c0 F1110000 		.4byte	0x11f1
 5207 11c4 1D       		.uleb128 0x1d
 5208 11c5 F5080000 		.4byte	.LASF171
 5209 11c9 01       		.byte	0x1
 5210 11ca DD08     		.2byte	0x8dd
 5211 11cc 65050000 		.4byte	0x565
 5212 11d0 02       		.uleb128 0x2
 5213 11d1 91       		.byte	0x91
 5214 11d2 6C       		.sleb128 -20
 5215 11d3 1D       		.uleb128 0x1d
 5216 11d4 470C0000 		.4byte	.LASF165
 5217 11d8 01       		.byte	0x1
 5218 11d9 DD08     		.2byte	0x8dd
 5219 11db B9000000 		.4byte	0xb9
 5220 11df 02       		.uleb128 0x2
 5221 11e0 91       		.byte	0x91
 5222 11e1 68       		.sleb128 -24
 5223 11e2 2A       		.uleb128 0x2a
 5224 11e3 757800   		.ascii	"ux\000"
 5225 11e6 01       		.byte	0x1
 5226 11e7 DF08     		.2byte	0x8df
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 139


 5227 11e9 41040000 		.4byte	0x441
 5228 11ed 02       		.uleb128 0x2
 5229 11ee 91       		.byte	0x91
 5230 11ef 74       		.sleb128 -12
 5231 11f0 00       		.byte	0
 5232 11f1 26       		.uleb128 0x26
 5233 11f2 12100000 		.4byte	.LASF227
 5234 11f6 01       		.byte	0x1
 5235 11f7 FA08     		.2byte	0x8fa
 5236 11f9 B9000000 		.4byte	0xb9
 5237 11fd 00000000 		.4byte	.LFB97
 5238 1201 4C000000 		.4byte	.LFE97-.LFB97
 5239 1205 01       		.uleb128 0x1
 5240 1206 9C       		.byte	0x9c
 5241 1207 38120000 		.4byte	0x1238
 5242 120b 1D       		.uleb128 0x1d
 5243 120c F5080000 		.4byte	.LASF171
 5244 1210 01       		.byte	0x1
 5245 1211 FA08     		.2byte	0x8fa
 5246 1213 65050000 		.4byte	0x565
 5247 1217 02       		.uleb128 0x2
 5248 1218 91       		.byte	0x91
 5249 1219 6C       		.sleb128 -20
 5250 121a 2A       		.uleb128 0x2a
 5251 121b 757800   		.ascii	"ux\000"
 5252 121e 01       		.byte	0x1
 5253 121f FC08     		.2byte	0x8fc
 5254 1221 41040000 		.4byte	0x441
 5255 1225 02       		.uleb128 0x2
 5256 1226 91       		.byte	0x91
 5257 1227 74       		.sleb128 -12
 5258 1228 1E       		.uleb128 0x1e
 5259 1229 06080000 		.4byte	.LASF228
 5260 122d 01       		.byte	0x1
 5261 122e FD08     		.2byte	0x8fd
 5262 1230 B9000000 		.4byte	0xb9
 5263 1234 02       		.uleb128 0x2
 5264 1235 91       		.byte	0x91
 5265 1236 70       		.sleb128 -16
 5266 1237 00       		.byte	0
 5267 1238 28       		.uleb128 0x28
 5268 1239 950D0000 		.4byte	.LASF229
 5269 123d 01       		.byte	0x1
 5270 123e 1609     		.2byte	0x916
 5271 1240 00000000 		.4byte	.LFB98
 5272 1244 50000000 		.4byte	.LFE98-.LFB98
 5273 1248 01       		.uleb128 0x1
 5274 1249 9C       		.byte	0x9c
 5275 124a 6C120000 		.4byte	0x126c
 5276 124e 1D       		.uleb128 0x1d
 5277 124f F5080000 		.4byte	.LASF171
 5278 1253 01       		.byte	0x1
 5279 1254 1609     		.2byte	0x916
 5280 1256 65050000 		.4byte	0x565
 5281 125a 02       		.uleb128 0x2
 5282 125b 91       		.byte	0x91
 5283 125c 6C       		.sleb128 -20
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 140


 5284 125d 2A       		.uleb128 0x2a
 5285 125e 757800   		.ascii	"ux\000"
 5286 1261 01       		.byte	0x1
 5287 1262 1809     		.2byte	0x918
 5288 1264 41040000 		.4byte	0x441
 5289 1268 02       		.uleb128 0x2
 5290 1269 91       		.byte	0x91
 5291 126a 74       		.sleb128 -12
 5292 126b 00       		.byte	0
 5293 126c 2B       		.uleb128 0x2b
 5294 126d EA020000 		.4byte	.LASF230
 5295 1271 0B       		.byte	0xb
 5296 1272 9606     		.2byte	0x696
 5297 1274 78120000 		.4byte	0x1278
 5298 1278 17       		.uleb128 0x17
 5299 1279 E1000000 		.4byte	0xe1
 5300 127d 0D       		.uleb128 0xd
 5301 127e D6000000 		.4byte	0xd6
 5302 1282 8D120000 		.4byte	0x128d
 5303 1286 0E       		.uleb128 0xe
 5304 1287 A9000000 		.4byte	0xa9
 5305 128b 0C       		.byte	0xc
 5306 128c 00       		.byte	0
 5307 128d 2C       		.uleb128 0x2c
 5308 128e 2D100000 		.4byte	.LASF231
 5309 1292 06       		.byte	0x6
 5310 1293 12       		.byte	0x12
 5311 1294 7D120000 		.4byte	0x127d
 5312 1298 05       		.uleb128 0x5
 5313 1299 03       		.byte	0x3
 5314 129a 00000000 		.4byte	sniffIDFilter
 5315 129e 2C       		.uleb128 0x2c
 5316 129f A80C0000 		.4byte	.LASF232
 5317 12a3 07       		.byte	0x7
 5318 12a4 10       		.byte	0x10
 5319 12a5 F1030000 		.4byte	0x3f1
 5320 12a9 05       		.uleb128 0x5
 5321 12aa 03       		.byte	0x3
 5322 12ab 00000000 		.4byte	buffer
 5323 12af 0D       		.uleb128 0xd
 5324 12b0 E6030000 		.4byte	0x3e6
 5325 12b4 BF120000 		.4byte	0x12bf
 5326 12b8 0E       		.uleb128 0xe
 5327 12b9 A9000000 		.4byte	0xa9
 5328 12bd 05       		.byte	0x5
 5329 12be 00       		.byte	0
 5330 12bf 2C       		.uleb128 0x2c
 5331 12c0 210E0000 		.4byte	.LASF233
 5332 12c4 0C       		.byte	0xc
 5333 12c5 0D       		.byte	0xd
 5334 12c6 AF120000 		.4byte	0x12af
 5335 12ca 05       		.uleb128 0x5
 5336 12cb 03       		.byte	0x3
 5337 12cc 00000000 		.4byte	objectList
 5338 12d0 0D       		.uleb128 0xd
 5339 12d1 8C060000 		.4byte	0x68c
 5340 12d5 E0120000 		.4byte	0x12e0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 141


 5341 12d9 0E       		.uleb128 0xe
 5342 12da A9000000 		.4byte	0xa9
 5343 12de 09       		.byte	0x9
 5344 12df 00       		.byte	0
 5345 12e0 2C       		.uleb128 0x2c
 5346 12e1 870C0000 		.4byte	.LASF234
 5347 12e5 01       		.byte	0x1
 5348 12e6 C4       		.byte	0xc4
 5349 12e7 D0120000 		.4byte	0x12d0
 5350 12eb 05       		.uleb128 0x5
 5351 12ec 03       		.byte	0x3
 5352 12ed 00000000 		.4byte	xQueueRegistry
 5353 12f1 00       		.byte	0
 5354              		.section	.debug_abbrev,"",%progbits
 5355              	.Ldebug_abbrev0:
 5356 0000 01       		.uleb128 0x1
 5357 0001 11       		.uleb128 0x11
 5358 0002 01       		.byte	0x1
 5359 0003 25       		.uleb128 0x25
 5360 0004 0E       		.uleb128 0xe
 5361 0005 13       		.uleb128 0x13
 5362 0006 0B       		.uleb128 0xb
 5363 0007 03       		.uleb128 0x3
 5364 0008 0E       		.uleb128 0xe
 5365 0009 1B       		.uleb128 0x1b
 5366 000a 0E       		.uleb128 0xe
 5367 000b 55       		.uleb128 0x55
 5368 000c 17       		.uleb128 0x17
 5369 000d 11       		.uleb128 0x11
 5370 000e 01       		.uleb128 0x1
 5371 000f 10       		.uleb128 0x10
 5372 0010 17       		.uleb128 0x17
 5373 0011 00       		.byte	0
 5374 0012 00       		.byte	0
 5375 0013 02       		.uleb128 0x2
 5376 0014 16       		.uleb128 0x16
 5377 0015 00       		.byte	0
 5378 0016 03       		.uleb128 0x3
 5379 0017 0E       		.uleb128 0xe
 5380 0018 3A       		.uleb128 0x3a
 5381 0019 0B       		.uleb128 0xb
 5382 001a 3B       		.uleb128 0x3b
 5383 001b 0B       		.uleb128 0xb
 5384 001c 49       		.uleb128 0x49
 5385 001d 13       		.uleb128 0x13
 5386 001e 00       		.byte	0
 5387 001f 00       		.byte	0
 5388 0020 03       		.uleb128 0x3
 5389 0021 24       		.uleb128 0x24
 5390 0022 00       		.byte	0
 5391 0023 0B       		.uleb128 0xb
 5392 0024 0B       		.uleb128 0xb
 5393 0025 3E       		.uleb128 0x3e
 5394 0026 0B       		.uleb128 0xb
 5395 0027 03       		.uleb128 0x3
 5396 0028 0E       		.uleb128 0xe
 5397 0029 00       		.byte	0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 142


 5398 002a 00       		.byte	0
 5399 002b 04       		.uleb128 0x4
 5400 002c 24       		.uleb128 0x24
 5401 002d 00       		.byte	0
 5402 002e 0B       		.uleb128 0xb
 5403 002f 0B       		.uleb128 0xb
 5404 0030 3E       		.uleb128 0x3e
 5405 0031 0B       		.uleb128 0xb
 5406 0032 03       		.uleb128 0x3
 5407 0033 08       		.uleb128 0x8
 5408 0034 00       		.byte	0
 5409 0035 00       		.byte	0
 5410 0036 05       		.uleb128 0x5
 5411 0037 0F       		.uleb128 0xf
 5412 0038 00       		.byte	0
 5413 0039 0B       		.uleb128 0xb
 5414 003a 0B       		.uleb128 0xb
 5415 003b 00       		.byte	0
 5416 003c 00       		.byte	0
 5417 003d 06       		.uleb128 0x6
 5418 003e 0F       		.uleb128 0xf
 5419 003f 00       		.byte	0
 5420 0040 0B       		.uleb128 0xb
 5421 0041 0B       		.uleb128 0xb
 5422 0042 49       		.uleb128 0x49
 5423 0043 13       		.uleb128 0x13
 5424 0044 00       		.byte	0
 5425 0045 00       		.byte	0
 5426 0046 07       		.uleb128 0x7
 5427 0047 26       		.uleb128 0x26
 5428 0048 00       		.byte	0
 5429 0049 49       		.uleb128 0x49
 5430 004a 13       		.uleb128 0x13
 5431 004b 00       		.byte	0
 5432 004c 00       		.byte	0
 5433 004d 08       		.uleb128 0x8
 5434 004e 26       		.uleb128 0x26
 5435 004f 00       		.byte	0
 5436 0050 00       		.byte	0
 5437 0051 00       		.byte	0
 5438 0052 09       		.uleb128 0x9
 5439 0053 04       		.uleb128 0x4
 5440 0054 01       		.byte	0x1
 5441 0055 0B       		.uleb128 0xb
 5442 0056 0B       		.uleb128 0xb
 5443 0057 49       		.uleb128 0x49
 5444 0058 13       		.uleb128 0x13
 5445 0059 3A       		.uleb128 0x3a
 5446 005a 0B       		.uleb128 0xb
 5447 005b 3B       		.uleb128 0x3b
 5448 005c 0B       		.uleb128 0xb
 5449 005d 01       		.uleb128 0x1
 5450 005e 13       		.uleb128 0x13
 5451 005f 00       		.byte	0
 5452 0060 00       		.byte	0
 5453 0061 0A       		.uleb128 0xa
 5454 0062 28       		.uleb128 0x28
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 143


 5455 0063 00       		.byte	0
 5456 0064 03       		.uleb128 0x3
 5457 0065 0E       		.uleb128 0xe
 5458 0066 1C       		.uleb128 0x1c
 5459 0067 0B       		.uleb128 0xb
 5460 0068 00       		.byte	0
 5461 0069 00       		.byte	0
 5462 006a 0B       		.uleb128 0xb
 5463 006b 13       		.uleb128 0x13
 5464 006c 01       		.byte	0x1
 5465 006d 0B       		.uleb128 0xb
 5466 006e 0B       		.uleb128 0xb
 5467 006f 3A       		.uleb128 0x3a
 5468 0070 0B       		.uleb128 0xb
 5469 0071 3B       		.uleb128 0x3b
 5470 0072 0B       		.uleb128 0xb
 5471 0073 01       		.uleb128 0x1
 5472 0074 13       		.uleb128 0x13
 5473 0075 00       		.byte	0
 5474 0076 00       		.byte	0
 5475 0077 0C       		.uleb128 0xc
 5476 0078 0D       		.uleb128 0xd
 5477 0079 00       		.byte	0
 5478 007a 03       		.uleb128 0x3
 5479 007b 0E       		.uleb128 0xe
 5480 007c 3A       		.uleb128 0x3a
 5481 007d 0B       		.uleb128 0xb
 5482 007e 3B       		.uleb128 0x3b
 5483 007f 0B       		.uleb128 0xb
 5484 0080 49       		.uleb128 0x49
 5485 0081 13       		.uleb128 0x13
 5486 0082 38       		.uleb128 0x38
 5487 0083 0B       		.uleb128 0xb
 5488 0084 00       		.byte	0
 5489 0085 00       		.byte	0
 5490 0086 0D       		.uleb128 0xd
 5491 0087 01       		.uleb128 0x1
 5492 0088 01       		.byte	0x1
 5493 0089 49       		.uleb128 0x49
 5494 008a 13       		.uleb128 0x13
 5495 008b 01       		.uleb128 0x1
 5496 008c 13       		.uleb128 0x13
 5497 008d 00       		.byte	0
 5498 008e 00       		.byte	0
 5499 008f 0E       		.uleb128 0xe
 5500 0090 21       		.uleb128 0x21
 5501 0091 00       		.byte	0
 5502 0092 49       		.uleb128 0x49
 5503 0093 13       		.uleb128 0x13
 5504 0094 2F       		.uleb128 0x2f
 5505 0095 0B       		.uleb128 0xb
 5506 0096 00       		.byte	0
 5507 0097 00       		.byte	0
 5508 0098 0F       		.uleb128 0xf
 5509 0099 13       		.uleb128 0x13
 5510 009a 01       		.byte	0x1
 5511 009b 0B       		.uleb128 0xb
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 144


 5512 009c 05       		.uleb128 0x5
 5513 009d 3A       		.uleb128 0x3a
 5514 009e 0B       		.uleb128 0xb
 5515 009f 3B       		.uleb128 0x3b
 5516 00a0 0B       		.uleb128 0xb
 5517 00a1 01       		.uleb128 0x1
 5518 00a2 13       		.uleb128 0x13
 5519 00a3 00       		.byte	0
 5520 00a4 00       		.byte	0
 5521 00a5 10       		.uleb128 0x10
 5522 00a6 13       		.uleb128 0x13
 5523 00a7 01       		.byte	0x1
 5524 00a8 03       		.uleb128 0x3
 5525 00a9 0E       		.uleb128 0xe
 5526 00aa 0B       		.uleb128 0xb
 5527 00ab 05       		.uleb128 0x5
 5528 00ac 3A       		.uleb128 0x3a
 5529 00ad 0B       		.uleb128 0xb
 5530 00ae 3B       		.uleb128 0x3b
 5531 00af 0B       		.uleb128 0xb
 5532 00b0 01       		.uleb128 0x1
 5533 00b1 13       		.uleb128 0x13
 5534 00b2 00       		.byte	0
 5535 00b3 00       		.byte	0
 5536 00b4 11       		.uleb128 0x11
 5537 00b5 0D       		.uleb128 0xd
 5538 00b6 00       		.byte	0
 5539 00b7 03       		.uleb128 0x3
 5540 00b8 0E       		.uleb128 0xe
 5541 00b9 3A       		.uleb128 0x3a
 5542 00ba 0B       		.uleb128 0xb
 5543 00bb 3B       		.uleb128 0x3b
 5544 00bc 0B       		.uleb128 0xb
 5545 00bd 49       		.uleb128 0x49
 5546 00be 13       		.uleb128 0x13
 5547 00bf 38       		.uleb128 0x38
 5548 00c0 05       		.uleb128 0x5
 5549 00c1 00       		.byte	0
 5550 00c2 00       		.byte	0
 5551 00c3 12       		.uleb128 0x12
 5552 00c4 21       		.uleb128 0x21
 5553 00c5 00       		.byte	0
 5554 00c6 49       		.uleb128 0x49
 5555 00c7 13       		.uleb128 0x13
 5556 00c8 2F       		.uleb128 0x2f
 5557 00c9 05       		.uleb128 0x5
 5558 00ca 00       		.byte	0
 5559 00cb 00       		.byte	0
 5560 00cc 13       		.uleb128 0x13
 5561 00cd 13       		.uleb128 0x13
 5562 00ce 01       		.byte	0x1
 5563 00cf 03       		.uleb128 0x3
 5564 00d0 0E       		.uleb128 0xe
 5565 00d1 0B       		.uleb128 0xb
 5566 00d2 0B       		.uleb128 0xb
 5567 00d3 3A       		.uleb128 0x3a
 5568 00d4 0B       		.uleb128 0xb
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 145


 5569 00d5 3B       		.uleb128 0x3b
 5570 00d6 0B       		.uleb128 0xb
 5571 00d7 01       		.uleb128 0x1
 5572 00d8 13       		.uleb128 0x13
 5573 00d9 00       		.byte	0
 5574 00da 00       		.byte	0
 5575 00db 14       		.uleb128 0x14
 5576 00dc 17       		.uleb128 0x17
 5577 00dd 01       		.byte	0x1
 5578 00de 0B       		.uleb128 0xb
 5579 00df 0B       		.uleb128 0xb
 5580 00e0 3A       		.uleb128 0x3a
 5581 00e1 0B       		.uleb128 0xb
 5582 00e2 3B       		.uleb128 0x3b
 5583 00e3 0B       		.uleb128 0xb
 5584 00e4 01       		.uleb128 0x1
 5585 00e5 13       		.uleb128 0x13
 5586 00e6 00       		.byte	0
 5587 00e7 00       		.byte	0
 5588 00e8 15       		.uleb128 0x15
 5589 00e9 0D       		.uleb128 0xd
 5590 00ea 00       		.byte	0
 5591 00eb 03       		.uleb128 0x3
 5592 00ec 0E       		.uleb128 0xe
 5593 00ed 3A       		.uleb128 0x3a
 5594 00ee 0B       		.uleb128 0xb
 5595 00ef 3B       		.uleb128 0x3b
 5596 00f0 0B       		.uleb128 0xb
 5597 00f1 49       		.uleb128 0x49
 5598 00f2 13       		.uleb128 0x13
 5599 00f3 00       		.byte	0
 5600 00f4 00       		.byte	0
 5601 00f5 16       		.uleb128 0x16
 5602 00f6 0D       		.uleb128 0xd
 5603 00f7 00       		.byte	0
 5604 00f8 03       		.uleb128 0x3
 5605 00f9 08       		.uleb128 0x8
 5606 00fa 3A       		.uleb128 0x3a
 5607 00fb 0B       		.uleb128 0xb
 5608 00fc 3B       		.uleb128 0x3b
 5609 00fd 0B       		.uleb128 0xb
 5610 00fe 49       		.uleb128 0x49
 5611 00ff 13       		.uleb128 0x13
 5612 0100 38       		.uleb128 0x38
 5613 0101 0B       		.uleb128 0xb
 5614 0102 00       		.byte	0
 5615 0103 00       		.byte	0
 5616 0104 17       		.uleb128 0x17
 5617 0105 35       		.uleb128 0x35
 5618 0106 00       		.byte	0
 5619 0107 49       		.uleb128 0x49
 5620 0108 13       		.uleb128 0x13
 5621 0109 00       		.byte	0
 5622 010a 00       		.byte	0
 5623 010b 18       		.uleb128 0x18
 5624 010c 2E       		.uleb128 0x2e
 5625 010d 01       		.byte	0x1
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 146


 5626 010e 03       		.uleb128 0x3
 5627 010f 0E       		.uleb128 0xe
 5628 0110 3A       		.uleb128 0x3a
 5629 0111 0B       		.uleb128 0xb
 5630 0112 3B       		.uleb128 0x3b
 5631 0113 0B       		.uleb128 0xb
 5632 0114 27       		.uleb128 0x27
 5633 0115 19       		.uleb128 0x19
 5634 0116 49       		.uleb128 0x49
 5635 0117 13       		.uleb128 0x13
 5636 0118 20       		.uleb128 0x20
 5637 0119 0B       		.uleb128 0xb
 5638 011a 01       		.uleb128 0x1
 5639 011b 13       		.uleb128 0x13
 5640 011c 00       		.byte	0
 5641 011d 00       		.byte	0
 5642 011e 19       		.uleb128 0x19
 5643 011f 34       		.uleb128 0x34
 5644 0120 00       		.byte	0
 5645 0121 03       		.uleb128 0x3
 5646 0122 0E       		.uleb128 0xe
 5647 0123 3A       		.uleb128 0x3a
 5648 0124 0B       		.uleb128 0xb
 5649 0125 3B       		.uleb128 0x3b
 5650 0126 0B       		.uleb128 0xb
 5651 0127 49       		.uleb128 0x49
 5652 0128 13       		.uleb128 0x13
 5653 0129 00       		.byte	0
 5654 012a 00       		.byte	0
 5655 012b 1A       		.uleb128 0x1a
 5656 012c 2E       		.uleb128 0x2e
 5657 012d 01       		.byte	0x1
 5658 012e 03       		.uleb128 0x3
 5659 012f 0E       		.uleb128 0xe
 5660 0130 3A       		.uleb128 0x3a
 5661 0131 0B       		.uleb128 0xb
 5662 0132 3B       		.uleb128 0x3b
 5663 0133 05       		.uleb128 0x5
 5664 0134 27       		.uleb128 0x27
 5665 0135 19       		.uleb128 0x19
 5666 0136 20       		.uleb128 0x20
 5667 0137 0B       		.uleb128 0xb
 5668 0138 01       		.uleb128 0x1
 5669 0139 13       		.uleb128 0x13
 5670 013a 00       		.byte	0
 5671 013b 00       		.byte	0
 5672 013c 1B       		.uleb128 0x1b
 5673 013d 05       		.uleb128 0x5
 5674 013e 00       		.byte	0
 5675 013f 03       		.uleb128 0x3
 5676 0140 0E       		.uleb128 0xe
 5677 0141 3A       		.uleb128 0x3a
 5678 0142 0B       		.uleb128 0xb
 5679 0143 3B       		.uleb128 0x3b
 5680 0144 05       		.uleb128 0x5
 5681 0145 49       		.uleb128 0x49
 5682 0146 13       		.uleb128 0x13
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 147


 5683 0147 00       		.byte	0
 5684 0148 00       		.byte	0
 5685 0149 1C       		.uleb128 0x1c
 5686 014a 2E       		.uleb128 0x2e
 5687 014b 01       		.byte	0x1
 5688 014c 3F       		.uleb128 0x3f
 5689 014d 19       		.uleb128 0x19
 5690 014e 03       		.uleb128 0x3
 5691 014f 0E       		.uleb128 0xe
 5692 0150 3A       		.uleb128 0x3a
 5693 0151 0B       		.uleb128 0xb
 5694 0152 3B       		.uleb128 0x3b
 5695 0153 05       		.uleb128 0x5
 5696 0154 27       		.uleb128 0x27
 5697 0155 19       		.uleb128 0x19
 5698 0156 49       		.uleb128 0x49
 5699 0157 13       		.uleb128 0x13
 5700 0158 11       		.uleb128 0x11
 5701 0159 01       		.uleb128 0x1
 5702 015a 12       		.uleb128 0x12
 5703 015b 06       		.uleb128 0x6
 5704 015c 40       		.uleb128 0x40
 5705 015d 18       		.uleb128 0x18
 5706 015e 9642     		.uleb128 0x2116
 5707 0160 19       		.uleb128 0x19
 5708 0161 01       		.uleb128 0x1
 5709 0162 13       		.uleb128 0x13
 5710 0163 00       		.byte	0
 5711 0164 00       		.byte	0
 5712 0165 1D       		.uleb128 0x1d
 5713 0166 05       		.uleb128 0x5
 5714 0167 00       		.byte	0
 5715 0168 03       		.uleb128 0x3
 5716 0169 0E       		.uleb128 0xe
 5717 016a 3A       		.uleb128 0x3a
 5718 016b 0B       		.uleb128 0xb
 5719 016c 3B       		.uleb128 0x3b
 5720 016d 05       		.uleb128 0x5
 5721 016e 49       		.uleb128 0x49
 5722 016f 13       		.uleb128 0x13
 5723 0170 02       		.uleb128 0x2
 5724 0171 18       		.uleb128 0x18
 5725 0172 00       		.byte	0
 5726 0173 00       		.byte	0
 5727 0174 1E       		.uleb128 0x1e
 5728 0175 34       		.uleb128 0x34
 5729 0176 00       		.byte	0
 5730 0177 03       		.uleb128 0x3
 5731 0178 0E       		.uleb128 0xe
 5732 0179 3A       		.uleb128 0x3a
 5733 017a 0B       		.uleb128 0xb
 5734 017b 3B       		.uleb128 0x3b
 5735 017c 05       		.uleb128 0x5
 5736 017d 49       		.uleb128 0x49
 5737 017e 13       		.uleb128 0x13
 5738 017f 02       		.uleb128 0x2
 5739 0180 18       		.uleb128 0x18
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 148


 5740 0181 00       		.byte	0
 5741 0182 00       		.byte	0
 5742 0183 1F       		.uleb128 0x1f
 5743 0184 2E       		.uleb128 0x2e
 5744 0185 01       		.byte	0x1
 5745 0186 03       		.uleb128 0x3
 5746 0187 0E       		.uleb128 0xe
 5747 0188 3A       		.uleb128 0x3a
 5748 0189 0B       		.uleb128 0xb
 5749 018a 3B       		.uleb128 0x3b
 5750 018b 05       		.uleb128 0x5
 5751 018c 27       		.uleb128 0x27
 5752 018d 19       		.uleb128 0x19
 5753 018e 11       		.uleb128 0x11
 5754 018f 01       		.uleb128 0x1
 5755 0190 12       		.uleb128 0x12
 5756 0191 06       		.uleb128 0x6
 5757 0192 40       		.uleb128 0x40
 5758 0193 18       		.uleb128 0x18
 5759 0194 9642     		.uleb128 0x2116
 5760 0196 19       		.uleb128 0x19
 5761 0197 01       		.uleb128 0x1
 5762 0198 13       		.uleb128 0x13
 5763 0199 00       		.byte	0
 5764 019a 00       		.byte	0
 5765 019b 20       		.uleb128 0x20
 5766 019c 1D       		.uleb128 0x1d
 5767 019d 01       		.byte	0x1
 5768 019e 31       		.uleb128 0x31
 5769 019f 13       		.uleb128 0x13
 5770 01a0 11       		.uleb128 0x11
 5771 01a1 01       		.uleb128 0x1
 5772 01a2 12       		.uleb128 0x12
 5773 01a3 06       		.uleb128 0x6
 5774 01a4 58       		.uleb128 0x58
 5775 01a5 0B       		.uleb128 0xb
 5776 01a6 59       		.uleb128 0x59
 5777 01a7 05       		.uleb128 0x5
 5778 01a8 01       		.uleb128 0x1
 5779 01a9 13       		.uleb128 0x13
 5780 01aa 00       		.byte	0
 5781 01ab 00       		.byte	0
 5782 01ac 21       		.uleb128 0x21
 5783 01ad 0B       		.uleb128 0xb
 5784 01ae 01       		.byte	0x1
 5785 01af 11       		.uleb128 0x11
 5786 01b0 01       		.uleb128 0x1
 5787 01b1 12       		.uleb128 0x12
 5788 01b2 06       		.uleb128 0x6
 5789 01b3 00       		.byte	0
 5790 01b4 00       		.byte	0
 5791 01b5 22       		.uleb128 0x22
 5792 01b6 34       		.uleb128 0x34
 5793 01b7 00       		.byte	0
 5794 01b8 31       		.uleb128 0x31
 5795 01b9 13       		.uleb128 0x13
 5796 01ba 02       		.uleb128 0x2
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 149


 5797 01bb 18       		.uleb128 0x18
 5798 01bc 00       		.byte	0
 5799 01bd 00       		.byte	0
 5800 01be 23       		.uleb128 0x23
 5801 01bf 0B       		.uleb128 0xb
 5802 01c0 01       		.byte	0x1
 5803 01c1 11       		.uleb128 0x11
 5804 01c2 01       		.uleb128 0x1
 5805 01c3 12       		.uleb128 0x12
 5806 01c4 06       		.uleb128 0x6
 5807 01c5 01       		.uleb128 0x1
 5808 01c6 13       		.uleb128 0x13
 5809 01c7 00       		.byte	0
 5810 01c8 00       		.byte	0
 5811 01c9 24       		.uleb128 0x24
 5812 01ca 1D       		.uleb128 0x1d
 5813 01cb 01       		.byte	0x1
 5814 01cc 31       		.uleb128 0x31
 5815 01cd 13       		.uleb128 0x13
 5816 01ce 11       		.uleb128 0x11
 5817 01cf 01       		.uleb128 0x1
 5818 01d0 12       		.uleb128 0x12
 5819 01d1 06       		.uleb128 0x6
 5820 01d2 58       		.uleb128 0x58
 5821 01d3 0B       		.uleb128 0xb
 5822 01d4 59       		.uleb128 0x59
 5823 01d5 05       		.uleb128 0x5
 5824 01d6 00       		.byte	0
 5825 01d7 00       		.byte	0
 5826 01d8 25       		.uleb128 0x25
 5827 01d9 05       		.uleb128 0x5
 5828 01da 00       		.byte	0
 5829 01db 31       		.uleb128 0x31
 5830 01dc 13       		.uleb128 0x13
 5831 01dd 02       		.uleb128 0x2
 5832 01de 18       		.uleb128 0x18
 5833 01df 00       		.byte	0
 5834 01e0 00       		.byte	0
 5835 01e1 26       		.uleb128 0x26
 5836 01e2 2E       		.uleb128 0x2e
 5837 01e3 01       		.byte	0x1
 5838 01e4 3F       		.uleb128 0x3f
 5839 01e5 19       		.uleb128 0x19
 5840 01e6 03       		.uleb128 0x3
 5841 01e7 0E       		.uleb128 0xe
 5842 01e8 3A       		.uleb128 0x3a
 5843 01e9 0B       		.uleb128 0xb
 5844 01ea 3B       		.uleb128 0x3b
 5845 01eb 05       		.uleb128 0x5
 5846 01ec 27       		.uleb128 0x27
 5847 01ed 19       		.uleb128 0x19
 5848 01ee 49       		.uleb128 0x49
 5849 01ef 13       		.uleb128 0x13
 5850 01f0 11       		.uleb128 0x11
 5851 01f1 01       		.uleb128 0x1
 5852 01f2 12       		.uleb128 0x12
 5853 01f3 06       		.uleb128 0x6
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 150


 5854 01f4 40       		.uleb128 0x40
 5855 01f5 18       		.uleb128 0x18
 5856 01f6 9742     		.uleb128 0x2117
 5857 01f8 19       		.uleb128 0x19
 5858 01f9 01       		.uleb128 0x1
 5859 01fa 13       		.uleb128 0x13
 5860 01fb 00       		.byte	0
 5861 01fc 00       		.byte	0
 5862 01fd 27       		.uleb128 0x27
 5863 01fe 2E       		.uleb128 0x2e
 5864 01ff 01       		.byte	0x1
 5865 0200 3F       		.uleb128 0x3f
 5866 0201 19       		.uleb128 0x19
 5867 0202 03       		.uleb128 0x3
 5868 0203 0E       		.uleb128 0xe
 5869 0204 3A       		.uleb128 0x3a
 5870 0205 0B       		.uleb128 0xb
 5871 0206 3B       		.uleb128 0x3b
 5872 0207 05       		.uleb128 0x5
 5873 0208 27       		.uleb128 0x27
 5874 0209 19       		.uleb128 0x19
 5875 020a 11       		.uleb128 0x11
 5876 020b 01       		.uleb128 0x1
 5877 020c 12       		.uleb128 0x12
 5878 020d 06       		.uleb128 0x6
 5879 020e 40       		.uleb128 0x40
 5880 020f 18       		.uleb128 0x18
 5881 0210 9642     		.uleb128 0x2116
 5882 0212 19       		.uleb128 0x19
 5883 0213 01       		.uleb128 0x1
 5884 0214 13       		.uleb128 0x13
 5885 0215 00       		.byte	0
 5886 0216 00       		.byte	0
 5887 0217 28       		.uleb128 0x28
 5888 0218 2E       		.uleb128 0x2e
 5889 0219 01       		.byte	0x1
 5890 021a 3F       		.uleb128 0x3f
 5891 021b 19       		.uleb128 0x19
 5892 021c 03       		.uleb128 0x3
 5893 021d 0E       		.uleb128 0xe
 5894 021e 3A       		.uleb128 0x3a
 5895 021f 0B       		.uleb128 0xb
 5896 0220 3B       		.uleb128 0x3b
 5897 0221 05       		.uleb128 0x5
 5898 0222 27       		.uleb128 0x27
 5899 0223 19       		.uleb128 0x19
 5900 0224 11       		.uleb128 0x11
 5901 0225 01       		.uleb128 0x1
 5902 0226 12       		.uleb128 0x12
 5903 0227 06       		.uleb128 0x6
 5904 0228 40       		.uleb128 0x40
 5905 0229 18       		.uleb128 0x18
 5906 022a 9742     		.uleb128 0x2117
 5907 022c 19       		.uleb128 0x19
 5908 022d 01       		.uleb128 0x1
 5909 022e 13       		.uleb128 0x13
 5910 022f 00       		.byte	0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 151


 5911 0230 00       		.byte	0
 5912 0231 29       		.uleb128 0x29
 5913 0232 2E       		.uleb128 0x2e
 5914 0233 01       		.byte	0x1
 5915 0234 03       		.uleb128 0x3
 5916 0235 0E       		.uleb128 0xe
 5917 0236 3A       		.uleb128 0x3a
 5918 0237 0B       		.uleb128 0xb
 5919 0238 3B       		.uleb128 0x3b
 5920 0239 05       		.uleb128 0x5
 5921 023a 27       		.uleb128 0x27
 5922 023b 19       		.uleb128 0x19
 5923 023c 49       		.uleb128 0x49
 5924 023d 13       		.uleb128 0x13
 5925 023e 11       		.uleb128 0x11
 5926 023f 01       		.uleb128 0x1
 5927 0240 12       		.uleb128 0x12
 5928 0241 06       		.uleb128 0x6
 5929 0242 40       		.uleb128 0x40
 5930 0243 18       		.uleb128 0x18
 5931 0244 9642     		.uleb128 0x2116
 5932 0246 19       		.uleb128 0x19
 5933 0247 01       		.uleb128 0x1
 5934 0248 13       		.uleb128 0x13
 5935 0249 00       		.byte	0
 5936 024a 00       		.byte	0
 5937 024b 2A       		.uleb128 0x2a
 5938 024c 34       		.uleb128 0x34
 5939 024d 00       		.byte	0
 5940 024e 03       		.uleb128 0x3
 5941 024f 08       		.uleb128 0x8
 5942 0250 3A       		.uleb128 0x3a
 5943 0251 0B       		.uleb128 0xb
 5944 0252 3B       		.uleb128 0x3b
 5945 0253 05       		.uleb128 0x5
 5946 0254 49       		.uleb128 0x49
 5947 0255 13       		.uleb128 0x13
 5948 0256 02       		.uleb128 0x2
 5949 0257 18       		.uleb128 0x18
 5950 0258 00       		.byte	0
 5951 0259 00       		.byte	0
 5952 025a 2B       		.uleb128 0x2b
 5953 025b 34       		.uleb128 0x34
 5954 025c 00       		.byte	0
 5955 025d 03       		.uleb128 0x3
 5956 025e 0E       		.uleb128 0xe
 5957 025f 3A       		.uleb128 0x3a
 5958 0260 0B       		.uleb128 0xb
 5959 0261 3B       		.uleb128 0x3b
 5960 0262 05       		.uleb128 0x5
 5961 0263 49       		.uleb128 0x49
 5962 0264 13       		.uleb128 0x13
 5963 0265 3F       		.uleb128 0x3f
 5964 0266 19       		.uleb128 0x19
 5965 0267 3C       		.uleb128 0x3c
 5966 0268 19       		.uleb128 0x19
 5967 0269 00       		.byte	0
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 152


 5968 026a 00       		.byte	0
 5969 026b 2C       		.uleb128 0x2c
 5970 026c 34       		.uleb128 0x34
 5971 026d 00       		.byte	0
 5972 026e 03       		.uleb128 0x3
 5973 026f 0E       		.uleb128 0xe
 5974 0270 3A       		.uleb128 0x3a
 5975 0271 0B       		.uleb128 0xb
 5976 0272 3B       		.uleb128 0x3b
 5977 0273 0B       		.uleb128 0xb
 5978 0274 49       		.uleb128 0x49
 5979 0275 13       		.uleb128 0x13
 5980 0276 3F       		.uleb128 0x3f
 5981 0277 19       		.uleb128 0x19
 5982 0278 02       		.uleb128 0x2
 5983 0279 18       		.uleb128 0x18
 5984 027a 00       		.byte	0
 5985 027b 00       		.byte	0
 5986 027c 00       		.byte	0
 5987              		.section	.debug_aranges,"",%progbits
 5988 0000 0C010000 		.4byte	0x10c
 5989 0004 0200     		.2byte	0x2
 5990 0006 00000000 		.4byte	.Ldebug_info0
 5991 000a 04       		.byte	0x4
 5992 000b 00       		.byte	0
 5993 000c 0000     		.2byte	0
 5994 000e 0000     		.2byte	0
 5995 0010 00000000 		.4byte	.LFB68
 5996 0014 B4000000 		.4byte	.LFE68-.LFB68
 5997 0018 00000000 		.4byte	.LFB69
 5998 001c 58000000 		.4byte	.LFE69-.LFB69
 5999 0020 00000000 		.4byte	.LFB70
 6000 0024 6C000000 		.4byte	.LFE70-.LFB70
 6001 0028 00000000 		.4byte	.LFB71
 6002 002c 4A000000 		.4byte	.LFE71-.LFB71
 6003 0030 00000000 		.4byte	.LFB72
 6004 0034 30000000 		.4byte	.LFE72-.LFB72
 6005 0038 00000000 		.4byte	.LFB73
 6006 003c 74000000 		.4byte	.LFE73-.LFB73
 6007 0040 00000000 		.4byte	.LFB74
 6008 0044 7E000000 		.4byte	.LFE74-.LFB74
 6009 0048 00000000 		.4byte	.LFB75
 6010 004c 3A000000 		.4byte	.LFE75-.LFB75
 6011 0050 00000000 		.4byte	.LFB76
 6012 0054 A4010000 		.4byte	.LFE76-.LFB76
 6013 0058 00000000 		.4byte	.LFB77
 6014 005c D6000000 		.4byte	.LFE77-.LFB77
 6015 0060 00000000 		.4byte	.LFB78
 6016 0064 CE000000 		.4byte	.LFE78-.LFB78
 6017 0068 00000000 		.4byte	.LFB79
 6018 006c 14020000 		.4byte	.LFE79-.LFB79
 6019 0070 00000000 		.4byte	.LFB80
 6020 0074 D4000000 		.4byte	.LFE80-.LFB80
 6021 0078 00000000 		.4byte	.LFB81
 6022 007c 8C000000 		.4byte	.LFE81-.LFB81
 6023 0080 00000000 		.4byte	.LFB82
 6024 0084 20000000 		.4byte	.LFE82-.LFB82
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 153


 6025 0088 00000000 		.4byte	.LFB83
 6026 008c 2A000000 		.4byte	.LFE83-.LFB83
 6027 0090 00000000 		.4byte	.LFB84
 6028 0094 1A000000 		.4byte	.LFE84-.LFB84
 6029 0098 00000000 		.4byte	.LFB85
 6030 009c 54000000 		.4byte	.LFE85-.LFB85
 6031 00a0 00000000 		.4byte	.LFB86
 6032 00a4 16000000 		.4byte	.LFE86-.LFB86
 6033 00a8 00000000 		.4byte	.LFB87
 6034 00ac 1A000000 		.4byte	.LFE87-.LFB87
 6035 00b0 00000000 		.4byte	.LFB88
 6036 00b4 18000000 		.4byte	.LFE88-.LFB88
 6037 00b8 00000000 		.4byte	.LFB89
 6038 00bc D4000000 		.4byte	.LFE89-.LFB89
 6039 00c0 00000000 		.4byte	.LFB90
 6040 00c4 4C000000 		.4byte	.LFE90-.LFB90
 6041 00c8 00000000 		.4byte	.LFB91
 6042 00cc A4000000 		.4byte	.LFE91-.LFB91
 6043 00d0 00000000 		.4byte	.LFB92
 6044 00d4 2C000000 		.4byte	.LFE92-.LFB92
 6045 00d8 00000000 		.4byte	.LFB93
 6046 00dc 26000000 		.4byte	.LFE93-.LFB93
 6047 00e0 00000000 		.4byte	.LFB94
 6048 00e4 30000000 		.4byte	.LFE94-.LFB94
 6049 00e8 00000000 		.4byte	.LFB95
 6050 00ec 2A000000 		.4byte	.LFE95-.LFB95
 6051 00f0 00000000 		.4byte	.LFB96
 6052 00f4 50000000 		.4byte	.LFE96-.LFB96
 6053 00f8 00000000 		.4byte	.LFB97
 6054 00fc 4C000000 		.4byte	.LFE97-.LFB97
 6055 0100 00000000 		.4byte	.LFB98
 6056 0104 50000000 		.4byte	.LFE98-.LFB98
 6057 0108 00000000 		.4byte	0
 6058 010c 00000000 		.4byte	0
 6059              		.section	.debug_ranges,"",%progbits
 6060              	.Ldebug_ranges0:
 6061 0000 00000000 		.4byte	.LFB68
 6062 0004 B4000000 		.4byte	.LFE68
 6063 0008 00000000 		.4byte	.LFB69
 6064 000c 58000000 		.4byte	.LFE69
 6065 0010 00000000 		.4byte	.LFB70
 6066 0014 6C000000 		.4byte	.LFE70
 6067 0018 00000000 		.4byte	.LFB71
 6068 001c 4A000000 		.4byte	.LFE71
 6069 0020 00000000 		.4byte	.LFB72
 6070 0024 30000000 		.4byte	.LFE72
 6071 0028 00000000 		.4byte	.LFB73
 6072 002c 74000000 		.4byte	.LFE73
 6073 0030 00000000 		.4byte	.LFB74
 6074 0034 7E000000 		.4byte	.LFE74
 6075 0038 00000000 		.4byte	.LFB75
 6076 003c 3A000000 		.4byte	.LFE75
 6077 0040 00000000 		.4byte	.LFB76
 6078 0044 A4010000 		.4byte	.LFE76
 6079 0048 00000000 		.4byte	.LFB77
 6080 004c D6000000 		.4byte	.LFE77
 6081 0050 00000000 		.4byte	.LFB78
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 154


 6082 0054 CE000000 		.4byte	.LFE78
 6083 0058 00000000 		.4byte	.LFB79
 6084 005c 14020000 		.4byte	.LFE79
 6085 0060 00000000 		.4byte	.LFB80
 6086 0064 D4000000 		.4byte	.LFE80
 6087 0068 00000000 		.4byte	.LFB81
 6088 006c 8C000000 		.4byte	.LFE81
 6089 0070 00000000 		.4byte	.LFB82
 6090 0074 20000000 		.4byte	.LFE82
 6091 0078 00000000 		.4byte	.LFB83
 6092 007c 2A000000 		.4byte	.LFE83
 6093 0080 00000000 		.4byte	.LFB84
 6094 0084 1A000000 		.4byte	.LFE84
 6095 0088 00000000 		.4byte	.LFB85
 6096 008c 54000000 		.4byte	.LFE85
 6097 0090 00000000 		.4byte	.LFB86
 6098 0094 16000000 		.4byte	.LFE86
 6099 0098 00000000 		.4byte	.LFB87
 6100 009c 1A000000 		.4byte	.LFE87
 6101 00a0 00000000 		.4byte	.LFB88
 6102 00a4 18000000 		.4byte	.LFE88
 6103 00a8 00000000 		.4byte	.LFB89
 6104 00ac D4000000 		.4byte	.LFE89
 6105 00b0 00000000 		.4byte	.LFB90
 6106 00b4 4C000000 		.4byte	.LFE90
 6107 00b8 00000000 		.4byte	.LFB91
 6108 00bc A4000000 		.4byte	.LFE91
 6109 00c0 00000000 		.4byte	.LFB92
 6110 00c4 2C000000 		.4byte	.LFE92
 6111 00c8 00000000 		.4byte	.LFB93
 6112 00cc 26000000 		.4byte	.LFE93
 6113 00d0 00000000 		.4byte	.LFB94
 6114 00d4 30000000 		.4byte	.LFE94
 6115 00d8 00000000 		.4byte	.LFB95
 6116 00dc 2A000000 		.4byte	.LFE95
 6117 00e0 00000000 		.4byte	.LFB96
 6118 00e4 50000000 		.4byte	.LFE96
 6119 00e8 00000000 		.4byte	.LFB97
 6120 00ec 4C000000 		.4byte	.LFE97
 6121 00f0 00000000 		.4byte	.LFB98
 6122 00f4 50000000 		.4byte	.LFE98
 6123 00f8 00000000 		.4byte	0
 6124 00fc 00000000 		.4byte	0
 6125              		.section	.debug_line,"",%progbits
 6126              	.Ldebug_line0:
 6127 0000 D9060000 		.section	.debug_str,"MS",%progbits,1
 6127      02006302 
 6127      00000201 
 6127      FB0E0D00 
 6127      01010101 
 6128              	.LASF26:
 6129 0000 42494E41 		.ascii	"BINARY_SEMAPHORE\000"
 6129      52595F53 
 6129      454D4150 
 6129      484F5245 
 6129      00
 6130              	.LASF169:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 155


 6131 0011 756C4F72 		.ascii	"ulOriginalBASEPRI\000"
 6131      6967696E 
 6131      616C4241 
 6131      53455052 
 6131      4900
 6132              	.LASF161:
 6133 0023 75635175 		.ascii	"ucQueueType\000"
 6133      65756554 
 6133      79706500 
 6134              	.LASF200:
 6135 002f 78517565 		.ascii	"xQueueGenericSendFromISR\000"
 6135      75654765 
 6135      6E657269 
 6135      6353656E 
 6135      6446726F 
 6136              	.LASF181:
 6137 0048 70727649 		.ascii	"prvInitialiseMutex\000"
 6137      6E697469 
 6137      616C6973 
 6137      654D7574 
 6137      657800
 6138              	.LASF217:
 6139 005b 75635175 		.ascii	"ucQueueGetQueueType\000"
 6139      65756547 
 6139      65745175 
 6139      65756554 
 6139      79706500 
 6140              	.LASF183:
 6141 006f 75784D75 		.ascii	"uxMutexLength\000"
 6141      7465784C 
 6141      656E6774 
 6141      6800
 6142              	.LASF210:
 6143 007d 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 6143      6575654D 
 6143      65737361 
 6143      67657357 
 6143      61697469 
 6144              	.LASF93:
 6145 0094 49445F45 		.ascii	"ID_EVENT_GROUP_DELETE\000"
 6145      56454E54 
 6145      5F47524F 
 6145      55505F44 
 6145      454C4554 
 6146              	.LASF3:
 6147 00aa 73697A65 		.ascii	"size_t\000"
 6147      5F7400
 6148              	.LASF136:
 6149 00b1 4D696E69 		.ascii	"MiniListItem_t\000"
 6149      4C697374 
 6149      4974656D 
 6149      5F7400
 6150              	.LASF145:
 6151 00c0 54696D65 		.ascii	"TimeOut_t\000"
 6151      4F75745F 
 6151      7400
 6152              	.LASF240:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 156


 6153 00ca 756C4E65 		.ascii	"ulNewMaskValue\000"
 6153      774D6173 
 6153      6B56616C 
 6153      756500
 6154              	.LASF168:
 6155 00d9 51756575 		.ascii	"QueueRegistryItem_t\000"
 6155      65526567 
 6155      69737472 
 6155      79497465 
 6155      6D5F7400 
 6156              	.LASF201:
 6157 00ed 70784869 		.ascii	"pxHigherPriorityTaskWoken\000"
 6157      67686572 
 6157      5072696F 
 6157      72697479 
 6157      5461736B 
 6158              	.LASF223:
 6159 0107 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 6159      75654973 
 6159      51756575 
 6159      65456D70 
 6159      74794672 
 6160              	.LASF6:
 6161 0121 5F5F7569 		.ascii	"__uint8_t\000"
 6161      6E74385F 
 6161      7400
 6162              	.LASF113:
 6163 012b 4F626A65 		.ascii	"ObjectListHeader\000"
 6163      63744C69 
 6163      73744865 
 6163      61646572 
 6163      00
 6164              	.LASF189:
 6165 013c 78517565 		.ascii	"xQueueTakeMutexRecursive\000"
 6165      75655461 
 6165      6B654D75 
 6165      74657852 
 6165      65637572 
 6166              	.LASF73:
 6167 0155 49445F54 		.ascii	"ID_TASK_RESUME\000"
 6167      41534B5F 
 6167      52455355 
 6167      4D4500
 6168              	.LASF209:
 6169 0164 78517565 		.ascii	"xQueuePeekFromISR\000"
 6169      75655065 
 6169      656B4672 
 6169      6F6D4953 
 6169      5200
 6170              	.LASF235:
 6171 0176 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 6171      43313120 
 6171      352E342E 
 6171      31203230 
 6171      31363036 
 6172 01a9 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m3 -mthumb -g -O"
 6172      20726576 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 157


 6172      6973696F 
 6172      6E203233 
 6172      37373135 
 6173 01dc 30202D66 		.ascii	"0 -ffunction-sections -ffat-lto-objects\000"
 6173      66756E63 
 6173      74696F6E 
 6173      2D736563 
 6173      74696F6E 
 6174              	.LASF154:
 6175 0204 78546173 		.ascii	"xTasksWaitingToReceive\000"
 6175      6B735761 
 6175      6974696E 
 6175      67546F52 
 6175      65636569 
 6176              	.LASF37:
 6177 021b 49445F54 		.ascii	"ID_TASK_SWITCHED_OUT\000"
 6177      41534B5F 
 6177      53574954 
 6177      43484544 
 6177      5F4F5554 
 6178              	.LASF170:
 6179 0230 756C4E65 		.ascii	"ulNewBASEPRI\000"
 6179      77424153 
 6179      45505249 
 6179      00
 6180              	.LASF219:
 6181 023d 70727643 		.ascii	"prvCopyDataFromQueue\000"
 6181      6F707944 
 6181      61746146 
 6181      726F6D51 
 6181      75657565 
 6182              	.LASF177:
 6183 0252 70784E65 		.ascii	"pxNewQueue\000"
 6183      77517565 
 6183      756500
 6184              	.LASF14:
 6185 025d 6C6F6E67 		.ascii	"long long unsigned int\000"
 6185      206C6F6E 
 6185      6720756E 
 6185      7369676E 
 6185      65642069 
 6186              	.LASF172:
 6187 0274 784E6577 		.ascii	"xNewQueue\000"
 6187      51756575 
 6187      6500
 6188              	.LASF104:
 6189 027e 49445F43 		.ascii	"ID_CUSTOM_MARKER_1\000"
 6189      5553544F 
 6189      4D5F4D41 
 6189      524B4552 
 6189      5F3100
 6190              	.LASF221:
 6191 0291 70727643 		.ascii	"prvCopyDataToQueue\000"
 6191      6F707944 
 6191      61746154 
 6191      6F517565 
 6191      756500
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 158


 6192              	.LASF80:
 6193 02a4 49445F54 		.ascii	"ID_TIMER_COMMAND_RECEIVED\000"
 6193      494D4552 
 6193      5F434F4D 
 6193      4D414E44 
 6193      5F524543 
 6194              	.LASF10:
 6195 02be 5F5F696E 		.ascii	"__int32_t\000"
 6195      7433325F 
 6195      7400
 6196              	.LASF164:
 6197 02c8 51554555 		.ascii	"QUEUE_REGISTRY_ITEM\000"
 6197      455F5245 
 6197      47495354 
 6197      52595F49 
 6197      54454D00 
 6198              	.LASF146:
 6199 02dc 51756575 		.ascii	"QueueHandle_t\000"
 6199      6548616E 
 6199      646C655F 
 6199      7400
 6200              	.LASF230:
 6201 02ea 49544D5F 		.ascii	"ITM_RxBuffer\000"
 6201      52784275 
 6201      66666572 
 6201      00
 6202              	.LASF92:
 6203 02f7 49445F45 		.ascii	"ID_EVENT_GROUP_SET_BITS_FROM_ISR\000"
 6203      56454E54 
 6203      5F47524F 
 6203      55505F53 
 6203      45545F42 
 6204              	.LASF135:
 6205 0318 784D494E 		.ascii	"xMINI_LIST_ITEM\000"
 6205      495F4C49 
 6205      53545F49 
 6205      54454D00 
 6206              	.LASF30:
 6207 0328 4F626A65 		.ascii	"ObjectType\000"
 6207      63745479 
 6207      706500
 6208              	.LASF204:
 6209 0333 78517565 		.ascii	"xQueueGenericReceive\000"
 6209      75654765 
 6209      6E657269 
 6209      63526563 
 6209      65697665 
 6210              	.LASF216:
 6211 0348 76517565 		.ascii	"vQueueSetQueueNumber\000"
 6211      75655365 
 6211      74517565 
 6211      75654E75 
 6211      6D626572 
 6212              	.LASF32:
 6213 035d 49445F45 		.ascii	"ID_END\000"
 6213      4E4400
 6214              	.LASF206:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 159


 6215 0364 784A7573 		.ascii	"xJustPeeking\000"
 6215      74506565 
 6215      6B696E67 
 6215      00
 6216              	.LASF5:
 6217 0371 7369676E 		.ascii	"signed char\000"
 6217      65642063 
 6217      68617200 
 6218              	.LASF167:
 6219 037d 78517565 		.ascii	"xQueueRegistryItem\000"
 6219      75655265 
 6219      67697374 
 6219      72794974 
 6219      656D00
 6220              	.LASF190:
 6221 0390 78546963 		.ascii	"xTicksToWait\000"
 6221      6B73546F 
 6221      57616974 
 6221      00
 6222              	.LASF53:
 6223 039d 49445F43 		.ascii	"ID_CREATE_COUNTING_SEMAPHORE_FAILED\000"
 6223      52454154 
 6223      455F434F 
 6223      554E5449 
 6223      4E475F53 
 6224              	.LASF4:
 6225 03c1 5F5F696E 		.ascii	"__int8_t\000"
 6225      74385F74 
 6225      00
 6226              	.LASF35:
 6227 03ca 49445F4C 		.ascii	"ID_LOW_POWER_IDLE_BEGIN\000"
 6227      4F575F50 
 6227      4F574552 
 6227      5F49444C 
 6227      455F4245 
 6228              	.LASF207:
 6229 03e2 70634F72 		.ascii	"pcOriginalReadPosition\000"
 6229      6967696E 
 6229      616C5265 
 6229      6164506F 
 6229      73697469 
 6230              	.LASF114:
 6231 03f9 6F626A65 		.ascii	"objectNumber\000"
 6231      63744E75 
 6231      6D626572 
 6231      00
 6232              	.LASF11:
 6233 0406 6C6F6E67 		.ascii	"long int\000"
 6233      20696E74 
 6233      00
 6234              	.LASF132:
 6235 040f 70764F77 		.ascii	"pvOwner\000"
 6235      6E657200 
 6236              	.LASF109:
 6237 0417 7061636B 		.ascii	"packetID\000"
 6237      65744944 
 6237      00
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 160


 6238              	.LASF117:
 6239 0420 4F626A65 		.ascii	"Object\000"
 6239      637400
 6240              	.LASF63:
 6241 0427 49445F51 		.ascii	"ID_QUEUE_RECEIVE_FROM_ISR_FAILED\000"
 6241      55455545 
 6241      5F524543 
 6241      45495645 
 6241      5F46524F 
 6242              	.LASF159:
 6243 0448 6354784C 		.ascii	"cTxLock\000"
 6243      6F636B00 
 6244              	.LASF160:
 6245 0450 75785175 		.ascii	"uxQueueNumber\000"
 6245      6575654E 
 6245      756D6265 
 6245      7200
 6246              	.LASF126:
 6247 045e 5469636B 		.ascii	"TickType_t\000"
 6247      54797065 
 6247      5F7400
 6248              	.LASF1:
 6249 0469 6C6F6E67 		.ascii	"long long int\000"
 6249      206C6F6E 
 6249      6720696E 
 6249      7400
 6250              	.LASF22:
 6251 0477 646F7562 		.ascii	"double\000"
 6251      6C6500
 6252              	.LASF147:
 6253 047e 70635265 		.ascii	"pcReadFrom\000"
 6253      61644672 
 6253      6F6D00
 6254              	.LASF124:
 6255 0489 42617365 		.ascii	"BaseType_t\000"
 6255      54797065 
 6255      5F7400
 6256              	.LASF102:
 6257 0494 49445F54 		.ascii	"ID_TASK_NOTIFY_FROM_ISR\000"
 6257      41534B5F 
 6257      4E4F5449 
 6257      46595F46 
 6257      524F4D5F 
 6258              	.LASF44:
 6259 04ac 49445F51 		.ascii	"ID_QUEUE_CREATE\000"
 6259      55455545 
 6259      5F435245 
 6259      41544500 
 6260              	.LASF116:
 6261 04bc 6F626A65 		.ascii	"objectName\000"
 6261      63744E61 
 6261      6D6500
 6262              	.LASF199:
 6263 04c7 7854696D 		.ascii	"xTimeOut\000"
 6263      654F7574 
 6263      00
 6264              	.LASF180:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 161


 6265 04d0 70727649 		.ascii	"prvInitialiseNewQueue\000"
 6265      6E697469 
 6265      616C6973 
 6265      654E6577 
 6265      51756575 
 6266              	.LASF69:
 6267 04e6 49445F54 		.ascii	"ID_TASK_DELAY_UNTIL\000"
 6267      41534B5F 
 6267      44454C41 
 6267      595F554E 
 6267      54494C00 
 6268              	.LASF186:
 6269 04fa 784D7574 		.ascii	"xMutex\000"
 6269      657800
 6270              	.LASF12:
 6271 0501 5F5F7569 		.ascii	"__uint32_t\000"
 6271      6E743332 
 6271      5F7400
 6272              	.LASF143:
 6273 050c 784F7665 		.ascii	"xOverflowCount\000"
 6273      72666C6F 
 6273      77436F75 
 6273      6E7400
 6274              	.LASF142:
 6275 051b 7854494D 		.ascii	"xTIME_OUT\000"
 6275      455F4F55 
 6275      5400
 6276              	.LASF54:
 6277 0525 49445F51 		.ascii	"ID_QUEUE_SEND\000"
 6277      55455545 
 6277      5F53454E 
 6277      4400
 6278              	.LASF72:
 6279 0533 49445F54 		.ascii	"ID_TASK_SUSPEND\000"
 6279      41534B5F 
 6279      53555350 
 6279      454E4400 
 6280              	.LASF34:
 6281 0543 49445F49 		.ascii	"ID_INCREASE_TICK_COUNT\000"
 6281      4E435245 
 6281      4153455F 
 6281      5449434B 
 6281      5F434F55 
 6282              	.LASF60:
 6283 055a 49445F51 		.ascii	"ID_QUEUE_SEND_FROM_ISR\000"
 6283      55455545 
 6283      5F53454E 
 6283      445F4652 
 6283      4F4D5F49 
 6284              	.LASF150:
 6285 0571 70634865 		.ascii	"pcHead\000"
 6285      616400
 6286              	.LASF120:
 6287 0578 4F626A65 		.ascii	"ObjectList\000"
 6287      63744C69 
 6287      737400
 6288              	.LASF0:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 162


 6289 0583 756E7369 		.ascii	"unsigned int\000"
 6289      676E6564 
 6289      20696E74 
 6289      00
 6290              	.LASF140:
 6291 0590 784C6973 		.ascii	"xListEnd\000"
 6291      74456E64 
 6291      00
 6292              	.LASF187:
 6293 0599 78526574 		.ascii	"xReturn\000"
 6293      75726E00 
 6294              	.LASF144:
 6295 05a1 7854696D 		.ascii	"xTimeOnEntering\000"
 6295      654F6E45 
 6295      6E746572 
 6295      696E6700 
 6296              	.LASF101:
 6297 05b1 49445F54 		.ascii	"ID_TASK_NOTIFY\000"
 6297      41534B5F 
 6297      4E4F5449 
 6297      465900
 6298              	.LASF46:
 6299 05c0 49445F43 		.ascii	"ID_CREATE_MUTEX\000"
 6299      52454154 
 6299      455F4D55 
 6299      54455800 
 6300              	.LASF138:
 6301 05d0 75784E75 		.ascii	"uxNumberOfItems\000"
 6301      6D626572 
 6301      4F664974 
 6301      656D7300 
 6302              	.LASF13:
 6303 05e0 6C6F6E67 		.ascii	"long unsigned int\000"
 6303      20756E73 
 6303      69676E65 
 6303      6420696E 
 6303      7400
 6304              	.LASF222:
 6305 05f2 70727649 		.ascii	"prvIsQueueEmpty\000"
 6305      73517565 
 6305      7565456D 
 6305      70747900 
 6306              	.LASF91:
 6307 0602 49445F45 		.ascii	"ID_EVENT_GROUP_SET_BITS\000"
 6307      56454E54 
 6307      5F47524F 
 6307      55505F53 
 6307      45545F42 
 6308              	.LASF98:
 6309 061a 49445F54 		.ascii	"ID_TASK_NOTIFY_TAKE\000"
 6309      41534B5F 
 6309      4E4F5449 
 6309      46595F54 
 6309      414B4500 
 6310              	.LASF48:
 6311 062e 49445F47 		.ascii	"ID_GIVE_MUTEX_RECURSIVE\000"
 6311      4956455F 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 163


 6311      4D555445 
 6311      585F5245 
 6311      43555253 
 6312              	.LASF85:
 6313 0646 49445F45 		.ascii	"ID_EVENT_GROUP_SYNC_BLOCK\000"
 6313      56454E54 
 6313      5F47524F 
 6313      55505F53 
 6313      594E435F 
 6314              	.LASF31:
 6315 0660 49445F53 		.ascii	"ID_START\000"
 6315      54415254 
 6315      00
 6316              	.LASF194:
 6317 0669 78517565 		.ascii	"xQueueGenericSend\000"
 6317      75654765 
 6317      6E657269 
 6317      6353656E 
 6317      6400
 6318              	.LASF121:
 6319 067b 64617461 		.ascii	"data\000"
 6319      00
 6320              	.LASF40:
 6321 0680 49445F42 		.ascii	"ID_BLOCKING_ON_QUEUE_RECEIVE\000"
 6321      4C4F434B 
 6321      494E475F 
 6321      4F4E5F51 
 6321      55455545 
 6322              	.LASF9:
 6323 069d 73686F72 		.ascii	"short unsigned int\000"
 6323      7420756E 
 6323      7369676E 
 6323      65642069 
 6323      6E7400
 6324              	.LASF198:
 6325 06b0 78596965 		.ascii	"xYieldRequired\000"
 6325      6C645265 
 6325      71756972 
 6325      656400
 6326              	.LASF78:
 6327 06bf 49445F54 		.ascii	"ID_TIMER_COMMAND_SEND\000"
 6327      494D4552 
 6327      5F434F4D 
 6327      4D414E44 
 6327      5F53454E 
 6328              	.LASF182:
 6329 06d5 78517565 		.ascii	"xQueueCreateMutex\000"
 6329      75654372 
 6329      65617465 
 6329      4D757465 
 6329      7800
 6330              	.LASF211:
 6331 06e7 75785265 		.ascii	"uxReturn\000"
 6331      7475726E 
 6331      00
 6332              	.LASF66:
 6333 06f0 49445F54 		.ascii	"ID_TASK_CREATE\000"
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 164


 6333      41534B5F 
 6333      43524541 
 6333      544500
 6334              	.LASF96:
 6335 06ff 49445F51 		.ascii	"ID_QUEUE_REGISTRY_ADD\000"
 6335      55455545 
 6335      5F524547 
 6335      49535452 
 6335      595F4144 
 6336              	.LASF41:
 6337 0715 49445F42 		.ascii	"ID_BLOCKING_ON_QUEUE_SEND\000"
 6337      4C4F434B 
 6337      494E475F 
 6337      4F4E5F51 
 6337      55455545 
 6338              	.LASF226:
 6339 072f 76517565 		.ascii	"vQueueAddToRegistry\000"
 6339      75654164 
 6339      64546F52 
 6339      65676973 
 6339      74727900 
 6340              	.LASF208:
 6341 0743 78517565 		.ascii	"xQueueReceiveFromISR\000"
 6341      75655265 
 6341      63656976 
 6341      6546726F 
 6341      6D495352 
 6342              	.LASF70:
 6343 0758 49445F54 		.ascii	"ID_TASK_DELAY\000"
 6343      41534B5F 
 6343      44454C41 
 6343      5900
 6344              	.LASF188:
 6345 0766 70784D75 		.ascii	"pxMutex\000"
 6345      74657800 
 6346              	.LASF99:
 6347 076e 49445F54 		.ascii	"ID_TASK_NOTIFY_WAIT_BLOCK\000"
 6347      41534B5F 
 6347      4E4F5449 
 6347      46595F57 
 6347      4149545F 
 6348              	.LASF50:
 6349 0788 49445F54 		.ascii	"ID_TAKE_MUTEX_RECURSIVE\000"
 6349      414B455F 
 6349      4D555445 
 6349      585F5245 
 6349      43555253 
 6350              	.LASF74:
 6351 07a0 49445F54 		.ascii	"ID_TASK_RESUME_FROM_ISR\000"
 6351      41534B5F 
 6351      52455355 
 6351      4D455F46 
 6351      524F4D5F 
 6352              	.LASF84:
 6353 07b8 49445F45 		.ascii	"ID_EVENT_GROUP_CREATE_FAILED\000"
 6353      56454E54 
 6353      5F47524F 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 165


 6353      55505F43 
 6353      52454154 
 6354              	.LASF123:
 6355 07d5 77726974 		.ascii	"write\000"
 6355      6500
 6356              	.LASF36:
 6357 07db 49445F4C 		.ascii	"ID_LOW_POWER_IDLE_END\000"
 6357      4F575F50 
 6357      4F574552 
 6357      5F49444C 
 6357      455F454E 
 6358              	.LASF15:
 6359 07f1 73697A65 		.ascii	"sizetype\000"
 6359      74797065 
 6359      00
 6360              	.LASF2:
 6361 07fa 6C6F6E67 		.ascii	"long double\000"
 6361      20646F75 
 6361      626C6500 
 6362              	.LASF228:
 6363 0806 70635265 		.ascii	"pcReturn\000"
 6363      7475726E 
 6363      00
 6364              	.LASF42:
 6365 080f 49445F4D 		.ascii	"ID_MOVED_TASK_TO_READY_STATE\000"
 6365      4F564544 
 6365      5F544153 
 6365      4B5F544F 
 6365      5F524541 
 6366              	.LASF215:
 6367 082c 76517565 		.ascii	"vQueueDelete\000"
 6367      75654465 
 6367      6C657465 
 6367      00
 6368              	.LASF238:
 6369 0839 756C506F 		.ascii	"ulPortRaiseBASEPRI\000"
 6369      72745261 
 6369      69736542 
 6369      41534550 
 6369      524900
 6370              	.LASF163:
 6371 084c 51756575 		.ascii	"Queue_t\000"
 6371      655F7400 
 6372              	.LASF24:
 6373 0854 4D555445 		.ascii	"MUTEX\000"
 6373      5800
 6374              	.LASF192:
 6375 085a 75784D61 		.ascii	"uxMaxCount\000"
 6375      78436F75 
 6375      6E7400
 6376              	.LASF23:
 6377 0865 51554555 		.ascii	"QUEUE\000"
 6377      4500
 6378              	.LASF175:
 6379 086b 75785175 		.ascii	"uxQueueLength\000"
 6379      6575654C 
 6379      656E6774 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 166


 6379      6800
 6380              	.LASF103:
 6381 0879 49445F54 		.ascii	"ID_TASK_NOTIFY_GIVE_FROM_ISR\000"
 6381      41534B5F 
 6381      4E4F5449 
 6381      46595F47 
 6381      4956455F 
 6382              	.LASF81:
 6383 0896 49445F4D 		.ascii	"ID_MALLOC\000"
 6383      414C4C4F 
 6383      4300
 6384              	.LASF52:
 6385 08a0 49445F43 		.ascii	"ID_CREATE_COUNTING_SEMAPHORE\000"
 6385      52454154 
 6385      455F434F 
 6385      554E5449 
 6385      4E475F53 
 6386              	.LASF236:
 6387 08bd 2E2E5C53 		.ascii	"..\\Source\\queue.c\000"
 6387      6F757263 
 6387      655C7175 
 6387      6575652E 
 6387      6300
 6388              	.LASF239:
 6389 08cf 76506F72 		.ascii	"vPortSetBASEPRI\000"
 6389      74536574 
 6389      42415345 
 6389      50524900 
 6390              	.LASF67:
 6391 08df 49445F54 		.ascii	"ID_TASK_CREATE_FAILED\000"
 6391      41534B5F 
 6391      43524541 
 6391      54455F46 
 6391      41494C45 
 6392              	.LASF171:
 6393 08f5 78517565 		.ascii	"xQueue\000"
 6393      756500
 6394              	.LASF131:
 6395 08fc 70785072 		.ascii	"pxPrevious\000"
 6395      6576696F 
 6395      757300
 6396              	.LASF213:
 6397 0907 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
 6397      6575654D 
 6397      65737361 
 6397      67657357 
 6397      61697469 
 6398              	.LASF64:
 6399 0925 49445F51 		.ascii	"ID_QUEUE_PEEK_FROM_ISR_FAILED\000"
 6399      55455545 
 6399      5F504545 
 6399      4B5F4652 
 6399      4F4D5F49 
 6400              	.LASF195:
 6401 0943 70764974 		.ascii	"pvItemToQueue\000"
 6401      656D546F 
 6401      51756575 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 167


 6401      6500
 6402              	.LASF25:
 6403 0951 434F554E 		.ascii	"COUNTING_SEMAPHORE\000"
 6403      54494E47 
 6403      5F53454D 
 6403      4150484F 
 6403      524500
 6404              	.LASF21:
 6405 0964 666C6F61 		.ascii	"float\000"
 6405      7400
 6406              	.LASF162:
 6407 096a 78515545 		.ascii	"xQUEUE\000"
 6407      554500
 6408              	.LASF139:
 6409 0971 7078496E 		.ascii	"pxIndex\000"
 6409      64657800 
 6410              	.LASF133:
 6411 0979 7076436F 		.ascii	"pvContainer\000"
 6411      6E746169 
 6411      6E657200 
 6412              	.LASF166:
 6413 0985 7848616E 		.ascii	"xHandle\000"
 6413      646C6500 
 6414              	.LASF197:
 6415 098d 78456E74 		.ascii	"xEntryTimeSet\000"
 6415      72795469 
 6415      6D655365 
 6415      7400
 6416              	.LASF27:
 6417 099b 52454355 		.ascii	"RECURSIVE_MUTEX\000"
 6417      52534956 
 6417      455F4D55 
 6417      54455800 
 6418              	.LASF149:
 6419 09ab 51756575 		.ascii	"QueueDefinition\000"
 6419      65446566 
 6419      696E6974 
 6419      696F6E00 
 6420              	.LASF19:
 6421 09bb 696E7433 		.ascii	"int32_t\000"
 6421      325F7400 
 6422              	.LASF7:
 6423 09c3 756E7369 		.ascii	"unsigned char\000"
 6423      676E6564 
 6423      20636861 
 6423      7200
 6424              	.LASF105:
 6425 09d1 49445F43 		.ascii	"ID_CUSTOM_MARKER_2\000"
 6425      5553544F 
 6425      4D5F4D41 
 6425      524B4552 
 6425      5F3200
 6426              	.LASF106:
 6427 09e4 49445F43 		.ascii	"ID_CUSTOM_MARKER_3\000"
 6427      5553544F 
 6427      4D5F4D41 
 6427      524B4552 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 168


 6427      5F3300
 6428              	.LASF107:
 6429 09f7 49445F43 		.ascii	"ID_CUSTOM_MARKER_4\000"
 6429      5553544F 
 6429      4D5F4D41 
 6429      524B4552 
 6429      5F3400
 6430              	.LASF108:
 6431 0a0a 49445F43 		.ascii	"ID_CUSTOM_MARKER_5\000"
 6431      5553544F 
 6431      4D5F4D41 
 6431      524B4552 
 6431      5F3500
 6432              	.LASF57:
 6433 0a1d 49445F51 		.ascii	"ID_QUEUE_PEEK\000"
 6433      55455545 
 6433      5F504545 
 6433      4B00
 6434              	.LASF148:
 6435 0a2b 75785265 		.ascii	"uxRecursiveCallCount\000"
 6435      63757273 
 6435      69766543 
 6435      616C6C43 
 6435      6F756E74 
 6436              	.LASF94:
 6437 0a40 49445F50 		.ascii	"ID_PEND_FUNC_CALL\000"
 6437      454E445F 
 6437      46554E43 
 6437      5F43414C 
 6437      4C00
 6438              	.LASF47:
 6439 0a52 49445F43 		.ascii	"ID_CREATE_MUTEX_FAILED\000"
 6439      52454154 
 6439      455F4D55 
 6439      5445585F 
 6439      4641494C 
 6440              	.LASF8:
 6441 0a69 73686F72 		.ascii	"short int\000"
 6441      7420696E 
 6441      7400
 6442              	.LASF158:
 6443 0a73 6352784C 		.ascii	"cRxLock\000"
 6443      6F636B00 
 6444              	.LASF191:
 6445 0a7b 78517565 		.ascii	"xQueueCreateCountingSemaphore\000"
 6445      75654372 
 6445      65617465 
 6445      436F756E 
 6445      74696E67 
 6446              	.LASF203:
 6447 0a99 78517565 		.ascii	"xQueueGiveFromISR\000"
 6447      75654769 
 6447      76654672 
 6447      6F6D4953 
 6447      5200
 6448              	.LASF51:
 6449 0aab 49445F54 		.ascii	"ID_TAKE_MUTEX_RECURSIVE_FAILED\000"
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 169


 6449      414B455F 
 6449      4D555445 
 6449      585F5245 
 6449      43555253 
 6450              	.LASF225:
 6451 0aca 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 6451      75654973 
 6451      51756575 
 6451      6546756C 
 6451      6C46726F 
 6452              	.LASF174:
 6453 0ae3 78517565 		.ascii	"xQueueGenericCreate\000"
 6453      75654765 
 6453      6E657269 
 6453      63437265 
 6453      61746500 
 6454              	.LASF137:
 6455 0af7 784C4953 		.ascii	"xLIST\000"
 6455      5400
 6456              	.LASF185:
 6457 0afd 78517565 		.ascii	"xQueueGiveMutexRecursive\000"
 6457      75654769 
 6457      76654D75 
 6457      74657852 
 6457      65637572 
 6458              	.LASF90:
 6459 0b16 49445F45 		.ascii	"ID_EVENT_GROUP_CLEAR_BITS_FROM_ISR\000"
 6459      56454E54 
 6459      5F47524F 
 6459      55505F43 
 6459      4C454152 
 6460              	.LASF141:
 6461 0b39 4C697374 		.ascii	"List_t\000"
 6461      5F7400
 6462              	.LASF184:
 6463 0b40 75784D75 		.ascii	"uxMutexSize\000"
 6463      74657853 
 6463      697A6500 
 6464              	.LASF202:
 6465 0b4c 75785361 		.ascii	"uxSavedInterruptStatus\000"
 6465      76656449 
 6465      6E746572 
 6465      72757074 
 6465      53746174 
 6466              	.LASF224:
 6467 0b63 70727649 		.ascii	"prvIsQueueFull\000"
 6467      73517565 
 6467      75654675 
 6467      6C6C00
 6468              	.LASF95:
 6469 0b72 49445F50 		.ascii	"ID_PEND_FUNC_CALL_FROM_ISR\000"
 6469      454E445F 
 6469      46554E43 
 6469      5F43414C 
 6469      4C5F4652 
 6470              	.LASF38:
 6471 0b8d 49445F54 		.ascii	"ID_TASK_PRIORITY_INHERIT\000"
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 170


 6471      41534B5F 
 6471      5052494F 
 6471      52495459 
 6471      5F494E48 
 6472              	.LASF20:
 6473 0ba6 75696E74 		.ascii	"uint32_t\000"
 6473      33325F74 
 6473      00
 6474              	.LASF155:
 6475 0baf 75784D65 		.ascii	"uxMessagesWaiting\000"
 6475      73736167 
 6475      65735761 
 6475      6974696E 
 6475      6700
 6476              	.LASF110:
 6477 0bc1 696E666F 		.ascii	"informationID\000"
 6477      726D6174 
 6477      696F6E49 
 6477      4400
 6478              	.LASF77:
 6479 0bcf 49445F54 		.ascii	"ID_TIMER_CREATE_FAILED\000"
 6479      494D4552 
 6479      5F435245 
 6479      4154455F 
 6479      4641494C 
 6480              	.LASF205:
 6481 0be6 70764275 		.ascii	"pvBuffer\000"
 6481      66666572 
 6481      00
 6482              	.LASF56:
 6483 0bef 49445F51 		.ascii	"ID_QUEUE_RECEIVE\000"
 6483      55455545 
 6483      5F524543 
 6483      45495645 
 6483      00
 6484              	.LASF176:
 6485 0c00 70785175 		.ascii	"pxQueue\000"
 6485      65756500 
 6486              	.LASF173:
 6487 0c08 78517565 		.ascii	"xQueueGenericReset\000"
 6487      75654765 
 6487      6E657269 
 6487      63526573 
 6487      657400
 6488              	.LASF16:
 6489 0c1b 63686172 		.ascii	"char\000"
 6489      00
 6490              	.LASF115:
 6491 0c20 6C656E4F 		.ascii	"lenObjectName\000"
 6491      626A6563 
 6491      744E616D 
 6491      6500
 6492              	.LASF196:
 6493 0c2e 78436F70 		.ascii	"xCopyPosition\000"
 6493      79506F73 
 6493      6974696F 
 6493      6E00
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 171


 6494              	.LASF129:
 6495 0c3c 78497465 		.ascii	"xItemValue\000"
 6495      6D56616C 
 6495      756500
 6496              	.LASF165:
 6497 0c47 70635175 		.ascii	"pcQueueName\000"
 6497      6575654E 
 6497      616D6500 
 6498              	.LASF76:
 6499 0c53 49445F54 		.ascii	"ID_TIMER_CREATE\000"
 6499      494D4552 
 6499      5F435245 
 6499      41544500 
 6500              	.LASF220:
 6501 0c63 70727655 		.ascii	"prvUnlockQueue\000"
 6501      6E6C6F63 
 6501      6B517565 
 6501      756500
 6502              	.LASF55:
 6503 0c72 49445F51 		.ascii	"ID_QUEUE_SEND_FAILED\000"
 6503      55455545 
 6503      5F53454E 
 6503      445F4641 
 6503      494C4544 
 6504              	.LASF234:
 6505 0c87 78517565 		.ascii	"xQueueRegistry\000"
 6505      75655265 
 6505      67697374 
 6505      727900
 6506              	.LASF134:
 6507 0c96 4C697374 		.ascii	"ListItem_t\000"
 6507      4974656D 
 6507      5F7400
 6508              	.LASF151:
 6509 0ca1 70635461 		.ascii	"pcTail\000"
 6509      696C00
 6510              	.LASF232:
 6511 0ca8 62756666 		.ascii	"buffer\000"
 6511      657200
 6512              	.LASF100:
 6513 0caf 49445F54 		.ascii	"ID_TASK_NOTIFY_WAIT\000"
 6513      41534B5F 
 6513      4E4F5449 
 6513      46595F57 
 6513      41495400 
 6514              	.LASF87:
 6515 0cc3 49445F45 		.ascii	"ID_EVENT_GROUP_WAIT_BITS_BLOCK\000"
 6515      56454E54 
 6515      5F47524F 
 6515      55505F57 
 6515      4149545F 
 6516              	.LASF179:
 6517 0ce2 70756351 		.ascii	"pucQueueStorage\000"
 6517      75657565 
 6517      53746F72 
 6517      61676500 
 6518              	.LASF59:
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 172


 6519 0cf2 49445F51 		.ascii	"ID_QUEUE_RECEIVE_FAILED\000"
 6519      55455545 
 6519      5F524543 
 6519      45495645 
 6519      5F464149 
 6520              	.LASF237:
 6521 0d0a 463A5C50 		.ascii	"F:\\Programme_Scripts\\PSOC Creator\\FreeRTOS\\Free"
 6521      726F6772 
 6521      616D6D65 
 6521      5F536372 
 6521      69707473 
 6522 0d39 52544F53 		.ascii	"RTOS_CY8CKIT_059-master\\FreeRTOS_Demo.cydsn\000"
 6522      5F435938 
 6522      434B4954 
 6522      5F303539 
 6522      2D6D6173 
 6523              	.LASF214:
 6524 0d65 75785175 		.ascii	"uxQueueGetQueueNumber\000"
 6524      65756547 
 6524      65745175 
 6524      6575654E 
 6524      756D6265 
 6525              	.LASF97:
 6526 0d7b 49445F54 		.ascii	"ID_TASK_NOTIFY_TAKE_BLOCK\000"
 6526      41534B5F 
 6526      4E4F5449 
 6526      46595F54 
 6526      414B455F 
 6527              	.LASF229:
 6528 0d95 76517565 		.ascii	"vQueueUnregisterQueue\000"
 6528      7565556E 
 6528      72656769 
 6528      73746572 
 6528      51756575 
 6529              	.LASF58:
 6530 0dab 49445F51 		.ascii	"ID_QUEUE_PEEK_FROM_ISR\000"
 6530      55455545 
 6530      5F504545 
 6530      4B5F4652 
 6530      4F4D5F49 
 6531              	.LASF83:
 6532 0dc2 49445F45 		.ascii	"ID_EVENT_GROUP_CREATE\000"
 6532      56454E54 
 6532      5F47524F 
 6532      55505F43 
 6532      52454154 
 6533              	.LASF61:
 6534 0dd8 49445F51 		.ascii	"ID_QUEUE_SEND_FROM_ISR_FAILED\000"
 6534      55455545 
 6534      5F53454E 
 6534      445F4652 
 6534      4F4D5F49 
 6535              	.LASF118:
 6536 0df6 6F626A65 		.ascii	"objectHeader\000"
 6536      63744865 
 6536      61646572 
 6536      00
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 173


 6537              	.LASF112:
 6538 0e03 6C656E67 		.ascii	"length\000"
 6538      746800
 6539              	.LASF17:
 6540 0e0a 696E7438 		.ascii	"int8_t\000"
 6540      5F7400
 6541              	.LASF65:
 6542 0e11 49445F51 		.ascii	"ID_QUEUE_DELETE\000"
 6542      55455545 
 6542      5F44454C 
 6542      45544500 
 6543              	.LASF233:
 6544 0e21 6F626A65 		.ascii	"objectList\000"
 6544      63744C69 
 6544      737400
 6545              	.LASF88:
 6546 0e2c 49445F45 		.ascii	"ID_EVENT_GROUP_WAIT_BITS_END\000"
 6546      56454E54 
 6546      5F47524F 
 6546      55505F57 
 6546      4149545F 
 6547              	.LASF45:
 6548 0e49 49445F51 		.ascii	"ID_QUEUE_CREATE_FAILED\000"
 6548      55455545 
 6548      5F435245 
 6548      4154455F 
 6548      4641494C 
 6549              	.LASF218:
 6550 0e60 78506F73 		.ascii	"xPosition\000"
 6550      6974696F 
 6550      6E00
 6551              	.LASF193:
 6552 0e6a 7578496E 		.ascii	"uxInitialCount\000"
 6552      69746961 
 6552      6C436F75 
 6552      6E7400
 6553              	.LASF62:
 6554 0e79 49445F51 		.ascii	"ID_QUEUE_RECEIVE_FROM_ISR\000"
 6554      55455545 
 6554      5F524543 
 6554      45495645 
 6554      5F46524F 
 6555              	.LASF156:
 6556 0e93 75784C65 		.ascii	"uxLength\000"
 6556      6E677468 
 6556      00
 6557              	.LASF29:
 6558 0e9c 4E554D42 		.ascii	"NUMBER_OF_OBJECTTYPES\000"
 6558      45525F4F 
 6558      465F4F42 
 6558      4A454354 
 6558      54595045 
 6559              	.LASF49:
 6560 0eb2 49445F47 		.ascii	"ID_GIVE_MUTEX_RECURSIVE_FAILED\000"
 6560      4956455F 
 6560      4D555445 
 6560      585F5245 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 174


 6560      43555253 
 6561              	.LASF153:
 6562 0ed1 78546173 		.ascii	"xTasksWaitingToSend\000"
 6562      6B735761 
 6562      6974696E 
 6562      67546F53 
 6562      656E6400 
 6563              	.LASF127:
 6564 0ee5 42756666 		.ascii	"Buffer\000"
 6564      657200
 6565              	.LASF178:
 6566 0eec 78517565 		.ascii	"xQueueSizeInBytes\000"
 6566      75655369 
 6566      7A65496E 
 6566      42797465 
 6566      7300
 6567              	.LASF86:
 6568 0efe 49445F45 		.ascii	"ID_EVENT_GROUP_SYNC_END\000"
 6568      56454E54 
 6568      5F47524F 
 6568      55505F53 
 6568      594E435F 
 6569              	.LASF68:
 6570 0f16 49445F54 		.ascii	"ID_TASK_DELETE\000"
 6570      41534B5F 
 6570      44454C45 
 6570      544500
 6571              	.LASF33:
 6572 0f25 49445F54 		.ascii	"ID_TASK_SWITCHED_IN\000"
 6572      41534B5F 
 6572      53574954 
 6572      43484544 
 6572      5F494E00 
 6573              	.LASF111:
 6574 0f39 6F626A65 		.ascii	"objectType\000"
 6574      63745479 
 6574      706500
 6575              	.LASF18:
 6576 0f44 75696E74 		.ascii	"uint8_t\000"
 6576      385F7400 
 6577              	.LASF152:
 6578 0f4c 70635772 		.ascii	"pcWriteTo\000"
 6578      69746554 
 6578      6F00
 6579              	.LASF39:
 6580 0f56 49445F54 		.ascii	"ID_TASK_PRIORITY_DISINHERIT\000"
 6580      41534B5F 
 6580      5052494F 
 6580      52495459 
 6580      5F444953 
 6581              	.LASF157:
 6582 0f72 75784974 		.ascii	"uxItemSize\000"
 6582      656D5369 
 6582      7A6500
 6583              	.LASF43:
 6584 0f7d 49445F50 		.ascii	"ID_POST_MOVED_TASK_TO_READY_STATE\000"
 6584      4F53545F 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 175


 6584      4D4F5645 
 6584      445F5441 
 6584      534B5F54 
 6585              	.LASF130:
 6586 0f9f 70784E65 		.ascii	"pxNext\000"
 6586      787400
 6587              	.LASF82:
 6588 0fa6 49445F46 		.ascii	"ID_FREE\000"
 6588      52454500 
 6589              	.LASF122:
 6590 0fae 72656164 		.ascii	"read\000"
 6590      00
 6591              	.LASF119:
 6592 0fb3 6F626A65 		.ascii	"objectArray\000"
 6592      63744172 
 6592      72617900 
 6593              	.LASF75:
 6594 0fbf 49445F54 		.ascii	"ID_TASK_INCREMENT_TICK\000"
 6594      41534B5F 
 6594      494E4352 
 6594      454D454E 
 6594      545F5449 
 6595              	.LASF89:
 6596 0fd6 49445F45 		.ascii	"ID_EVENT_GROUP_CLEAR_BITS\000"
 6596      56454E54 
 6596      5F47524F 
 6596      55505F43 
 6596      4C454152 
 6597              	.LASF128:
 6598 0ff0 784C4953 		.ascii	"xLIST_ITEM\000"
 6598      545F4954 
 6598      454D00
 6599              	.LASF212:
 6600 0ffb 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 6600      65756553 
 6600      70616365 
 6600      73417661 
 6600      696C6162 
 6601              	.LASF227:
 6602 1012 70635175 		.ascii	"pcQueueGetName\000"
 6602      65756547 
 6602      65744E61 
 6602      6D6500
 6603              	.LASF125:
 6604 1021 55426173 		.ascii	"UBaseType_t\000"
 6604      65547970 
 6604      655F7400 
 6605              	.LASF231:
 6606 102d 736E6966 		.ascii	"sniffIDFilter\000"
 6606      66494446 
 6606      696C7465 
 6606      7200
 6607              	.LASF71:
 6608 103b 49445F54 		.ascii	"ID_TASK_PRIORITY_SET\000"
 6608      41534B5F 
 6608      5052494F 
 6608      52495459 
ARM GAS  C:\Users\THUNDE~1\AppData\Local\Temp\ccMJprgM.s 			page 176


 6608      5F534554 
 6609              	.LASF28:
 6610 1050 5441534B 		.ascii	"TASK\000"
 6610      00
 6611              	.LASF79:
 6612 1055 49445F54 		.ascii	"ID_TIMER_EXPIRED\000"
 6612      494D4552 
 6612      5F455850 
 6612      49524544 
 6612      00
 6613              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
